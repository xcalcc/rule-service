[
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_2_3",
		"master_id": "2001",
		"name": "A project should not include undefined data types",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\ntypedef int used; // type is declared here\n\nint main()\n{\n    used a = 1; // type is used here\n    printf(\"%d\",a);\n    return 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\ntypedef int used; // type is declared but not used\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "",
		"desc": "A project should not include undefined data types",
		"details": "#### Abstract\nA project should not include undefined data types\n\n#### Explanation\nAn undefined data type will cause a waste of resources. When reviewing the code, it will also be difficult to determine whether the data type is not used due to an error in the programming process or if it is just extra code. "
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_2_6",
		"master_id": "2002",
		"name": "Unused label in function not allowed",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint func( void )\n{\n    int i = 5;\n    goto lab1; // label used\n    if (i != 5) i = 5;\nlab1: // label declared\n    return i;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint func( void )\n{\n    int i = 5;\n    if (i != 5) i = 5;\nlab1: // unused label declared\n    return i;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, unused tags are declared in ${so.func}.",
		"desc": "Unused tags cannot be declared in the function",
		"details": "#### Abstract\nUnused tags cannot be declared in the function\n\n#### Explanation\nThe reviewer of the code cannot judge whether the unused tag is redundant or is not used due to negligence, so the unused label cannot be declared. "
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_2_7",
		"master_id": "2003",
		"name": "All declared parameters must be used",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint Addtion(int a,int b,int c);\n\nint main()\n{\n    printf(\"%d\",Addtion(1,2,3));\n    return 0;\n}\nint Addtion(int a,int b,int c)\n{\n    return a+b+c; // every parameter is used\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint Addtion(int a,int b,int c);\n\nint main()\n{\n    printf(\"%d\",Addtion(1,2,3));\n    return 0;\n}\n // three parameters are defined\nint Addtion(int a,int b,int c)\n{\n    return a+b; // only two of them are used\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, unused parameters appear in ${so.func}.",
		"desc": "Unused parameters should not appear in the function",
		"details": "#### Abstract\nUnused parameters should not appear in the function\n\n#### Explanation\nThe function should use all its parameters. If the function does not use all its parameters, the implementation will not match the declaration of the function. "
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_5_1",
		"master_id": "2004",
		"name": "All external identifiers must be unique up to 31 characters",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint main()\n{\n    // the first 31 characters are distinct\n    int a_non_compliant_example_a = 1;\n    int a_non_compliant_example_b = 2; \n    int a;\n    a = a_non_compliant_example_a + a_non_compliant_example_b;\n    printf(\"%d\\n\",a);\n    return 0;\n} "
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint main()\n{\n    // the first 31 characters are not distinct\n    int this_is_a_non_compliant_example_a = 1;\n    int this_is_a_non_compliant_example_b = 2; \n    int a;\n    a = this_is_a_non_compliant_example_a + this_is_a_non_compliant_example_b;\n    printf(\"%d\\n\",a);\n    return 0;\n} "
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, external identifiers are not unique.",
		"desc": "The external identifier must be distinguishable",
		"details": "#### Abstract\nThe external identifier must be distinguishable\n\n#### Explanation\nIn the C99 standard, external identifiers should be distinguished by at least the first 31 characters. The external identifiers must be distinct with respect to the first 31 characters, so they are deemed unique by the compiler. "
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_5_2",
		"master_id": "2005",
		"name": "Identifiers of same scope and name space must be unique",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n// this example have two identifiers, first 31 characters are the same\nextern int this_is_a_non_compliant_example_a = 1; // first identifier, global scope\n\nint main()\n{\n    int a;\n    int this_is_a_non_compliant_example_b = 2; // two identifiers are defined in local scope\n    a = 1 + this_is_a_non_compliant_example_b;\n    printf (\"%d\\n\",a);\n    return 0;\n} "
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n// this example have two identifiers, first 31 characters are the same\nextern int a_non_compliant_example_a = 1;\nextern int a_non_compliant_example_b = 2; // two indistinct identifiers are defined in the same scope\n\nint main()\n{\n    int a;\n    a = 1 + a_non_compliant_example_b;\n    printf(\"%d\\n\",a);\n    return 0;\n} "
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, identifiers are not distinguishable.",
		"desc": "Identifiers declared in the same scope and name space should be distinguishable",
		"details": "#### Abstract\nIdentifiers declared in the same scope and name space should be distinguishable\n\n#### Explanation\nIn the same scope, the first 31 characters of different identifiers should not be exactly the same to ensure they are distinguishable."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_5_3",
		"master_id": "2006",
		"name": "Identifiers in inner and outer scope must be distinct",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint a = 3; // identifier defined, outer scope\n\nint main()\n{\n    int b; // identifier defined, inner scope, different form the outer one\n    b = 4;\n    printf(\"%d\",b);\n    return 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint a = 3; // identifier defined, outer scope\n\nint main()\n{\n    int a; // identifier defined, inner scope, covering the outer one\n    a = 4;\n    printf(\"%d\",a);\n    return 0;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, identifiers are not distinct.",
		"desc": "The identifier of the internal scope should be different from the identifier of the external scope",
		"details": "#### Abstract\nThe identifier of the internal scope should be different from the identifier of the external scope\n\n#### Explanation\nWhen defining variables in the internal scope, you should avoid having the same name as the external scope to prevent creating ambiguity."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_5_6",
		"master_id": "2007",
		"name": "typedef name should be a unique identifier",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\ntypedef int my_name; // unique typedef declared\n\nint main()\n{\n    int my_name_2 = 1; // unique variable declared \n    printf(\"%d\",my_name_2);\n    return 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\ntypedef int my_name; // typedef declared\n\nint main()\n{\n    int my_name = 1; // variable declared, same identifier\n    printf(\"%d\",my_name);\n    return 0;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the typedef identifier is not unique.",
		"desc": "A typedef identifier must be unique",
		"details": "#### Abstract\nA typedef identifier must be unique\n\n#### Explanation\nUnless the alias is defined in the header file, and the header file is included, the alias defined by the typedef used must be unique in all namespaces."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_5_7",
		"master_id": "2008",
		"name": "Tag names should be a unique identifier",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nstruct my_name // unique tag declared\n{\n    int a;\n    int b;\n};\n\nint main()\n{\n    int my_name_2 = 1; // unique variable declared\n    printf(\"%d\",my_name_2);\n    return 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nstruct my_name // tag declared\n{\n    int a;\n    int b;\n};\n\nint main()\n{\n    int my_name = 1; // variable declared, same identifier\n    printf(\"%d\",my_name);\n    return 0;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, tag names are not unique identifiers.",
		"desc": "A tag must be unique",
		"details": "#### Abstract\nA tag must be unique\n\n#### Explanation\nUnless the tag is defined in the header file, and the header file is included, the tag used must be unique in all namespaces."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_6_1",
		"master_id": "2009",
		"name": "Bit field types must not be builtin types",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nstruct str\n{\n    signed int a:2;   // signed int permitted\n    unsigned int b:2; // unsigned int permitted\n};\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nstruct str {\n  int a:2;\n  unsigned int b1:2;\n};\n\n\nstruct str1 {\n  unsigned int b1:2;\n  short b:2;\n};\n\nint foo()\n{\n  printf(\"finished\\n\");\n  return 0;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, bit fields are not appropriate data types.",
		"desc": "Bit fields must be declared as appropriate data types",
		"details": "#### Abstract\nBit fields must be declared as appropriate data types\n\n#### Explanation\nWhen declaring a bit field, it must be declared as one of the specified data types either signed or unsigned. It cannot be omitted in the declaration."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_6_2",
		"master_id": "2010",
		"name": "Single-bit named field must be unsigned",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nstruct str\n{\n    unsigned int a:1;   // single-bit bit field declared unsigned\n};\n\nint main()\n{\n    printf (\"finished\") ;\n    return 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nstruct str\n{\n    signed int a:1;   // single-bit bit field declared signed\n};\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the single-bit named field is signed data.",
		"desc": "A bit field that only occupies one bit cannot be signed data",
		"details": "#### Abstract\nA bit field that only occupies one bit cannot be signed data\n\n#### Explanation\nSince signed data requires the first sign bit, a bit field that only occupies one bit is not allowed to be defined as a signed data type."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_7_4",
		"master_id": "2011",
		"name": "String literal must only be assigned to a const char pointer",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nextern int foo (const char *a);\nextern int foo2 (const char *b);\n\nint func()\n{\n    const char *str = \"string\"; // str is not const-qualified\n    foo ( \"string\" );\n    foo2 ( \"string\" ); // string can not be modified\n    return 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nextern int foo (char *a);\nextern int foo2 (char *b);\n\nint func()\n{\n    char *str = \"string\"; // str is not const-qualified\n    foo ( \"string\" );\n    foo2 ( \"string\" ); // may be modified by foo\n    return 0;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, a string literal is not assigned to char type.",
		"desc": "Always assign a string literal through a const qualified pointer to char type",
		"details": "#### Abstract\nAlways assign a string literal through a const qualified pointer to char type\n\n#### Explanation\nSince the constant string is stored in the static storage area, the modification operation will cause an error. Only the constant string can be copied to the pointer to the constant string to prevent its modification operation."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_8_4",
		"master_id": "2012",
		"name": "External object, when defined must be the same as a visble declaration.",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nextern int x;\nint x = 0; // compliant\n\nextern int func1(int a); // extern function declared\n\nint func1(int a) // extern compatible funtion defined\n{\n    return 0;\n}\n\n// compliant for functions with internal linkage\nstatic int func2 ( void )\n{\n    return 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nextern int x = 0; // x not declared before\n\nextern int func1(int a); // extern function declared\n\nint func1(int a, int b) // parameters different\n{\n    return 0;\n}\n\nint func2( void )\n{\n    // func2 not declared before\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the external object is not compatible with its declaration.",
		"desc": "Defining objects that have external linkage should be compatible with their declarations",
		"details": "#### Abstract\nDefining objects that have external linkage should be compatible with their declarations\n\n#### Explanation\nWhen defining an object or function with external linkage, the data type, number of parameters, etc. of the object or function must be compatible with the external declaration."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_8_8",
		"master_id": "2013",
		"name": "Objects with internal linkage should be declared static ",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nstatic int func (int a) // function defined with \"static\"\n{\n    return a;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n// this example will cause compilation error\nextern int func (int a); // declare external scope\n\nstatic int func (int a) // function with internal linkage declared\n{\n    return a;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the object with internal linkage is not declared static.",
		"desc": "The static specifier should be added to the object that has internal linkage",
		"details": "#### Abstract\nThe static specifier should be added to the object that has internal linkage\n\n#### Explanation\nWhen declaring an object or function with internal linkage, a static specifier must be added to ensure the declaration is correct. "
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_8_9",
		"master_id": "2014",
		"name": "An object should be defined at block scope if its identifier only appears in a single function",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nextern int foo (int *a);\nextern void foo2 ( void );\n\nint count ( void )\n{\n    static int num = 0; // object declared at block scope\n    num++; // object appears only in this function\n    return num;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nextern int foo(int *a);\nextern void foo2( void );\nstatic int num = 0; // object declared, global scope\n\nint count( void )\n{\n    num++; // object appears only in this function\n    return num;\n}\n\nextern void foo2( void )\n{\n    foo(&num); // object may be modified at outer scope\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the object is not defined in the scope in which it appears.",
		"desc": "The object should only be defined in the scope in which it appears",
		"details": "#### Abstract\nThe object should only be defined in the scope in which it appears\n\n#### Explanation\nWhen an object only functions in a certain scope, it should be defined in that scope to prevent other scopes from changing its value."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_8_10",
		"master_id": "2015",
		"name": "Inline function should have a static declaration",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nstatic inline int func( void ); // inline function declared with internal linkage\n\nint func2( void )\n{\n    func();\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nextern inline int func( void ); // inline function declared with external linkage\n\nint func2( void )\n{\n    func();\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, inline function ${so.func} does not have static declaration.",
		"desc": "A static storage class should be used to declare inline functions",
		"details": "#### Abstract\nA static storage class should be used to declare inline functions\n\n#### Explanation\nReferencing an inline function of an external linkage may affect the execution time, so the inline function should be declared with a static storage class."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_8_11",
		"master_id": "2016",
		"name": "When an array with external linkage is declared, its size should be explicitly specified",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nextern int array[20]; // declare array with external linkage and its size\n\nint foo ( void )\n{\n    return array[10];\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nextern int array[]; // declare array with external linkage but without size\n\nint foo ( void )\n{\n    return array[10]; // 10 may be bigger than actual array size\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the size of the array of external linkage is not explicitly specified.",
		"desc": "The size of the array of external linkage must be explicitly specified",
		"details": "#### Abstract\nThe size of the array of external linkage must be explicitly specified\n\n#### Explanation\nIn order to ensure consistency and determine the boundaries of the storage area, the size of the array must be determined when declaring an externally linked array."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_8_12",
		"master_id": "2017",
		"name": "An implicitly specified enum constant list should be unique",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n// all implicitly-specified enmueration constants is unique\ntypedef enum weekday {thu = 4, fri, sat = 6, sun = 6};"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n// implicitly-specified enmueration sat is not unique\ntypedef enum weekday {thu = 4, fri, sat, sun = 6};"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the implicitly specified enum constant list is not unique.",
		"desc": "The value of the enumeration member assigned by default must be unique",
		"details": "#### Abstract\nThe value of the enumeration member assigned by default must be unique\n\n#### Explanation\nIn order to avoid the incorrect repetition of the value of the enumeration member, the value of the enumeration member should be "
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_8_13",
		"master_id": "2018",
		"name": "A pointer should point to a const-qualified type whenever possible",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func (const char *ptr);\n\nvoid func (const char *ptr) // pointer declared const-qualified\n{\n    // ptr pointed to is not modified\n    printf (\"%c\", *ptr);\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func (char *ptr);\n\nvoid func (char *ptr) // pointer declared is not const-qualified\n{\n    // ptr pointed to is not modified, it should be const-qualified\n    printf (\"%c\", *ptr);\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the pointer is not declared with const qualifier.",
		"desc": "Try to declare pointers with const qualifier",
		"details": "#### Abstract\nTry to declare pointers with const qualifier\n\n#### Explanation\nA pointer should always point to the same underlying qualified type. Mixed type assignments should be always explicitly casted."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_8_14",
		"master_id": "2019",
		"name": "Restrict qualifier should not be used",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n// restrict type qualifier removed\nextern void func (int * ptr1, int * ptr2);\n\nvoid func2(void)\n{\n    int i;\n    int *a,*b;\n    a = b = &i;\n    func (a, b);\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n// restrict-qualified parameters declared\nextern void func (int * restrict ptr1, int * restrict ptr2);\n\nvoid func2(void)\n{\n    int i;\n    int *a,*b;\n    a = b = &i;\n    // overlap memory areas\n    func (a, b);\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the restrict type qualifier is used",
		"desc": "Try to avoid using the restrict type qualifier",
		"details": "#### Abstract\nTry to avoid using the restrict type qualifier\n\n#### Explanation\nIn order to prevent problems such as overlapping of the areas pointed to by the pointer, the restrict type qualifier should be avoided as much as possible."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_9_3",
		"master_id": "2020",
		"name": "Arrays should not be partially initialized",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint func ( void )\n{\n    int a[10] = {0}; // array totally initialized\n    return a[9];\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint func ( void )\n{\n    int a[10] = {0, 0, 0}; // array only initialized three elements\n    return a[9]; // a[9] is still unknown value\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, arrays are partially initialized",
		"desc": "Arrays must not be partially initialized",
		"details": "#### Abstract\nArrays must not be partially initialized\n\n#### Explanation\nIn order to ensure that there are no unprocessed values in the array after explicitly initializing the array, all elements in the array must also be explicitly initialized."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_9_4",
		"master_id": "2021",
		"name": "Multiple initialization of elements in an object is not allowed",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func( void )\n{\n    // all elements initialized once\n    int arr[3] = { [ 0 ] = 3, [ 1 ] = 2, [ 2 ] = 1};\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func( void )\n{\n    // a[0] initialized twice\n    int arr[3] = { [ 0 ] = 3, [ 1 ] = 2, [ 2 ] = 1, [ 0 ] = 4};\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the elements in the object have been initialized more than once",
		"desc": "The elements in the object can only be initialized once",
		"details": "#### Abstract\nThe elements in the object can only be initialized once\n\n#### Explanation\nWhen initializing arrays and structures that are not in the default order, you must not initialize the same element(s) repeatedly."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_9_5",
		"master_id": "2022",
		"name": "If initializers are used in an array, its size must be known",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n// This is example from MISRA document\n// Compliant\nint a2[ 10 ] = { [ 0 ] = 1 };"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n// This is example from MISRA document\n// Non-compliant - probably unint entional to have single element\nint a1[ ] = { [ 0 ] = 1 };"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the size of the array that uses explicit initializer is not declared",
		"desc": "The size of the array must be declared if an explicit initializer is used on the array",
		"details": "#### Abstract\nThe size of the array must be declared if an explicit initializer is used on the array\n\n#### Explanation\nIn order to determine the maximum number of elements in the array, when this array is explicitly initialized, the array size must be specified."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_10_3",
		"master_id": "2023",
		"name": "Down casting of an expression is not allowed",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdint.h>\n#include <stdbool.h>\n\nvoid func ( void )\n{\n    short short_a;\n    int b;              // b declared as int for illustration\n    b = short_a;        // short_a assigned to wider essential type object\n    uint16_t c = 0;   // compliant by exception\n    bool d = false;     // compliant\n    uint16_t e = 5;   // compliant by exception\n    char f = \"f_char\";  // char to char\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdint.h>\n#include <stdbool.h>\n\nvoid func ( void )\n{\n    short short_a;\n    long int b;\n    short_a = b;            // b assigned to narrower essential type\n    uint16_t c = 0.5f;    // float to unsigned\n    bool d = 1;             // signed to boolean\n    char e = 3;             // signed to char\n    uint32_t f = 'test';  // char to unsigned\n    uint16_t g = 5;       // signed to unsigned\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func} includes down casting of an expression",
		"desc": "You cannot assign values to objects with different essential types",
		"details": "#### Abstract\nYou cannot assign values to objects with different essential types\n\n#### Explanation\nIt is erroneous to assign the value of an expression to an object with an inappropriate type or is not large enough to represent the data type of the value."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_10_4",
		"master_id": "2024",
		"name": "operands and type conversion",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int int_var;\n    char char_var;\n    // int 1 added to char char_var, permitted\n    char_var += 1;\n    // int 1 added to int int_var, same type\n    int_var += 1;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int int_var;\n    char char_var;\n    // float 1.0f added to char char_var, not permitted\n    char_var += 1.0f;\n    // float 1.0f added to int int_var, differnt type\n    int_var += 1.0f;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the two operands of the same operator are not of the same essential type category",
		"desc": "The two operands of the same operator must be of the same essential type category",
		"details": "#### Abstract\nThe two operands of the same operator must be of the same essential type category\n\n#### Explanation\nUsing binary or ternary operands for two different types of operands may cause some information of the resulting value to be lost. Therefore, in general, the two operands of the uniform operator should be of the same type."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_10_6",
		"master_id": "2026",
		"name": "Assignment from a composite expression should remain the same size ",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    long long_var;\n    short short_a, short_b;\n    short_a = 1;\n    short_b = 1;\n    long_var = ( long )short_a + short_b; // explicitly converted to long\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    long int long_var;\n    short int short_a, short_b;\n    short_a = short_b = 1;\n    long_var = short_a + short_b; // implicitly converted to long\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the use of composite expressions to assign values to objects of larger data types does not use explicit conversions",
		"desc": "The use of composite expressions to assign values to objects of larger data types should use explicit conversions",
		"details": "#### Abstract\nThe use of composite expressions to assign values to objects of larger data types should use explicit conversions\n\n#### Explanation\nExplicit conversion must be used when converting the value of a composite expression to a data type with more storage space and assigning it to an object."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_10_7",
		"master_id": "2027",
		"name": "For composite expressions, any up casting on either side is not allowed",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    short int short_a, short_b;\n    long int long_a, long_b;\n    long_a = 1;\n    short_a = short_b = 2;\n    long_b = ( ( long ) short_a * short_b ) * long_a; // explicitly converted to long\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    short int short_a, short_b;\n    long int long_a, long_b;\n    long_a = 1;\n    short_a = short_b = 2;\n    long_b = (short_a * short_b) * long_a; // implicitly converted to long\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, an explicit conversion is not used when a composite expression is converted to a larger data type as an operand",
		"desc": "An explicit conversion is used when a composite expression is converted to a larger data type as an operand",
		"details": "#### Abstract\nAn explicit conversion is used when a composite expression is converted to a larger data type as an operand\n\n#### Explanation\nWhen a composite expression is used as one of the operands of an operator and needs to be converted to a larger data type, explicit conversion must be used."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_10_8",
		"master_id": "2028",
		"name": "Composite expression cannot be up casted",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <stdint.h>\n\nvoid func ( void )\n{\n    float float_a, float_b;\n    int int_var;\n    float_a = float_b = 1.0f;\n    int_var = ( int ) float_a + ( int ) float_b; // float_a and float_b casted to type int\n\n    uint8_t uint_var;\n    uint_var = ( uint8_t ) int_var; // compliant\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include<stdint.h>\n\nvoid func ( void )\n{\n    float float_a, float_b;\n    int int_var;\n    float_a = float_b = 1.0f;\n    int_var = ( int ) ( float_a + float_b ); // casted to inappropriate type int\n\n    uint8_t uint_var;\n    uint_var = ( uint8_t ) ( float_a + float_b ); // different essential type\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the value of a composite expression is cast to an inappropriate data type",
		"desc": "The value of a composite expression cannot be cast to an inappropriate data type",
		"details": "#### Abstract\nThe value of a composite expression cannot be cast to an inappropriate data type\n\n#### Explanation\nThe data type cast conversion may cause the loss or change of data."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_11_2",
		"master_id": "2029",
		"name": "No conversion of pointer to incomplete type convert to any other type",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nunion uni\n{\n    int i;\n    char c;\n}; // union declared\n\nvoid func ( void )\n{\n    union uni union_var;\n    union_var.i =1;\n    int *ptr_int;\n    // ptr_int point to union_var.i\n    ptr_int = &union_var.i;\n\n    // exception 1\n    struct a;\n    struct a *p;\n    p = NULL;\n\n    // exception 2\n    struct a *test ( void );\n    ( void ) test ();\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nunion uni; // incomplete type declared\n\nvoid func ( void )\n{\n    union uni *ptr_union;\n    int *ptr_int; \n    // ptr_int converted to pointer to incomplete type\n    ptr_union = ( union uni * ) ptr_int;\n    // ptr_union (incomplete type) converted to int pointer\n    ptr_int = ( int * )ptr_union;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, pointers to incomplete types are converted to pointers of other types",
		"desc": "Pointers to incomplete types cannot be converted to pointers of other types and vice versa ",
		"details": "#### Abstract\nPointers to incomplete types cannot be converted to pointers of other types and vice versa \n\n#### Explanation\nType conversion operations between pointers to incomplete types may destroy the encapsulation of incomplete types, so pointers of incomplete types cannot be converted to pointers of other types."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_11_3",
		"master_id": "2030",
		"name": "No casting between pointers of different types",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int *ptr_int;    // pointer to int declared\n    char *ptr_char;  // pointer to char declared\n    *ptr_char = NULL;\n    *ptr_int = NULL; // pointers point to null\n    const *ptr_const;\n    const volatile *ptr_const_v;\n    ptr_const_v = (const volatile *) ptr_const; // compliant\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int *ptr_int;                 // pointer to int declared\n    char *ptr_char;               // pointer to char declared\n    ptr_int = ( int * ) ptr_char; // convert to int type pointer\n\n    const int * const * ptr_const_int;\n    ptr_const_int = ( const int * const * ) ptr_int; // convert to constant-qualified int type pointer\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, pointers are cast to pointers of other types",
		"desc": "Pointers cannot be cast to pointers of other types",
		"details": "#### Abstract\nPointers cannot be cast to pointers of other types\n\n#### Explanation\nCasting one type of pointer to another type of pointer may be incorrectly aligned causing undefined behavior, so you cannot convert pointers to other types of pointers."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_11_4",
		"master_id": "2031",
		"name": "No conversion of int type to pointer",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int *ptr_int;\n    int int_a, int_b;\n    int_a = 1;\n    ptr_int = &int_a; // ptr_int point to int_a\n    int_b = *ptr_int; // *ptr_int assigned to int_b\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int *ptr_int;\n    int int_a, int_b;\n    int_a = 1;\n    ptr_int = ( int * ) int_a; // convert int to pointer\n    int_b = ( int ) ptr_int;   // convert pointer to type int\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, there is conversion between pointers and integers",
		"desc": "Avoid the conversion between pointers and integers",
		"details": "#### Abstract\nAvoid the conversion between pointers and integers\n\n#### Explanation\nImplementing the conversion between pointers and integers may result in data overflow of the integers or mis-alignment of the pointers. Avoid conversion between pointers and integers as much as possible."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_11_5",
		"master_id": "2032",
		"name": "No conversion from pointers to void into pointer to object",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    void *ptr_void; // void pointer declared\n    int *ptr_int;   // int pointer declared\n    int int_var;\n    ptr_int = &int_var;\n    // convert int pointer into void pointer\n    ptr_void = ( void * ) ptr_int;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    void *ptr_void; // void pointer declared\n    int *ptr_int;   // int pointer declared\n    int int_var;\n    ptr_void = &int_var;\n    // convert void pointer into int pointer\n    ptr_int = ( int * ) ptr_void;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, null pointers are coverted to pointers to objects",
		"desc": "Avoid converting null pointers to pointers to objects",
		"details": "#### Abstract\nAvoid converting null pointers to pointers to objects\n\n#### Explanation\nConversion from pointer to void into pointer to object may result in undefined behaviour."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_11_6",
		"master_id": "2033",
		"name": "No casting between a void pointer and an arithmatic type",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n#define ZERO 0\n\nvoid func ( void )\n{\n    void *ptr_void;\n    int int_var;\n    // ptr_void point to the address of int_var\n    ptr_void = &int_var;\n    ptr_void = (void *)ZERO;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    void *ptr_void;\n    int int_var;\n    // convert int_var to void pointer\n    ptr_void = ( void * ) int_var;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, there is null type pointer and arithmetic type conversion",
		"desc": "Cannot perform a null type pointer and arithmetic type conversion",
		"details": "#### Abstract\nCannot perform a null type pointer and arithmetic type conversion\n\n#### Explanation\nDuring data conversion, data type conversion between null pointers and arithmetic types may cause unalignment with undefined behavior during data conversion."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_11_7",
		"master_id": "2034",
		"name": "No casting between void pointer and a non-int arithmatic type",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int a, b;\n    int *p;\n    a = ( int ) p; // compliant\n    p = ( int * ) b; // compliant\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    char a, b;\n    int *p;\n    a = ( char ) p;  // non-compliant\n    p = ( int * ) b; // non-compliant\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, there is casting between pointers to objects and non-integer arithmetic types",
		"desc": "Cannot cast pointers to objects and non-integer arithmetic types",
		"details": "#### Abstract\nCannot cast pointers to objects and non-integer arithmetic types\n\n#### Explanation\nIn order to prevent undefined behavior during the type conversion process, the data type conversion between the pointer to the object and the non-integer arithmetic is not allowed. "
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_11_8",
		"master_id": "2035",
		"name": "Const or volatile pointers to pointed should not be cast away ",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <malloc.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    // const pointer declared\n    int * const ptr_const = ( int *) malloc ( sizeof ( int ) );\n    int *ptr_int;\n    // ptr_int point to the address of ptr_const\n    ptr_int = ptr_const;\n    // more code that may change ptr_const\n    // ...\n    \n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <malloc.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int * const *p_constpt;\n    volatile int *p_volatile;\n    // pointer to const declared\n    const int * ptr_const = ( int *) malloc ( sizeof ( int ) );\n    int *ptr_int;\n    int * *p_ptr_int;\n    // const qualifier removed in a cast\n    ptr_int = ( int * ) ptr_const;\n    ptr_int = ( int * ) p_volatile;\n    p_ptr_int = ( int * * ) p_constpt;\n    // more code that may change ptr_const\n    // ... \n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, pointer data type cast removes const or volatile qualifiers",
		"desc": "Pointer data type cast cannot remove const or volatile qualifiers",
		"details": "#### Abstract\nPointer data type cast cannot remove const or volatile qualifiers\n\n#### Explanation\nThe const and volatile qualifiers in the definition cannot be removed when the pointer data type is converted. This may cause errors in the reading and writing process of the pointer."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_11_9",
		"master_id": "2036",
		"name": "int null pointer const must be the NULL macro",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *int_ptr = NULL; // ptr_int point to NULL\n    // NULL appear as an operand with the other operand a pointer\n    if ( int_ptr != (int *)NULL )\n    {\n        *int_ptr = NULL;\n    }\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *int_ptr = 0; // 0 assigned to ptr_int\n    // 0 appear as an operand with the other operand a pointer\n    if ( int_ptr != 0 )\n    {\n        *int_ptr = NULL;\n    }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, a null integer pointer not only points to the macro NULL",
		"desc": "A null integer pointer can only point to the macro NULL",
		"details": "#### Abstract\nA null integer pointer can only point to the macro NULL\n\n#### Explanation\nAn integer constant expression with the value 0 should be derived from expansion of the macro NULL if it appears as the value being assigned to a pointer or an operand of equal/not-equal, or operand of a trigraph."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_12_2",
		"master_id": "2037",
		"name": "Shift amount of shift operator must be smaller than the bit size of operand",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdint.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    uint16_t uint16_var = 2;\n    uint32_t uint32_var;\n    // 17 is in the range 0 to the size of uint16_var\n    uint32_var = uint32_var << 17;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdint.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    uint16_t uint16_var = 2;\n    // 17 is bigger than the size of uint16_var\n    uint16_var = uint16_var << 17;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the right operand of the shift operator is not taken from zero to one less than the number of bits in the left operand",
		"desc": "The right operand of the shift operator should be taken from zero to one less than the number of bits in the left operand",
		"details": "#### Abstract\nThe right operand of the shift operator should be taken from zero to one less than the number of bits in the left operand\n\n#### Explanation\nThe right operand of the shift operator should be a positive integer, the value range is from zero to one less than the number of digits in the left operand. Any value beyond this range will cause undefined behavior."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_12_3",
		"master_id": "2038",
		"name": "Comma operator not allowed",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdint.h>\n\nstatic char a[ 10 ];\n\nvoid func ( void )\n{\n    int i;\n    char *p;\n    // same effect achieved by other mean\n    p = &a[ 0 ];\n    for ( i = 0; i < 10 ; ++i)\n    {\n        *p++ = i;\n    }\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdint.h>\n\nstatic char a[ 10 ];\n\nvoid func ( void )\n{\n    int i;\n    char *p;\n    // comma operator would reduce the readability of code\n    for ( i = 0, p = &a[ 0 ]; i < 10 ; ++i, *p++ = i)\n    {\n        foo(p);\n    }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the comma operator is used",
		"desc": "Try not to use the comma operator",
		"details": "#### Abstract\nTry not to use the comma operator\n\n#### Explanation\nSince using the comma operator will reduce the readability of the code, try to avoid using the comma operator."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_12_4",
		"master_id": "2039",
		"name": "Const expression should not cause unsigned wrap-around",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n#define MAXIMUM 0xffffffffu // maximum value of unsigned int\n\nconst unsigned int const_int = 1;\nvoid func( void );\n\nvoid func( void )\n{\n    unsigned int uint_var;\n    // 0xffffffff assigned to long_long_var\n    uint_var = MAXIMUM;\n    // uint_var + 1 and uint_var + const_int is not a constant expression\n    uint_var = uint_var + 1;\n    uint_var = uint_var + const_int;\n    \n    if (( 1 < 0 ) || ( 0u - 10u ))\n    {\n        // compliant\n    }\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n#define MAXIMUM 0xffffffffu // value of unsigned int (assume int is 32 bits)\n#define ONE     0x1u\nvoid func( void );\n\nvoid func( void )\n{\n    unsigned int uint_var;\n    // the value of MAXIMUM + 1 lead to wrap-around\n    uint_var = MAXIMUM + ONE;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, a constant expression causes an unsigned integer wrap-around",
		"desc": "A constant expression should not cause an unsigned integer wrap-around",
		"details": "#### Abstract\nA constant expression should not cause an unsigned integer wrap-around\n\n#### Explanation\nTo prevent wrap-around, the value range of the unsigned integer constant expression should be in the range of zero to the maximum value that the unsigned integer can represent."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_13_1",
		"master_id": "2040",
		"name": "Initializer lists should not contain persistent side effects",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func( void )\n{\n    int x = 0;\n    // array initialized with no side effect\n    int arr[2] = { 1, 2 };\n    // more code may call x\n    // ...\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func( void )\n{\n    int x = 0;\n    // object x modified due to side effect\n    int arr[2] = { ++x, ++x };\n    // more code may call x\n    // ...\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the initialization list has side effects",
		"desc": "The initialization list should not have side effects",
		"details": "#### Abstract\nThe initialization list should not have side effects\n\n#### Explanation\nIn order to avoid causing errors in the initialization content and side effects affecting the operation of the program, operations that produce side effects such as assigning other parameters to other parameters, should not be performed in the initialization list."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_13_2",
		"master_id": "2041",
		"name": "Persistent side effect expressions should be the same",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint func( void )\n{\n    int a = 6;\n    // the value will sure to be -60\n    a -= a*a;\n    a += a;\n    return a;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint func( void )\n{\n    int a = 6;\n\n    a += a -= a*a;\n    return a;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, the value of ${so.func} is not deterministic in all possible execution orders.",
		"desc": "The values and side effects of all expressions in the execution order must be the same",
		"details": "#### Abstract\nThe values and side effects of all expressions in the execution order must be the same\n\n#### Explanation\nSince the expression may have multiple execution orders, the design expression should ensure that the value of the expression and its side effects are the same in all possible execution orders."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_13_3",
		"master_id": "2042",
		"name": "Side effect free expr (except ++, --)",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint func( void )\n{\n    int int_a, int_b, int_c;\n    int_a = int_b = 1;\n    // make the code more readable by this mean\n    ++int_a;\n    int_c = int_a * int_b;\n    int_b--;\n    return int_c;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint func1( void )\n{\n    int int_a, int_b, int_c;\n    int_a = int_b = 1;\n    // the complex expression impairs the readability\n    int_c = ++int_a * int_b--;\n    return int_c;\n}\n\nvoid func2 ( void )\n{\n    int x = 1;\n    // function call is side effect\n    if ( ( func1() - ++x ) > 5)\n    {\n        // non-compliant\n    }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the increment (++) or decrement (--) operators have additional side effects",
		"desc": "The increment (++) or decrement (--) operators cannot have additional side effects",
		"details": "#### Abstract\nThe increment (++) or decrement (--) operators cannot have additional side effects\n\n#### Explanation\nAvoid mixing increment or decrement operators with other operators in expressions, including function calls, as this will cause an undefined behavior. Doing so will impair readability of the code."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_13_4",
		"master_id": "2043",
		"name": "Assign operators inside an expression ",
		"severity": "H",
		"compliance": "A",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <stdbool.h>\n\nvoid func( void )\n{\n    bool bool_var;\n    bool_var = true;\n    // == is not an assignment operator\n    while (bool_var == true)\n    {\n        // some code that change bool_var\n        // ...\n    }\n    \n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <stdbool.h>\n\nint test( void )\n{\n  return 0;\n}\n\nint func(int x, int y)\n{\n  int ret_var;\n  ret_var = 1;\n  bool bool_var;\n\n  if ( ( ret_var == 1 ) || ( bool_var = true ) )\n  {\n    // non-compliant\n  }\n\n  if ( ( ret_var = test() ) > 1 )\n  {\n    // non-compliant\n  }\n\n  while (0) {\n    // ...\n    if (x = 0) {  // typical typo interpreted as an assignment\n      ret_var = x = y; // non-compliant\n    }\n  }\n  return ret_var;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the result of the assignment operator is used",
		"desc": "The result of the assignment operator cannot be used",
		"details": "#### Abstract\nThe result of the assignment operator cannot be used\n\n#### Explanation\nThe result of the assignment operator should not be used since it introduces additional side-effects. Doing so also impairs readability of the code."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_13_5",
		"master_id": "2044",
		"name": "The right operand of the && and || operators should not contain persistent side effect",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <stdbool.h>\n\nstatic int int_a;\nvoid func( void );\nint func2( void );\nbool return_true( void );\n\nvoid func( void )\n{\n    int int_b;\n    \n    // right operand do not have side effect\n    if( return_true() || int_b == func2() );\n    // more code that may read int_a\n    // ...\n}\n\nint func2( void )\n{\n    return int_a + 1; // do not have side effect\n}\n\nbool return_true( void )\n{\n    return true;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <stdbool.h>\n\nstatic int int_a;\nvoid func( void );\nint func2( void );\nbool return_true( void );\n\nvoid func( void )\n{\n    int int_b;\n    \n    // int_a is not modified as intended\n    if( return_true() || int_b == func2() );\n    // more code that may read int_a\n    // ...\n}\n\nint func2( void )\n{\n    int_a++; // side effect: int_a is modified\n    return int_a;\n}\n\nbool return_true( void )\n{\n    return true;\n}\n\nvoid func3( void )\n{\n    volatile int x;\n    int y = 1;\n    if ( ( y != 0) || ( x != 1 ) );\n    // access volatile object x has persistent side effect\n}\n\nvoid func4( void )\n{\n    int *fp = func2;\n    if ( (fp == NULL) || (*fp) );\n    // fp points to function with persistent effect\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the right operand of the && and || operators have side effects",
		"desc": "The right operand of the && and || operators cannot have side effects",
		"details": "#### Abstract\nThe right operand of the && and || operators cannot have side effects\n\n#### Explanation\nThe evaluation of the right hand operand of the && and || operators is conditional on the value of the left-hand operand. The right hand operand"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_13_6",
		"master_id": "2045",
		"name": "The operand of sizeof operator should not have potential side effects",
		"severity": "H",
		"compliance": "M",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func( void )\n{\n    int int_a, int_b;\n\n    // the operand do not have side effect\n    int_a = sizeof( int_b );\n    int_b++; // int_b modified as intended\n    // some code that may read int_b\n    // ...\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func( void )\n{\n    int int_a, int_b;\n    \n    // int_b is not modified as intended\n    int_a = sizeof( int_b++ );\n    // some code that may read int_b\n    // ...\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the operand of sizeof operator has persistent side effects",
		"desc": "The operand of sizeof operator cannot have persistent side effects",
		"details": "#### Abstract\nThe operand of sizeof operator cannot have persistent side effects\n\n#### Explanation\nSince sizeof operator does not necessarily execute the expression in its operand, the operand of sizeof must not produce side effects."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_18_4",
		"master_id": "2047",
		"name": "Pointer arithmatic should not be used, except for ++ and --",
		"severity": "L",
		"compliance": "A",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    int *ptr;\n    ptr = arr;\n    ptr++;  // ++ operator is allowed\n    ptr[1] = 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    int *ptr;\n    ptr = arr;\n\n    * (ptr + 1) = 0; // Using + in pointer arithmatic is confusing\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, pointer arithmatic is used, except for ++ and --",
		"desc": "Pointer arithmatic should not be used, except for ++ and --",
		"details": "#### Abstract\nPointer arithmatic should not be used, except for ++ and --\n\n#### Explanation\nPointer arithmetic is confusing to the novice programmers. The expression ptr+1 may be mistakenly interpreted as adding one byte to the address held in ptr."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_18_8",
		"master_id": "2048",
		"name": "Variable length array types should not be used",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid foo() {\n    // Don't use variable-length array\n    int arr[5];\n}\n\nvoid func() {\n    foo();\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid foo(int n) {\n    int arr[n];\n}\n\nvoid func() {\n    foo(-1);\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, variable length array types are used",
		"desc": "Variable length array types should not be used",
		"details": "#### Abstract\nVariable length array types should not be used\n\n#### Explanation\nThe use of variable-length array types would make it impossible to determine statically the amount of memory that must be reserved for a stack"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_19_2",
		"master_id": "2049",
		"name": "Union should not be used",
		"compliance": "A",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <string.h>\n\nstruct Foo {\n    int i;\n    float f;\n    char str[10];\n};\n\nvoid func() {\n    struct Foo data;\n\n    data.i = 5;\n    data.f = 10.5;\n    strcpy(data.str, \"string\");\n\n    // Use struct instead of union to keep everything\n    printf(\"%d\\n\", data.i);\n    printf(\"%f\\n\", data.f);\n    printf(\"%s\\n\", data.str);\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\ntypedef union UnionT\n{\n  int    i;\n  char   c;\n  double d;\n} UNIONT;\n\ntypedef struct MyData\n{\n  int     tag;\n  UNIONT  u;\n} MYDATA;\n\n\nint foo(char ch_param)\n{\n   MYDATA md;\n\n   md.tag = 0;  // say, 0 for int, 1 for char, 2 for double\n   md.u.c = ch_param;\n\n   return md.u.i; // return is undefined\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, union is used",
		"desc": "Union should not be used",
		"details": "#### Abstract\nUnion should not be used\n\n#### Explanation\nIf the union member read is wider than the member written then the value is unspecified. Since it is possible to access bytes with unspecified values, unions should not be used."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_21_3",
		"master_id": "2050",
		"name": "Memory allocation related functions in stdlib.h shall not be used",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid func() {\n\n    #define MAX_STR_SZ 10   \n    char str[MAX_STR_SZ];\n    strncpy(str, \"string\", MAX_STR_SZ);\n    \n    strcpy(str, \"string\");\n    printf(\"%s\", str);\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid func() {\n    char *str;\n\n    str = (char *) malloc(10);\n    strcpy(str, \"string\");\n    printf(\"%s\", str);\n\n    free(str);\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, memory allocation related function ${so.func} in stdlib.h is used",
		"desc": "Memory allocation related functions in stdlib.h shall not be used",
		"details": "#### Abstract\nMemory allocation related functions in stdlib.h shall not be used\n\n#### Explanation\nThe use of memory allocation related functions in stdlib.h can lead to an undefined behaviour. For example:  memory that was dynamically allocated may not be freed subsequently."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_21_4",
		"master_id": "2051",
		"name": "setjmp.h should not be used",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <stdlib.h>\n\n// Do not use functions from setjmp.h\nvoid func() {\n    int val;\n    val = 10;\n    printf(\"%d\", val);\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <stdlib.h>\n#include <setjmp.h>\n\nvoid func() {\n    int val;\n    jmp_buf env_buffer;\n\n    val = setjmp(env_buffer);\n\n    // Set value to val after lngjmp\n    if (val != 0) {\n        printf(\"Return from longjmp with value = %d\", val);\n        exit(0);\n    }\n\n    // Jump back to top\n    printf(\"Jump to top\");\n    // Using longjmp and setjmp can cause undefined behaviour\n    longjmp(env_buffer, 10);\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, setjmp.h is used",
		"desc": "setjmp.h should not be used",
		"details": "#### Abstract\nsetjmp.h should not be used\n\n#### Explanation\nSetjmp allows the normal function call/return mechanisms to be bypassed. The use of that can lead to undefined and unspecified behavior."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_21_5",
		"master_id": "2052",
		"name": "signal.h should not be used",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <stdbool.h>\n#include <unistd.h>\n\nvoid func() { \n    // Do not use signal handler functions \n\n    while(true) {    \n        printf(\"Inside func()\");    \n        sleep(1);  \n    }\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <unistd.h>\n\nvoid sig_handler(int signum) {\n    printf(\"\\nInside handler function\\n\");\n}\n\nvoid func() { \n    // Register signal handler\n    // Using functions from signal.h can lead to undefined behaviour\n    signal(SIGINT,sig_handler); \n  \n    while(true) {    \n        printf(\"Inside func()\");    \n        sleep(1);  \n    }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, signal.h is used",
		"desc": "signal.h should not be used",
		"details": "#### Abstract\nsignal.h should not be used\n\n#### Explanation\nSince signal handling contains an implementation-defined and undefined behaviour, signal.h should not be used for C90 and C99 modes."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_21_6",
		"master_id": "2053",
		"name": "I/O functions in stdio.h should not be used",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    // Do something\n    // Do not use stdio.h functions\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid bar_c(void* ptr)\n{\n    int* dest = (int*)ptr;\n    int data = (*dest);\n    int i;\n    int Buffer[10] = { 0 };\n    if(data >= 0)\n      {\n         Buffer[data] = 1;\n         for(i=0; i<10; i++)\n         {\n             printf(\"%d\", Buffer[i]);\n         }\n     }\n }\n\n void foo_v()\n {\n     int data;\n     data = -1;\n     fscanf(stdin, \"%d\", &data); // this can easily cause array out of bound\n     bar_c(&data);\n } "
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, I/O functions in stdio.h is used",
		"desc": "I/O functions in stdio.h should not be used",
		"details": "#### Abstract\nI/O functions in stdio.h should not be used\n\n#### Explanation\nSince I/O have unspecified, undefined and implementation-defined behaviours，I/O functions and their wide char equivalents in stdio.h should not be used for C90 and C99 modes."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_21_7",
		"master_id": "2054",
		"name": "ascii conversion functions in stdlib.h should not be used",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func() {\n   float val;\n   char str[10];\n   \n   strcpy(str, \"914\");\n   val = 914.000; //Do not use atof, atol, atoll, atoi\n   printf(\"String value = %s, Float value = %f\\n\", str, val);\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <iostream>\n#include <cstdlib>\n\nint foo()\n{\n  char s[] = \"98\";\n  long num;\n\n  num = atol(s);\n\n  std::cout << \"number in long = \" << num << std::endl;\n    \n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, ascii conversion functions in stdlib.h is used",
		"desc": "ascii conversion functions in stdlib.h should not be used",
		"details": "#### Abstract\nascii conversion functions in stdlib.h should not be used\n\n#### Explanation\nSince atof, atol and atoll functions have undefined behaviors associated with them when the string cannot be converted, they should not be used for C90 and C99 modes."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_21_8",
		"master_id": "2055",
		"name": "getenv, getenv and exit functions should not be used",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid func () {\n   printf(\"Start of program\\n\");\n   \n   // Do not use abort, exit, getenv or system\n\n   printf(\"End of program\\n\");\n\n   return(0);\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void)\n{\n  char* ptr_h;\n  char h[64];\n\n  ptr_h = getenv(\"HOME\");  // value of HOME could be > 64, need size guard\n  if (ptr_h != NULL) {\n    // ...\n  }\n  return 0;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, getenv, getenv and exit functions are used",
		"desc": "getenv, getenv and exit functions should not be used",
		"details": "#### Abstract\ngetenv, getenv and exit functions should not be used\n\n#### Explanation\nSince getenv, getenv and exit functions have undefined and implementation-defined behaviors, they should not be used for C90 and C99 modes."
	},
	{
		"category": "",
		"mapping": "",
		"language": "",
		"code": "MSR_21_9",
		"master_id": "2056",
		"name": "bsearch and qsort should not be used",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <stdlib.h>\n\nint arr[] = { 1, 2, 3, 4, 5 };\n\nvoid func () {\n   int key = 3;\n\n   // Use other method other than bsearch for searching element in an array\n   for (int i = 0; i < sizeof(arr) / 4; i++) {\n      if (arr[i] == key) {\n         printf(\"Item found\");\n         break;\n      }\n   }\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <stdlib.h>\n\n\nint cmpfunc(const void * a, const void * b) {\n   return ( *(int*)a - *(int*)b );\n}\n\nint arr[] = { 1, 2, 3, 4, 5 };\n\nvoid func () {\n   int *item;\n   int key = 3;\n\n   // use bsearch to compare and find values of 3 in the array arr\n   item = (int*) bsearch (&key, arr, 5, sizeof (int), cmpfunc);\n   if( item != NULL ) {\n      printf(\"Found item\");\n   } else {\n      printf(\"Item is not in the array\");\n   }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, bsearch and qsort is used",
		"desc": "bsearch and qsort should not be used",
		"details": "#### Abstract\nbsearch and qsort should not be used\n\n#### Explanation\nIf bsearch and qsort function do not behave consistently when comparing elements, or they modify any of the elements, the behavior is undefined. So they should not be used for C90 and C99 modes."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_21_10",
		"master_id": "2057",
		"name": "Time and date functions in stdlib.h should not be used",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n \nvoid func (){\n   // Do something\n   // Do not use time and date function\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <time.h>\n \nvoid func (){\n   // Using time and date function can lead to undefined behaviour\n   printf(\"%ld\", time(NULL));\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, time and date functions in stdlib.h are used",
		"desc": "Time and date functions in stdlib.h should not be used",
		"details": "#### Abstract\nTime and date functions in stdlib.h should not be used\n\n#### Explanation\nSince the time and date functions have unspecified, undefined and implementation-defined behaviors, they should not be used for C90 and C99 modes."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_5_0_1",
		"master_id": "3001",
		"name": "The value of an expression should be the same under any order of evaluation permitted by the standard",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					"\n#define LEN 1024\n\nint array_int[LEN];\n\nint foo(int i, int j)\n{\n  if (j > 0) {\n    return i+1;\n  }\n  else\n    return i;\n}\n\nint bar(unsigned int parm_b)\n{\n  if (parm_b < LEN) \n  {\n    unsigned int temp = parm_b++;\n    array_int[temp] = parm_b ; // behavior is deterministic\n  }\n  return parm_b;\n}\n\nint call_foo(int i)\n{\n  int j = i++;\n  return foo(j, i); // return value non-ambiguous\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n#define LEN 1024\n\nint array_int[LEN];\n\nint foo(int i, int j)\n{ \n  if (j > 0) {\n    return i+1;\n  }\n  else\n    return i;\n}\n\nint bar(unsigned int parm_b)\n{\n  if (parm_b < LEN)\n    array_int[parm_b++] = parm_b ; // behavior is undefined\n  return parm_b;\n}\n  \nint call_foo(int i)\n{\n  return foo(i++, i); // return value is implementation defined\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, the value of ${so.func} is not the same under any evaluation order permitted by the language standard",
		"desc": "For an evaluation of any expression and its side effects, the value must be the same under any evaluation order permitted by the language standard",
		"details": "#### Abstract\nFor an evaluation of any expression and its side effects, the value must be the same under any evaluation order permitted by the language standard\n\n#### Explanation\nSince the expression may have multiple execution orders, the design for any expression, should ensure that the value of the expression and its side effects are the same in all possible execution orders as prescribed by the lexical rule for the expression."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_5_0_8",
		"master_id": "3002",
		"name": "The value of an expression cannot be cast to sizes larger than the underlying type of the expression",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					"\nvoid func_5_0_8(int si, short sh_j, float flt_k)\n{\n  short  local_sh = 0x1234;\n  int    local_int1, local_int2;\n  float  local_flt = 1.0;\n  double local_dbl, local_dbl2;\n\n  local_int1 = static_cast< int > (local_sh) + sh_j;  // compliant\n  local_int2 = static_cast< int > (local_int1) + si;     // compliant\n\n  local_dbl2 = static_cast<double> ((double)flt_k) + local_flt;  // compliant\n  \n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\nvoid func_5_0_8(int si, short sh_j, float flt_k)\n{\n  short  local_sh = 0x1234;\n  int    local_int1, local_int2;\n  float  local_flt = 1.0;\n  double local_dbl, local_dbl2;\n\n  local_int1 = static_cast< int > (local_sh + sh_j);  // non-compliant\n\n  local_dbl2 = static_cast<double> (flt_k + local_flt);  // non-compliant\n  \n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, the value of ${so.func} is cast to sizes larger than the underlying type of the expression",
		"desc": "The value of an expression cannot be cast to sizes larger than the underlying type of the expression",
		"details": "#### Abstract\nThe value of an expression cannot be cast to sizes larger than the underlying type of the expression\n\n#### Explanation\nWhen the value of an expression is cast to a size larger than its underlying type, there may be information loss such as signedness of the value."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_5_0_19",
		"master_id": "3003",
		"name": "More than 2 indirections",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					"\nint array[10][20];\n\n// this example is equivalent to the \"avoid\" example\n// \nint mlk_three_indirect(int val)\n{\n  int j = val;\n  int *p = &j;\n  int **p_2, **r_2;\n  int *p_2_array = &array[*p][0];\n  int p3;\n  \n  array[val][0] = val;\n  p3 = array[val][0];\n  return p3;\n\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\nint array[10][20];\n\nint mlk_three_indirect(int val)\n{\n  int j = val;\n  int *p = &j;\n  int **p_2, **r_2;\n  int *p_2_array = &array[*p][0];\n  int ***p3;\n\n  // ... \n  p_2 = &p;\n  \n  // ...\n  array[val][0] = **p_2;\n  \n  //...\n  r_2 = &p_2_array;\n  \n  // ...\n  p3 = &r_2;\n  \n  // ... \n  return ***p3;\n\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, declaration of objects contains more than two levels of pointer indirection",
		"desc": "Declaration of objects cannot contain more than two levels of pointer indirection",
		"details": "#### Abstract\nDeclaration of objects cannot contain more than two levels of pointer indirection\n\n#### Explanation\nHaving more than two levels of indirection, which gives, at least three levels of dereferencing an object, means it can be very hard to understand the intended behavior of the program."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_8_5_3",
		"master_id": "3004",
		"name": "Bad enum initialization",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					"\ntypedef enum color { red=3 } GoodEnum;   // compliant\n\n// compliant (but assignment not in sequence )\ntypedef enum bad_enum_color { white=0,\n         blue=1,         // 2 is not used \n         yellow=3 } BadEnum;  \n\ntypedef enum no_assign { NO_ONE, NO_TWO, NO_THREE } GoodEnum_NoAssign;\n\nextern void bar( color c, bad_enum_color b, no_assign n);\n\nvoid func_use(void)\n{\n  color var_color = red;\n  bad_enum_color var_bad_color = blue;\n  no_assign var_no_assign = NO_TWO;\n\n  bar(var_color, var_bad_color, var_no_assign);\n  return;\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\ntypedef enum color { red=3 } GoodEnum;   // compliant\n\ntypedef enum bad_enum_color { white=0,\n\t\t\t      blue=1,\n\t\t\t      yellow } BadEnum;  // non-compliant\n\ntypedef enum no_assign { NO_ONE, NO_TWO, NO_THREE } GoodEnum_NoAssign;\n\nextern void bar( color c, bad_enum_color b, no_assign n);\n\nvoid func_use(void)\n{\n  color var_color = red;\n  bad_enum_color var_bad_color = blue;\n  no_assign var_no_assign = NO_TWO;\n\n  bar(var_color, var_bad_color, var_no_assign);\n  return;\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the enum initialization is incorrect",
		"desc": "The only explicit initialization of an enum with the “=” construct is such that all, none or the first one, are initialized",
		"details": "#### Abstract\nThe only explicit initialization of an enum with the “=” construct is such that all, none or the first one, are initialized\n\n#### Explanation\nExplicit and uniform initialization of an enum list prevents mixing of automatic and manual assignment, which is error-prone. The compiler can also detect possible out of range errors for the enum."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_10_1_3",
		"master_id": "3005",
		"name": "Base class has virtual and non-virtual",
		"severity": "H",
		"compliance": "R",
		"likelihood": "L",
		"cost": "H",
		"examples": {
			"good": {
				"cpp": [
					"\nclass Base {};\n\nclass Derived1 : public virtual Base {}; // Base is virtual\n\nclass Derived2 : public virtual Base {}; // Base virtual\n\n// This hierarchy has two derived class from virtual base class\nclass V_and_V : public Derived1, public Derived2 { /* code here */ };\n  \n"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\nclass Base {};\n\nclass Derived1 : public virtual Base {};\n\nclass Derived2 : public Base { };\n\n\nclass V_and_nonV : public Derived1, public Derived2 { };"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, a base class is virtual and non-virtual in a multiple inheritance hierarchy",
		"desc": "A base class should not be both, virtual and non-virtual in a multiple inheritance hierarchy",
		"details": "#### Abstract\nA base class should not be both, virtual and non-virtual in a multiple inheritance hierarchy\n\n#### Explanation\nIf the base class is both virtual and non-virtual in a multiple inheritance hierarchy, then there will be multiple copies of the base class sub-object in the derived object. This is likely a declaration error."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_12_1_1",
		"master_id": "3006",
		"name": "Dynamic type in ctor or dtor",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\nclass Base {\npublic:\n  virtual void func_char();\n  \n  Base() {\n    Base::func_char();   // dynamic, non-virtual call\n  };\n};\n\n\nvoid foo(void)\n{\n  Base example;\n\n  example.func_char();  //  \n  return;\n}\n  "
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n#include <typeinfo>\n\nclass Base {\npublic:\n  virtual void func_char();\n  \n  Base() {\n    func_char();   // dynamic, virtual call to a virtual function\n    typeid(Base);  // dynamic typeid on a class with virtual function\n  };\n};\n\n\nvoid foo(void)\n{\n  Base example;\n\n  example.func_char();  //  \n  return;\n}\n  "
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, an object’s dynamic type is used from the body of its constructor or destructor",
		"desc": "An object’s dynamic type cannot be used from the body of its constructor or destructor",
		"details": "#### Abstract\nAn object’s dynamic type cannot be used from the body of its constructor or destructor\n\n#### Explanation\nA non-static member of an object can have an initialization with the declaration of the member in its body (NSDMI). To avoid confusion, any member initialized this way (NSDMI) or with a constructor should be the same."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_12_1_2",
		"master_id": "3007",
		"name": "ctor must explicitly call ctor for all its immediate base classes",
		"compliance": "A",
		"examples": {
			"good": {
				"cpp": [
					"\nclass Base {\npublic:\n  Base() {}\n  Base(int i);\n};\nclass Derived1 : public virtual Base {\npublic:\n  //  Derived1() {}\n  Derived1(int) : Base(0) {}\n};\nclass Derived2 : public virtual Base {\npublic:\n  //  Derived2() {}\n  Derived2(int) : Base(1) {}\n};"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\nclass Base {\npublic:\n  Base() {}\n  Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {}\n  Derived1(int) : Base(0) {}\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  Derived2(int) : Base(1) {}\n}; \n\n\nclass Hier : public Derived1, public Derived2 {\n  //  Hier()    {}\n  Hier(int) {} // constructor used is ambiguous w.r.t. Derived1 or Derived2\n\n};"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, ctor does not explicitly call ctor for all its immediate base classes",
		"desc": "ctor must explicitly call ctor for all its immediate base classes",
		"details": "#### Abstract\nctor must explicitly call ctor for all its immediate base classes\n\n#### Explanation\nIf ctor call ctor for all its immediate base classes, it would reduce confusion over which constructor and parameters to use."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_12_1_3",
		"master_id": "3008",
		"name": "ctor with single parameter of basic type should be explicit",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\nclass Base {\npublic:\n  Base() {}\n  explicit Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {} \n  explicit Derived1(int) : Base(0) {}    // make explicit\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  explicit Derived2(int) : Base(1) {}    // make explicit\n}; \n\n\nclass Hier : public Derived1, public Derived2 {\n  explicit Hier(int) : Derived1(2), Derived2(), Base() {}  // make explicit\n\n};"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n\nclass Base {\npublic:\n  Base(void) {}\n  Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {}\n  Derived1(int) : Base(0) {}\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  Derived2(int) : Base(1) {}\n}; \n\nclass Hier : public Derived1, public Derived2 {\n  Hier(int)    {}\n};"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, ctor with single parameter of basic type is not explicit",
		"desc": "ctor with single parameter of basic type should be explicit",
		"details": "#### Abstract\nctor with single parameter of basic type should be explicit\n\n#### Explanation\n"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_11_0_1",
		"master_id": "3009",
		"name": "Non-POD member in a class must be private",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\ntypedef char    Letter;  \ntypedef Letter* pLetter;\n  \nclass Class_Without_POD    \n{\npublic:\n  Letter  c;  \n  pLetter p;\n};\n\nclass Class_with_POD\n{\nprivate:\n  char    c;         // will need interfaces to access and modify\n  char*   pc;  \n};"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n#include <stdint.h>\n\ntypedef char    Letter;  \ntypedef Letter* pLetter;\n  \nclass Class_Without_POD    \n{\npublic:\n  Letter  c;  \n  pLetter p;\n};\n\nclass Class_with_POD\n{\npublic:\n  int8_t   c;         // POD has no default constructor\n  char*   pc;  \n};"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, non-POD member in a class is not private",
		"desc": "Non-POD member in a class must be private",
		"details": "#### Abstract\nNon-POD member in a class must be private\n\n#### Explanation\n"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_10_2_1",
		"master_id": "3010",
		"name": "All visible names within an inheritance hierarchy must be unique",
		"compliance": "A",
		"examples": {
			"good": {
				"cpp": [
					"\nclass Base {\npublic:\n  Base() {}\n  void func_char(char) {};\n};\n\nclass Derived : public Base {\npublic:\n  Derived() : Base() {}\n  void func_int(int) {};\n};\n\n\nint foo(void)\n{\n  int   i;\n  char ch;\n  Derived example;\n\n  example.func_int(i);\n\n  example.func_char(ch);  // func(char) in Base is not visible\n\n  return i;  \n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n\nclass Base {\npublic:\n  void func(char) {};\n};\n\nclass Derived : public Base {\npublic:\n  void func(int) {};\n};\n\n\nint foo(void)\n{\n  int   i;\n  char ch;\n  Derived example;\n\n  example.func(i);\n  example.func(ch);  // func(char) in Base is not visible \n  \n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the visiable names within a inheritance hierarchy are not unique",
		"desc": "All visible names within an inheritance hierarchy must be unique",
		"details": "#### Abstract\nAll visible names within an inheritance hierarchy must be unique\n\n#### Explanation\n"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_17_7",
		"master_id": "2058",
		"name": "Value returned by a function should be used",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nextern int func_ret_int(int, int);\n\n\nvoid bar(int n, int m)\n{\n  if (n > 0) {\n    n += func_ret_int(n, m);\n  }\n  else {\n    (void)func_ret_int(m, m); // func return value ignored\n  }\n}\n"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nextern int func_ret_int(int);\n\n\nvoid bar(int n, int m)\n{\n  if (n > 0) {\n    n += func_ret_int(n);\n  }\n  else {\n    func_ret_int(m); // func return value ignored\n  }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, value returned by ${so.func} is not used",
		"desc": "The value returned by a function which has non-void return type should be used",
		"details": "#### Abstract\nThe value returned by a function which has non-void return type should be used\n\n#### Explanation\nCalling a function without using the return value may be an error for a C90 and a C99 mode. Return value of a function should be cast to the void type if it is intended not to be used explicitly."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_17_8",
		"master_id": "2059",
		"name": "A function parameter should not be modified",
		"compliance": "A",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func(int param){\n    // Only use param, do not ever modify it by assigning another value\n    printf(\"%d\\n\", param);\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint param_0 =1;\n\nvoid func(int param){\n    // Modifying parameter can cause confusion\n    param = param_0;\n    printf(\"%d\\n\", param);\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, a function parameter is modified",
		"desc": "The parameter of a function should not be modified",
		"details": "#### Abstract\nThe parameter of a function should not be modified\n\n#### Explanation\nModifying the parameter of a function can be confusing and in conflict with programmer expectations for C90 and C99 modes. So the The parameter of a function should not be modified."
	},
	{
		"category": "",
		"language": "c",
		"code": "MSR_10_2",
		"master_id": "2046",
		"name": "char not allowed in arithmatic expression",
		"examples": {
			"good": {
				"cpp": "",
				"java": "",
				"c": "\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    // essentially character type declared\n  char char_var;   \n  char numb;\n  char_var = '9';\n  // convert numa to digit value 9\n  numb = char_var - '0';\n  return numb\n\n}\n",
				"general": ""
			},
			"bad": {
				"cpp": "",
				"java": "",
				"c": "\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    // essentially character type declared\n    char char_var;\n    int numb;\n    char_var = '9';\n    // the result of char_var + '>' do not make sense\n    numb = char_var + '>';\n    return numb;\n\n}",
				"general": ""
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, char is used in arithmatic expression ${so.func}",
		"desc": "Use basic character variables appropriately for addition and subtraction",
		"details": "#### Abstract\nUse basic character variables appropriately for addition and subtraction\n\n#### Explanation\nSince the data in the basic character variable does not represent a numeric value, the basic character variable should be used appropriately in the addition and subtraction expressions."
	},
	{
		"category": "",
		"mapping": "",
		"language": "",
		"code": "MSR_14_2",
		"master_id": "2060",
		"name": "A for loop should be well-formed",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // Do something \n    }\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // modifying the induction variable i. Error prone and hard to review\n        i = i + 4;\n    }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the for loop is not well-formed",
		"desc": "A loop consists of three clauses. Firstly, a loop counter properly assigned and defined (empty is permissible). Secondly, a loop terminating expression that uses the loop counter, with no persistent side effects. And that expression does not contain objects modified in the loop body. Thirdly, an expression with the loop counter being modified and no other objects used that are modified in the loop body.",
		"details": "#### Abstract\nA for loop should be well-formed\n\n#### Explanation\nThe second and third clause of the for loop statement should not use any object that is modified in the for loop body. Using a restricted form of for loop will make code easier to check and review."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_14_3",
		"master_id": "2061",
		"name": "Controlling expressions should not be invariant",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdbool.h>\n\nvoid func() {\n    // Compliant by exception 1\n    while (true) {\n        // Do something\n    } \n\n    // Compliant by exception 2\n    do {\n        // Do something\n    } while (0 == 1);\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    // The if statement always evaluates to false, dead code\n    if (10 > 11) {\n        // Do something\n    }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func} is using an invariant value for controlling expressions",
		"desc": "Controlling expression of a statement should not be invariant",
		"details": "#### Abstract\nControlling expression of a statement should not be invariant\n\n#### Explanation\nUsing invariant values as controlling expresson can cause programming error. The compiler might even remove the code as it may not be able to be reached due to invariant expression. This might result in unwanted removal of defensive code."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_15_1",
		"master_id": "2062",
		"name": "The goto statement should not be used",
		"compliance": "A",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    int num = 0;\n\n    num += 1;\n    // Do not use the goto statement\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    int num = 0;\n\n    P1:\n    num += 1;\n\n    // Using the goto statement can cause confusion\n    goto P1;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func} uses the goto statement",
		"desc": "The goto statement should not be used",
		"details": "#### Abstract\nThe goto statement should not be used\n\n#### Explanation\nUsing the goto statement without constraints can lead to unstructured and extremely difficult to understand programs."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_15_2",
		"master_id": "2063",
		"name": "The goto statement should jump to a label declared later in the same function",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    int num = 0;\n\n    // No back jump in the code\n    goto P1;\n\n    P1:\n    num += 1;\n}\n"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    int num = 0;\n\n    P1:\n    num += 1;\n\n    // Non-compliant as back jump is allowed\n    goto P1;\n}\n"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the goto statement does not jump to a label declared later in the same function",
		"desc": "If a goto statement is really needed, it shall be a forward goto.",
		"details": "#### Abstract\nIf a goto statement is really needed, it shall be a forward goto.\n\n#### Explanation\nSince using the goto statement without constraints can lead to unstructured and extremely difficult to understand programs, the use of goto statement should be restricted. Using language provided iteration statement results in much more readable code."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_15_3",
		"master_id": "2064",
		"name": "A goto statement and its label must be in the same scope",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    int num = 0;\n\n    P1:\n        if (num == 5) {\n        P2:\n            num += 1;\n        }\n\n    // Jumping into the reference label outside of the nested block\n    goto P1;\n}\n"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    int num = 0;\n\n    P1:\n        if (num == 5) {\n        P2:\n            num += 1;\n        }\n\n    // Jumping into nested label is non-compliant\n    goto P2;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, a goto statement and its label are not in the same scope",
		"desc": "Label should be declared in the same scope as its goto statement.",
		"details": "#### Abstract\nLabel should be declared in the same scope as its goto statement.\n\n#### Explanation\nUsing the goto statement without constraints can lead to unstructured and extremely difficult to understand programs. Allowing goto statement to jump between blocks or into nested blocks to a reference label make the code visually complex."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_15_4",
		"master_id": "2065",
		"name": "There should not be more than one break or goto for early loop termination",
		"compliance": "A",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // Only use either break or goto, don"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // Multiple early termination\n        if (i == 2) {\n            break;\n        }\n        // Multiple early termination\n        else if (i == 2) {\n            goto EXIT;\n        }\n        else {\n            // Continue\n        }\n    }\n\n    EXIT:\n        ;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, loop early exits use both break and goto in the same loop",
		"desc": "There should not be more than one break or goto for early loop termination",
		"details": "#### Abstract\nThere should not be more than one break or goto for early loop termination\n\n#### Explanation\nUsing the goto statement without constraints can lead to unstructured and extremely difficult to understand programs. Restricting the number of exits in a loop helps simplify the source code."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_15_7",
		"master_id": "2066",
		"name": "Each if statement in if-else should have an else statement",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdbool.h>\n\nvoid func() {\n    bool flag;\n\n    if (flag == true) {\n        // Do something\n    }\n    else {\n        // Add else statement as defensive programming\n        // Do something\n    }\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdbool.h>\n\nvoid func() {\n    bool flag;\n\n    if (flag == true) {\n        // Do something\n    }\n    else if (flag == false) {\n        // Do something\n    }\n    // Non-compliant as there is no else statement\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func} did not end with an else statement.",
		"desc": "Each if-else should have an if statement and end with an else statement.",
		"details": "#### Abstract\nEach if-else should have an if statement and end with an else statement.\n\n#### Explanation\nUsing the else statement to terminate the if ... else if constructs complements the requirement for a default clause in a switch statement ad is a kind of defensive programming."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_16_5",
		"master_id": "2067",
		"name": "A default label should appear as either the first or the last switch label of a switch statement",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nint loop_cnt(int count, int input)\n{\n  int idx = count;\n  \n  switch (input) {\n  case 0:\n    idx--;\n    break;\n    \n  case 1:\n    idx++;\n    break;\n    \n  default:\n    break;\n  }\n  \n  // ...\n  return idx;\n}\n\n\nint loop_cnt_ex2(int count, int input)\n{\n  int idx = count;\n  \n  switch (input) {\n    \n  default:   // default at beginning of switch\n    break;\n    \n  case 0:\n    idx--;\n    break;\n    \n  case 1:\n    idx++;\n    break;\n\n  }\n  \n  // ...\n  return idx;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nint loop_cnt(int count, int input)\n{\n  int idx = count;\n  \n  switch (input) {\n    \n  case 0:\n    idx--;\n    break;\n    \n  default:  // default in between case statements\n    break;\n    \n  case 1:\n    idx++;\n    break;    \n\n  }\n  \n  // ...\n  return idx;\n}\n\n\nint loop_cnt_ex2(int count, int input)\n{\n  int idx = count;\n  \n  switch (input) {\n    \n  // missing default statement in begin nor end \n    \n  case 0:\n    idx--;\n    break;\n    \n  case 1:\n    idx++;\n    break;\n\n  }\n  \n  // ...\n  return idx;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the default label for the switch statement was not placed in first or last.",
		"desc": "The default label for the switch statement should be placed in first or last.",
		"details": "#### Abstract\nThe default label for the switch statement is not placed in first or last.\n\n#### Explanation\nPutting the default label anywhere else other than the first or last in a switch statement makes it difficult to locate."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_16_7",
		"master_id": "2068",
		"name": "A switch-expression should not have essentially Boolean type",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdbool.h>\n#include <stdio.h>\n\nvoid func( int num ) {\n    // If else is more appropriate than switch for controlling expression with boolean\n    if (num == 0) {\n        printf(\"True\");\n    }\n    else {\n        printf(\"default\");\n    }\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdbool.h>\n#include <stdio.h>\n\nvoid func() {\n    int num = 0;\n    // Switch with boolean caluse as the controlling expression is redundant\n    switch(num == 0) {\n        case true:\n            printf(\"True case\");\n            break;\n        default:\n            printf(\"default case\");\n            break;\n    }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, a switch expression was of boolean type.",
		"desc": "A switch expression should not be of boolean type.",
		"details": "#### Abstract\nA switch expression should not be of boolean type.\n\n#### Explanation\nAlthough it is possible to implement a switch statement controlling expression with a Boolean, it would be more appropriate to implement the logic with an if-else construct as defined by the standard."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_17_1",
		"master_id": "2069",
		"name": "The features of <stdarg.h> should not be used",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func(double arg) {\n    double var;\n    \n    // Should not use <stdarg.h> for variable argument processing\n    var = arg;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdarg.h>\n\nvoid func(va_list var_arg) {\n    double var;\n    \n    // Using va_list and va_arg can cause undefined behaviour\n    var = va_arg(var_arg, double);\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func},  features of <stdarg.h> were used.",
		"desc": "The features of <stdarg.h> should not be used.",
		"details": "#### Abstract\nThe features of <stdarg.h> should not be used.\n\n#### Explanation\nva_list, va_arg, va_start, va_end, and va_copy should never be used. There are many instances of undefined behaviour when the source code are not organized properly causing inconsistency in type or usages."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_17_2",
		"master_id": "2070",
		"name": "Functions should not call themselves, either directly or indirectly",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func(int num){\n    // Implement recursion using for loop instead\n    for (int i = num; i == 0; i--){\n        printf(\"%d\\n\", i);\n    }\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func(int num){\n    if (num == 0) {\n        return;\n    }\n\n    printf(\"%d\\n\", num);\n\n    func(num - 1); // Using recursion unless tightly controlled can exceed available stack\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func} called itself.",
		"desc": "Functions should not call themselves, either directly or indirectly - recursive function (direct or indirect) should not be reused.",
		"details": "#### Abstract\nFunctions should not call themselves, either directly or indirectly - recursive function (direct or indirect) should not be reused.\n\n#### Explanation\nWhen a function is calling itself, i.e. recursion, it can lead to stack space exhaustion. It is not possible to determine what the worst-case stack usage is before execution."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_17_5",
		"master_id": "2071",
		"name": "Parameters of array type should have specified sizes",
		"compliance": "A",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid fun_arr1 (int array[4]) {\n    // Do something\n}\n\nvoid func(int num){\n    int arr[4] = {1, 2, 3, 4};\n\n    // Array size match prototype\n    func_arr1(arr);\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid arr1 (int array[4]) {\n    // Do something\n}\n\nvoid func(int num){\n    int arr[3] = {1, 2, 3};\n\n    // Array size does not match prototype\n    arr1(arr);\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, parameters of array type did not have specific sizes.",
		"desc": "Parameters of array type should have specified sizes.",
		"details": "#### Abstract\nParameters of array type should have specified sizes.\n\n#### Explanation\nAlthough it is legal in C to pass an array of the unspecified size to a parameter with a specified size, doing so can lead to unexpected behaviour such as array out of bound."
	},
	{
		"category": "",
		"mapping": "",
		"language": "",
		"code": "MSR_18_1",
		"master_id": "2072",
		"name": "A pointer resulting from arithmetic on a pointer operand shall address an element of the same array as that pointer operand",
		"severity": "H",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    // Points to one beyond only, still defined\n    int *p = &arr[3];\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    // Points to two beyond, undefined\n    int *p = &arr[4];\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func} assessed an undefined location with a pointer that went out of bound.",
		"desc": "Pointer arithmatic should not cause an array out of bound access",
		"details": "#### Abstract\nPointer arithmatic should not cause an array out of bound access\n\n#### Explanation\nCompilers can only determine at compile time whether an array boundary has been exceeded. No checks are done at run-time for invalid array indexing. Using invalid indexing can cause program to have erroneous behaviour."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_21_11",
		"master_id": "2073",
		"name": "The standard header file <tgmath.h> should not be used",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <math.h>\n\nvoid func() {\n   float f1;\n   // Float version of square root is used, safer\n   f1 = sqrt(49);\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <tgmath.h>\n\nvoid func() {\n   float f1;\n   // Generic square root is used, can cause undefined behaviour\n   f1 = sqrt(49);\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func} use the standard header file <tgmath.h>",
		"desc": "The standard header file <tgmath.h> should not be used",
		"details": "#### Abstract\nThe standard header file <tgmath.h> should not be used\n\n#### Explanation\nSince using functions declared in tgmath.h can result in undefined behaviour, <tgmath.h> shall not be used"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_21_12",
		"master_id": "2074",
		"name": "The exception handling features of <fenv.h> should not be used",
		"compliance": "A",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <fenv.h>\n#include <stdio.h>\n#include <math.h>\n\nvoid func() {\n   // Do not use functions from fenv.h for exception handling\n   sqrt(-1);\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <fenv.h>\n#include <stdio.h>\n#include <math.h>\n\nvoid func() {\n   // Using exception handlinf features can cause undefined behaviour\n   feclearexcept(FE_ALL_EXCEPT);\n   \n   sqrt(-1);\n\n   if (fetestexcept(FE_INVALID)) {\n      printf(\"FE_INVALID casued by sqrt(-1\");\n   }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func} use exception handling features declared in <fenv.h>",
		"desc": "The program used exception handling features declared in <fenv.h>",
		"details": "#### Abstract\nThe program used exception handling features declared in <fenv.h>\n\n#### Explanation\nThe floatin-point status flags may become unspecified in some circumstances. Attempting to access them may cause undefined behaviour. "
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_14_1",
		"master_id": "2075",
		"name": "A loop counter should not have essentially floating type",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    // Using int as a loop counter\n    for (int i = 1; i < 10; i++) {\n        // Do something\n    }\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nvoid func() {\n    // Using float as a loop counter can lead to unexpected result\n    for (float f = 0.0f; f < 10.0f; f += 0.1f) {\n        // Do something\n    }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func} use floating point as a loop counter",
		"desc": "The program uses floating point as a loop counter which can cause mismatch betweeen expected and actual result.",
		"details": "#### Abstract\nThe program uses floating point as a loop counter which can cause mismatch betweeen expected and actual result.\n\n#### Explanation\nUsing a floating point as a loop counter can cause accumulation of rounding errors. This might cause mismatch between the expected number of iterations and the actual number of iterations when the program runs depending on the implementation."
	},
	{
		"category": "",
		"mapping": "",
		"language": "",
		"code": "MSR_16_6",
		"master_id": "2076",
		"name": "Every switch statement should have at least two switch-clauses",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nint func ( char grade )\n{\n    // Switch statement have at least two switch-clauses\n    switch( grade ) \n    {        \n        case 'A':\n            printf( \"great\" );\n            break;\n        case 'B':\n            printf( \"good\" );\n            break;\n        default:\n            printf( \"not so well\" );\n            break;\n    }\n    return 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func() {\n    int num = 2;\n    switch(num + 2) {\n        default:\n            // Only one switch-clause\n            printf(\"default case\");\n            break;\n    }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func} have less than two switch-clause",
		"desc": "Every switch statement should have more than one switch-clause",
		"details": "#### Abstract\nEvery switch statement should have more than one switch-clause\n\n#### Explanation\nHaving a single path for a switch statement is not only redundant but also an indicative of programming error."
	},
	{
		"category": "",
		"mapping": "",
		"language": "",
		"code": "MSR_9_1",
		"master_id": "2077",
		"name": "Local variables should be initialized before being read",
		"compliance": "M",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "",
		"desc": "Local variables should be initialized before being read",
		"details": "#### Abstract\nLocal variables should be initialized before being read\n\n#### Explanation\nObjects with static storage duration are automatically initialized to zero unless initialized explicitly. Objects with atutomatic storage duration are not automatically initialized so that they can have indeterminate values."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_18_2",
		"master_id": "2078",
		"name": "Subtraction between pointers should only be applied to pointers that address elements of the same array",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stddef.h>\n\nvoid func()\n{\n    int arr[3] = {0, 1, 2};\n\n    // Points to two beyond\n    int *p1 = &arr[0];\n    int *p2 = &arr[2];\n\n    ptrdiff_t diff;\n    diff = p1 - p2; // undefined\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}，pointer subtraction causes an array out of bound access",
		"desc": "Pointer subtraction should not cause access violation, such as array out of bound.",
		"details": "#### Abstract\nPointer subtraction should not cause access violation, such as array out of bound.\n\n#### Explanation\nIf pointers do not point to elements of the same array or the element one beyond the end of that array, the subtraction between them is undefined behaviour."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_18_6",
		"master_id": "2079",
		"name": "Address of a local variable should not be passed outside of the variable's scope",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, address of a local variable is passed outside of the variable's scope",
		"desc": "Address of a local variable should not be passed outside of the variable's scope",
		"details": "#### Abstract\nAddress of a local variable should not be passed outside of the variable's scope\n\n#### Explanation\nWhen the lifetime of one object expires, its address becomes indeterminate. Then the use of that inderterminate address would result in undefined behaviour."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_22_1",
		"master_id": "2080",
		"name": "All resources obtained dynamically by means of Standard Library functions should be released",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}，resources obtained dynamically from Standard library functions are not relaeased.",
		"desc": "Resources obtained dynamically from Standard library functions should be relaeased.",
		"details": "#### Abstract\nResources obtained dynamically from Standard library functions should be relaeased.\n\n#### Explanation\nIt is possible for a failure to occur due to exhaustion of resources if those resources are not explicitly released . Releasing resources as soon as possible reduces the possibility of exhaustion."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_22_2",
		"master_id": "2081",
		"name": "A block of memory should only be freed if it was allocated by Standard Library function",
		"compliance": "M",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}，a block of memory is freed when it was not allocated by Standard Library function",
		"desc": "A block of memory should only be freed if it was allocated by Standard Library function",
		"details": "#### Abstract\nA block of memory should only be freed if it was allocated by Standard Library function\n\n#### Explanation\nIt is undefined behavior to freeing non-allocated memory or freeing the same allocated memory more than one time."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_22_4",
		"master_id": "2082",
		"name": "There should be no attempt to write to a stream which has been opened as read-only",
		"compliance": "M",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    FILE *fp;\n    fp = fopen ( \"test_file\", \"w+\" );\n    fprintf( fp, \"write to a stream\" ); // compliant\n    fclose( fp );\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    FILE *fp;\n    fp = fopen ( \"test_file\", \"r\" );\n    fprintf( fp, \"write to a read-only stream\" ); // non-compliant\n    fclose( fp );\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the stream which is opened as read-only is written to.",
		"desc": "Read-only stream should not be written to",
		"details": "#### Abstract\nRead-only stream should not be written to\n\n#### Explanation\nSince the Standard does not specify the behaviour if an attempt is made to write to a read-only stream, writting to a read-only stream is unsafe."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_14_4",
		"master_id": "2084",
		"name": "The controlling expression of an if statement and iteration-statement should have Boolean type",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#define NULL 0\n\nint foo(int *p_int)\n{\n  int ret = 0;\n  int i;\n  \n  while (p_int != NULL) {   // p_int is a pointer\n      i = *p_int;\n      \n      if (i != 0) {   // i != 0 is a boolean expression\n\tret++;\n      }\n    ret++;\n    p_int--;\n    if (ret > 5)\n    {\n      break;\n    }\n  } \n  return ret;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nint foo(int *p_int)\n{\n  int ret = 0;\n  int i;\n  \n  while (p_int) {   // p_int is a pointer\n    i = *p_int;\n    \n    if (i) {   // i is int, not boolean\n      ret++;\n    }\n\n    ret++;\n    p_int--;\n  } \n  return ret;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the controlling expression of an if statement does not have Boolean type.",
		"desc": "The controlling expression of an if or iteration statement should basically be of boolean type",
		"details": "#### Abstract\nThe controlling expression of an if or iteration statement should basically be of boolean type\n\n#### Explanation\nThe controlling expression without basically Boolean type of an if statement or iteration-statement would lead to a weak typing."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_18_7",
		"master_id": "2085",
		"name": "Flexible array members should not be declared",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n// compliant\nstruct Books\n{\n    char    title[20];\n    char    author[10];\n    int     id[5];\n} book;"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nstruct Books\n{\n    char    title[20];\n    char    author[10];\n    int     id[ ]; // flexible array menber\n} book;"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the flexible array menbers are declared.",
		"desc": "The program should not declare flexible array members",
		"details": "#### Abstract\nFlexible array members should not be declared\n\n#### Explanation\nSince the assignment of a structure that contains a flexible array member to another similar type may behave unexpectedly, flexible array members should not be declared."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_8_1",
		"master_id": "2086",
		"name": "Type should be clearly specified",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n// Compliant function type\nextern void g (char a, const int b); // Explicit int type for b\n\n// Compliant object type\nconst int p; // Explicit int type for p"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n// Non-compliant function type\nextern void g (char a, const b); // Implicit int type for b\n\n// Non-compliant object type\nconst   p; // Implicit int type for p"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, type is not clearly specified.",
		"desc": "The program should explicitly specify the types for all objects",
		"details": "#### Abstract\nThe program should explicitly specify the types for all objects\n\n#### Explanation\nIf an explicit type is omitted, it may lead to declaration confusion."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_11_1",
		"master_id": "2087",
		"name": "Conversions should not be performed between a pointer to a function and any other type",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid func ( void )\n{\n    typedef void ( *fp ) ( int x );\n    extern void f ( int y );\n    typedef fp ( *test ) ( void );\n\n    fp p = NULL; // null pointer constant into function pointer is compliant\n    fp q = f; // function into function pointer is compliant\n    test tfunc;\n    ( void ) ( *tfunc( ) ); // function pointer into void\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					" \n#include <stdio.h>\n #include <stdlib.h>\n\ntypedef char ( *f1 ) ( int );\ntypedef char ( *f2 ) ( int );\n\nvoid func ( void )\n{\n    int x = 1;\n    int *p = &x;\n    int *q[10];\n    f1 a = ( f1 ) p; // function pointer converted into different one is non-compliant\n    f2 b = ( f2 ) *q; // non-compliant\n    f1 c = ( f1 ) 1; // function pointer converted into int is non-compliant\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, a pointer to a function is converted into other type.",
		"desc": "A pointer to a function should not be converted into any other type",
		"details": "#### Abstract\nThe program should not convert a pointer to a function into any other type\n\n#### Explanation\n The function which uses an incompatible pointer type should not be called. Otherwise it would lead to undefined behaviour."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_16_2",
		"master_id": "2088",
		"name": "The use of a switch label",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint main( int s )\n{\n    switch (s)\n    {\n        case 1: // Compliant\n            printf(\"%d\", 1);\n            break;\n        case 2: // Compliant\n            printf(\"%d\", 2);\n            break;\n        default:\n            break;\n    }\n\n    return 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint main()\n{\n    int s, i;\n\n    switch (s)\n    {\n        case 5: // Compliant\n            printf(\"%d\", 5);\n            for( i=0; i<3; i++ )\n            {\n        case 10: // Unstructed code\n            printf(\"%c\", \"s\");\n            }\n            break;\n        default:\n            break;\n    }\n    \n    return 0;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the switch label is placed before any statement.",
		"desc": "switch label should be used at the outermost level of of the compound statement",
		"details": "#### Abstract\nswitch label should be used at the outermost level of of the compound statement\n\n#### Explanation\nPlacing the switch label before any statement in the body of a switch statement is unstructured code"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_16_4",
		"master_id": "2089",
		"name": "Every switch statement should have a default label",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint main( int s )\n{\n    switch (s)\n    {\n        case 10:\n            printf(\"%s\", \"ten\");\n            break;\n        case 20:\n            printf(\"%s\", \"twenty\");\n            break;\n        default: // Compliant\n            break;\n    }\n\n    return 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint main( int s )\n{\n    switch (s)\n    {\n        case 10:\n            printf(\"%s\", \"ten\");\n            break;\n        case 20:\n            printf(\"%s\", \"twenty\");\n            break;\n    // default label is missing\n    }\n\n    return 0;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the switch statement does not have a default label",
		"desc": "There should be a default label after every switch statement",
		"details": "#### Abstract\nThere should be a default label after every switch statement\n\n#### Explanation\nThe default label makes the programming defensive. And there should be a statement or comment after the default label."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_17_4",
		"master_id": "2090",
		"name": "All exit paths for a non-void function should have a return statement",
		"compliance": "M",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint func ( void )\n{\n    printf(\"Hello\");\n    return 0; // compliant\n}\n\nint main()\n{\n    func(); // compliant\n    return 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint func ( int x )\n{\n    for ( ; x < 5; x++){\n        printf(\"less than five\");\n        return 0;\n    }\n    // control may reach end of function without returning\n}\n\nint main()\n{\n    func(10); // undefined behaviour\n    return 0;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the return statement does not have an expression for non-void return type function",
		"desc": "There should be a return statement expression for non-void function",
		"details": "#### Abstract\nThere should be a return statement expression for non-void function\n\n#### Explanation\nIt is undefined behaviour that the calling function uses the returned value while the non-void function does not return a value. "
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_17_6",
		"master_id": "2091",
		"name": "The declaration of an array parameter should not contain the static keyword between the [ ]",
		"compliance": "M",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n// array parameter declaration without static\nvoid func(int arr[10])\n{\n    for (int i =0; i < 10; i++)\n    {\n        arr[i]++;\n        printf(\"%d\", arr[i]);\n    }\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n// non-compliant for use of static in array parameter declaration\nvoid func(int arr[static 5])\n{\n    int i = 0;\n    for (int i =0; i < 5; i++)\n    {\n        arr[i]++;\n    }\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the declaration of an array parameter contain the static keyword between the [ ]",
		"desc": "There should not be static keyword in the declaration of an array parameter",
		"details": "#### Abstract\nThere should not be static keyword in the declaration of an array parameter\n\n#### Explanation\nIf the number of elements contained by an array parameter is less than the minimum specified, it is undefined behaviour."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_18_5",
		"master_id": "2092",
		"name": "Declarations should not contain more than two levels of pointer nesting",
		"compliance": "A",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n// compliant for no more than two pointer declarators\nint i = 0;\nint * ip1 = &i;\nint ** ip2 = &ip1;"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\nint i = 0;\nint * ip1 = &i;\nint ** ip2 = &ip1;\n// more than two levels of pointer nesting should be avoided\nint ***ip3 = &ip2;\nint ****ip4 = &ip3;\nint *****ip5 = &ip4;"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the declarations contain more than two levels of pointer nesting",
		"desc": "There should not be more than two levels of pointer nesting",
		"details": "#### Abstract\nThere should not be more than two levels of pointer nesting\n\n#### Explanation\nIf there are more than two levels of pointer nesting for declaration, it would be confusing to understand the code."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_3_1_2",
		"master_id": "2093",
		"name": "Functions should not be declared at block scope",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\n#include <stdio.h>\n\nvoid func ( int x )\n{\n    x++;\n}\n\nvoid func_out_block(); // function declared out of block"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n#include <stdio.h>\n\nvoid func ( int x )\n{\n    x++;\n    void func_in_block(); // function declared in block\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the functions are declared at block scope",
		"desc": "There should not be function declaration at block scope",
		"details": "#### Abstract\nThere should not be function declaration at block scope\n\n#### Explanation\nDeclaration of a function at block scope would lead to a member of enclosing namespace which is confusing."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_4_10_1",
		"master_id": "2094",
		"name": "NULL should not be used as an integer",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\n#include <stdio.h>\n\nvoid func ( int *x )\n{\n    x++;\n}\n\nint main ( )\n{\n    func ( NULL ); // NULL used as an pointer\n    return 0;\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n#include <stdio.h>\n\nvoid func ( int x )\n{\n    x++;   \n}\n\nint main ( )\n{\n    func ( NULL ); // NULL used as an integer value\n    return 0;\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func},  NULL is used as an integer",
		"desc": "NULL should not be used as integer",
		"details": "#### Abstract\nNULL should not be used as integer\n\n#### Explanation\nNULL should be considerded to be of pointer type in order to be different from 0."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_4_10_2",
		"master_id": "2095",
		"name": "0 should not be used as null-pointer-constant",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\n#include <stdio.h>\n\nvoid func ( int x )\n{\n    x++;\n}\n\nint main ( )\n{\n    func ( 0 ); // 0 used as an integer value\n    return 0;\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n#include <stdio.h>\n\nvoid func ( int *x )\n{\n    x++;   \n}\n\nint main ( )\n{\n    func ( 0 ); // 0 used as an null pointer constant\n    return 0;\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, 0 is used as null-pointer-constant",
		"desc": "0 should not be used as null-pointer-constant",
		"details": "#### Abstract\n0 should not be used as null-pointer-constant\n\n#### Explanation\n0 should be considered to be of integer type in order to be different from NULL"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_6_2_1",
		"master_id": "2096",
		"name": "Assignment operators should not be used in sub-expressions",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int a,b,c;\n    a = 5;\n    b = 10;\n    c = b; // assignment outside sub-expression\n    if ( c > a )\n    {\n        printf(\"c bigger than a\");\n    }\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int a,b,c;\n    a = 5;\n    b = 10;\n    if ( ( c = b ) > a ) // assignment inside sub-expression\n    {\n        printf(\"c bigger than a\");\n    }\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, assignment operators are used in sub-expressions",
		"desc": "Assignment should not be used in sub-expressions",
		"details": "#### Abstract\nAssignment should not be used in sub-expressions\n\n#### Explanation\nThe assignment used in sub-expression would add side effect to the full expression and make = and == confusing."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_6_4_1",
		"master_id": "2097",
		"name": "The if/else construct should be followed by compound statement(s)",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int x, y;\n    x = 5;\n    y = 10;\n    if ( x > y ) // if construct with compound statement\n    {\n        printf(\"x bigger\");\n    }\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int x, y;\n    x = 5;\n    y = 10;\n    if ( x > y ); // if construct without compound statement\n    {\n        x++;\n    }\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the if construct is not followed by a compound statement",
		"desc": "The if/else construct should be followed by compound statement(s)",
		"details": "#### Abstract\nThe if/else construct should be followed by compound statement(s)\n\n#### Explanation\nAn if construct without a compound statement would raise error if the required braces are failed to add when changing a single statement to a multi-statement."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_6_5_2",
		"master_id": "2098",
		"name": "if loop-counter is not modified by -- or ++, it should only be used as an operand to <=, <, > or >=",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int i, j;\n    j = 5;\n    for ( i = 3; i < j; i += 3 ) // compliant\n    {\n        printf(\"i smaller than j\");\n    }\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int i, j;\n    j = 5;\n    for ( i = 3; i != j; i += 3 ) // non-compliant\n    {\n        printf(\"infinite loop\");\n    }\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, loop-counter is used to != when it is not modified by -- or ++",
		"desc": "loop-counter should only be used to <=, <, > or >= when not modified by -- or ++",
		"details": "#### Abstract\nloop-counter should only be used to <=, <, > or >= when not modified by -- or ++\n\n#### Explanation\nIf the loop-counter is modified by operator other than -- or ++, the use of == and != would result in infinite loop."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_6_6_3",
		"master_id": "2099",
		"name": "The continue statement should only be used within a well-formed for loop",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int j = 2;\n    for ( int i = 10; i < j; i-- )\n    {\n        if ( ( i % j == 0 ) )\n        {\n            printf(\"well-formed\");\n            continue; // finite loop\n        }\n    }\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int j = 3;\n    for ( int i = 5; i > j; i++ )\n    {\n        if ( ( i % j == 0 ) )\n        {\n            printf(\"not well-formed\");\n            continue; // infinite loop\n        }\n    }\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the continue statement is overused",
		"desc": "The continue statement should not be overused",
		"details": "#### Abstract\nThe continue statement should not be overused\n\n#### Explanation\nThe overuse of the continue statement would make the code unnecessarily complex"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_7_5_3",
		"master_id": "2100",
		"name": "Function should not return a reference or a pointer to a parameter passed by reference or const reference",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\n#include <stdio.h>\n\nint t;\nint test = 1;\n\nint func( t )\n{   \n    t = test;\n    return t; // compliant\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n#include <stdio.h>\n\nint & func ( int & test )\n{\n    int & t = test;\n    return t;\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, function returns reference parameter as a temporary object",
		"desc": "Function should not return reference parameter as a temporary object",
		"details": "#### Abstract\nFunction should not return reference parameter as a temporary object\n\n#### Explanation\nThe use of the reference parameter as a temporary object when the function returns is undefined behaviour."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_8_4_4",
		"master_id": "2101",
		"name": "A function identifier should be used to call the function or preceded by &",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\n#include <stdio.h>\n\nint func ( void )\n{\n    return 0;\n}\n\nint main ( void )\n{\n    if( &func == 0 ) // compliant\n    {\n        func(); // call the function\n        printf(\"the use of func is clear\");\n    }\n    return 0;\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n#include <stdio.h>\n\nint func ( void )\n{\n    return 0;\n}\n\nint main ( void )\n{\n    if( func == 0 ) // unclear use of func\n    {\n        printf(\"the use of func is not clear\");\n    }\n    return 0;\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the function identifiers are not used to call the functions or preceded by &",
		"desc": "Function identifiers should be used to call the functions or preceded by &",
		"details": "#### Abstract\nFunction identifiers should be used to call the functions or preceded by &\n\n#### Explanation\nThe conversion of function identifier to function pointer may make it unclear between the address of the funtion and the calling of it."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_4_2",
		"master_id": "2107",
		"name": "Trigraphs should not be used",
		"compliance": "A",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n#define NON_TRG_STR \"NON-Trigraph string\"\n\nint foo()\n{\n  printf(\"This example uses %s\", NON_TRG_STR); // trigraph is not used\n  return 0;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nextern void prints(char *, char *);\n\n// trigraph is used\nchar TRG_STR[] = \"[??)\"; // \"??)\" represents \"]\"\n\nint foo()\n{\n  prints(\"This example uses %s\", TRG_STR);\n  return 0;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, trigraph is used",
		"desc": "Trigraphs should not be used",
		"details": "#### Abstract\nTrigraphs should not be used\n\n#### Explanation\nThe use of trigraphs can cause accidental confusion with other two question marks."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_5_4",
		"master_id": "2108",
		"name": "Macro identifiers should be unique",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n#define VERY_VERY_LONG_NAME_FST 10\n\n#define VERY_VERY_LONG_NAME_SEC 20 // compliant\n\nint main()\n{\n  int i;\n  if (VERY_VERY_LONG_NAME_FST == VERY_VERY_LONG_NAME_SEC) {\n    i = 0;\n  }\n  else {\n    i = 1;\n  }\n  printf(\"i = %d\\n\", i);\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n/*\n this example does not guarantee the same result for\n different compilers with std C90 or before\n*/\n\n#define VERY_VERY_LONG_NAME2123456789312   10\n\n#define VERY_VERY_LONG_NAME21234567893123  20\n\nint main()\n{\n  int i;\n  if (VERY_VERY_LONG_NAME2123456789312 == VERY_VERY_LONG_NAME21234567893123) {\n    i = 0;\n  }\n  else {\n    i = 1;\n  }\n  printf(\"i = %d\\n\", i);\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, macro identifiers are not unique",
		"desc": "Macro identifiers should be unique",
		"details": "#### Abstract\nMacro identifiers should be unique\n\n#### Explanation\nIt is undefined behavior that macro identifiers are different only in non-significant characters."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_5_5",
		"master_id": "2109",
		"name": "identifiers should be different from macro names",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdio.h>\n\n/*\n this example does not guarantee the same result for\n different compilers with std C90 or before\n*/\n\n#define VERY_VERY_LONG_NAME   10\n\nint     VERY_VERY_LONG_NAME_test;  // compliant"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <string.h>\n\nextern int Both_Macro_and_Var_name(int, int);\n \n// this example will get compilation error\n#define Both_Macro_and_Var_name(a, b) ((a) * (b))\n\nint foo(int j) {\n  int i = 5;\n  i = Both_Macro_and_Var_name(i, j);\n  return i;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, macro names are the same as identifiers",
		"desc": "Macro names should not be the same as identifiers in a program",
		"details": "#### Abstract\nMacro names should not be the same as identifiers in a program\n\n#### Explanation\nIf the macro names are the same as identifiers, it would raise confusion."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_8_2",
		"master_id": "2110",
		"name": "Function types should be in prototype form with named parameters",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n\nextern int functionX(int, char *);  /* parameters without name */\n\nint foo(int a1, char *c2)\n{\n  int i = functionX(a1, c2);\n  if (i != 0)\n    return i;\n  return -1;\n}\n\n\nint bar(int b1, char *b2)    /* declaration in prototype form */\n{\n  int i = functionX(b1, b2);\n  if (i != 0)\n    return i;\n  else\n    return -1;\n}\n"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n\nextern int functionX(int, char *);  /* parameters without name */\n\nint foo(int a1, char *c2)\n{\n  int i = functionX(a1, c2);\n  if (i != 0)\n    return i;\n  return -1;\n}\n\n\nint bar(b1, b2)\nint b1;\nchar *b2;\n{\n  int i = functionX(b1, b2);\n  if (i != 0)\n    return i;\n  else\n    return -1;\n}\n"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, function types are not in prototype form with named parameters",
		"desc": "Function declaration should be in prototype form and parameters in prototype should be named",
		"details": "#### Abstract\nFunction declaration should be in prototype form and parameters in prototype should be named\n\n#### Explanation\nThe specification of parameter types and function types help avoid undefined behaviors."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_15_6",
		"master_id": "2111",
		"name": "The body of iteration or selection statements should be compound-statements",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nint foo(int i)\n{\n  int ret = i;\n  \n  if (i == 0) {\n    return i++;\n  }\n  else if (i < 0) {\n    return -i;\n  }\n  else {\n    ; // empty else\n  }\n\n  // loop with compound statement\n  while (ret < 0) {\n    ret++;\n  }\n  return ret;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nint foo(int i)\n{\n  int ret = i;\n  \n  if (i == 0)  // conditional with non-compound statement\n    return i++;\n  else if (i < 0) \n    return -i;\n  else \n    ; // empty else\n\n\n  // loop with one non compound statement in body\n  while (i != 0) \n    ret--;\n  \n  return ret;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the body of iterative or selection statements are not compound-statements",
		"desc": "The body of iterative or selection statements should be inside a compound statement",
		"details": "#### Abstract\nThe body of iterative or selection statements should be inside a compound statement\n\n#### Explanation\nThe use of compound-statement could clearify which statements form the body of iterative or selection statements."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_16_3",
		"master_id": "2112",
		"name": "All switch statement should have a terminating break statement",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nint loop_cnt(int count, int input)\n{\n  int idx = count;\n  int ret = 0;\n  \n  switch (input) {\n  case 0:\n    idx--;\n    ret++;\n    break;\n    \n  case 1:\n    idx++;\n    ret++;\n    break;\n    \n  default:   // default with a break statement\n    break;\n  }\n  \n  // ...\n  return ret;\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\nint loop_cnt_ex2(int count, int input)\n{\n  int idx = count;\n  int ret = 0;\n  \n  switch (input) {\n    \n  default:   // default at beginning of switch\n    \n  case 0:\n    idx--;\n    break;\n    \n  case 1:    // this case at end of switch has no break\n    idx++;\n\n  }\n  \n  // ...\n  return ret;\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, switch statements do not have terminating break statements",
		"desc": "All switch statement should have a terminating break statement",
		"details": "#### Abstract\nAll switch statement should have a terminating break statement\n\n#### Explanation\nThe switch-clause without a break statement may fall into switch-clause which are added later."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_15_0_2",
		"master_id": "2113",
		"name": "There should not be exception object of pointer type",
		"compliance": "A",
		"examples": {
			"good": {
				"cpp": [
					"\nclass A {\npublic:\n  A(void) {}\n  A(const A &b) {\n    // ...\n  }\n  A(int) {}\n\n  int Priv_int() const { return priv_int; }\nprivate:\n  static int priv_int;\n};\n\nvoid foo(int i)\n{\n  A varA;\n  // local is dynamically created with local scope\n  A *local = new A;\n  \n  if (varA.Priv_int() == 0) {\n    throw(varA);    // varA is not address\n  }\n  else {\n    int l = local->Priv_int();\n    delete local;\n    throw(l); // return value copy of local's content, no heap address exposed\n  }\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n\nclass A {\npublic:\n  A(void) {}\n  A(const A &b) {\n    // ...\n  }\n  A(int) {}\n\n  int Priv_int() const { return priv_int; }\nprivate:\n  static int priv_int;\n};\n\nvoid foo(int i)\n{\n  A varA;\n  // local is dynamically created with local scope\n  A *local = new A;\n  \n  if (varA.Priv_int() < 0) {\n    throw(&varA);  // addr of local exposed (stack address)\n  }\n  else {\n    throw(local);  // this could cause a heap object not properly deleted\n  }\n}\n"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, a exception object has pointer type",
		"desc": "There should not be exception object of pointer type",
		"details": "#### Abstract\nThere should not be exception object of pointer type\n\n#### Explanation\nIt is unclear which function should destroy the exception object if it has pointer type and refers to a dynamically created object."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_15_1_1",
		"master_id": "2114",
		"name": "When constructing an exception object, an exception should not be thrown",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\n#include <iostream>\n\nusing namespace std;\n\nclass MyException\n{\n  public:\n    MyException ()\n    {\n      cout << \"constructor does not cause exception\" << endl; // compliant\n    }\n};\n\nvoid func ( int n ) throw (int, MyException)\n{\n  if ( n == 1 )\n  {\n    throw 1;\n  }\n  else\n  {\n    throw MyException();\n  }\n}\n\nint main( void )\n{\n  try\n  {\n    func(2);\n  }\n\n  catch ( int n )\n  {\n    cout << \"catch int ...\" << endl;\n  }\n  catch (MyException)\n  {\n    cout << \"catch MyException ...\" << endl;\n  }\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n#include <iostream>\n \nusing namespace std;\n\nclass MyException\n{\n  public:\n    MyException ()\n    {\n      throw \"Exception thrown when constructing an exception object\"; // non-compliant\n    }\n};\n\nvoid func ( int n ) throw (int, MyException)\n{\n  if ( n == 1 )\n  {\n    throw 1;\n  }\n  else\n  {\n    throw MyException();\n  }\n}\n\nint main( void )\n{\n  try\n  {\n    func(2);\n  }\n\n  catch ( int n )\n  {\n    cout << \"catch int ...\" << endl;\n  }\n  catch (MyException)\n  {\n    cout << \"catch MyException ...\" << endl;\n  }\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, an exception is thrown when constructing an exception object",
		"desc": "When constructing an exception object, an exception should not be thrown",
		"details": "#### Abstract\nWhen constructing an exception object, an exception should not be thrown\n\n#### Explanation\nIf an exception is thrown during the construction of an exception object, it propagates in preference to the one about to be thrown, which may be out of expectation."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_15_1_2",
		"master_id": "2115",
		"name": "NULL should not be thrown explicitly",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\n#include <iostream>\n \nusing namespace std;\n\nclass Str {\npublic:\n  int Report()    const { cout << \"Str error \"; return 0; }\n  void NullReport(void) { cout << \"Null pointer\"; }  \n  \npublic:\n  Str() {} \n  void setLength( double len );\n  int  Length( void ) {\n    if (length <= 0)\n      throw Report();\n    else\n      return length;\n  }\n \nprivate:\n  int length;\n};\n\n\nint main(class Str *p)\n{\n  // ...\n  \n  try {\n    p->Length();  // Legth() fully handle throw\n    // ...\n  }\n  catch (int m) {\n    if (m == 0)\n      p->NullReport();\n    // ...\n  }\n  catch (...) {\n    // ...\n  }\n\n  // ..\n}\n"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n#include <iostream>\n \nusing namespace std;\n\nclass Str {\npublic:\n  int Report()  const { cout << \"Str error \"; return 0; }\n  void NullReport(void) { cout << \"Null pointer\"; }\n  \npublic:\n  Str() {} \n  void setLength( double len );\n  int  Length( void ) {\n    if (length == 0)\n      throw Report();\n    else\n      return length;\n  }\n \nprivate:\n  int length;\n};\n\n\nvoid foo(class Str *p)\n{\n  // ...\n  \n  try {\n    if (p->Length() < 0) {\n      throw (NULL);    // throw NULL\n    }\n    // ...\n  }\n  catch (int m) {\n    if (m == 0) {\n      p->NullReport();\n    }\n    // ...\n  }\n\n  // ..\n}\n"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, NULL is thrown explicitly ",
		"desc": "Throwing a NULL will be caught by an integer handler, this may be unexpected behavior",
		"details": "#### Abstract\nThrowing a NULL will be caught by an integer handler, this may be unexpected behavior\n\n#### Explanation\nThrow NULL would be caught by an integer handler, which may not match developer expectations."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_15_1_3",
		"master_id": "2116",
		"name": "An empty throw should only be used in a catch handler",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\n#include <iostream>\n \nusing namespace std;\n\nclass Str {\npublic:\n  int Report()    const { cout << \"Str error \"; return 0; }\n  void NullReport(void) { cout << \"Null pointer\"; }  \n  \npublic:\n  Str() {} \n  void setLength( double len );\n  int  Length( void ) {\n    if (length <= 0)\n      throw Report();\n    else\n      return length;\n  }\n \nprivate:\n  int length;\n};\n\n\nvoid foo(class Str *p)\n{\n  // ...\n  \n  try {\n    p->Length();\n    // ...\n  }\n  catch (int m) {\n    if (m == 0)\n      p->NullReport();\n    else {\n      throw;  // re-throw - allowed\n    }\n    // ...\n  }\n\n  // ..\n}\n"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n#include <iostream>\n \nusing namespace std;\n\nclass Str {\npublic:\n  int Report()  const { cout << \"Str error \"; return 0; }\n  void NullReport(void) { cout << \"Null pointer\"; }\n  \npublic:\n  Str() {} \n  void setLength( double len );\n  int  Length( void ) {\n    if (length == 0)\n      throw Report();\n    else\n      return length;\n  }\n \nprivate:\n  int length;\n};\n\n\nvoid foo(class Str *p)\n{\n  // ...\n  \n  try {\n    if (p->Length() < 0) {\n      throw;    // empty throw\n    }\n    // ...\n  }\n  catch (int m) {\n    if (m == 0)\n      p->NullReport();\n    else {\n      throw;\n    }\n    // ...\n  }\n\n  // ..\n}\n"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, an empty throw is used outside a catch handler",
		"desc": "An empty throw shall not be used outside a catch handler",
		"details": "#### Abstract\nAn empty throw shall not be used outside a catch handler\n\n#### Explanation\nUse of empty throw outside a catch handler would terminate the program since there is no exception object to re-thrown. The behavior is implementation defined."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_15_3_2",
		"master_id": "2117",
		"name": "An exception handler to catch all otherwise unhandled exceptions should be provided",
		"compliance": "A",
		"examples": {
			"good": {
				"cpp": [
					"\n\n#include <stdlib.h>\n\nclass X {\n  \npublic:\n  X() { }  // constructor that does not throw\n  void setLen( double len );\n  int check_and_handle_error(int) {\n    if (len < 0)\n      throw 0;\n    return len;\n  }  \nprivate:\n  int  len;\n};\n\nvoid f()\n{\n  X local_x;\n  int i;\n  \n  // code\n  // ...\n\n  // where check_and_error() resides inside main\n  // such that all exceptions are caught\n  i = local_x.check_and_handle_error(0);\n  // ...\n}\n\n\nint main(int argc, char *argv[])\n{\n  try {\n    \n    // code can call f() which may throw exception\n    // ...\n   \n  }\n  catch (int m) {    \n    // handle any uncaught exception\n  }\n  \n  return 0;\n}\n"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n\n#include <stdlib.h>\n\nvoid f()\n{\n\n  // code\n  // ...\n  \n  exit(0);\n}\n\n\nint main(int argc, char *argv[])\n{\n  try {\n    \n    // code with no call to f()\n\n  }\n  catch (int m) {    \n    // handle any uncaught exception\n  }\n  \n  return 0;\n}\n"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, an exception handler to catch all otherwise unhandled exceptions is not provided",
		"desc": "An exception handler to catch all otherwise unhandled exceptions should be provided",
		"details": "#### Abstract\nAn exception handler to catch all otherwise unhandled exceptions should be provided\n\n#### Explanation\nAn exception handler to catch all otherwise unhandled exceptions ensures that unexpected exceptions can also be caught."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_15_3_3",
		"master_id": "2118",
		"name": "handlers of a function-try-block should not reference non-static members from this class or its bases",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\n#include <iostream>\n \nusing namespace std;\n\nclass Count {\npublic:\n  int Report()  const { cout << \"argument C \"; return 0; }\n  void NullReport(void) { cout << \"Null pointer\"; }\n  \npublic:\n  static int static_x;  // static scope variable\n  Count( void ) {\n    try {\n      // ...\n    }\n    catch (int m) {\n      // static var will have deterministic state\n      if (static_x == 0) throw Report();  \n    }\n  }\n  void setCount( int c );\n\n};\n\nCount ct; \n\nint main(int argc, char *argv[])\n{\n\n  // ...\n  // main code\n\n  return 0;\n}\n"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n#include <iostream>\n \nusing namespace std;\n\nclass Count {\npublic:\n  int Report()  const { cout << \"argument C \"; return 0; }\n  void NullReport(void) { cout << \"Null pointer\"; }\n  \npublic:\n  int local_x;\n  Count( void ) {\n    try {\n      // ...\n    }\n    catch (int m) {\n      // reference local that may be in unknown state\n      if (local_x == 0) throw Report();  \n    }\n  }\n  ~Count( void ) {\n    try {\n      // ...\n    }\n    catch (int m) {\n      // reference local who"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, handlers of a function-try-block reference non-static members from this class or its bases",
		"desc": "In ctor/dtor, handlers of a function-try-block should not reference non-static members from this class or its bases",
		"details": "#### Abstract\nIn ctor/dtor, handler of a function-try-block should not reference non-static members from this class or its bases\n\n#### Explanation\nIt is undefined behavior to access a non-static member of a class or a base class in the handler of a function-try-block."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_15_3_5",
		"master_id": "2119",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\nclass Base {\npublic:\n  Base(void) {}\n  Base(const Base &b) {}\n  virtual const char* test() {\n    return \"Base\";\n  };\n\nprivate:\n  static int priv_int;\n};\n\n\nclass Derived : public virtual Base {\npublic:\n  Derived() {}\n  //  Derived1(int) : Base(0) {}\n  virtual const char* test() {\n    return \"Derived\";\n  };\n  \n  \n  void foo()\n  {\n    Derived D1;\n    \n    try {\n      // ...\n      throw Derived();\n      throw Base();\n    }\n    catch (Base &b) {\n      b.test();\n      throw b;\n    }\n    catch (Derived &d) {\n      d.test();\n      throw d;\n    }\n  }\n};\n"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\nclass Base {\npublic:\n  Base(void) {}\n  Base(const Base &b) {}\n  virtual const char* test() {\n    return \"Base\";\n  }; \nprivate:\n  static int priv_int;\n};\n\n\nclass Derived : public virtual Base {\npublic:\n  Derived() {}\n  virtual const char* test() {\n    return \"Derived\";\n  };\nprivate:\n  int d;\n  \n  void foo()\n  {    \n    try {\n      // ...\n      throw Derived();\n      throw Base();\n    }\n    catch (Base b) {\n      b.test();\n      throw b;\n    }\n  }\n};\n"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}, 类类型异常对象未被引用捕获",
		"name": "一个类类型异常对象应仅通过引用捕获",
		"desc": "一个类类型异常对象应仅通过引用捕获",
		"details": "#### 概要\n一个类类型异常对象应仅通过引用捕获\n\n#### 解释\n如果类类型异常对象不是通过引用捕获的，则无法访问派生类中的其他成员数据。"
	},
	{
		"category": "",
		"mapping": "",
		"language": "c",
		"code": "MSR_12_5",
		"master_id": "2120",
		"name": "sizeof operator should not be used to function parameters declared as \"array of type\"",
		"compliance": "M",
		"examples": {
			"good": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdint.h>\n\nint arr1[] = {1, 2, 3};\nint arr2[] = {1, 2};\n\nvoid func( void )\n{\n    int a = sizeof( arr1 ) - sizeof (arr2);\n    /*\n        compliant;\n        sizeof arr1, arr2 return the size of arrays\n    */\n    printf( a );\n}"
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					""
				],
				"java": [
					""
				],
				"c": [
					"\n#include <stdint.h>\n\nvoid func( int arr1[ 5 ], int arr2[ 3 ] )\n{\n    int a = sizeof( arr1 ) - sizeof (arr2);\n    /*\n        non-compliant;\n        arr1, arr2 have type int *;\n        sizeof arr1, arr2 do not return the size of array\n    */\n    printf( a );\n}"
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, sizeof operator is used to function parameters declared as \"array of type\"",
		"desc": "function parameter declared as \"array of type\" should not be used as operator for sizeof",
		"details": "#### Abstract\nfunction parameter declared as \"array of type\" should not be used as operator for sizeof\n\n#### Explanation\nSince the function parameters declared as arrays would degenerate to pointer to type, the use of size of cannot return the size of the array."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_2_10_6",
		"master_id": "2125",
		"name": "An identifier should not refer to a type and an object in the same scope",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\n#include <stdio.h>\n\n// different names refer to a type and an object\ntypedef struct test1 { int x; int y; } test2;"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n#include <stdio.h>\n\n// a name refer to both a type and an object\ntypedef struct test1 { int x; int y; } test1;\n\n/* \na name refer to both a type and a function,\nthis example will get compilation error\n*/\ntypedef struct test2 { int a; int b; } test2;\n\nint test2( void )\n{\n    return 1;\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, an identifier refer to a type and an object in the same scope",
		"desc": "An identifier should not refer to a type and an object in the same scope",
		"details": "#### Abstract\nAn identifier should not refer to a type and an object in the same scope\n\n#### Explanation\nAn identifier which refers to both a type and object or a type and function can lead to confusion."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_4_5_1",
		"master_id": "2126",
		"name": "Bool expression should not be used as operands to built-in operators other than =, &&, ||, !, ==, !=, &, ?:",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\n#include <stdio.h>\n\nbool a = true;\nbool b = false;\n\nint func( void )\n{\n    if ( a && b )           // the use of bool and && is meaningful\n    {\n        printf(\"compliant\");\n    }\n    else if ( a != b )      // the use of bool and != is meaningful\n    {\n        printf(\"compliant\");\n    }\n    return 0;   \n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n#include <stdio.h>\n\nbool a = true;\nbool b = false;\n\nvoid func( void )\n{\n    if ( a < b ) // the use of bool and < is unmeaningful\n    {\n        printf(\"non-compliant\");\n    }\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, bool expression is used as operands to built-in operators other than =, &&, ||, !, ==, !=, &, ?:.",
		"desc": "Bool expression should not be used as operands to built-in operators other than =, &&, ||, !, ==, !=, &, ?:",
		"details": "#### Abstract\nBool expression should not be used as operands to built-in operators other than =, &&, ||, !, ==, !=, &, ?:\n\n#### Explanation\nThe use of bool operands with other operators is unmeaningful."
	},
	{
		"category": "",
		"mapping": "",
		"language": "c++",
		"code": "MSR_7_3_4",
		"master_id": "2132",
		"name": "Using-directives should not be used",
		"compliance": "R",
		"examples": {
			"good": {
				"cpp": [
					"\n#include <iostream>\n\nnamespace T1\n{\n\tint t{ 5 };\n}\n\nnamespace T2\n{\n\tint t{ 1 };\n}\n\nint func( void )\n{   \n    using T2::t; // using declaration is compliant\n    std::cout << t;\n    return 0;\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			},
			"bad": {
				"cpp": [
					"\n#include <iostream>\n\nnamespace T1\n{\n\tint t{ 5 };\n}\n\nnamespace T2\n{\n\tint t{ 1 };\n}\n\n/* This example may cause compilation error;\nusing directives raises confusion for \n\"std::cout << t\" of which t to refer to*/\nint func( void )\n{   \n    using namespace T1; \n    using namespace T2;\n    std::cout << t;\n    return 0;\n}"
				],
				"java": [
					""
				],
				"c": [
					""
				],
				"general": [
					""
				]
			}
		},
		"msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, using-directives is used.",
		"desc": "Using-directives should not be used",
		"details": "#### Abstract\nUsing-directives should not be used\n\n#### Explanation\nUsing-directives increases the possibility that the identifier found by the compiler creates confusion while using-declarations is a safer choice."
	}
]