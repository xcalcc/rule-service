[
    {
        "master_id": 1,
        "category": "BAD_PRACTICE",
        "language": "c,c++",
        "code": "CSL",
        "name": "调用栈的深度超於设置上限",
        "desc": "该程序调用序列太深, 超出用户设置的上限。",
        "msg_templ": "在${si.filename}，${si.line}行上，函数 ${si.func}有一个调用序列，该调用序列超过了在扫描配置设置时设置的上限。",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序调用序列太深，超出用户设置的上限。\n\n#### 解释\n当函数A调用另外一个函数B时，B同时也有可能正在调用C函数。这类调用链可以无限进行下去。在嵌入式系统中，调用链太深可能会引起意外的结果，如内存不足、执行时间不足等。\n\n",
        "examples": {
            "good": {},
            "bad": {
                "c": [
                    "int __attribute__((__noinline__)) f1() {\n  return 1;\n}\nint __attribute__((__noinline__)) f2() {\n  return 2 + f1();\n}\nint __attribute__((__noinline__)) f3() {\n  return 3 + f2();\n}\nint __attribute__((__noinline__)) f4() {\n  return 4 + f3();\n}\nint __attribute__((__noinline__)) f5() {\n  return 5 + f4();\n}\nint __attribute__((__noinline__)) f6() {\n  return 6 + f5();\n}\nint __attribute__((__noinline__)) f7() {\n  return 7 + f6();\n}\nint __attribute__((__noinline__)) f8() {\n  return 8 + f7();\n}\nint __attribute__((__noinline__)) f9() {\n  return 9 + f8();\n}\nint __attribute__((__noinline__)) f10() {\n  return 10 + f9();\n}\nint __attribute__((__noinline__)) f11() {\n  return 11 + f10();\n}\nint __attribute__((__noinline__)) f12() {\n  return 12 + f11();\n}\nint __attribute__((__noinline__)) f13() {\n  return 13 + f12();\n}\nint __attribute__((__noinline__)) f14() {\n  return 14 + f13();\n}\nint __attribute__((__noinline__)) f15() {\n  return 15 + f14();\n}\nint __attribute__((__noinline__)) f16() {\n  return 16 + f15();\n}\nint __attribute__((__noinline__)) f17() {\n  return 17 + f16();\n}\nint __attribute__((__noinline__)) f18() {\n  return 18 + f17();\n}\nint __attribute__((__noinline__)) f19() {\n  return 19 + f18();\n}\nint __attribute__((__noinline__)) f20() {\n  return 20 + f19();\n}\nint __attribute__((__noinline__)) f21() {\n  return 21 + f20();\n}\nint __attribute__((__noinline__)) f22() {\n  return 22 + f21();\n}\nint __attribute__((__noinline__)) f23() {\n  return 23 + f22();\n}\nint __attribute__((__noinline__)) f24() {\n  return 24 + f23();\n}\nint __attribute__((__noinline__)) f25() {\n  return 25 + f24();\n}\nint __attribute__((__noinline__)) f26() {\n  return 26 + f25();\n}\nint __attribute__((__noinline__)) f27() {\n  return 27 + f26();\n}\nint __attribute__((__noinline__)) f28() {\n  return 28 + f27();\n}\nint __attribute__((__noinline__)) f29() {\n  return 29 + f28();\n}\nint __attribute__((__noinline__)) f30() {\n  return 30 + f29();\n}\nint __attribute__((__noinline__)) f31() {\n  return 31 + f30();\n}\nint __attribute__((__noinline__)) f32() {\n  return 32 + f31();\n}\nint __attribute__((__noinline__)) f33() {\n  return 33 + f32();\n}\nint __attribute__((__noinline__)) f34() {\n  return 34 + f33();\n}\nint __attribute__((__noinline__)) f35() {\n  return 35 + f34();\n}\nint __attribute__((__noinline__)) f36() {\n  return 36 + f35();\n}\nint __attribute__((__noinline__)) f37() {\n  return 37 + f36();\n}\nint __attribute__((__noinline__)) f38() {\n  return 38 + f37();\n}\nint __attribute__((__noinline__)) f39() {\n  return 39 + f38();\n}\nint __attribute__((__noinline__)) f40() {\n  return 40 + f39();\n}\nint __attribute__((__noinline__)) f41() {\n  return 41 + f40();\n}\nint __attribute__((__noinline__)) f42() {\n  return 42 + f41();\n}\nint __attribute__((__noinline__)) f43() {\n  return 43 + f42();\n}\nint __attribute__((__noinline__)) f44() {\n  return 44 + f43();\n}\nint __attribute__((__noinline__)) f45() {\n  return 45 + f44();\n}\nint __attribute__((__noinline__)) f46() {\n  return 46 + f45();\n}\nint __attribute__((__noinline__)) f47() {\n  return 47 + f46();\n}\nint __attribute__((__noinline__)) f48() {\n  return 48 + f47();\n}\nint __attribute__((__noinline__)) f49() {\n  return 49 + f48();\n}\nint __attribute__((__noinline__)) f50() {\n  return 50 + f49();\n}\n"
                ],
                "general": [
                    "// This case does not need an example.\n// The complete call level from function A to Z, i.e. A() ==> B() ==> .... ==> Z(), is too deep."
                ]
            }
        }
    },
    {
        "master_id": 2,
        "category": "BAD_PRACTICE",
        "language": "c,c++",
        "code": "CSS",
        "name": "调用栈的內存超於设置上限",
        "desc": "该程序有调用序列, 会致使运行时栈內存超出设置的上限。",
        "msg_templ": "在${si.filename}，${si.line}行上，函数 ${si.func}有一个调用序列，该调用序列会致使运行时栈內存超过了在扫描配置设置时设置的上限。",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序有调用序列，会致使运行时栈內存超出设置的上限。\n\n#### 解释\n当函数A调用另外一个函数B时，传递给被调用函数的参数和被调用函数给调用函数的返回值将被放置在执行栈上。局部变量也会被放置在执行栈上。\n",
        "examples": {
            "good": {
                "c": [
                    "// Assume that stack size is 8 bytes for parameter, 4 bytes for return value (assume) 32 bit ABI\n// Assume we limit the size of stack to that of 32 bytes\n\nint func_callee(int *a, int i)\n{\n    return a[i];\n}\n\n// stack size is 0 byte (no parameter), 12 byte for local variable, 4 bytes for return value\nint func_caller()\n{\n    int a[3] = {0, 1}, b;\n    b = func_callee(a, 1);\n    // callee stack size if 12 bytes\n    return 0;\n}\n\n// total stack size for the call sequence func_caller -> func_callee is 28 bytes\n// (assume ABI specifies all parameters uses stack and not register)"
                ]
            },
            "bad": {
                "c": [
                    "extern void init_buf(char *buf, int sz);\nint f1() {\n  char buf[8192];\n  init_buf(buf, sizeof(buf));\n  return buf[1];\n}\n\nint f2() {\n  char buf[8192];\n  init_buf(buf, sizeof(buf));\n  return buf[2] + f1();\n}\n\nint f3() {\n  char buf[8192];\n  init_buf(buf, sizeof(buf));\n  return buf[3] + f2();\n}\n\nint f4() {\n  char buf[8192];\n  init_buf(buf, sizeof(buf));\n  return buf[4] + f3();\n}\n\n"
                ],
                "general": [
                    "// Assuming that stack size is 8 bytes for parameter, 4 bytes for return value (assume) 32 bit ABI\nint func_callee(int* a, int i)\n{\n return a[i];\n}\n\n// stack size is 0 byte (no parameter), 12 byte for local variable, 4 bytes for return value\nint func_caller() {\n int a[3] = {0, 1}, b;\n b = assign(a, 1); /* callee stack size if 12 bytes\n return 0;\n}\n\n// total stack size for the call sequence func_caller -> func_callee is 28 bytes\n// (assume ABI specifies all parameters uses stack and not register)"
                ]
            }
        }
    },
    {
        "master_id": 3,
        "category": "VUL",
        "language": "c,c++",
        "code": "DBF",
        "name": "资源被多次释放",
        "desc": "该程序已多次释放了某些资源（例如，堆内存、I/O流对象等）。",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func}的资源变量${si.var}已被多次释放。该资源变量${si.var}在${so.filename}第${so.line}行被首次释放。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序已多次释放了某些资源（例如，堆内存、I/O流对象等）。\n\n### 解释\n该程序已多次调用了诸如free()、close()这样的函数来释放同一个资源对象。这会导致系统不一致，例如系统的堆管理数据结构或I/O流子类等的损坏，从而可能允许恶意用户访问任意内存或造成IOException。\n\n",
        "examples": {
            "good": {
                "general": [
                    "int func_1(void *p) {\n if (p != NULL) {\n free(p); // free p\n }\n}\n\nint func_2(void *p) {\n if (p != NULL) {\n free(p); // free p\n }\n}\n\nint main() {\n int i, *p, *q;\n p = malloc(10 * sizeof(int));\n if (p == NULL)\n return 1;\n for (i=0; i < 10; ++i)\n p[i] = i;\n q = p;\n func_1(p); // free p the first time and only time\n return 0;\n}"
                ]
            },
            "bad": {
                "general": [
                    "int func_1(void *p) {\n if (p != NULL) {\n free(p); // free p\n }\n}\n\nint func_2(void *p) {\n if (p != NULL) {\n free(p); // free p\n }\n}\n\nint main() {\n int i, *p, *q;\n p = malloc(10 * sizeof(int));\n if (p == NULL)\n return 1;\n for (i=0; i < 10; ++i)\n p[i] = i;\n q = p;\n func_1(p); // free p the first time\n func_2(q); // free p the second time due to value of p copied into q\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 4,
        "category": "VUL",
        "language": "c,c++",
        "code": "FMT",
        "name": "格式字符串溢出",
        "desc": "该程序正调用printf函数族中的一个，其使用的参数个数（或类型）与格式字符串声明的不同。",
        "msg_templ": "在${si.filename}，第${si.line}行${si.func}中参数${si.var}的格式与格式字符串声明有些不同。",
        "severity": "HIGH",
        "likelihood": "UNLIKELY",
        "cost": "LOW",
        "details": "#### 概要\n该程序正调用printf函数族中的一个，其使用的参数个数（或类型）与格式字符串声明的不同。\n\n#### 解释\n在printf（或此类系统调用的家族）里，实际使用的参数个数或类型与格式化字符串说明的不同。当传递的实际参数不同时，实际打印出的内容将不可预测。\n\n",
        "examples": {
            "good": {
                "c": [
                    "\nfoo(int a, int guard)\n{  int x = 0;\n  int int_result = 0;\n  if (guard != 0) int_result = a * x;\n\n  // number of actuals match that with format statement\n  printf(\"result %d is %x truncated\", int_result, int_result); \n  return 0;\n}\n\n"
                ]
            },
            "bad": {
                "c": [
                    "foo(int a, int guard)\n{\n  int x = 0;\n  int int_result = 0;\n  if (guard != 0) int_result = a * x;\n  \n  // The format string specified two values to be printed,\n  // only one actual parameter is passed. The second output is unpredictable\n  printf(\"result %d is %x truncated\", int_result); \n  return 0;\n}\n\n"
                ]
            }
        }
    },
    {
        "master_id": 5,
        "category": "ROBUSTNESS",
        "language": "c,c++",
        "code": "MSF",
        "name": "没有释放",
        "desc": "该程序已分配了堆内存，但未能释放那块内存。",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func}里的变量${si.var}未被释放。${si.var}是在${so.filename}，第${so.line}行获得首个堆内存的分配。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序已分配了堆内存，但未能释放那块内存。\n\n#### 解释\n分配了堆内存并且分配的内存地址存储在引用（指针）类型的变量里。该堆内存在其生命周期结束后从未被释放，其对应的引用仍然指向该内存空间。这可能会导致敏感数据泄漏或意外程序行为（例如拒绝服务）。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n\nstruct S\n{\n    int *p;\n};\n\nint main()\n{\n    int *p;\n    struct S *s;\n    p = malloc(10 * sizeof(int)); // heap memory allocated and pointed to by p\n    if (p == NULL)\n    {\n        return 1;\n    }\n    s = (struct S *)malloc(sizeof(struct S)); // heap memory allocated and pointed to by s\n    if (s == NULL)\n    {\n        free(p);\n        return 1;\n    }\n    s->p = p;\n    // both s and p are freed\n    free(s); \n    free(p); \n    return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n\nstruct S\n{\n    int *p;\n};\n\nint main()\n{\n    int *p;\n    struct S *s;\n    p = malloc(10 * sizeof(int)); // heap memory allocated and pointed to by p\n    if (p == NULL)\n    {\n        return 1;\n    }\n    s = (struct S *)malloc(sizeof(struct S)); // heap memory allocated and pointed to by s\n    if (s == NULL)\n    {\n        free(p);\n        return 1;\n    }\n    s->p = p;\n    free(s); // only s is freed\n    // s->p, which is copied from p is not freed\n    return 0;\n}"
                ],
                "general": [
                    "struct S {\n int *p;\n};\n\nint main() {\n int *p;\n struct S *s;\n p = malloc(10 * sizeof(int)); // heap memory allocated and pointed to by p\n if (p == NULL)\n return 1;\n s = (struct S*)malloc(sizeof(struct S)); // heap memory allocated and pointed to by s\n if (s == NULL) {\n free(p);\n return 1;\n }\n s->p = p;\n free(s); // only s is freed\n // s->p, which is copied from p is not freed\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 6,
        "category": "VUL",
        "language": "c,c++",
        "code": "RAL",
        "name": "局部变量的返回地址",
        "desc": "该函数返回了栈变量的地址，这会导致意外程序行为。",
        "msg_templ": "在${si.filename}，第${si.line}行，局部变量${si.var}的地址已返回给了调用者。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### 概要\n该函数返回了栈变量的地址，这会导致意外程序行为。\n\n#### 解释\n由于局部变量分配在栈上，当函数返回至调用者时，被调用者的栈地址不再有效。随后的函数调用很可能重用这个相同的栈地址，并覆盖先前的调用的返回值。\n",
        "examples": {
            "good": {
                "c": [
                    "int foo()\n{\n    int *c;\n    return *c; // item *c is pointing to returned\n}"
                ]
            },
            "bad": {
                "c": [
                    "extern void bar(int);\n\nint *foo()\n{\n    int c = 0;\n    bar(c);\n    return &c; //return a local address to caller\n}\n"
                ],
                "general": [
                    "int foo()\n{\n int *c;\n return &c; //return a local address to caller\n}"
                ]
            }
        }
    },
    {
        "master_id": 7,
        "category": "VUL",
        "language": "c,c++",
        "code": "RXS",
        "name": "从外部套接字读取",
        "desc": "该程序可能已从包含不受信任数据的外部接口中读取。",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func}从外部接口接收了不受信任的数据，此外部接口是在${si.filename}的第${si.line}行被建立的。",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### 概要\n该程序可能已从包含不受信任数据的外部接口中读取。\n\n#### 解释\n外部接口会允许程序同外部世界产生相互作用，因此确保外部接口不接收安全敏感型或者不受信任的输入是非常重要的。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <sys/socket.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#define BUF_SZ 256\n\nint foo(void)\n{\n    int n;\n    char buffer[BUF_SZ];\n    char *cp = buffer; \n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n\n    if (sockfd < 0)\n    {\n        perror(\"ERROR opening socket\");\n        exit(1);\n    }\n\n    // filter out untrusted data and characters\n    static char approved[] = \"abcdefghijklmnopqrstuvwxyz\"\n                             \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                             \"1234567890_-.@\";\n    const char *end = buffer + strlen(buffer);\n    for (cp += strspn(cp, approved); cp != end; cp += strspn(cp, approved))\n    {\n        *cp = '_';\n    }\n\n    n = read(sockfd, buffer, 255);\n\n    // use buffer\n    // if buffer is used as argument to system() or to setenv()\n    // the buffer may contain untrusted commands or characters leading to unpredictable program behavior\n    // ...\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <sys/socket.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#define BUF_SZ 256\n\nint foo(void)\n{\n    int n;\n    char buffer[BUF_SZ];\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n\n    if (sockfd < 0)\n    {\n        perror(\"ERROR opening socket\");\n        exit(1);\n    }\n\n    n = read(sockfd, buffer, 255);\n\n    // use buffer\n    // if buffer is used as argument to system() or to setenv()\n    // the buffer may contain untrusted commands or characters leading to unpredictable program behavior\n    // ...\n}"
                ],
                "general": [
                    "#include <sys/socket.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#define BUF_SZ 256\n\nint foo(void)\n{\n int n;\n char buffer[BUF_SZ];\n sockfd = socket(AF_INET, SOCK_STREAM, 0);\n\n if (sockfd < 0) {\n perror(\\\"ERROR opening socket\\\");\n exit(1);\n }\n\n n = read(sockfd,buffer,255);\n\n // use buffer\n // if buffer is used as argument to system() or to setenv()\n // the buffer may contain untrusted commands or characters leading to unpredictable program behavior\n // ...\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 8,
        "category": "VUL",
        "language": "c,c++",
        "code": "UAF",
        "name": "释放后重用",
        "desc": "该程序在已释放了内存后引用了该内存。这可能导致程序崩溃或不可预测的程序行为。",
        "msg_templ": "在${so.filename}，第${so.line}行，${so.func}里使用了变量${so.var}。然而，此变量在${so.filename}第${so.line}行已被释放。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序在已释放了内存后引用了该内存。这可能导致程序崩溃或不可预测的程序行为。\n\n#### 解释\n释放后重用是悬空指针引用的一种形式。它通常发生在指针所指向的内存对象已被释放而指针未被更新时。该指针将指向不正确的内存，这在使用指针时会引起未经授权的访问。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n\nint g = 2;\n\nvoid my_free(void *p)\n{\n    if (p != NULL) \n    {\n        free(p); // free p\n    }\n        \n}\n\nint main()\n{\n    int i, j, *p, *q;\n    p = malloc(10 * sizeof(int));\n    if (p == NULL)\n    {\n        return 1;\n    }\n    for (i = 0; i < 10; ++i) \n    {\n        p[i] = i;\n    }    \n    q = p;\n    my_free(p); // p is freed\n    j = 0;\n\n    // checks if q is illegal before running the for loop\n    if (q == 0 || q == NULL)\n    {\n        exit(1);\n    }\n    \n    for (i = 0; i < 10; ++i)\n    {\n        // Use after free here (note the statement q = p), read of q[i] is illegal\n        j += q[i]; \n    }\n        \n    return j;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n\nint g = 2;\n\nvoid my_free(void *p)\n{\n    if (p != NULL) \n    {\n        free(p); // free p\n    }\n}\n\nint main()\n{\n    int i, j, *p, *q;\n    p = malloc(10 * sizeof(int));\n    if (p == NULL)\n    {\n        return 1;\n    }\n    for (i = 0; i < 10; ++i) \n    {\n        p[i] = i;\n    }\n    q = p;\n    my_free(p); // p is freed\n    j = 0;\n    for (i = 0; i < 10; ++i)\n    {\n        j += q[i]; // Use after free here (note the statement q = p), read of q[i] is illegal\n    }\n    return j;\n}"
                ],
                "general": [
                    "#include <stdio.h>\n\nint g = 2;\n\nvoid my_free(void *p) {\n if (p != NULL)\n free(p); // free p\n}\n\nint main() {\n int i, j, *p, *q;\n p = malloc(10 * sizeof(int));\n if (p == NULL)\n return 1;\n for (i=0; i < 10; ++i)\n p[i] = i;\n q = p;\n my_free(p); // p is freed\n j = 0;\n for (i=0; i < 10; ++i)\n j += q[i]; // Use after free here (note the statement q = p), read of q[i] is illegal\n return j;\n}"
                ]
            }
        }
    },
    {
        "master_id": 9,
        "category": "VUL",
        "language": "c,c++",
        "code": "UDR",
        "name": "使用悬空指针",
        "desc": "已使用了悬空指针来引用无效的内存资源。",
        "msg_templ": "在${so.filename}，第${so.line}行，使用了${so.func}里的内存引用变量${so.var}。该变量首次被赋值为内存引用，这在${so.filename}的第${so.line}行可能无效。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "HIGH",
        "details": "#### 概要\n已使用了悬空指针来引用无效的内存资源。\n\n#### 解释\n悬空指针是引用无效或不正确的内存资源的指针。引用这些内存资源可能会造成内存损坏，从而导致不可预测的程序行为或系统不稳定。\n",
        "examples": {
            "good": {
                "c": [
                    "void assign(int *c)\n{\n    *c = 1;\n    return;\n}\n\nint foo()\n{\n    int a;\n    assign(&a); \n    printf(\"assigned value: %d\", a); // pointer is not dangling\n    return 0;\n}\n\n"
                ]
            },
            "bad": {
                "c": [
                    "int *assign()\n{\n    int *c;\n    c = 1;\n    return &c;\n}\n\nint foo()\n{\n    int *a;\n    a = assign(); // return a stack address and assign to a\n    printf(\"assigned value: %d\", a); // use dangling pointer\n    return 0;\n}",
                    "#include <alloca.h>\n#include <stdlib.h>\n\nvoid extern fill(char *data, int num);\nvoid dangling_ptr_func(int sz, char *data_buf)\n{\n  data_buf = alloca(sz);\n  fill(data_buf, sz);  // fill data buffer\n  // more manipulation of data buffer ...\n\n\n  // free does not really free data_buf\n  // data_buf points to memory that is out of scope after\n  free(data_buf);\n  return;\n}"
                ],
                "general": [
                    "int *assign()\n{\n int *c;\n c = 1;\n return &c;\n}\n\nint foo()\n{\n int *a;\n a = assign(); // return a stack address and assign to a\n printf(\\\"assigned value: %d\\\", a); // use dangling pointer\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 10,
        "category": "VUL",
        "language": "c,c++",
        "code": "WRF",
        "name": "写入只读文件",
        "desc": "该程序正对只读文件执行写操作。",
        "msg_templ": "在${si.filename}，第${si.line}行，函数${si.func}对只读文件执行写操作。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序正对只读文件执行写操作。\n\n#### 解释\n当打开文件进行读取并随后写入时，fwrite会报告错误。如果不检查fwrite的结果，则该程序会继续进行，而文件可能不会按预期得到更新。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint file_operation()\n{\n    struct stat statBefore, statAfter;\n\n    lstat(\"/tmp/x\", &statBefore);\n\n    // file open for read\n    FILE *fp_open_readonly = fopen(\"/tmp/x\", \"w\");\n    lstat(\"/tmp/x\", &statAfter);\n\n    if (statAfter.st_ino == statBefore.st_ino)\n    {\n        if (fp_open_readonly != NULL)\n        {\n            // writing to the file\n            fwrite(\"HELLO!\", 1, 5, fp_open_readonly);\n        }\n    }\n\n    fclose(fp_open_readonly);\n    return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint file_operation()\n{\n    struct stat statBefore, statAfter;\n\n    lstat(\"/tmp/x\", &statBefore);\n\n    // file open for read\n    FILE *fp_open_readonly = fopen(\"/tmp/x\", \"r\");\n    lstat(\"/tmp/x\", &statAfter);\n\n    if (statAfter.st_ino == statBefore.st_ino)\n    {\n        if (fp_open_readonly != NULL)\n        {\n            // writing to the file\n            fwrite(\"HELLO!\", 1, 5, fp_open_readonly);\n        }\n    }\n\n    fclose(fp_open_readonly);\n    return 0;\n}"
                ],
                "general": [
                    "int file_operation(two_level *p, two_level *q)\n{\n struct stat statBefore, statAfter;\n\n lstat(\\\"/tmp/x\\\", &statBefore);\n\n // file open for read\n FILE *fp_open_readonly = fopen(\\\"/tmp/x\\\", \\\"r\\\");\n lstat(\\\"/tmp/x\\\", &statAfter);\n\n if (statAfter.st_ino == statBefore.st_ino) {\n if (fp_open_readonly != NULL) {\n // writing to the file\n fwrite(\\\"HELLO!\\\", 1, 5, fp_open_readonly);\n }\n }\n\n fclose(fp_open_readonly);\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 11,
        "category": "VUL",
        "language": "c,c++,java",
        "code": "AOB",
        "name": "数组越界",
        "desc": "该程序正在预期缓存定义的界限外（界限之前或之后）访问数据。",
        "msg_templ": "在${si.filename}，第${si.line}行，已经检测到 ${si.func} 里的变量${si.var}有数组越界。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "HIGH",
        "details": "#### 概要\n该程序正在预期缓存声明的界限外（界限前后）访问数据。\n#### 解释\n通常情况下，这可能会引起程序在执行期间受到攻击而导致程序崩溃。当代码从其他内存位置读取敏感数据或可疑数据量并假定存在前哨来阻止读操作时（例如字符串里的空值），可能会发生崩溃。预期的前哨可能不位于越界内存里，致使读取过量数据，从而导致段错误或缓存溢出。软件可能修改引用在缓存界限之外的内存位置的索引或执行指针运算。随后的读运算便会产生未定义或意外结果。\n\n",
        "examples": {
            "good": {
                "c": [
                    "int assign(int* a, int i)\n{\n    return a[i];    /* called by main\n    a only has 2 elements but i is 2 */\n}\n\n#define ARR_SZ 2\nint main()\n{\n    int a[ARR_SZ] = {0, 1}, b;\n    b = assign(a, (ARR_SZ-1)); // call assign with a and i\n    // a has two elements and i is 2\n    // a[2] is out-of-bound and also uninitialized\n    printf(\"value of b = %d\\\\\", b);\n    return 0;\n}"
                ],
                "general": [
                    "int assign(int* a, int i)\n{\n return a[i]; /* called by main\n a only has 2 elements but i is 2 */\n}\n\n#define ARR_SZ 2\nint main() {\n int a[ARR_SZ] = {0, 1}, b;\n if ()\n b = assign(a, (ARR_SZ-1)); // call assign with a and i\n // a has two elements and i is 2\n // a[2] is out-of-bound and also uninitialized\n printf(\"value of b = %d\\\\\", b);\n return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "int assign(int* a, int i)\n{\n return a[i]; /* called by main\n a only has 2 elements but i is 2 */\n}\n\nint main() {\n int a[2] = {0, 1}, b;\n b = assign(a, 2); // call assign with a and i\n // a has two elements and i is 2\n // a[2] is out-of-bound and also uninitialized\n printf(\"value of b = %d\\\\\", b);\n return 0;\n}"
                ],
                "general": [
                    "int assign(int* a, int i)\n{\n return a[i]; /* called by main\n a only has 2 elements but i is 2 */\n}\n\nint main() {\n int a[2] = {0, 1}, b;\n b = assign(a, 2); // call assign with a and i\n // a has two elements and i is 2\n // a[2] is out-of-bound and also uninitialized\n printf(\"value of b = %d\\\\\", b);\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 12,
        "category": "BAD_PRACTICE",
        "language": "c,c++,java",
        "code": "CRF",
        "name": "使用了递归函数",
        "desc": "该程序有调用序列，它在运行时造成了递归。",
        "msg_templ": "在${si.filename}，${si.line}行上，函数 ${si.func}在调用自身。",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序有调用序列，它在运行时造成了递归\n\n#### 解释\n当一个函数(假定是A)调用另外一个函数而调用序列最终再次调用A时，会发生递归。其最简单的形式是函数在执行期间就调用自身，这可能会导致无限循环，还可能会造成对栈空间的过分使用，并可能导致内存不足或栈空间问题。\n",
        "examples": {
            "good": {
                "c": [
                    "// suppose first call to func_recurse is (p_glbl, 6)\n\nconst int MAXIMUM_LIMIT = 100;\nint global = 5;\nstatic *p_glbl = &global;\nint func_recurse(int *p, int i)\n{\n    if (i > MAXIMUM_LIMIT) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (i != 0) {\n        // recursion bottoms out when second argument tends to 0\n        return func_recurse(p_glbl, i - 1);                                           \n    }\n    return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "// Most simple forms of recursion.\n// if first call to func_recurse is: func_recurse(p_glbl, 6)\n// this code segment will recurse and get into an infinite loop\n\nint global = 5;\nstatic *p_glbl = &global;\nint func_recurse(int *p, int i)\n{\n    if ((p != 0) && (*p != i))\n    {\n        return func_recurse(p, 2); // calls itself directly\n    }\n    return 0;\n}"
                ],
                "general": [
                    "// Most simple forms of recursion.\n// if first call to func_recurse is: func_recurse(p_glbl, 6)\n// this code segment will recurse and get into an infinite loop\n\nint global = 5;\nstatic *p_glbl = &global;\nint func_recurse(int* p, int i)\n{\n if ((p != 0) && (*p != i))\n return func_recurse(p, 2); // calls itself directly\n return 0;\n}",
                    "// Indirect recursion.\n// if first call to func_recurse is: func_recurse(p_glbl, 6)\n// this code segment will call func_recurse inside func_b\n\nint global = 5;\nstatic *p_glbl = &global;\n\nint func_b(int *q, int j)\n{\n if (q != 0) {\n return func_recurse(q, 5);\n }\n else\n return 5;\n}\n\nint func_recurse(int *p, int i)\n{\n if ((p != 0) && (*p != i))\n return func_b(p, i); // calls func_recurse indirectly\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 13,
        "category": "CORRECTNESS",
        "language": "c,c++,java",
        "code": "DBZ",
        "name": "被零除",
        "desc": "该程序正试图将值除以零。",
        "msg_templ": "在${so.filename}，第${so.line}行，${so.func} 里的变量 ${so.var}，已检测到了被除以零。该变量的值是零。",
        "severity": "LOW",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "#### 概要\n该程序正试图将值除以零。\n\n#### 解释\n当把意外的常数零赋值给除数，或者发生了未适当检测到的错误（例如函数调用的返回值）时，将值除以零的情况就可能会发生。\n\n",
        "examples": {
            "good": {
                "c": [
                    "int divide(int num, int denom) {\n\n    // checks if denom is 0, and always throws an\n    // error when trying to divide by 0\n    if (denom == 0) \n    {\n        printf(\"Cannot divide a number by 0\");\n        exit(133);\n    }\n\n    return num/denom;\n}"
                ]
            },
            "bad": {
                "c": [
                    "int divide(int num, int denom)\n{\n    // denom could be of value 0, and dividing \n    // by 0 results in undefined behavior\n    return num / denom;\n}\n\nint func(void)\n{\n    return divide(3, 0); // non-compliant\n}"
                ],
                "general": [
                    "int foo(int a, int guard)\n{\n int x = 0;\n int result = 0;\n if (guard != 0)\n result = a / x; // did not check for zero\n printf(\\\"result is %d\\\", result);\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 14,
        "category": "BAD_PRACTICE",
        "language": "c,c++,java",
        "code": "DDC",
        "name": "跳转语句后有无法访问的代码",
        "desc": "跳转语句后有无法访问的代码。",
        "msg_templ": "在${si.filename}，函数${si.func}，第${si.line}行，在执行期间存在无法访问的代码。",
        "severity": "LOW",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n跳转语句后有无法访问的代码。\n\n#### 解释\n跳转语句后面的代码不会被执行， 无返回值的函数之后的代码也不会被执行。这可能是由于意外编辑导致。这是代码质量问题。\n",
        "examples": {
            "good": {
                "c": [
                    "void abort();\nvoid exit();\nint foo();\n\nint f1()\n{\n    foo(); // reachable\n}\nint f2()\n{\n    foo(); // reachable\n}\n\nint f3()\n{\n    foo();\n    goto L;\n    L:\n        foo();  // reachable\n}\n"
                ]
            },
            "bad": {
                "c": [
                    "void abort();\nvoid exit();\nint foo();\n\nint f1()\n{\n    abort();\n    foo(); // unreachable\n}\nint f2()\n{\n    exit();\n    foo(); // unreachable\n}\n\nint f3()\n{\n    foo();\n    goto L;\n    foo(); // unreachable\nL:\n    foo();\n}\n\nint f4(int x)\n{\n    foo();\n    goto L;\n    if (x > 5)\n    { // unreachable\n    L:\n        foo();\n    }\n}\n"
                ],
                "general": [
                    "void abort();\nvoid exit();\nint foo();\n\nint f1() {\n abort();\n foo(); // unreachable\n}\nint f2() {\n exit();\n foo(); // unreachable\n}\n\nint f3() {\n foo();\n goto L;\n foo(); // unreachable\nL:\n foo();\n}\n\nint f4(int x) {\n foo();\n goto L;\n if (x>5) { // unreachable\nL:\n foo();\n }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 15,
        "category": "PFM",
        "language": "c,c++,java",
        "code": "DDV",
        "name": "闲置变量",
        "desc": "这个语句之后的另一个语句将使此语句的执行无效，或这个语句的结果不会被使用。",
        "msg_templ": "在${si.filename}，第${si.line}行，检测到${si.func}里的变量${si.var}是闲置赋值。",
        "severity": "LOW",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n这个语句之后的另一个语句将使此语句的执行无效，或这个语句的结果不会被使用。\n\n#### 解释\n此类错误通常由输入错误引起，抑或是由于一些被删除了的语句导致。\n",
        "examples": {
            "good": {
                "c": [
                    "void assign(int input)\n{\n    int a = input; // a is only used once and does not get nullified\n    printf(\"a value: %d\", a);\n}"
                ]
            },
            "bad": {
                "c": [
                    "void assign(int input)\n{\n    int a = 0; // dead code\n    a = input; // result of \\\"a = 0\\\" will be nullified by this statement\n    printf(\"a value: %d\", a);\n}"
                ],
                "general": [
                    "void assign(int input)\n{\n int a = 0; // dead code\n a = input; // result of \\\"a = 0\\\" will be nullified by this statement\n printf(\\\"a value: %d\\\", a);\n}"
                ]
            }
        }
    },
    {
        "master_id": 16,
        "category": "VUL",
        "language": "c,c++,java",
        "code": "FAM",
        "name": "形式和实际参数不匹配",
        "desc": "该程序正调用函数，其使用的参数个数与原型声明的参数个数不同。",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func}的参数与文件${si.filename}，第${si.line}行里的函数声明不匹配。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "#### 概要\n该程序正调用函数，其使用的参数个数与原型声明的参数个数不同。\n\n#### 解释\n在调用点里，传递的实际参数个数与函数声明里的参数个数不同。如果传递的实际参数比声明的要少，缺失的实际参数最终会变成\\\"wild\\\"，并可能发生不可预测的行为后果。\n",
        "examples": {
            "good": {
                "c": [
                    "int foo(int a, int guard)\n{\n    int x = 0;\n    int result = 0;\n    if (guard != 0)\n    {\n        result = a * x;\n    }\n    foo(result, guard); // no parameters missing\n    return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "int foo(int a, int guard)\n{\n    a++;\n    guard++;\n    return 0;\n}\n\nint func(void)\n{\n    int t = 1;\n    /* \n    missing one parameter, and \\\"guard\\\" will have \n    random value during execution at this point;\n    compilation error would be raised here\n    */\n    foo(t);\n    return 1;\n}"
                ],
                "general": [
                    "int foo(int a, int guard)\n{\n int x = 0;\n int result = 0;\n if (guard != 0)\n result = a * x;\n foo(result); // missing one parameter, and \\\"guard\\\" will have random value during execution at this point\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 17,
        "category": "ROBUSTNESS",
        "language": "c,c++,java",
        "code": "NPD",
        "name": "空指针解除引用",
        "desc": "该程序正通过有空值的指针访问内存。这可能会导致段错误或不可预测的程序行为。该漏洞与EXP34-C等同。",
        "msg_templ": "在${so.filename}，第${so.line}行，${so.func} 里对变量${so.var}检测到了NPD缺陷。该变量的值是零。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序正通过有空值的指针访问内存。这可能会导致段错误或不可预测的程序行为。该漏洞与EXP34-C等同。\n\n#### 解释\n在有内存保护的系统里（例如Linux），解引用空指针会导致段错误。 对于嵌入系统来说，它会造成不可预测的程序行为。在Java里，空指针解除引用会触发空指针异常。\n",
        "examples": {
            "good": {
                "c": [
                    "extern int bar(int);\n\nint assign(int* a)\n{\n int i;\n if (a != 0)\n i = bar(*a); // dereference a\n else {\n // handle error and exit gracefully (such exit program)\n exit(1);\n }\n return i;\n}\n\nint foo(void)\n{\n int *p = 0; // p as a pointer has been initialized to 0 (null)\n assign(p);\n}"
                ],
                "java": [
                    "class User {\n public String getName() {\n return null;\n }\n}\n\nclass Bar {\n private User findUser(String uid) {\n if (user.containsKey(uid)) {\n return user.get(uid);\n }\n else\n return null;\n }\n public void Npd(String uid) {\n // program continues\n // ...\n User user = findUser(uid); \n if (user == null) {\n throw new RuntimeException(\\\"Null String\\\");\n }\n String getName() {\n return null;\n }\n }\n}"
                ]
            },
            "bad": {
                "c": [
                    "extern int bar(int);\n\nint assign(int* a)\n{\n int i = bar(*a) // dereference a\n return i;\n}\n\nint foo(void)\n{\n int *p = 0; // p as a pointer has been initialized to 0 (null)\n assign(p);\n}"
                ],
                "java": [
                    "class User {\n public String getName() {\n return null;\n }\n}\n\nclass Bar {\n private User findUser(String uid) {\n if (user.containsKey(uid)) {\n return user.get(uid);\n }\n else\n return null;\n }\n public void Npd(String uid) {\n // program continues\n // ...\n User user = findUser(uid); // Throws NPE if \\\"user\\\" has not been properly initialized\n String getName() {\n return null;\n }\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 18,
        "category": "BAD_PRACTICE",
        "language": "c,c++,java",
        "code": "RCD",
        "name": "冗余的控制语句",
        "desc": "冗余的控制语句。",
        "msg_templ": "在${si.filename}，函数 ${si.func}，第${si.line}行的语句是多余的。",
        "severity": "LOW",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n冗余的控制语句。\n\n#### 解释\n当两个条件语句在执行流中有依赖时，一个条件可以在逻辑上包含另一个条件语句。在这种情况下，另一个条件是多余和不必要的，这种情况可能是编辑错误造成的，这是一个代码质量问题。\n",
        "examples": {
            "good": {
                "c": [
                    "int foo();\nint bar();\n\nint f1(int x)\n{\n    if (x > 16) // removed x>15 since unnecessary\n        foo();\n}\n\nint f2(int x)\n{\n    if (x > 16) // removed x>15 since unnecessary\n        foo();\n}\n\nint f3(int x)\n{\n    if (x > 16)\n    {\n        foo();\n        bar(); // bar will always run anyways so no need an if statement\n    }\n}\n\nint f4(int x)\n{\n    if (x > 15)\n    {\n        foo();\n        if (x > 16) \n        {\n            bar();\n        }\n    }\n}"
                ]
            },
            "bad": {
                "c": [
                    "int foo();\nint bar();\n\nint f1(int x)\n{\n    if (x > 15 && x > 16) // x>16 will subsume x>15\n        foo();\n}\n\nint f2(int x)\n{\n    if (x > 16 && x > 15) // x>16 implies x>15, hence x>15 is redundant\n        foo();\n}\n\nint f3(int x)\n{\n    if (x > 16)\n    {\n        foo();\n        if (x > 15) // x>16 implies x>15, hence this check is unnecessary\n            bar();\n    }\n}\n\nint f4(int x)\n{\n    if (x > 15)\n    {\n        foo();\n        if (x > 16) // x>15 does not imply x>16, this check is not redundant\n            bar();\n    }\n}"
                ],
                "general": [
                    "int foo();\nint bar();\n\nint f1(int x) {\n if (x>15 && x>16) // x>16 will subsume x>15\n foo();\n}\n\nint f2(int x) {\n if (x>16 && x>15) // x>16 implies x>15, hence x>15 is redundant\n foo();\n}\n\nint f3(int x) {\n if (x>16) {\n foo();\n if (x>15) // x>16 implies x>15, hence this check is unnecessary\n bar();\n }\n}\n\nint f4(int x) {\n if (x>15) {\n foo();\n if (x>16) // x>15 does not imply x>16, this check is not redundant\n bar();\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 19,
        "category": "BAD_PRACTICE",
        "language": "c,c++,java",
        "code": "SCB",
        "name": "相同的代码块",
        "desc": "一个条件语句中相同的代码块。",
        "msg_templ": "在${si.filename}，函数${si.func}，第${si.line}行的条件语句，其两边后面的代码块是相同的。",
        "severity": "LOW",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n一个条件语句中相同的代码块。\n\n#### 解释\n条件语句中的两个代码块是相同的。这可能是由于编辑错误造成的。这是一个代码质量问题。\n",
        "examples": {
            "good": {
                "c": [
                    "int foo();\nint a, b;\n\nint f1(int x)\n{\n    foo(); // no dead code\n}\n\nint f2(int x)\n{\n    return foo();\n}\n"
                ]
            },
            "bad": {
                "c": [
                    "int foo();\nint a, b;\n\nint f1(int x)\n{\n    if (a) \n    {\n        foo();\n    } \n    else \n    {\n        foo();\n    }\n}\n\nint f2(int x)\n{\n    return x ? foo() : foo();  // equivalent to above\n}\n\nint f3(int x)\n{\n    if (x);  // both then and else blocks are empty\n}\n"
                ],
                "general": [
                    "int foo();\nint a, b;\n\nint f1(int x) {\n if (x) // in this condition (if-then-else, block 1 and block 2 are the same. Effectively making the conditional statement useless)\n foo(); // block 1\n else\n foo(); // block 2\n}\n\nint f2(int x) {\n return x ? foo() : foo(); // similar code written differently\n}\n\nint f3(int x) {\n  if (x);  // both then and else blocks are empty\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 20,
        "category": "BAD_PRACTICE",
        "language": "c,c++,java",
        "code": "SSE",
        "name": "相同的子表达式",
        "desc": "程序有相同的子表达式。",
        "msg_templ": "在${si.filename}，函数${si.func}，第${si.line}行，条件语句中有相同的子表达式。",
        "severity": "LOW",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n程序有相同的子表达式。\n\n#### 解释\n在语句中有相同的表达式，其中表达式中变量的值也没有更改。 这可能是由于程序中的拼写错误。 这是一个代码质量问题。\n",
        "examples": {
            "good": {
                "c": [
                    "int foo();\nint a, b;\n\nint f3(int x, int *p)\n{\n    if (*p && *p) // same sub-expression\n        foo();\n}\n\nint f4(int x, int y)\n{\n    if ((x + y++) && (y + x)) // not same sub-expression due to y++\n        foo();\n}"
                ]
            },
            "bad": {
                "c": [
                    "int foo();\nint a, b;\n\nint f3(int x, int *p)\n{\n    if (*p && x) // both expressions are not the same \n    {\n        foo();\n    }  \n}\n\nint f4(int x, int y)\n{\n    if ((x + y++) && (y + x)) \n    {\n        foo();\n    }\n        \n}"
                ],
                "general": [
                    "int foo();\nint a, b;\n\n\nint f3(int x, int *p) {\n if (*p && *p) // same sub-expression\n foo();\n}\n\nint f4(int x, int y) {\n if ((x+y++) && (y+x)) // not same sub-expression due to y++\n foo();\n}"
                ]
            }
        }
    },
    {
        "master_id": 21,
        "category": "BAD_PRACTICE",
        "language": "c,c++,java",
        "code": "UIC",
        "name": "构造函数中有未初始化字段",
        "desc": "构造函数中有未初始化字段。",
        "msg_templ": "在${si.filename}，函数${si.func}，第${si.line}行，有一个字段${si.var}尚未初始化。",
        "severity": "LOW",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### 概要\n构造函数中有未初始化字段 \n\n#### 解释\n类的构造函数通常包括类内字段的初始化。如果字段没有初始化，很可能是由于编辑错误，这是一个代码质量问题。\n",
        "examples": {
            "good": {
                "cpp": [
                    "#include <stdio.h>\n\nclass Construct_Init\n{\nprivate:\n    int a;\n    int b;\n\npublic:\n    // all variables in all constructors are\n    // initialized\n    Construct_Init()\n    {\n        a = 0;\n        b = 0;\n    };\n    Construct_Init(int i)\n    {\n        a = i;\n        b = 0;\n    }\n    Construct_Init(int i, int j)\n    {\n        a = i;\n        b = j;\n    }\n\n    void CI_Run() { printf(\"%d:%d\", a, b); }\n};\n\nint main(int argc, char **argv)\n{\n    Construct_Init ci;\n    ci.CI_Run();\n    Construct_Init ci1(1);\n    ci1.CI_Run();\n    Construct_Init ci2(1, 2);\n    ci2.CI_Run();\n}"
                ]
            },
            "bad": {
                "cpp": [
                    "#include <stdio.h>\n\nclass Construct_Init\n{\nprivate:\n    int a;\n    int b;\n\npublic:\n    // all variables in all constructors are\n    // initialized\n    Construct_Init();\n    Construct_Init(int i);\n    Construct_Init(int i, int j);\n\n    void CI_Run() { printf(\"%d:%d\", a, b); }\n};\n\nConstruct_Init::Construct_Init()\n{\n}\n\nConstruct_Init::Construct_Init(int i)\n{\n    a = i;\n}\n\nConstruct_Init::Construct_Init(int i, int j)\n{\n    a = i;\n    b = j;\n}\n\nint main(int argc, char **argv)\n{\n    Construct_Init ci;\n    ci.CI_Run();\n    Construct_Init ci1(1);\n    ci1.CI_Run();\n    Construct_Init ci2(1, 2);\n    ci2.CI_Run();\n}\n"
                ],
                "general": [
                    "#include <stdio.h>\n\nclass Construct_Init{\nprivate:\n int a;\n int b;\npublic:\n Construct_Init();\n Construct_Init(int i): a(i) {}; // did not initialize b\n Construct_Init(int i, int j) { a = i; b = j; }\n\n void CI_Run() { printf(\\\"%d:%d\\\n\\\", a, b); }\n};\n\nint main(int argc, char**argv)\n{\n Construct_Init ci;\n ci.CI_Run();\n Construct_Init ci1(1);\n ci1.CI_Run();\n Construct_Init ci2(1,2);\n ci2.CI_Run();\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 22,
        "category": "CORRECTNESS",
        "language": "c,c++,java",
        "code": "UIV",
        "name": "未初始化的变量",
        "desc": "该程序正在使用未初始化的变量。",
        "msg_templ": "在${so.filename}，第${so.line}行，已经使用了${so.func}里的变量${so.var}但从未对其赋值。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序在变量初始化前使用该变量。\n\n#### 解释\nC和C++里的栈变量默认为非初始化，并且非静态全局变量不默认为零。它们的初始值取决于调用函数时它们在内存中的位置里恰好有的值。这么做会导致意外程序行为。\n",
        "examples": {
            "good": {
                "c": [
                    "int assign(int *a)\n{\n    return *a; // dereference a\n}\n\nint main()\n{\n    int a = 100; // a is assigned as 100\n    int b;\n    b = assign(&a); \n    printf(\"value of b = %d\", b);\n    return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "int assign(int *a)\n{\n    return *a; // dereference a\n}\n\nint main()\n{\n    int a, b;\n    b = assign(&a); // call assign with a uninitialized variable\n    printf(\"value of b = %d\", b);\n    return 0;\n}"
                ],
                "general": [
                    "int assign(int* a)\n{\n return *a; // dereference a\n}\n\nint main() {\n int a, b;\n b = assign(&a); // call assign with a uninitialized\n printf(\\\"value of b = %d\\\n\\\", b);\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 23,
        "category": "BAD_PRACTICE",
        "language": "c++,java",
        "code": "ECB",
        "name": "空的异常catch块",
        "desc": "该程序有带空catch块的异常构造。",
        "msg_templ": "在${si.filename}，${si.func}里第${si.line}行的catch块是空的。",
        "severity": "LOW",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序有带空catch块的异常构造。\n\n#### 解释\n空的catch块会导致另一个try块无法正确处理异常。 “未被抓取到”的异常可能会导致程序出现异常。\n\n",
        "examples": {
            "good": {
                "cpp": [
                    "#include <iostream>\n\nint integer_divide(int a, int b) {\n    if (b == 0) {\n        throw \"division by zero error\";\n    }\n    else return (a/b);\n}\n\nint foo(int x, int y) {\n    try {\n        int z = integer_divide(x, y);\n        std::cout << z << std::endl;\n    }\n    catch (const char* msg) {\n    // non-empty catch body and return error\n        std::cout << \"division exception\" << std::endl;\n        return 1;\n    }\n    return 0;\n}"
                ],
                "general": [
                    "#include <iostream>\n\nint integer_divide(int a, int b) {\n if (b == 0) {\n throw \\\"division by zero error\\\";\n }\n else return (a/b);\n}\n\nint foo(int x, int y) {\n try {\n int z = integer_divide(x, y);\n std::cout << z << std::endl;\n }\n catch (const char* msg) {\n // non-empty catch body and return error\n std::cout << \\\"division exception\\\" << std::endl;\n return 1;\n }\n return 0;\n}"
                ]
            },
            "bad": {
                "cpp": [
                    "#include <iostream>\n\nint integer_divide(int a, int b) \n{\n    if (b == 0) \n    {\n        throw \"division by zero error\";\n    }\n    else return (a/b);\n}\n\nint foo(int x, int y) {\n    try {\n        int z = integer_divide(x, y);\n        std::cout << z << std::endl;\n    }\n    catch (const char* msg) {\n    // empty catch body, zero as divisor notice suppressed\n    }\n    return 0;\n}"
                ],
                "general": [
                    "#include <iostream>\n\nint integer_divide(int a, int b) {\n if (b == 0) {\n throw \\\"division by zero error\\\";\n }\n else return (a/b);\n}\n\nint foo(int x, int y) {\n try {\n int z = integer_divide(x, y);\n std::cout << z << std::endl;\n }\n catch (const char* msg) {\n // empty catch body, zero as divisor notice suppressed\n }\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 24,
        "category": "VUL",
        "language": "c,c++",
        "code": "FIO37-C",
        "name": "fgets()和fgetws()可能返回空字符串",
        "desc": "该程序正调用fgets()或fgetws()，并假定返回的字符串为非空字符串。",
        "msg_templ": "在${si.filename}，第${si.line}行的函数${si.func}可能会返回空字符串。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序正调用fgets()或fgetws()，并假定返回的字符串为非空字符串。\n\n#### 解释\nfgets()和fgetws()这两个函数可能返回空字符串（例如，文件可能为二进制文件）。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n\n#define BUF_SZ 1024\n\nvoid read_string(void)\n{\n char buf[BUF_SZ];\n FILE *fp = fopen(\"/myfile\", \"+r\");\n // check fp valid\n // ...\n\n if (fgets(buf, BUF_SZ, fp) != 0) {\n // replace newline character if it is there\n char *pchar = strchr(buf, '');\n if (pchar) *pchar = '\\\\0';\n\n printf(\"Size of string read = %d\", strlen(buf)-1);\n }\n\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n\n#define BUF_SZ 1024\n\nvoid read_string(void)\n{\n char buf[BUF_SZ];\n FILE *fp = fopen(\"/myfile\", \"+r\");\n // check fp valid\n // ...\n\n if (fgets(buf, BUF_SZ, fp) != 0) {\n // if the first character of buf is '\\\\0', a random meaningless large number will be printed\n printf(\"Size of string read = %d\", strlen(buf)-1);\n }\n\n}"
                ]
            }
        }
    },
    {
        "master_id": 25,
        "category": "VUL",
        "language": "c,c++",
        "code": "MSC32-C",
        "name": "请在使用伪随机数生成器前为其生成种子",
        "desc": "该程序正使用有播种（初始状态）的伪随机数生成器，这会产生确定性的数字序列。",
        "msg_templ": "在${si.filename}，第${si.line}行的函数${si.func}里，正在调用变量${si.var}。该产生器会生成确定性的序列。",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### 概要\n该程序正使用有播种（初始状态）的伪随机数生成器，这会产生确定的数字序列。\n\n#### 解释\n适当生成种子的PRNG在每次运行时都会生成不同的数字序列（例如，在调用random函数前调用srandom()），这能阻止潜在的攻击者预测生成的数字序列攻击。或者也可以使用不能生成种子的随机数生成器来阻止潜在的攻击。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n#include <stdlib.h>\n\n// function calls random() with proper seeding\nvoid print_rand(void)\n{\n    srandom(time(NULL));\n    for (int i = 0; i < 20; i++)\n    {\n        printf(\"%lx \\n\", random());\n    }\n}\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n#include <stdlib.h>\n\n// this function calls random() without proper seeding it\n// output of this function will be the same each time it is called\nvoid print_rand(void)\n{\n    for (int i = 0; i < 20; i++)\n    {\n        printf(\"%lx \\n\", random());\n    }\n}\n\n\n\n"
                ]
            }
        }
    },
    {
        "master_id": 26,
        "category": "VUL",
        "language": "c,c++",
        "code": "ENV32-C",
        "name": "退出处理程序必须正常返回",
        "desc": "该程序正使用某个未正常返回的退出处理程序。",
        "msg_templ": "在${si.filename}，第${si.line}行的函数${si.func}被注册为退出处理程序。该程序会退出，且不会正常返回。",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序正使用某个未正常返回的退出处理程序。\n\n#### 解释\n以下三个函数_Exit()、exit()、quick_exit()是C的标准退出函数。exit()和quick_exit()会因为清理目的分别调用退出处理程序atexit()和at_quick_exit()，_Exit()则不会。用户可以定义其自有的处理程序并在系统提供的处理程序注册。这些退出处理程序必须正常返回，这样才能适当地执行所有退出处理程序（从而执行所有清理任务）。此外，所有退出处理程序均不应调用exit()。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdlib.h>\n#include <stdio.h>\n\nstatic int file_opened;\n\nvoid my_exit1(void)\n{\n // some clean up code for opened file\n fprintf(stderr, \"abnormal exit from my_exit1() with file closed\\\\\");\n exit(0); // this exit handler does not return normally. exit() is called the second time when value of file_opened is 1.\n}\n\nvoid my_exit2(void)\n{\n if (file_opened == 1) {\n my_exit1();\n }\n fprintf(stderr, \"abnormal exit with errno %d\", errno());\n // other cleanup code\n // if file_opened is 1, the clean up code here will not be executed\n // ...\n return;\n\n}\n\nint main() {\n // ...\n file_opened = 1;\n if (atexit(my_exit2) != 0) {\n // handle error\n }\n}\n return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdlib.h>\n#include <stdio.h>\n\nextern int file_opened;\n\nint my_exit1(void)\n{\n // some clean up code for opened file\n fprintf(stderr, \"abnormal exit from my_exit1() with file closed\\\\\");\n exit(0); // this exit handler does not return normally. exit() is called the second time when value of file_opened is 1.\n}\n\nint my_exit2(void)\n{\n if (file_opened == 1) {\n my_exit1();\n }\n fprintf(stderr, \"abnormal exit with errno %d\", errno());\n // other cleanup code\n // if file_opened is 1, the clean up code here will not be executed\n // ...\n return 1;\n\n}\n\nint main() {\n // ...\n if (atexit(my_exit2) != 0) {\n // handle error\n }\n}\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 27,
        "category": "VUL",
        "language": "c,c++",
        "code": "ENV33-C",
        "name": "请注意对system()的直接调用",
        "desc": "该程序正调用C标准system()函数。如果保护不当，可能会导致多种攻击。",
        "msg_templ": "在${si.filename}，函数${si.func}里的第${si.line}行，system()有未经清理的输入参数。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序正调用C标准system()函数。如果保护不当，可能会导致多种攻击。\n\n#### 解释\n该程序正调用有字符串参数的system()函数。必须适当地保护此类字符串，例如清理过的字符串、规范化的路径等等。未能这么做将导致程序的任意执行、权限提升或其它不可预测行为。\n\n",
        "examples": {
            "good": {
                "c": [
                    "void func_call_sys(const char *in)\n{\n // system() is called with a string \\\"in\\\" passed from outside of this function\n // There is no evidence that \\\"in\\\" has been sanitized\n // Sanitize input to system()\n // use full path name for directory for example\n sanitise(in); // e.g. for file or directory name, do not include \\\"../\\\" substring\n system(in);\n}"
                ]
            },
            "bad": {
                "c": [
                    "void func_call_sys(const char *in)\n{\n // system() is called with a string \\\"in\\\" passed from outside of this function\n // There is no evidence that \\\"in\\\" has been sanitized\n // for example, if \\\"in\\\" is the string \\\"rm *\\\"\n // executing the system() call could be devastating\n system(in);\n}"
                ]
            }
        }
    },
    {
        "master_id": 28,
        "category": "VUL",
        "language": "c,c++",
        "code": "ERR33-C",
        "name": "请检查并处理标准库返回错误",
        "desc": "该程序正调用标准库函数，但未能检查并处理函数的错误返回。",
        "msg_templ": "在${si.filename}，第${si.line}行的${si.func}里，未检查系统库调用${si.var}的返回值。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序正调用标准库函数，但未能检查并处理函数的错误返回。\n\n#### 解释\n该程序正调用标准库函数。这些函数通常返回一个有效值，或某种形式的值以表示有错误发生。未能检查调用是成功还是失败可能造成意外或未定义行为。请参考语言或系统规范，以获得对标准接口的完整描述。请注意有一些系统函数，不需要对其返回值进行检查。您也可以在系统或语言规范里找到这些函数的列表，一些经常被使用的函数是printf、vprintf、memcpy、memmove、strcpy、strcat、memset（以及其宽字符版本）。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n int len;\n int *data;\n} vec_rec, *vec_rec_ptr;\n\nenum { VEC_SZ = 32 };\n\nvec_rec vr[VEC_SZ] = { 0 }; // initialize table content\nvec_rec_ptr func_call_stdlib(int len, vec_rec_ptr in_vec)\n{\n vec_rec_ptr vrp = (vec_rec_ptr)(malloc(sizeof(vec_rec) * len));\n\n // Checks if vrp is NULL, such as when malloc failed\n if (vrp == NULL) \n {\n  printf(\"Malloc has failed, the program will terminate.\");\n  return NULL;\n }\n\n // this memcpy may enable an attacker to access memory causing remote code execution\n memcpy(vrp, in_vec, len);\n\n}\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n int len;\n int *data;\n} vec_rec, *vec_rec_ptr;\n\nenum { VEC_SZ = 32 };\n\nvec_rec vr[VEC_SZ] = { 0 }; // initialize table content\nvec_rec_ptr func_call_stdlib(int len, vec_rec_ptr in_vec)\n{\n vec_rec_ptr vrp = (vec_rec_ptr)(malloc(sizeof(vec_rec) * len));\n // vrp may be NULL if malloc failed\n // this code did not check that vrp may be invalid\n\n // this memcpy may enable an attacker to access memory causing remote code execution\n memcpy(vrp, in_vec, len);\n\n}"
                ]
            }
        }
    },
    {
        "master_id": 29,
        "category": "VUL",
        "language": "c,c++",
        "code": "FIO34-C",
        "name": "作为\"char\"大小对象的EOF和WEOF与从文件里读取的字符不一",
        "desc": "该程序正使用文件读（例如getchar()、getc()、getwc()......）的返回值来核实EOF/WEOF为文件读操作的末尾。",
        "msg_templ": "在${si.filename}第${si.line}行上的函数${si.func}正使用文件读的返回值来核实EOF。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序正使用文件读（例如getchar()、getc()、getwc()......）的返回值来核实EOF/WEOF为文件读操作的末尾。\n\n#### 解释\n从文件中读取字符的函数会返回int类型。把读取的字符直接和EOF/WEOF比较可能导致意外结果，因为EOF和WEOF是以实现为准的。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n\nvoid read_char(void)\n{\n\tFILE *fp = fopen(\"/tmp/myfile\", \"+r\");\n\t// check fp valid\n\t// ...\n\t\n\tint c = getc(fp);\n\t\n\t// make sure it is really an EOF character and that the EOF is due to end-of-file\n\t\n\twhile (c != EOF || (feof(stdin) && !ferror(stdin)) \n\t{\n\tputchar(c); // echo what is read in\n\tc = getc(fp);\n\t}\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n\nvoid read_char(void)\n{\n FILE *fp = fopen(\"/tmp/myfile\", \"+r\");\n // check fp valid\n // ...\n\n int c = getc(fp);\n while (c != EOF) // this check does not guarantee read has reached end of file\n {\n putchar(c); // echo what is read in\n c = getc(fp);\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 30,
        "category": "VUL",
        "language": "c,c++",
        "code": "FIO42-C",
        "name": "请关闭使用完的文件",
        "desc": "该程序打开了文件但未能在使用完文件后或程序终止前关闭该文件。",
        "msg_templ": "在${si.filename}第${si.line}行上的函数${si.func}，文件${si.var}未经关闭。",
        "severity": "MEDIUM",
        "likelihood": "UNLIKELY",
        "cost": "MEDiUM",
        "details": "#### 概要\n该程序打开了文件但未能在使用完文件后或程序终止前关闭该文件。\n\n#### 解释\n当不再需要文件时就关闭它是很重要的。未能这么做可能会把与文件相关的资源（例如缓存数据）暴露给攻击者。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n\nint open_file(const char *fname)\n{\n FILE *fp = fopen(fname, \"+r\");\n if (fp == NULL) return -1;\n\n // program continues\n\n if (fclose(fp) == EOF) {\n // handle error\n ...\n }\n return 0; // file is properly closed on return\n\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n\nint open_file(const char *fname)\n{\n FILE *fp = fopen(fname, \"+r\");\n if (fp == NULL) return -1;\n\n // program continues\n return 0; // file is not properly closed on return\n\n}"
                ]
            }
        }
    },
    {
        "master_id": 31,
        "category": "VUL",
        "language": "c,c++",
        "code": "FIO45-C",
        "name": "文件访问可能有竞态条件，应该要避免",
        "desc": "竞态条件在访问文件（time of check，time of use）时可能发生，並需要避免。",
        "msg_templ": "在${si.filename}第${si.line}行的函数 ${si.func}，文件${si.var}有TOCTOU的漏洞。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "#### 概要\n在访问文件（time of check，time of use）时竞态条件可能发生，这应该要避免。\n\n#### 解释\n在共享文件系统里，两个或多个进程可能访问同一个文件，从而导致竞态条件。攻击者可以在不同进程的两次访问之间更改文件，或用不同的文件代替该文件（符号或硬链接）。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint file_s1(char *p, char *q)\n{\n    struct stat statBefore, statAfter;\n\n    lstat(\"/tmp/x\", &statBefore);\n    \n    // \"x\" mode will cause fopen() to fail\n    // if the file exists.  \n    // NOTE: Only works for C11 and above or\n    // systems that support this feature\n    FILE *f = fopen(\"/tmp/x\", \"wx\");\n    if (statAfter.st_ino == statBefore.st_ino)\n    {\n        if (f != NULL)\n            fwrite(\"HELLO!\", 1, 5, f);\n    }\n\n    fclose(f);\n    return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n// This example is modified from example in \n// CERT-C FIO45 site\nint file_s1(char *p, char *q)\n{\n    struct stat statBefore, statAfter;\n\n    lstat(\"/tmp/x\", &statBefore);\n    // previous contents of file gets destroyed \n    // with \"w\" mode\n    FILE *f = fopen(\"/tmp/x\", \"w\");\n    lstat(\"/tmp/x\", &statAfter);\n    if (statAfter.st_ino == statBefore.st_ino)\n    {\n        if (f != NULL)\n            fwrite(\"HELLO!\", 1, 5, f);\n    }\n\n    fclose(f);\n    return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 32,
        "category": "VUL",
        "language": "c,c++",
        "code": "MEM35-C",
        "name": "请确保分配了足够的内存给对象",
        "desc": "该程序使用了malloc函数家族来分配内存，该内存比程序所需的内存要小。",
        "msg_templ": "在${si.filename}，第${si.line}行的${si.func}函数里，正访问位于分配的范围之外的内存。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "#### 概要\n该程序使用了malloc函数家族来分配内存，该内存比程序所需的内存要小。\n\n#### 解释\n对应malloc函数的大小参数的参数应有足够的范围来表示要存储的对象的大小。未能这么做将造成缓存溢出，从而导致意外程序行为。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdlib.h>\n\ntypedef struct\n{\n    size_t len;\n    int *data;\n} vect_record, *vect_ptr;\n\nvect_record *vector_new(size_t len)\n{\n    vect_record *vect;\n    // dereferenced pointer type means correct amount \n    // of memory is allocated for the struct tm object\n    vect_ptr result = (vect_ptr)malloc(sizeof(*vect));\n    if (result == NULL)\n    {\n        // handle error and return\n        return NULL;\n    }\n\n    // initialize vector\n    result[0].len = 1;\n    result[1].len = 2;\n    // ...\n    return result;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdlib.h>\n\ntypedef struct\n{\n    size_t len;\n    int *data;\n} vect_record, *vect_ptr;\n\nvect_record *vector_new(size_t len)\n{\n    vect_record *vect;\n    // size of pointer used to determine size of pointed-to object\n    vect_ptr result = (vect_ptr)malloc(sizeof(vect));\n    if (result == NULL)\n    {\n        // handle error and return\n        return NULL;\n    }\n\n    // initialize vector\n    result[0].len = 1;\n    result[1].len = 2;\n    // ...\n    return result;\n}"
                ]
            }
        }
    },
    {
        "master_id": 33,
        "category": "VUL",
        "language": "c,c++",
        "code": "MEM36-C",
        "name": "调用realloc()可能会使得之前对齐的对象再次不一致",
        "desc": "该程序使用了realloc()，它导致指针的对齐比内存重新分配前的对齐限制要小。",
        "msg_templ": "在${si.filename}，第${si.line}行，函数${si.func}使用了realloc()。",
        "severity": "LOW",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "#### 概要\n该程序使用了realloc()，它导致指针的对齐比内存重新分配前的对齐限制要小。\n\n#### 解释\nrealloc()会分配新内存并把之前分配的内存指针指向新的分配区域。如果之前分配的内存有更多对齐上的限制（例如，16byte），新指向的内存将不会满足这一限制，从而导致意外程序行为。\n",
        "examples": {
            "good": {},
            "bad": {
                "c": [
                    "#include <stdlib.h>\n\nint *vector_calc(size_t vec_sz, int elements)\n{\n size_t align_vec = 1 << vec_sz;\n int *ptr_align;\n\n if ((ptr_align = (int *)aligned_alloc(align_vec, sizeof(int)*elements)) == NULL) {\n // handle error and return;\n // ...\n }\n\n // program continues\n // ...\n if ((ptr1 = (int *) realloc(ptr_align, sizeof(int)*elements * 2)) == NULL) {\n // handle error and return\n //...\n }\n\n // program continues\n // but ptr1 is not guaranteed to properly aligned with the vector objects previous allocated\n\n return ptr1;\n\n}"
                ]
            }
        }
    },
    {
        "master_id": 34,
        "category": "VUL",
        "language": "c,c++",
        "code": "MSC33-C",
        "name": "asctime()函数的使用必须传递所需的、有着有效范围的参数",
        "desc": "该程序正调用asctime()函数，然而该函数的输入参数来自不受信任来源。",
        "msg_templ": "在${si.filename}，第${si.line}行，函数asctime被调用并以变量${si.var}为参数。该变量${si.var}可能尚未经过清理。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### 概要\n该程序正调用asctime()函数，然而该函数的输入参数来自不受信任来源。\n\n#### 解释\n函数asctime()不验证其输入参数的值或范围。在试图打印到字符串时，对该函数返回结果的继续使用可能造成缓存溢出及其它安全违规。\n",
        "examples": {
            "good": {
                "c": [
                    "#define __STDC_WANT_LIB_EXT1__ 1\n#include <time.h>\n#include <stdio.h>\n\nenum\n{\n    max = 50\n};\n\nvoid read_time(struct tm *time_info)\n{   \n    // checks for invalid data below and handles \n    // error if exists\n    char buffer[max];\n    if (asctime_s(buffer, max, &time_info))\n    {\n        /* Handle error */\n    }\n\n    char *time = asctime(time_info);\n    printf(\"time is %s\", time);\n}\n    \n\n\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <time.h>\n#include <stdio.h>\n\nvoid read_time(struct tm *time_info)\n{\n    // does not check for invalid or potentially\n    // unsanitised data\n    char *time = asctime(time_info);\n    printf(\"time is %s\", time);\n}"
                ]
            }
        }
    },
    {
        "master_id": 35,
        "category": "VUL",
        "language": "c,c++",
        "code": "MSC37-C",
        "name": "非void函数应始终通过返回语句退出该函数",
        "desc": "该程序有一个执行路径，它可能不通过\"return\"语句就到达非void函数的退出点。",
        "msg_templ": "在${si.filename}第${si.line}行，声明了函数${si.func}的返回非void，但在没有返回语句的情况下已达到了函数末尾。",
        "severity": "HIGH",
        "likelihood": "UNLIKELY",
        "cost": "LOW",
        "details": "#### 概要\n该程序有一个执行路径，它可能不通过返回语句就到达非void函数的退出点。\n\n#### 解释\n当该程序在没有返回语句的执行路径上退出此函数时，返回值会是不确定的，从而导致意外程序行为。如果此函数恰好是\\\"main\\\"，或者如果它被标为有\\\"no-return\\\"属性，那么就没有问题。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <string.h>\n#define BUF_SZ 1024\nint has_char(const char *s)\n{\n    if (s != NULL)\n    {\n        int l = strlen(s);\n        int i;\n        for (i = 0; i < l; i++)\n        {\n            if (s[i] == 'c')\n                return i;\n        }\n    }\n    // return statement ensures control never reaches end of\n    // the function, returns -1 if no letter 'c'\n    return -1;\n}\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <string.h>\n\n#define BUF_SZ 1024\n\nint has_char(const char *s)\n{\n    if (s != NULL)\n    {\n        int l = strlen(s);\n        int i;\n        for (i = 0; i < l; i++)\n        {\n            if (s[i] == 'c')\n                return i;\n        }\n    }\n    // missing return here, return value will be undefined\n}"
                ]
            }
        }
    },
    {
        "master_id": 36,
        "category": "VUL",
        "language": "c,c++",
        "code": "POS30-C",
        "name": "readlink()函数只会填满第二个参数里的缓存，但不包括空终止符",
        "desc": "该程序调用了readlink()函数，而写在缓存（第二个参数）上的字符数不足够容纳有效字符串。",
        "msg_templ": "在${si.filename}第${si.line}行，调用了函数readlink()并把其赋值给变量${si.var}。字符串读不一定是空终止。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序调用了readlink()函数，而写在缓存（第二个参数）上的字符数不足够容纳有效字符串。\n\n#### 解释\n由readlink()写入的字符数可能会溢出第二个参数里指定的缓存。另外我们需要确保字符串末尾为空终止。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n\n#define BUF_SZ 1024\n\nint func(char *env_str)\n{\n    char buf[BUF_SZ];\n\n    // if len is >= sizeof(buf), up till the last byte of buf is non-null\n    ssize_t len = readlink(\"/usr/somedir/symlinkfile\", buf, sizeof(buf)); \n\n    // case handled when len is an invalid value\n    if (len >= sizeof(buf) || len == -1) {\n        // Handle Exception \n        return;\n    }\n\n    buf[len] = '\\0'; // len is always within buf size range\n    return;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n\n#define BUF_SZ 1024\n\nint func(char *env_str)\n{\n    char buf[BUF_SZ];\n\n    // if len is >= sizeof(buf), up till the last byte of buf is non-null\n    ssize_t len = readlink(\"/usr/somedir/symlinkfile\", buf, sizeof(buf));\n\n    // len is outside of buf size range (i may be -1 or i >= sizeof(buf))\n    buf[len] = '\\0'; \n    return;\n}"
                ]
            }
        }
    },
    {
        "master_id": 37,
        "category": "VUL",
        "language": "c,c++",
        "code": "POS34-C",
        "name": "putenv()调用的指针参数不应指向本地对象",
        "desc": "该程序调用了putenv()，它有指向本地对象的参数。",
        "msg_templ": "在${si.filename}，第${si.line}行的函数${si.func}正用变量${si.var}作为参数调用系统函数putenv()。",
        "severity": "HIGH",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序调用了putenv()，它有指向本地对象的参数。\n\n#### 解释\n系统调用putenv()会保存参数（为指向预期字符串的指针）到环境数组。当该函数返回到调用者时，可能会重写带有环境字符串的本地对象。这会造成不可预测的程序行为。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <string.h>\n\n#define BUF_SZ 1024\n\nint func(char *env_str)\n{\n    // use a static array so that call to putenv() is \n    // only necessary the first time func() is called\n    static char buf[BUF_SZ];\n    // ...\n    if (strlen(env_str) < BUF_SZ)\n    {\n        strcpy(buf, env_str);\n        return putenv(buf);\n    }\n    else\n    {\n        // handle error\n        // ...\n    }\n    return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <string.h>\n\n#define BUF_SZ 1024\n\n// TEST environment variable may take on unintended value\n\nint func(char *env_str)\n{\n    char buf[BUF_SZ];\n    // ...\n    if (strlen(env_str) < BUF_SZ)\n    {\n        strcpy(buf, env_str);\n        return putenv(buf);\n    }\n    else\n    {\n        // handle error\n        // ...\n    }\n    return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 38,
        "category": "VUL",
        "language": "c,c++",
        "code": "POS35-C",
        "name": "在检查符号链接的有效性时，可能会出现竞态条件，它可能会使经过检查的结果无效",
        "desc": "该程序调用了函数lstat()来检查命名文件是否为符号链接。之后若再此访问该文件，之前检查的结果可能无效。",
        "msg_templ": "在${si.filename}，第${si.line}行的函数${si.func}调用了函数lstat()来检查命名文件是否为符号链接。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序调用了函数lstat()来检查命名文件是否为符号链接。之后若再此访问该文件，之前检查的结果可能无效。\n\n#### 解释\n检查文件是符号链接会遇到time of call、time of use（TOCTOU）问题。换句话说，当最终打开文件访问时，为符号链接状态的该文件可能已经不再有效。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n\n#define BUF_SZ 1024\n\nstruct stat link_info;\nint val;\n\nint func(char *fname)\n{\n    FILE *fp;\n    // Race condition eliminated by using O_NOFOLLOW \n    // to cause open() to fail if passed a symbolic link\n    int fd = open(fp, \"O_RDWR\"|\"O_NOFOLLOW\");\n    if (fd == -1)\n    {\n        /* Handle error */\n        return 0;\n    }\n\n    return 1;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n\n#define BUF_SZ 1024\n\nstruct stat link_info;\nint val;\n\nint func(char *fname)\n{\n    FILE *fp;\n    if (lstat(fname, &link_info) == -1)\n    {\n        // handle error\n        // ...\n        printf(\"lstat return error\");\n        return 0;\n    }\n    else if (S_ISLNK(link_info.st_mode))\n    {\n\n        // both fopen and lstat operate on a file name\n        // the name can be manipulated asynchronously such that\n        // lstat and fopen referred to different files in reality\n        fp = fopen(fname, \"O_RDWR\"); \n        if (fp == 0)\n        {\n            // handle error\n            return 0;\n        }\n\n        size_t i = fread(&val, sizeof(int), 1, fp);\n        // ...\n    }\n    return 1;\n}"
                ]
            }
        }
    },
    {
        "master_id": 39,
        "category": "VUL",
        "language": "c,c++",
        "code": "POS37-C",
        "name": "在通过set/set uid/euid函数操控系统权限时，请确保权限已成功撤回",
        "desc": "该程序有一组get/set uid/euid函数，它对用户ID权限进行操作。调用此类函数的结果并未受到检查，这将导致该程序的权限处于意外状态。",
        "msg_templ": "在${si.filename}，第${si.line}行的函数${si.func}，尚未适当地恢复权限。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "LOW",
        "details": "#### 概要\n该程序有一组get/set uid/euid函数，它对用户id权限进行操作。调用此类函数的结果并未受到检查，这将导致该程序的权限处于意外状态。\n\n#### 解释\n权限能力是以实现为准的。要确保按预期设置及撤回权限，检查返回时的错误条件是很重要的。未能这么做可能导致用根权限运行该程序。\n",
        "examples": {
            "good": {
                "c": [
                    " // ...\n\n // the following check alone is not sufficient. need to make sure privilege can be restored\n if (setuid(getuid()) != 0) {\n // Handle error\n }\n\n // check for failure to set uid when the caller is UID 0\n // failure to do this will result in a serious security risk\n if (setuid(0) != -1) {\n // privilege can be restored. Handle error\n }"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n#include <unistd.h>\n\nvoid func()\n{\n    // Permanently drop privileges\n    if (setuid(getuid()) != 0) {\n        // Handle error\n    }\n    \n    // Check for failure of privilege relinquishmnet has to be done here\n    // Else, attacker can regain elevated privileges    \n}"
                ]
            }
        }
    },
    {
        "master_id": 40,
        "category": "VUL",
        "language": "c,c++",
        "code": "POS54-C",
        "name": "当使用POSIX库时，请确保检测并恰当地处理函数返回的错误",
        "desc": "该程序调用了某些POSIX库函数，但未能检查及处理返回错误条件。",
        "msg_templ": "在${si.filename}，第${si.line}行的函数${si.func}调用了POSIX函数，调用结果被使用前并未检查该返回值是否有效。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### 概要\n该程序调用了某些POSIX库函数，但未能检查及处理返回错误条件。\n\n#### 解释\n每一个POSIX库都有明确定义的错误返回。未能检查返回值以获得错误条件的标示并合理地处理错误将造成意外程序行为。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <sys/types.h>\n#include <sys/mman.h>\n#include <err.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main(void)\n{\n    const char str1[] = \"string 1\";\n    int fd = -1;\n    void *rwrite;\n\n    if ((fd = open(\"/usr/somefile\", O_RDWR, 0)) == -1)\n    {\n        err(1, \"open\");\n    }\n\n    rwrite = (char *)mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n\n    // checks if rwrite fails and handles error so that\n    // strcpy() works properly below\n    if (rwrite == NULL) \n    {\n        // Handle error\n    }\n\n    strcpy(rwrite, str1);\n\n    // ... continue\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <sys/types.h>\n#include <sys/mman.h>\n#include <err.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main(void)\n{\n    const char str1[] = \"string 1\";\n    int fd = -1;\n    void *rwrite;\n\n    if ((fd = open(\"/usr/somefile\", O_RDWR, 0)) == -1)\n    {\n        err(1, \"open\");\n    }\n\n    rwrite = (char *)mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n\n    // rwrite may not be valid pointer since mmap may have failed\n    strcpy(rwrite, str1);\n\n    // ... continue\n}"
                ]
            }
        }
    },
    {
        "master_id": 41,
        "category": "VUL",
        "language": "c,c++",
        "code": "SIG30-C",
        "name": "信号处理函数只能调用异步安全函数",
        "desc": "该程序的信号处理函数正在调用非异步安全函数。",
        "msg_templ": "在${si.filename}，第${si.line}行的函数${si.func}调用了signal程序。它的处理信号函数为${si.var}。此处理信号会调用非异步安全函数。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序的信号处理函数正在调用非异步安全函数。\n\n#### 解释\n异步安全函数表是可以被信号处理函数安全调用而不会产生副作用的函数。非可重入函数通常是不安全的。用户可以检查您的系统用户手册以获得一份可以使用的所有安全函数的完整列表。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nchar *messg = NULL;\n// sets flag of type volatile\nvolatile sig_atomic_t eflag = 0;\nint errflag;\n\n#define BUF_SZ 1024\n\nvoid put_messg(void)\n{\n    fputs(messg, stderr);\n}\n\nvoid handler(int signum)\n{\n    errflag = 1;\n}\n\nint main(void)\n{\n    if (signal(SIGINT, handler) == SIG_ERR)\n    {\n        // handle error\n    }\n    messg = (char *)malloc(BUF_SZ);\n    if (messg == 0)\n    {\n        // handle error\n    }\n\n    while (!errflag)\n    {\n        put_messg();\n        // ...\n    }\n\n    // put_messg() and free() are directly called from main()\n    put_messg();\n    free(messg);\n    messg = NULL;\n\n    return 0;\n}\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nchar *messg = NULL;\nint errflag;\n\n#define BUF_SZ 1024\n\nvoid put_messg(void)\n{\n    fputs(messg, stderr);\n}\n\nvoid handler(int signum)\n{\n    put_messg(); // this is not asynchronous safe\n    free(messg); // this is not asynchronous safe\n    errflag = 1;\n}\n\nint main(void)\n{\n    if (signal(SIGINT, handler) == SIG_ERR)\n    {\n        // handle error\n    }\n    messg = (char *)malloc(BUF_SZ);\n    if (messg == 0)\n    {\n        // handle error\n    }\n\n    if (!errflag)\n    {\n        put_messg();\n        // ...\n    }\n    return 0;\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 42,
        "category": "VUL",
        "language": "c,c++",
        "code": "SIG31-C",
        "name": "访问共享变量或对象的信号处理函数可能会导致竞态条件",
        "desc": "该程序正在信号处理函数里访问共享变量或对象。",
        "msg_templ": "在${si.filename}，第${si.line}行的函数${si.func}，用处理函数${si.var}对信号进行了调用。该处理函数最终会访问可共享的内存对象。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "HIGH",
        "details": "#### 概要\n该程序正在信号处理函数里访问共享变量或对象。\n\n#### 解释\n除了类型为\\\"volatile sig_atomic_t\\\"的变量外，在信号处理函数里访问任何其它类型的对象都可能导致竞态条件，从而造成未定义行为。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <signal.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n\nchar *messg = NULL;\n#define BUF_SZ 1024\nint sockfd; // as a simple example, we assume sockfd has been properly initialized and connected\n\nint errflag; // this is a shared variable\n\nssize_t put_messg(void)\n{\n    ssize_t err = send(sockfd, (const void *)messg, BUF_SZ, MSG_DONTWAIT);\n    return err;\n}\n\nvoid handler(int signum)\n{\n    errflag = 1; // access shared variable inside handler\n}\n\nint main(void)\n{\n    messg = (char *)malloc(1024);\n    if (messg == 0)\n    {\n        // handle error\n    }\n\n    if (signal(SIGINT, handler) == SIG_ERR)\n    {\n        // handle error\n    }\n\n    if (!errflag)\n    {\n        if (put_messg() >= 0)\n        {\n            // messg sent\n            // ...\n        }\n        else\n        {\n            // ...\n        }\n    }\n    return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <signal.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n\nchar *messg = NULL;\n#define BUF_SZ 1024\nint sockfd; // as a simple example, we assume sockfd has been properly initialized and connected\n\nvolatile sig_atomic_t errflag = 0;\n\nssize_t put_messg(void)\n{\n    ssize_t err = send(sockfd, (const void *)messg, BUF_SZ, MSG_DONTWAIT);\n    return err;\n}\n\nvoid handler(int signum)\n{\n    errflag = 1; // access shared variable inside handler\n}\n\nint main(void)\n{\n    messg = (char *)malloc(1024);\n    if (messg == 0)\n    {\n        // handle error\n    }\n\n    if (signal(SIGINT, handler) == SIG_ERR)\n    {\n        // handle error\n    }\n\n    if (!errflag)\n    {\n        if (put_messg() >= 0)\n        {\n            // messg sent\n            // ...\n        }\n        else\n        {\n            // ...\n        }\n    }\n    return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 43,
        "category": "VUL",
        "language": "c,c++",
        "code": "STR02-C",
        "name": "传递给外部包或子系统的数据应该先安全化清理",
        "desc": "该程序正传递字符串数据给外部包或子系统，这些作为字符串的数据需进行安全清理",
        "msg_templ": "在${si.filename}，第${si.line)行的函数${si.func}，传递了${si.var}给系统调用。该变量已被声明，在程序流里被认为没有经过清理。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序正传递字符串数据给外部包或子系统，这些作为字符串的数据需进行安全清理。\n\n#### 解释\n当传递包含敏感数据的数据给系统调用、数据库或其它外部第三方组件时，确保只传递产生者和使用者双方都认可的数据是很重要的。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdlib.h>\n#include <stdio.h>\n\nchar *messg = NULL;\n#define BUF_SZ 1024\n\nvoid foo(char *argv)\n{\n    int len;\n    char buf[BUF_SZ];\n\n\n    // filter out invalid data and characters\n    static char approved[] = \"abcdefghijklmnopqrstuvwxyz\"\n                             \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                             \"1234567890_-.@\";\n    const char *end = *argv + strlen(*argv);\n    for (argv += strspn(argv, approved); argv != end; argv += strspn(argv, approved))\n    {\n        *argv = '_';\n    }\n\n    if (*argv != 0)\n        len = snprintf(buf, BUF_SZ, \"%s\", *argv); \n    if (len < 0)\n    {\n        // report error\n        return;\n    }\n    else\n    {\n        if (system(buf) == -1)\n        {\n            // report error\n            return;\n        }\n    }\n}\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdlib.h>\n#include <stdio.h>\n\nchar *messg = NULL;\n#define BUF_SZ 1024\n\nvoid foo(char *argv)\n{\n    int len;\n    char buf[BUF_SZ];\n\n    if (*argv != 0)\n        len = snprintf(buf, BUF_SZ, \"%s\", *argv); // buf will be fed into system call later. \\\"argv\\\" needs to be sanitized\n    if (len < 0)\n    {\n        // report error\n        return;\n    }\n    else\n    {\n        if (system(buf) == -1)\n        {\n            // report error\n            return;\n        }\n    }\n}"
                ]
            }
        }
    },
    {
        "master_id": 44,
        "category": "VUL",
        "language": "c,c++",
        "code": "STR31-C",
        "name": "字符串应有足够的存储空间以便能放下包括空终止符在内的所有字符",
        "desc": "请确保字符串的目的地存储空间足够大，能包括空终止。",
        "msg_templ": "在${si.filename}，第${si.line}行的函数${si.func}，指向字符的指针${si.var}用来填充另一个字符数组/指针。指针${si.var} 的大小不足以存储包含空终止在内的所有数据，可能会导致内存访问错误",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n请确保字符串的目的地存储空间足够大，能包括空终止。\n\n#### 解释\n字符串由空字符终止，它应该是字符串大小/长度的一部分。如果字符串的存储空间不够大，这将造成缓存溢出或其它伪错误。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nvoid get_passwd(void)\n{\n    // length is not fixed, so no buffer overflow\n    \n    char *buf;\n    char *passwd = getenv(\"PASSWORD\");\n    if (passwd == NULL)\n    {\n        printf(\"Error getting password\");\n        exit(1);\n    }\n\n    size_t length = strlen(passwd) + 1;\n    buf = (char *)malloc(length);\n    if (buf == NULL)\n    {\n        // handle error\n    }\n\n    memcpy(buf, passwd, length);\n    free(buf);\n}\n\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nvoid get_passwd(void)\n{\n    char buf[256];\n    char *passwd = getenv(\"PASSWORD\");\n    if (passwd == NULL)\n    {\n        printf(\"Error getting password\");\n        exit(1);\n    }\n    //\n    // copy environmental string to a fixed-length can cause buffer overflow\n    //\n    strcpy(buf, passwd);\n}"
                ]
            }
        }
    },
    {
        "master_id": 45,
        "category": "VUL",
        "language": "c,c++",
        "code": "STR32-C",
        "name": "应合理终止库函数的字符串参数",
        "desc": "该程序正调用有字符串参数的库函数。该字符串可能没有被适当地终止。",
        "msg_templ": "在${si.filename}，第${si.line}行的函数${si.func}，传递了变量${si.var}给库函数。该变量不是空终止。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序正调用有字符串参数的库函数。该字符串可能没有被适当地终止。\n\n#### 解释\n在非空终止的字符串上操作的库函数会造成访问在字符串对象界限之外的内存。这进而会造成意外程序行为。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdlib.h>\n#include <stdio.h>\n\nchar *messg = NULL;\n#define BUF_SZ 3\n\nvoid foo(void)\n{\n    char buf[] = \"123\";\n\n    printf(\"string is %s\", buf); \n\n    // ...\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdlib.h>\n#include <stdio.h>\n\nchar *messg = NULL;\n#define BUF_SZ 3\n\nvoid foo(void)\n{\n    char buf[BUF_SZ] = \"123\";\n\n    printf(\"string is %s\", buf); // buf may not be null terminated since the array is a local array\n\n    // ...\n}"
                ]
            }
        }
    },
    {
        "master_id": 46,
        "category": "VUL",
        "language": "c,c++",
        "code": "STR38-C",
        "name": "窄和宽字符串以及函数应有合适的空终止符和长度的类型",
        "desc": "该程序正在使用函数，并在使用字符大小或类型不匹配的参数来表示字符串的字符大小。",
        "msg_templ": "在${si.filename}的第${si.line}行，变量${si.var}错误地被函数${si.func}使用。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### 概要\n该程序正在使用函数，并在使用字符大小或类型不匹配的参数来表示字符串的字符大小。\n\n#### 解释\n该程序正传递指向对象的指针和大小参数给库函数。当这两个参数组合在一起时，会造成库函数在该对象的有效范围之外访问它，从而导致未定义行为。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stddef.h>\n#include <stdlib.h>\n#include <wchar.h>\n\n#define ARRAY_SZ 2\nint mismatch_char_type()\n{\n    char char_array[] = \"0123456789\";\n    char char_array_2[] = \"0123456789\";\n\n    // char type is the same, so comparing is acceptable\n    strncpy(&char_array[0], &char_array[2], sizeof(char_array));\n    return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stddef.h>\n#include <stdlib.h>\n#include <wchar.h>\n\n#define ARRAY_SZ 2\nint mismatch_char_type()\n{\n    char char_array[] = \"0123456789\";\n    wchar_t wchar_array[] = \"0123456789\";\n\n    // size of char_array is smaller than wchar_array due to different char type\n    memcpy(&char_array[0], &wchar_array[0], sizeof(wchar_array));\n    return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 47,
        "category": "VUL",
        "language": "c++",
        "code": "STR50-CPP",
        "name": "确保字符串存储足以储存内容",
        "desc": "程序使用了不适当的字符串方法来处理字符，这可能导致绕过验证检查或内存泄漏。",
        "msg_templ": "在${si.filename}的第${si.line}行，直接将数据复制到内存可能会引发缓冲区溢出。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序正在使用不正确的字符串方法来处理字符，这有可能会导致绕过验证或者内存泄漏。\n\n#### 解释\n在C或者C++中创建字符串时，必须定义字符串的最大长度。在进行变量输入时（例如通过控制台输入），如果输入的字符长度超过了变量允许的范围，这会引发缓冲区溢出，导致程式受到攻击的风险。\n",
        "examples": {
            "good": {
                "cpp": [
                    "void f(){\nstd:;string x;\nstd::cin >> x;\n}"
                ]
            },
            "bad": {
                "cpp": [
                    "#include <string>\n#include <iostream>\nvoid f(){\nchar x[5];\nstd::cin>>x;\n}"
                ]
            }
        }
    },
    {
        "master_id": 48,
        "category": "VUL",
        "language": "c++",
        "code": "ERR54-CPP",
        "name": "catch处理程序的顺序应为从最具体到最不具体",
        "desc": "在try语句之后，程序无法按正确的顺序处理异常捕获处理程序。当前顺序是从最小派生（更一般）到最大派生（更具体），因此最大派生的捕获处理程序将不会被执行。",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func} 里，异常捕获程序的顺序不正确。",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### 概要\n在try语句之后，程序无法按正确的顺序管理异常捕获处理程序。 当前顺序是从最小派生（更一般）到最大派生（更具体）。\n \n#### 解释\n捕获处理程序按照try语句后的声明顺序进行。正确的顺序应该是从最大派生到最小派生，从最具体到不具体。\n如果捕获是从最小派生开始，而它可能从最大派生处中捕获到的问题。这样，最大派生的捕获处理程序将不会被执行，这种行为是不可取的。\n",
        "examples": {
            "good": {
                "cpp": [
                    "// Classes used for exception handling\n#include <iostream>\n \nclass Base {};\n \nclass Derived1 : public Base {};\nclass Derived2 : public Derived1 {};\n \nvoid foo();\nvoid bar();\n \nvoid foo()\n{\n std::cout << \"foo\" << std::endl;\n}\nvoid bar() {\n std::cout << \"bar\" << std::endl;\n}\n \nvoid f()\n{\n try {\n foo();\n bar();\n // ...\n }\n catch (Derived1 &) {\n // ...\n }\n catch (Base &)\n {\n // ...\n }\n try {\n foo();\n bar();\n // ...\n }\n catch (Derived2 &) {\n // ...\n }\n catch (Base &) //\n {\n // ...\n }\n \n try {\n foo();\n bar();\n // ...\n }\n catch (Derived1 *) {\n // ...\n }\n catch (Base *) { //\n // ...\n }\n}\n \nint main() {\n f();\n}"
                ]
            },
            "bad": {
                "cpp": [
                    "// Classes used for exception handling\n#include <iostream>\n \nclass Base {};\n \nclass Derived1 : public Base {};\nclass Derived2 : public Derived1 {};\n \nvoid foo();\nvoid bar();\n \nvoid foo()\n{\n std::cout << \"foo\" << std::endl;\n}\nvoid bar()\n{\n std::cout << \"bar\" << std::endl;\n}\n \nvoid f()\n{\n try {\n foo();\n bar();\n // ...\n }\n catch (Base &) {\n // ...\n }\n catch (Derived1 &) { // violation here in Line 19\n // ...\n }\n try {\n foo();\n bar();\n // ...\n }\n catch (Base &) {\n // ...\n }\n catch (Derived2 &) // violation here in Line 31\n {\n // ...\n }\n \n try {\n foo();\n bar();\n // ...\n }\n catch (Base *) {\n // ...\n }\n catch (Derived1 *) { // violation here in Line 44\n // ...\n }\n}\n \nint main() {\n f();\n}"
                ]
            }
        }
    },
    {
        "master_id": 49,
        "category": "VUL",
        "language": "c++",
        "code": "MEM55-CPP",
        "name": "用户定义的动态存储管理应遵循语言要求",
        "desc": "该程序替换使用了不符合C++标准语义规范的动态内存分配或释放函数。",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func} 里，动态内存分配/释放的替代函数违反了C++标准的语义规范。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序替换使用了不符合C++标准语义规范的动态内存分配或释放函数。\n\n#### 解释\n内存分配的替换函数包含一个外部声明，该声明可能返回nullptr。 函数 \\\"new \\\" 将返回nullptr，而不是本该返回的 \\\"std :: bad_alloc \\\"。\n",
        "examples": {
            "good": {
                "cpp": [
                    "#include <cstdio>\n#include <cstdlib>\n#include <new>\n#include <iostream>\n\nextern void* cust_allocator(std::size_t);\n\nclass Person {\n int age; \n std::string name;\n \npublic:\n Person(){}\n void* operator new(size_t s)\n {\n if (((void*) ret = cust_allocator) == 0)\n return ret;\n return cust_allocator(s);\n }\n};"
                ]
            },
            "bad": {
                "cpp": [
                    "#include <cstdio>\n#include <cstdlib>\n#include <new>\n#include <iostream>\n\nextern void* cust_allocator(std::size_t);\n\nclass Person {\n int age; \n std::string name;\n \npublic:\n Person(){}\n void* operator new(size_t s)\n {\n return cust_allocator(s);\n }\n};"
                ]
            }
        }
    },
    {
        "master_id": 50,
        "category": "VUL",
        "language": "c++",
        "code": "MSC51-CPP",
        "name": "应正确设置随机数生成器的种子",
        "desc": "程序没有正确地为伪随机数生成器设定种子。它使用了一个常量种子，或可预测的非常量种子（如时间）。",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func} 里，使用了未正确设定种子的伪随机数发生器，该种子是常量或者可预测的非常量。",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### 概要\n程序没有正确地为伪随机数生成器设定种子。它使用了一个常量种子，或可预测的种子, 使用后会反复产生相同的数字序列。\n\n#### 解释\n当调用具有相同初始状态的伪随机数生成器（PRNG）时，例如使用相同的种子，它将生成完全相同的数字序列。攻击者可以很容易地预测数字序列并引发安全问题。\n\n\n",
        "examples": {
            "good": {
                "cpp": [
                    "#include <stdlib.h>\n#include <iostream>\n#include <vector>\n\n#define MAX_VALUE 100\n#define VECTOR_SIZE 10\n\nint main() \n{\n std::vector<int> vec;\n std::random_device rd;\n\n srand(rd()); // seed is randomized again for every execution\n for(int i = 0 ; i < VECTOR_SIZE; ++i) {\n vec.push_back(rand()%MAX_VALUE); // no repeated sequence \n }\n\n for(int j=0 ; j < vec.size() ; ++j ) {\n std::cout << vec[j] << \\\" \\\";\n }\n std::cout << '\\\n';\n}"
                ]
            },
            "bad": {
                "cpp": [
                    "#include <stdlib.h>\n#include <iostream>\n#include <vector>\n\n#define MAX_VALUE 100\n#define VECTOR_SIZE 10\nint main()\n{ \n std::vector<int> vec;\n \n for(int i = 0 ; i < VECTOR_SIZE; ++i) {\n vec.push_back(rand()%MAX_VALUE); // using the same initial seed \n }\n\n // printing\n for(int j=0 ; j < vec.size() ; ++j ) {\n std::cout << vec[j] << \\\" \\\";\n }\n std::cout << '\\\n';\n}"
                ]
            }
        }
    },
    {
        "master_id": 51,
        "category": "VUL",
        "language": "c++",
        "code": "MSC54-CPP",
        "name": "确保信号处理程序是普通的传统函数",
        "desc": "程序中的信号处理函数不是一个普通的传统函数(POF)。这个特定的信号处理函数使用无C链接的纯C++链接。",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func}，它不是一个POF（普通的传统函数），尽管它展现出信号处理的行为。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "#### 概要\n程序中的信号处理程序函数不是普通的传统函数。 特定的信号处理函数使用纯C++ 链接，而没有与C的链接。\n\n#### 解释\nPOF或“普通的传统函数”是在C和C ++语言公共子集上使用功能的函数。在C++源代码中声明的所有信号处理程序都必须具有C链接，否则可能导致未定义的行为。\n\n",
        "examples": {
            "good": {
                "cpp": [
                    "#include <iostream>\n#include <csignal>\nusing namespace std;\n\n// use C signature\nextern \\\"C\\\" void handle_signal(int signum)\n{\n cout << \\\"Signal to interrupt \\\" << signum << endl;\n exit(signum);\n}\n\nint main() \n{\n signal(SIGINT, handle_signal);\n // ....\n\n}"
                ]
            },
            "bad": {
                "cpp": [
                    "#include <iostream>\n#include <csignal>\nusing namespace std;\n\n\n\nvoid handle_signal(int signum) \n{\n cout << \\\"Signal to interrupt \\\" << signum << endl;\n exit(signum);\n}\n\nint main() \n{\n signal(SIGINT, handle_signal);\n // ....\n\n}"
                ]
            }
        }
    },
    {
        "master_id": 52,
        "category": "VUL",
        "language": "Java",
        "code": "IDS16-J",
        "name": "用于XML处理的XMLStrings必须在处理之前通过验证",
        "desc": "该程序正在没有验证字符串的情况下操作用于XML处理的XMLStrings。",
        "msg_templ": "在${si.filename}，第${si.line}行，函数${si.func}的字符串${si.var}未被清理就被传递到XML查询。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序正在没有验证字符串的情况下操作用于XML处理的XMLString对象。\n\n#### 解释\n当XMLString对象没有经过清理时，可能会恶意注入XML字符串并将其错认为有效的XML，从而导致XML注入攻击。\n",
        "examples": {
            "good": {
                "java": [
                    "import java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\n \npublic class j_ids16_1 {\n public static void createXMLStreamBad(final BufferedOutputStream outStream,\n final String number) throws IOException {\n String xmlString = \\\"<item>\\\n<description>Widget</description>\\\n\\\"\n + \\\"<level>500</>\\\n\\\";\n\n if (number != null) {\n int sanitizedNumber = Integer.parseUnsignedInt(number);\n // the string xmlString should be validated\n // to prevent XML injection\n\\t xmlString = xmlString + \\\"<number>\\\" + sanitizedNumber\n + \\\"</number></item>\\\";\n }\n outStream.write(xmlString.getBytes());\n outStream.flush();\n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "import java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\n \npublic class j_ids16_1 {\n public static void createXMLStreamBad(final BufferedOutputStream outStream,\n final String number) throws IOException {\n String xmlString = \\\"<item>\\\n<description>Widget</description>\\\n\\\"\n + \\\"<level>500</>\\\n\\\";\n\n if (number != null) {\n // the string xmlString should be validated\n // to prevent XML injection\n\\t xmlString = xmlString + \\\"<number>\\\" + number\n + \\\"</number></item>\\\";\n }\n outStream.write(xmlString.getBytes());\n outStream.flush();\n }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 53,
        "category": "VUL",
        "language": "Java",
        "code": "MSC02-J",
        "name": "使用安全性强的随机数生成器",
        "desc": "该程序使用了安全性不强的随机数生成器（PRNG）。",
        "msg_templ": "在${si.filename}，第${si.line}行，函数${si.func}中的${si.var}不会产生强随机数。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序使用了安全性不强的随机数生成器（PRNG）。\n\n#### 解释\nJava API在java.util.Random类里提供PRNG，当使用了相同种子时它会生成相同的序列。对于安全敏感型程序，应该使用像java.security.SecureRandom类这样的更安全的PRNG。\n",
        "examples": {
            "good": {
                "java": [
                    "// The Random() generates identical sequences in the following cases\nimport java.util.Random;\nimport java.lang.Math;\n\npublic class msc02_0 {\n\n public void foo0() {\n Random number = new SecureRandom(); // use SecureRandom class \n for (int i = 0; i < 20; i++) {\n int n = number.nextInt();\n System.out.println(n);\n }\n }\n\n public void foo1() {\n Random number = new SecureRandom.getInstanceStrong(); // use strong algorithm \n System.out.println(number.nextLong());\n }\n\n}"
                ]
            },
            "bad": {
                "java": [
                    "// The Random() generates identical sequences in all three cases\nimport java.util.Random;\nimport java.lang.Math;\n\npublic class msc02_0 {\n\n public void foo0() {\n Random number = new Random(123L);\n for (int i = 0; i < 20; i++) {\n int n = number.nextInt();\n System.out.println(n);\n }\n }\n\n public void foo1() {\n Random number = new Random();\n System.out.println(number.nextLong());\n }\n\n}"
                ]
            }
        }
    },
    {
        "master_id": 54,
        "category": "VUL",
        "language": "Java",
        "code": "SEC07-J",
        "name": "请调用超类别的getPermissions()方法实现自定义类加载器",
        "desc": "该程序有自定义类加载器，并未能调用super.getPermission()方法。",
        "msg_templ": "在${si.filename}，第${si.line}行，在函数${si.func}里，${si.var}自定义加载器覆盖getPermission()，而未调用超类别的权限。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "LOW",
        "details": "#### 概要\n该程序有自定义类加载器，并未能调用super.getPermission()方法。\n\n#### 解释\n该程序有自定义加载器来重写getPermission()方法。该实现应调用超类别的getPermission()以获得默认系统方案，然后再赋予程序自定义权限。这样一来，系统全局的安全方案也能得到应用。\n",
        "examples": {
            "good": {
                "java": [
                    "import java.net.URL;\nimport java.net.URLClassLoader;\nimport java.security.CodeSource;\nimport java.security.PermissionCollection;\nimport java.security.Permissions;\n\npublic class j_sec07_0 extends URLClassLoader { \n\n public j_sec07_0(URL[] urls) {\n super(urls);\n }\n\n protected PermissionCollection getPermissions(CodeSource cs) {\n // apply default system wide security policy\n PermissionCollection pc = superPermissions(cs);\n // Allow exit from the VM anytime\n pc.add(new RuntimePermission(\\\"exitVM\\\"));\n return pc;\n }\n\n public static boolean checkRtPermission(URL[] urls, String tag) {\n j_sec07_0 loader = new j_sec07_0(urls);\n PermissionCollection pc = loader.getPermissions(null);\n RuntimePermission rp = new RuntimePermission(tag);\n if(pc.implies(rp)) {\n System.out.println(\\\"Able to exit vm\\\");\n return true;\n } else {\n System.out.println(\\\"Not Able to exit VM\\\");\n return false;\n }\n }\n\n public static void main(String[] args) {\n URL[] urls = new URL[0];\n checkRtPermission(urls, \\\"exitVM\\\");\n checkRtPermission(urls, \\\"stopVM\\\");\n }\n\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "import java.net.URL;\nimport java.net.URLClassLoader;\nimport java.security.CodeSource;\nimport java.security.PermissionCollection;\nimport java.security.Permissions;\n\npublic class j_sec07_0 extends URLClassLoader { \n\n public j_sec07_0(URL[] urls) {\n super(urls);\n }\n\n protected PermissionCollection getPermissions(CodeSource cs) {\n PermissionCollection pc = new Permissions();\n // Allow exit from the VM anytime\n pc.add(new RuntimePermission(\\\"exitVM\\\"));\n return pc;\n }\n\n public static boolean checkRtPermission(URL[] urls, String tag) {\n j_sec07_0 loader = new j_sec07_0(urls);\n PermissionCollection pc = loader.getPermissions(null);\n RuntimePermission rp = new RuntimePermission(tag);\n if(pc.implies(rp)) {\n System.out.println(\\\"Able to exit vm\\\");\n return true;\n } else {\n System.out.println(\\\"Not Able to exit VM\\\");\n return false;\n }\n }\n\n public static void main(String[] args) {\n URL[] urls = new URL[0];\n checkRtPermission(urls, \\\"exitVM\\\");\n checkRtPermission(urls, \\\"stopVM\\\");\n }\n\n}"
                ]
            }
        }
    },
    {
        "master_id": 55,
        "category": "VUL",
        "language": "Java",
        "code": "DCL00-J",
        "name": "程序不应具有类初始化循环",
        "desc": "程序具有类的初始化会构成循环。",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func}中的${si.var}类会构成初始化循环。",
        "severity": "LOW",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n程序具有类的初始化会构成循环。\n\n#### 解释\n静态字段会触发类的初始化。当静态字段依赖于另一个类的初始化时，将构成一个循环。\n",
        "examples": {
            "good": {
                "java": [
                    "import java.util.Calendar;\npublic class j_dcl00_0 {\n private int elapse;\n private static final int curr_year = Calendar.getInstance().get(Calendar.YEAR);\n private static final j_dcl00_0 obj = new j_dcl00_0(); // curr_year is initialized before used in constructor\n \n public j_dcl00_0() {\n if(200 > Calendar.getInstance().get(Calendar.YEAR))\n elapse = curr_year - 2000; \n }\n\n public static void main(String[] args) {\n System.out.println(\\\"It was \\\" + obj.elapse + \\\" years since 2000\\\");\n }\n \n}"
                ]
            },
            "bad": {
                "java": [
                    "import java.util.Calendar;\npublic class j_dcl00_0 {\n private int elapse;\n private static final j_dcl00_0 obj = new j_dcl00_0(); // self cycle (call constructor)\n private static final int curr_year = Calendar.getInstance().get(Calendar.YEAR);\n \n public j_dcl00_0() {\n if(200 > Calendar.getInstance().get(Calendar.YEAR))\n elapse = curr_year - 2000; // curr_year not initialized yet, due to constructor is called before curr_year assignment in line 73. \n // ( Remediate suggestion: swap lines 72 and line 73 will ensure initialized)\n }\n\n public static void main(String[] args) {\n System.out.println(\\\"It was \\\" + obj.elapse + \\\" years since 2000\\\");\n }\n \n}"
                ]
            }
        }
    },
    {
        "master_id": 56,
        "category": "VUL",
        "language": "Java",
        "code": "ENV03-J",
        "name": "应明确并审慎地授予权限",
        "desc": "程序用授予权限或者权限组合给代码。",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func}里的方法${si.var}有危险的权限组合，可以导致越权操作。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### 概要\n程序授予权限或者权限组合给代码，而这类操作可能存在风险。\n\n#### 解释\n权限组合授予代码可能是危险的。例如，当应用RunitimePermission到createClassLoader时，它会创建自定义类加载器并分配任意权限。ReflextPermission和suppressAccessChecks一起将阻止所有标准检查。\n",
        "examples": {
            "good": {
                "java": [
                    "import java.net.URL;\nimport java.net.URLClassLoader;\nimport java.net.MalformedURLException;\nimport java.security.cert.Certificate;\nimport java.security.CodeSource;\nimport java.security.PermissionCollection;\nimport java.security.Permissions;\nimport java.lang.reflect.*;\n\npublic class env03_0 extends URLClassLoader {\n\n public env03_0(URL[] urls) {\n super(urls);\n }\n\n protected PermissionCollection getPermissions(CodeSource cs) {\n PermissionCollection pc = super.getPermissions(cs);\n // ...\n // other permissions\n return pc;\n }\n\n public static boolean checkRtPermission(URL[] urls, String tag) throws MalformedURLException{\n env03_0 loader = new env03_0(urls);\n Certificate[] cert = null;\n CodeSource cs = new CodeSource(new URL(\"http://abc\"), cert);\n PermissionCollection pc = loader.getPermissions(cs);\n ReflectPermission rp = new ReflectPermission(tag);\n if(pc.implies(rp)) {\n System.out.println(\"Able to get suppressAccessChecks\");\n return true;\n } else {\n System.out.println(\"Not Able to get suppressAccessChecks\");\n return false;\n }\n }\n\n public static void main(String[] args) throws MalformedURLException{\n URL[] urls = new URL[0];\n checkRtPermission(urls, \"suppressAccessChecks\");\n }\n\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "import java.net.URL;\nimport java.net.URLClassLoader;\nimport java.net.MalformedURLException;\nimport java.security.cert.Certificate;\nimport java.security.CodeSource;\nimport java.security.PermissionCollection;\nimport java.security.Permissions;\nimport java.lang.reflect.*;\n\npublic class env03_0 extends URLClassLoader {\n\n public env03_0(URL[] urls) {\n super(urls);\n }\n\n protected PermissionCollection getPermissions(CodeSource cs) {\n PermissionCollection pc = super.getPermissions(cs); \n pc.add(new ReflectPermission(\"suppressAccessChecks\")); // add permission to create a class loader\n // includes granting \"suppressAccessChecks\"\n // ...\n // other permissions\n return pc;\n }\n\n public static boolean checkRtPermission(URL[] urls, String tag) throws MalformedURLException{\n env03_0 loader = new env03_0(urls);\n Certificate[] cert = null;\n CodeSource cs = new CodeSource(new URL(\"http://abc\"), cert);\n PermissionCollection pc = loader.getPermissions(cs);\n ReflectPermission rp = new ReflectPermission(tag);\n if(pc.implies(rp)) {\n System.out.println(\"Able to get suppressAccessChecks\");\n return true;\n } else {\n System.out.println(\"Not Able to get suppressAccessChecks\");\n return false;\n }\n }\n\n public static void main(String[] args) throws MalformedURLException{\n URL[] urls = new URL[0];\n checkRtPermission(urls, \"suppressAccessChecks\");\n }\n\n}"
                ]
            }
        }
    },
    {
        "master_id": 57,
        "category": "VUL",
        "language": "Java",
        "code": "ENV06-J",
        "name": "调试入口点不应保留在产品代码中",
        "desc": "该程序应删除所有用于调试的且不计划随应用程序一起提供或部署的代码。",
        "msg_templ": "在${si.filename}，${si.func} 里第${si.line}行，有疑似调试入口\\\"main\\\"。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "LOW",
        "details": "#### 概要\n该程序应删除所有用于调试的且不计划随应用程序一起提供或部署的代码。\n\n#### 解释\n包含“main”开发虽然是一个认可的做法，但将它遗留在上线代码里会给攻击者留下后门入口点。应从上线应用程序里删除包含“main”的方法。\n",
        "examples": {
            "good": {
                "java": [
                    "public class my_code {\n // DEBUG is set to false, but \\\"main\\\" is left behind\n private static final boolean DEBUG = false;\n // remove the following statement if DEBUG is set to FALSE\n // public static void main(String[] args) {\n // my_code f = new my_code();\n // }\n}"
                ]
            },
            "bad": {
                "java": [
                    "public class my_code {\n // DEBUG is set to false, but \\\"main\\\" is left behind\n private static final boolean DEBUG = false;\n public static void main(String[] args) {\n my_code f = new my_code();\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 58,
        "category": "VUL",
        "language": "Java",
        "code": "ERR08-J",
        "name": "不应捕捉NullPointerException或其父类",
        "desc": "该程序正捕捉NullPointerException。",
        "msg_templ": "在${si.filename}，第${si.line}行，有NullPointerException的异常在${si.func}函数的try块捕获到。",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序正捕捉NullPointerException。\n\n#### 解释\n运行时抛出的NullPointerException表明有底层缺陷，必须在应用程序代码里修复它。捕捉此异常（或者其它像RuntimeException、Exception或Throwable这样的异常）会增加运行时的性能消耗。此外，当发生这种情况时，程序很可能处于未知状态，而继续执行可能导致意外结果。\n",
        "examples": {
            "good": {
                "java": [
                    "public class err08_0 {\n boolean isName(String s) {\n try {\n String names = s.concat(\"abc\");\n if (names.length() != 5) {\n return false;\n }\n return true;\n } \n }\n\n boolean foo1() {\n try {\n throw new RuntimeException(\"xyz\");\n } catch (RuntimeException e) {\n // this catch RuntimeException is ancestor of the NullPointerException\n return false;\n }\n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "public class err08_0 {\n boolean isName(String s) {\n try {\n String names = s.concat(\"abc\");\n if (names.length() != 5) {\n return false;\n }\n return true;\n } catch (NullPointerException e) {\n // catch Null pointer exception \n return false;\n }\n \n }\n\n boolean foo1() {\n try {\n throw new RuntimeException(\"xyz\");\n } catch (RuntimeException e) {\n // this catch RuntimeException is ancestor of the NullPointerException\n return false;\n }\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 59,
        "category": "VUL",
        "language": "Java",
        "code": "EXP02-J",
        "name": "Object.equal() 不应用于比较两个数组",
        "desc": "该程序正使用Object.equals()方法比较两个数组。",
        "msg_templ": "在${si.filename}，${si.func} 里第${si.line}行，Object.equals() 被用来比较${si.var}。",
        "severity": "LOW",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### 概要\n该程序正使用Object.equals()方法比较两个数组。\n\n#### 解释\n如果两个数组包含相同的元素并且它们有相同的顺序，则这两个数组是等同的。在数组上使用Object.equals()只比较数组引用，而不是其内容。\n",
        "examples": {
            "good": {
                "java": [
                    "// this example is modified from CERT-J site\nimport java.util.Arrays;\n\npublic class exp02_example {\n\n public static void println(int[] ar1, int[] ar2) {\n System.out.println(Arrays.equals(arr1, arr2)); // prints true\n }\n \n public static void main(String[] args) {\n int[] arr1 = new int[20]; // Initialized to 0\n int[] arr2 = new int[20]; // Initialized to 0\n println(arr1, arr2); \n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "// this example is modified from CERT-J site\nimport java.util.Arrays;\n\npublic class exp02_example {\n\n public static void println(int[] ar1, int[] ar2) {\n System.out.println(ar1.equals(ar2)); // prints false\n }\n \n public static void main(String[] args) {\n int[] arr1 = new int[20]; // Initialized to 0\n int[] arr2 = new int[20]; // Initialized to 0\n println(arr1, arr2); \n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 60,
        "category": "VUL",
        "language": "Java",
        "code": "FIO02-J",
        "name": "应该检查并处理和文件有关的错误",
        "desc": "该程序正试图操控一个文件，但未能检查该方法返回值的有效性。",
        "msg_templ": "在${si.filename}，${si.func}里第${si.line}行，请求打开新文件对象${si.var}。其后在第${si.line}对此对象进行调用时，未能检查文件操作是否成功。",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序正试图操控一个文件，但未能检查该方法返回值的有效性。\n\n#### 解释\nJava里的文件I/O操作必须检查执行文件I/O方法的返回值。例如，如果不经过检查，File.delete()会悄无声息地失败。\n",
        "examples": {
            "good": {
                "java": [
                    "import java.io.File;\nimport java.io.IOException;\n\npublic class j_fio02_0 {\n void foo(boolean b) {\n try {\n File f = new File(\"file\");\n if (b) {\n if (f.delete()) {\n System.out.println(\"Deletion error\");\n }\n }\n else {\n if (f.delete()) {\n System.out.println(\"Deletion error\");\n }\n \n }\n }\n catch(Exception e) {\n System.out.println(\"Exception\");\n }\n }\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "import java.io.File;\nimport java.io.IOException;\n\npublic class j_fio02_0 {\n void foo(boolean b) {\n try {\n File f = new File(\"file\");\n if (b) {\n if (f.delete()) {\n System.out.println(\"Deletion error\");\n }\n }\n else {\n f.delete(); // failed to check return value of delete()\n }\n }\n catch(Exception e) {\n System.out.println(\"Exception\");\n }\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 61,
        "category": "VUL",
        "language": "Java",
        "code": "FIO05-J",
        "name": "不应把用wrap()或duplicate()创建的缓存暴露给不受信任的代码",
        "desc": "该程序正使用java.nio包里的buffer类的wrap()或duplicate()方法。这些缓存暴露给了程序里不受信任的代码。",
        "msg_templ": "在${si.filename}里第${si.line}行，buffer类中的${si.var}后备数组有可能通过函数${si.func}暴露给不可信任的代码。",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### 概要\n该程序正使用java.nio包里的buffer类里的wrap()或duplicate()方法。这些缓存暴露给了程序里不受信任的代码。\n\n#### 解释\n此方法会创建从给定输入数组生成的新Buffer对象。而新的Buffer对象可能被恶意修改。使用只读Buffer或确保原本的buffer不被修改是很重要的。\n",
        "examples": {
            "good": {
                "java": [
                    "// this example is modified from CERT-J example\nimport java.nio.CharBuffer;\n\npublic class j_fio05_0 {\n private char[] dataArray;\n private CharBuffer cb;\n\n public j_fio05_0() {\n dataArray = new char[10];\n }\n\n public CharBuffer getBufferCopy() {\n return CharBuffer.wrap(dataArray).asReadOnlyBuffer(); // attemp to modify will result in exception\n }\n}",
                    "import java.nio.CharBuffer;\n\npublic class j_fio05_0 {\n private char[] dataArray;\n private CharBuffer cb;\n\n public j_fio05_0() {\n dataArray = new char[10];\n }\n\n public CharBuffer getBufferCopy() {\n return CharBuffer.wrap(dataArray).asReadOnlyBuffer();; // attempt to modify will result in exception\n }\n\n private void storeBuffer() {\n cb = CharBuffer.wrap(dataArray).asReadOnlyBuffer();; // attempt to modify will result in exception\n }\n\n public CharBuffer getBufferCopy2() {\n storeBuffer();\n return cb; \n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "// this example is modified from CERT-J example\nimport java.nio.CharBuffer;\n\npublic class j_fio05_0 {\n private char[] dataArray;\n private CharBuffer cb;\n\n public j_fio05_0() {\n dataArray = new char[10];\n }\n\n public CharBuffer getBufferCopy() {\n return CharBuffer.wrap(dataArray); // dataArray (private) is exposed through this wrap\n }\n}",
                    "import java.nio.CharBuffer;\n\npublic class j_fio05_0 {\n private char[] dataArray;\n private CharBuffer cb;\n\n public j_fio05_0() {\n dataArray = new char[10];\n }\n\n public CharBuffer getBufferCopy() {\n return CharBuffer.wrap(dataArray); // dataArray (private) is exposed through this wrap\n }\n\n private void storeBuffer() {\n cb = CharBuffer.wrap(dataArray); // dataArray (private) is exposed, see comment in return statement below\n }\n\n public CharBuffer getBufferCopy2() {\n storeBuffer();\n return cb; // dataArray is exposed through cb which is assigned in storeBuffer()\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 62,
        "category": "VUL",
        "language": "Java",
        "code": "FIO14-J",
        "name": "在程序终止时，应通过Runtime.exit()执行适当的清理",
        "desc": "在程序终止时，未有进行适当的清理。",
        "msg_templ": "在${si.filename}，第${si.line}行，程序已经终止，但是与${si.var}关联的资源将无法被正确清理。",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n在程序终止时，未有进行适当的清理。\n\n#### 解释\n当检测到不可恢复的错误时，通常会快速关闭系统并允许操作员在确定的状态下重新启动。这应该包括涉及外部资源的清理。否则，可能会在系统中留下重要或敏感数据。\n",
        "examples": {
            "good": {
                "java": [
                    "import java.io.*;\n\npublic class fio14_example {\n public static void reg_hook(PrintStream out) {\n // shut down hook will be called when Runtime.exit(),\n // make sure in call hierarchy,\n // there is an edge from Runtime.exit() to Runtime.addShutdownHook\n Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {\n public void run() {\n System.out.println(\"exit without closing file, need out.close()\");\n out.close(); // report double close\n }\n }\n ));\n }\n\n public static void close2() throws FileNotFoundException {\n final PrintStream out =\n new PrintStream(new BufferedOutputStream(\n new FileOutputStream(\"foo.txt\")));\n reg_hook(out);\n out.println(\"hello\");\n Runtime.getRuntime().exit(1);\n }\n public static void main(String[] args) throws FileNotFoundException{\n close2();\n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "import java.io.*;\n\npublic class fio14_example {\n public static void reg_hook(PrintStream out) {\n // shut down hook will be called when Runtime.exit(),\n // make sure in call hierarchy,\n // there is an path from Runtime.exit() to Runtime.addShutdownHook\n Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {\n public void run() {\n System.out.println(\"exit without closing file, need out.close()\");\n out.close(); // report double close\n }\n }\n ));\n }\n\n public static void close2() throws FileNotFoundException {\n final PrintStream out =\n new PrintStream(new BufferedOutputStream(\n new FileOutputStream(\"foo.txt\")));\n reg_hook(out);\n out.println(\"register hook\");\n Runtime.getRuntime().exit(1);\n }\n public static void main(String[] args) throws FileNotFoundException{\n close2();\n }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 63,
        "category": "VUL",
        "language": "Java",
        "code": "FIO16-J",
        "name": "请在验证路径名之前将其规范化",
        "desc": "该程序在没有首先规范化路径名的情况下对其进行验证。",
        "msg_templ": "在${si.filename}，${si.func} 里第${si.line}行，文件名的字符串 ${si.var} 在文件打开之前未被规范化。",
        "severity": "MEDIUM",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序在没有规范化路径名的情况下对其进行验证。\n\n#### 解释\n路径名可能包含特殊字符，这让验证变得困难。而且，路径名可能其实是软连接、影子等等，攻击者能利用这些绕过安全检查。在验证前完全解析/规范化路径名是很重要的。\n",
        "examples": {
            "good": {
                "java": [
                    "import javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.*;\n\npublic class fio16_example\n{\n\n public void bad_1(HttpServletRequest request, HttpServletResponse response) throws IOException\n {\n String fname = request.getParameter(\"FileName\");\n String info = request.getParameter(\"Info\");\n File fp = new File(fname);\n \n { \n String uniqPath = fp.getCanonicalPath();\n // va;odate after calling getCanonicalPath\n if (fp.exists() && is_safe(uniqPath) { \n FileOutputStream writer = new FileOutputStream(uniqPath);\n writer.write(info.getBytes());\n writer.close(); // info is written to validated location\n }\n }\n }\n \n private Boolean is_safe(String path)\n {\n // do path validation\n if(path.startsWith(\"/share/user\")) {\n return true;\n } else {\n return false;\n }\n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "import javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.*;\n\npublic class fio16_example\n{\n\n public void bad_1(HttpServletRequest request, HttpServletResponse response) throws IOException\n {\n String fname = request.getParameter(\"FileName\");\n String info = request.getParameter(\"Info\");\n File fp = new File(fname);\n \n if(fp.exists() && is_safe(fname)) { // fp validated but before calling getCanonicalPath,\n // hacker can bypass the validateion\n String uniqPath = fp.getCanonicalPath();\n FileOutputStream writer = new FileOutputStream(uniqPath);\n writer.write(info.getBytes());\n writer.close(); // info may be written to unkown location\n }\n }\n \n private Boolean is_safe(String path)\n {\n // do path validation\n if(path.startsWith(\"/share/user\")) {\n return true;\n } else {\n return false;\n }\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 64,
        "category": "VUL",
        "language": "Java",
        "code": "IDS00-J",
        "name": "在查询前必须清理所有SQL查询的字符串输入",
        "desc": "在查询前必须清理所有SQL查询的字符串输入。",
        "msg_templ": "在${si.filename}，函数${si.func}的字符串${si.var}在${si.line}行的SQL查询之前未有被清理。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n在查询前必须清理所有SQL查询的字符串输入。\n\n#### 解释\n来自于不受信任来源的字符串必须经过清理及验证流程，以避免被当作SQL数据库的恶意输入。没有字符串清理及验证可能造成数据泄漏和违反隐私。\n",
        "examples": {
            "good": {
                "java": [
                    "import java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class j_ids00_2 {\n\n public Connection getConnection() throws SQLException {\n String dbConnection = System.getProperty(\\\"db.connection\\\");\n return DriverManager.getConnection(dbConnection);\n }\n\n String hashPwd(char[] pwd) {\n // Create hash of password\n return new String(pwd);\n }\n\n public void doPrivilegedAction(\n String username, char[] password // username is unsanitized \n ) throws SQLException, SecurityException {\n Connection connection = getConnection();\n if (connection == null) {\n // Handle error\n }\n try {\n String pwd = hashPwd(password);\n // the string query is composed with sanitized string (username) input\n PreparedStatement stmt = connection.prepareStatement(\\\"SELECT * FROM db_user WHERE username = ? AND passwd = ?\\\");\n \n // use set*() to enforce strong type checking\n stmt.setString(1, username); // to be sure, username may still be considered \\\"tainted\\\"\n stmt.setString(2, pwd); // to be sure, pwd ma still be considered \\\"tainted\\\" \n\n ResultSet result = stmt.executeQuery();\n if (!result.next()) {\n throw new SecurityException(\\\"User name/password incorrect\\\");\n }\n\n // Authenticated\n } finally {\n try {\n connection.close();\n } catch (SQLException x) {\n // Forward to handler\n }\n }\n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "import java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class j_ids00_2 {\n\n public Connection getConnection() throws SQLException {\n String dbConnection = System.getProperty(\\\"db.connection\\\");\n return DriverManager.getConnection(dbConnection);\n }\n\n String hashPwd(char[] pwd) {\n // Create hash of password\n return new String(pwd);\n }\n\n public void doPrivilegedAction(\n String username, char[] password // username is unsanitized \n ) throws SQLException, SecurityException {\n Connection connection = getConnection();\n if (connection == null) {\n // Handle error\n }\n try {\n String pwd = hashPwd(password);\n // the string query is composed with unsanitized string (username) input\n String query = \\\"SELECT * from where product username =\\\" +\n username + \\\" and password =\\\" + pwd;\n \n PreparedStatement stmt = connection.prepareStatement(query);\n\n ResultSet result = stmt.executeQuery();\n if (!result.next()) {\n throw new SecurityException(\\\"User name/password incorrect\\\");\n }\n\n // Authenticated\n } finally {\n try {\n connection.close();\n } catch (SQLException x) {\n // Forward to handler\n }\n }\n }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 65,
        "category": "VUL",
        "language": "Java",
        "code": "IDS01-J",
        "name": "请勿验证尚未被规范化的字符串",
        "desc": "该程序正在验证尚未被规范化的字符串。",
        "msg_templ": "在${si.filename}，第${si.line}行已验证了字符串。并在函数${si.var}被规范化。可是之后在${si.filename}，第${si.line}行才规范化。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序正在验证尚未被规范化的字符串。\n\n#### 解释\n字符串有多种表现形式，例如“char”、“unicode”等等。许多过滤或验证机制是基于字符串的字符数据。未能在验证前过滤或规范化字符串可能最终致使绕过验证机制，从而造成代码的任意执行\n",
        "examples": {
            "good": {
                "java": [
                    "import java.text.Normalizer;\nimport java.text.Normalizer.Form;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n \npublic class j_ids01_0 { // inspired by CERT-J example\n public static String filterString(String str) {\n \n // Normalization form for validate String is NFKC\n String s = Normalizer.normalize(str, Form.NFKC); \n // compliant - Validate after the string is normalized\n Pattern pattern = Pattern.compile(\\\"<script>\\\");\n Matcher matcher = pattern.matcher(str);\n if (matcher.find()) {\n throw new IllegalArgumentException(\\\"Invalid input\\\");\n }\n return s;\n }\n \n public static void main(String[] args) {\n // \\\"\\\\ \\\" is a noncharacter code point\n String maliciousInput = \\\"<scr\\\" + \\\"\\\\ \\\" + \\\"ipt>\\\";\n String sb = filterString(maliciousInput);\n // sb = \\\"<script>\\\"\n }\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "import java.text.Normalizer;\nimport java.text.Normalizer.Form;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n \npublic class j_ids01_0 { // inspired by CERT-J example\n public static String filterString(String str) {\n \n // Non-compliant - Validate before the string is normalized\n Pattern pattern = Pattern.compile(\\\"<script>\\\");\n Matcher matcher = pattern.matcher(str);\n if (matcher.find()) {\n throw new IllegalArgumentException(\\\"Invalid input\\\");\n }\n // Normalization form for validate String is NFKC\n String s = Normalizer.normalize(str, Form.NFKC); \n return s;\n }\n \n public static void main(String[] args) {\n // \\\"\\\\ \\\" is a noncharacter code point\n String maliciousInput = \\\"<scr\\\" + \\\"\\\\ \\\" + \\\"ipt>\\\";\n String sb = filterString(maliciousInput);\n // sb = \\\"<script>\\\"\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 66,
        "category": "VUL",
        "language": "Java",
        "code": "IDS11-J",
        "name": "请勿修改已经过验证的字符串",
        "desc": "该程序修改了一个已经过验证的字符串。",
        "msg_templ": "在${si.filename}，第${si.line}行，程序修改了已经被规范化并验证了的字符串${si.var}，导致字符串再次变成不可信仼。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序修改了一个已经过验证的字符串。\n\n#### 解释\n字符串在经过处理验证后又经过了修改，如此该字符串可能又会变成不受信任的字符串，使之前的验证无效。\n",
        "examples": {
            "good": {
                "java": [
                    "import java.text.Normalizer;\nimport java.text.Normalizer.Form;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n \npublic class j_ids11_0 {\n public static String filterString(String s) {\n // Normalize input string\n String str = Normalizer.normalize(s, Form.NFKC);\n \n // Delete noncharacter code\n // input string may have noncharacter code\n // however, the new string formed should go through normalize and validation again\n str = str.replaceAll(\\\"[\\\\\\\\p{Cn}]\\\", \\\"\\\");\n \n // Validate input after normalization\n Pattern pattern = Pattern.compile(\\\"<script>\\\");\n Matcher matcher = pattern.matcher(str);\n if (matcher.find()) {\n throw new IllegalArgumentException(\\\"Invalid input\\\");\n }\n \n return str;\n }\n // ... more code \n}"
                ]
            },
            "bad": {
                "java": [
                    "import java.text.Normalizer;\nimport java.text.Normalizer.Form;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n \npublic class j_ids11_0 {\n public static String filterString(String s) {\n // Normalize input string\n String str = Normalizer.normalize(s, Form.NFKC);\n \n // Validate input after normalization\n Pattern pattern = Pattern.compile(\\\"<script>\\\");\n Matcher matcher = pattern.matcher(str);\n if (matcher.find()) {\n throw new IllegalArgumentException(\\\"Invalid input\\\");\n }\n \n // Delete noncharacter code\n // input string may have noncharacter code\n // however, the new string formed should go through normalize and validation again\n str = str.replaceAll(\\\"[\\\\\\\\p{Cn}]\\\", \\\"\\\");\n return str;\n }\n // ... more code \n}"
                ]
            }
        }
    },
    {
        "master_id": 67,
        "category": "VUL",
        "language": "Java",
        "code": "IDS17-J",
        "name": "在XML输入里引用外部软件实体可能会导致XML攻击",
        "desc": "应该适当地过滤定义了外部实体（通常由URI指定）的外部声明。",
        "msg_templ": "在${si.filename}，第${si.line}行，外部声明未被适当过滤。",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n应该适当过滤定义外部实体（通常由URI指定）的外部声明。\n\n#### 解释\n应该过滤外部实体，或是通过白名单或预注册，这样能控制XML攻击。未能这么做可能导致拒绝服务或数据泄漏。\n",
        "examples": {
            "good": {
                "java": [
                    "import java.io.IOException;\nimport org.xml.sax.EntityResolver;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\n\nclass ids17_CustomResolver implements EntityResolver {\n public InputSource resolveEntity(String publicId, String systemId)\n throws SAXException, IOException {\n // Check by whitelist good entity\n ....\n }\n}\n \npublic class ids17_example{\n private static void bad_receiveXMLStream(InputStream inStream,\n DefaultHandler defaultHandler)\n throws ParserConfigurationException, SAXException, IOException {\n SAXParserFactory factory = SAXParserFactory.newInstance();\n SAXParser saxParser = factory.newSAXParser();\n saxParser.parse(inStream, defaultHandler); // IDS17-J\n }\n\n private static void bad_receiveXMLStream2(InputStream inStream,\n DefaultHandler defaultHandler,\n Boolean do_sanitize) \n throws ParserConfigurationException, SAXException, IOException {\n try {\n SAXParserFactory factory = SAXParserFactory.newInstance();\n SAXParser saxParser = factory.newSAXParser();\n\n XMLReader reader = saxParser.getXMLReader();\n reader.setContentHandler(defaultHandler);\n // always sanitize\n reader.setEntityResolver(new ids17_CustomResolver()); // sanitized\n \n InputSource is = new InputSource(inStream);\n reader.parse(is); // no IDS17 complaince issue \n } catch (java.net.MalformedURLException mue) {\n System.err.println(\\\"Malformed URL Exception: \\\" + mue);\n }\n }\n\n \n public static void main(String[] args) throws ParserConfigurationException,\n SAXException, IOException {\n // invokes bad_receiveXMLStream and bad_receiveXMLStream2\n // ...\n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "import java.io.IOException;\nimport org.xml.sax.EntityResolver;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\n\nclass ids17_CustomResolver implements EntityResolver {\n public InputSource resolveEntity(String publicId, String systemId)\n throws SAXException, IOException {\n // Check by whitelist good entity\n ....\n }\n}\n \npublic class ids17_example{\n private static void bad_receiveXMLStream(InputStream inStream,\n DefaultHandler defaultHandler)\n throws ParserConfigurationException, SAXException, IOException {\n SAXParserFactory factory = SAXParserFactory.newInstance();\n SAXParser saxParser = factory.newSAXParser();\n saxParser.parse(inStream, defaultHandler); // IDS17-J\n }\n\n private static void bad_receiveXMLStream2(InputStream inStream,\n DefaultHandler defaultHandler,\n Boolean do_sanitize) \n throws ParserConfigurationException, SAXException, IOException {\n try {\n SAXParserFactory factory = SAXParserFactory.newInstance();\n SAXParser saxParser = factory.newSAXParser();\n\n XMLReader reader = saxParser.getXMLReader();\n reader.setContentHandler(defaultHandler);\n if(do_sanitize) {\n reader.setEntityResolver(new ids17_CustomResolver()); // sanitized\n }\n InputSource is = new InputSource(inStream);\n reader.parse(is); // IDS17-J, not setEntityResolver if !do_sanitize\n } catch (java.net.MalformedURLException mue) {\n System.err.println(\\\"Malformed URL Exception: \\\" + mue);\n }\n }\n\n \n public static void main(String[] args) throws ParserConfigurationException,\n SAXException, IOException {\n // invokes bad_receiveXMLStream and bad_receiveXMLStream2\n // ...\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 68,
        "category": "VUL",
        "language": "Java",
        "code": "MET06-J",
        "name": "不要在clone()中调用可覆盖的方法",
        "desc": "该程序在clone()里调用了可覆盖的方法。",
        "msg_templ": "在${si.filename}，第${si.line}行，可覆盖的方法${si.var}会被clone()覆盖。",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "LOW",
        "details": "#### 概要\n该程序在clone()里调用了可覆盖的方法。\n\n#### 解释\n恶意的子类可能会覆盖clone()里的方法，造成不安全或不可预测的行为。另外，受信任的子类可以修改处于构造过程的被复制的对象，造成被复制的对象的不一致。\n",
        "examples": {
            "good": {
                "java": [
                    "import java.net.HttpCookie;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass j_met06 implements Cloneable {\n HttpCookie[] cookies;\n\n j_met06(HttpCookie[] c) {\n cookies = c;\n }\n\n public Object clone() throws CloneNotSupportedException {\n // get shallow copy of object\n final j_met06 clone = (j_met06) super.clone();\n clone.doSomething(); // Can invoke overridable method\n\n // the class has mutable object, need to deep copy those field\n clone.cookies = clone.deepCopy();\n return clone;\n }\n\n final void doSomething() { // not overridable method\n for (int i = 0; i < cookies.length; i++) {\n cookies[i].setValue(\\\"\\\" + i);\n }\n }\n\n final HttpCookie[] deepCopy() { // not overridable method\n if (cookies == null) {\n throw new NullPointerException();\n }\n\n // implements deep copy\n List<HttpCookie> cloned_cookie = new ArrayList<>();\n // ...\n return (HttpCookie[]) cloned_cookie;\n }\n}\n\nclass j_met06_ext extends j_met06 {\n j_met06_ext(HttpCookie[] c) {\n super(c);\n }\n\n public Object clone() throws CloneNotSupportedException {\n final j_met06_ext clone = (j_met06_ext) super.clone();\n clone.doSomething();\n return clone;\n }\n\n void doSomething() { // will not be called\n for (int i = 0;i < cookies.length; i++) {\n cookies[i].setDomain(i + \\\".xxx.com\\\");\n }\n }\n\n public static void main(String[] args)\n throws CloneNotSupportedException {\n HttpCookie[] hc = new HttpCookie[20];\n for (int i = 0 ; i < hc.length; i++){\n hc[i] = new HttpCookie(\\\"cookie\\\" + i,\\\"\\\" + i);\n }\n // deep copy was invoked, the original object cannot be modified\n j_met06 badcookie = new j_met06_ext(hc);\n badcookie.clone();\n }\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "// this example is extended from CERT site\nimport java.net.HttpCookie;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass j_met06 implements Cloneable {\n HttpCookie[] cookies;\n\n j_met06(HttpCookie[] c) {\n cookies = c;\n }\n\n public Object clone() throws CloneNotSupportedException {\n // get shallow copy of object\n final j_met06 clone = (j_met06) super.clone();\n clone.doSomething(); // Can invoke overridable method\n\n // the class has mutable object, need to deep copy those field\n clone.cookies = clone.deepCopy();\n return clone;\n }\n\n void doSomething() { // Overridable method\n for (int i = 0; i < cookies.length; i++) {\n cookies[i].setValue(\\\"\\\" + i);\n }\n }\n\n HttpCookie[] deepCopy() {\n if (cookies == null) {\n throw new NullPointerException();\n }\n\n // implements deep copy\n List<HttpCookie> cloned_cookie = new ArrayList<>();\n // ...\n return (HttpCookie[]) cloned_cookie;\n }\n}\n\nclass j_met06_ext extends j_met06 {\n j_met06_ext(HttpCookie[] c) {\n super(c);\n }\n\n public Object clone() throws CloneNotSupportedException {\n final j_met06_ext clone = (j_met06_ext) super.clone();\n clone.doSomething();\n return clone;\n }\n\n void doSomething() { // Erroneously executed\n for (int i = 0;i < cookies.length; i++) {\n cookies[i].setDomain(i + \\\".xxx.com\\\");\n }\n }\n\n public static void main(String[] args)\n throws CloneNotSupportedException {\n HttpCookie[] hc = new HttpCookie[20];\n for (int i = 0 ; i < hc.length; i++){\n hc[i] = new HttpCookie(\\\"cookie\\\" + i,\\\"\\\" + i);\n }\n // shallow copy was invoked, the original object can be modified\n j_met06 badcookie = new j_met06_ext(hc);\n badcookie.clone();\n }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 69,
        "category": "VUL",
        "language": "Java",
        "code": "MSC61-J",
        "name": "安全关键型代码必须避免使用不安全或弱加密算法",
        "desc": "该程序正为安全敏感型代码使用弱加密算法。",
        "msg_templ": "在${si.filename}，第${si.line}行，函数${si.func}用${si.var}加密算法是比较弱和不安全的。",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "#### 概要\n该程序正为安全敏感型代码使用弱加密算法。\n\n#### 解释\n安全和隐私敏感型信息应使用安全性强的加密算法，包括有Galois/Counter模式（GCM）的AES和有加密块链模式的AES。\n",
        "examples": {
            "good": {
                "java": [
                    "import javax.crypto.*;\nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\n\npublic class j_msc61_0 {\n \n public static SecretKey genKey() {\n // DES is a weak encryption algorithm\n // AES is also weak, however, if AES is to be used\n // GCM (Galois/Counter Mode) will do the encryption\n try {\n KeyGenerator keygen = KeyGenerator.getInstance(\\\"AES\\\");\n keygen.init(128);\n return keygen.generateKey();\n } catch (NoSuchAlgorithmException e) {\n // handle exception\n ...\n }\n }\n \n public static byteArray[] encryption(String strToBeEncrypted, SecretKey seckey) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, UnsupportedEncodingException, BadPaddingException, IllegalBlockSizeException {\n Cipher cipher = Cipher.getInstance(\\\"AES/GCM/NoPadding\\\");\n // please consult example in CERT-J site for MSC61-J\n ...\n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "import javax.crypto.*;\nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\n\npublic class j_msc61_0 {\n public static byteArray[] encryption(String strToBeEncrypted) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, UnsupportedEncodingException, BadPaddingException, IllegalBlockSizeException {\n \n // DES is a weak encryption algorithm\n // AES is also weak, however, if AES is to be used\n // GCM (Galois/Counter Mode) will do the encryption\n SecretKey key = KeyGenerator.getInstance(\\\"DES\\\").generateKey();\n Cipher cipher = Cipher.getInstance(\\\"DES\\\");\n cipher.init(Cipher.ENCRYPT_MODE, key);\n\n // Encode bytes as UTF8; strToBeEncrypted contains\n // the input string that is to be encrypted\n byteArray[] encoded = strToBeEncrypted.getBytes(\\\"UTF8\\\");\n\n // Perform encryption\n byteArray[] encrypted = cipher.doFinal(encoded);\n return encrypted;\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 70,
        "category": "VUL",
        "language": "Java",
        "code": "OBJ09-J",
        "name": "比较类名称可能导致混搭攻击",
        "desc": "比较类名称可能会导致混合搭配攻击。",
        "msg_templ": "在${si.filename}，第${si.line}行，函数${si.func}使用了名称来比较类。",
        "severity": "HIGH",
        "likelihood": "UNLIKELY",
        "cost": "LOW",
        "details": "#### 概要\n比较类名称可能会导致混合搭配攻击。\n\n#### 解释\n只有当两个类具有相同的限定名称时，它们才是同一类。 具有相同名称的类可能具有不同的包名称。 同样由于不同的类加载器（或类加载器的不同实例），具有相同限定名称类也可能成为不同的类。\n\n",
        "examples": {
            "good": {},
            "bad": {
                "java": [
                    "import java.lang.String;\npublic class j_obj09_1 {\n void callComp(Boolean v) {\n Class cls1 = getClass();\n Class cls2 = String.class;\n if(v) {\n badComp1(cls1.getName()); \n } else {\n badComp2(cls1.getName(), cls2.getName());\n }\n }\n Boolean badComp1(String clsName) {\n if(clsName.equals(\\\"j_obj09_0\\\")) {\n return true;\n }\n else {\n return false;\n }\n } \n\n Boolean badComp2(String name1, String name2)\n {\n if(name1.equals(name2)) {\n return true;\n }\n else {\n return false;\n }\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 71,
        "category": "VUL",
        "language": "Java",
        "code": "OBJ11-J",
        "name": "构造函数不应抛出异常",
        "desc": "抛出异常的构造函数可能会使对象处于部分初始状态。",
        "msg_templ": "构造函数${si.func}会在${si.filename}，第${si.line}行抛出异常${si.var}。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n抛出异常的构造函数可能会使对象处于部分初始状态。\n\n#### 解释\n在对象构造过程中，该对象处于部分初始状态。在构造过程中抛出异常会使对象处于不稳定状态。\n\n",
        "examples": {
            "good": {},
            "bad": {
                "java": [
                    "import java.io.IOException;\n\npublic class obj11_0 {\n public obj11_0()\n {\n // by throwing an exception in constructor\n // attacker can capture a reference to the partially initialized object of the obj11_0 class since\n // the object reference remains in the garbge collector\n if (!performVerification()) {\n throw new SecurityException(\\\"Access Denied!\\\");\n }\n }\n\n private boolean performVerification() {\n return false; // Returns true if data entered is valid, else false\n // Assume that the attacker always enters an invalid value\n }\n\n public void greeting() {\n System.out.println(\\\"Welcome user!\\\");\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 72,
        "category": "VUL",
        "language": "Java",
        "code": "SEC02-J",
        "name": "安全检查代码不应基于不受信任来源",
        "desc": "此程序中安全检查代码的来源可能基于不受信任的来源。",
        "msg_templ": "在${si.filename}，第${si.line}行，函数${si.func}返回来源不可信任的安全检查给${si.var}。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n此程序中安全检查代码的来源可能基于不受信任的来源。\n\n#### 解释\n不受信任代码可能有许多不同的来源。安全检查可能通过代码重写被绕过。经过安全检查的对象在检查后也能被重写。即使通过安全检查后保存的该对象，也有可能存在复制方法不足够的问题（例如浅复制这类不够完全彻底的复制方法）。\n",
        "examples": {
            "good": {
                "java": [
                    "import java.io.FileNotFoundException;\nimport java.io.RandomAccessFile;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.io.IOException;\n\npublic class sec02_0 {\n public static RandomAccessFile openFile(final java.io.File f) {\n // get a copy through getPath(), but not a clone\n final java.io.File copy = new java.io.File(f.getPath());\n // use copy of path later on\n if (copy.getPath().contains(\\\"passwd\\\")){\n return null;\n };\n // ...\n return (RandomAccessFile) AccessController.doPrivileged(new PrivilegedAction<Object>() {\n public Object run() {\n try {\n return new RandomAccessFile(copy.getPath(), \\\"r\\\");\n } catch (FileNotFoundException e) {\n e.printStackTrace();\n }\n return null;\n }\n });\n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "import java.io.FileNotFoundException;\nimport java.io.RandomAccessFile;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.io.IOException;\n\npublic class sec02_0 {\n public static RandomAccessFile openFile(final java.io.File f) {\n // getPath() can be extended, thus security check can pass the first time, \n // but getPath() changed the second time, bypass the good check\n if (f.getPath().contains(\\\"passwd\\\")){\n return null;\n };\n // ...\n return (RandomAccessFile) AccessController.doPrivileged(new PrivilegedAction<Object>() {\n public Object run() {\n try {\n return new RandomAccessFile(f, \\\"r\\\");\n } catch (FileNotFoundException e) {\n e.printStackTrace();\n }\n return null;\n }\n });\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 73,
        "category": "VUL",
        "language": "Java",
        "code": "SEC06-J",
        "name": "不应使用URLClassLoader和java.util.jar提供的默认自动签名检验器",
        "desc": "该程序正使用URLClassLoader和java.util.jar提供的默认自动签名检验器。",
        "msg_templ": "在${si.filename}，第${si.line}行，在函数${si.func}里， ${si.var}使用URLClassLoader默认自动签名验证器。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序正使用URLClassLoader和java.util.jar提供的默认自动签名检验器。\n\n#### 解释\n当签名用于权限提升目的时，把这些包当作默认自动签名检验来使用是不够的。它只会执行完整性检查。并且它只使用公钥来对加载的类进行认证，此公钥可能已被恶意修改。\n",
        "examples": {
            "good": {
                "java": [
                    "package io.xc5.cert;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.JarURLConnection;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.jar.Attributes;\nimport java.security.GeneralSecurityException;\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.io.FileInputStream;\n\npublic class j_sec06_fp_1 extends URLClassLoader {\n private URL url;\n public j_sec06_fp_1(URL url) {\n super(new URL[] { url });\n this.url = url;\n }\n\n Boolean verifyClass(Class c) throws ClassNotFoundException, NoSuchMethodException,\n InvocationTargetException, GeneralSecurityException,\n IOException {\n Certificate[] certs = c.getProtectionDomain().getCodeSource().getCertificates();\n if (certs == null) {\n return false;\n }\n else { \n KeyStore ks = KeyStore.getInstance(\\\"JKS\\\");\n ks.load(new FileInputStream(\\\"sec06.jks\\\"), \\\"loadkeystorepassword\\\".toCharArray());\n Certificate pubCert = ks.getCertificate(\\\"sec06\\\");\n // Check with the trusted public key, else throws exception\n certs[0].verify(pubCert.getPublicKey());\n return true;\n }\n }\n\n public void invokeClass(String name, String[] args)\n throws ClassNotFoundException, NoSuchMethodException,\n InvocationTargetException , GeneralSecurityException, IOException {\n Class c = loadClass(name);\n Method m = c.getMethod(\\\"getValue\\\", new Class[] { args.getClass() });\n m.setAccessible(true);\n \n // use customized, non-default verification method declared above\n if(verifyClass(c)) {\n try {\n m.invoke(null, new Object[] { args });\n } catch (IllegalAccessException e) {\n System.out.println(\\\"Access denied\\\");\n }\n }\n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "package io.xc5.cert;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.JarURLConnection;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.jar.Attributes;\nimport java.security.GeneralSecurityException;\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.io.FileInputStream;\n\npublic class j_sec06_1 extends URLClassLoader {\n private URL url;\n public j_sec06_1(URL url) {\n super(new URL[] { url });\n this.url = url;\n }\n\n public void invokeClass(String name, String[] args)\n throws ClassNotFoundException, NoSuchMethodException,\n InvocationTargetException , GeneralSecurityException, IOException {\n Class c = loadClass(name);\n Method m = c.getMethod(\\\"getValue\\\", new Class[] { args.getClass() });\n m.setAccessible(true);\n try {\n m.invoke(null, new Object[] { args });\n } catch (IllegalAccessException e) {\n System.out.println(\\\"Access denied\\\");\n }\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 74,
        "category": "VUL",
        "language": "c,c++",
        "code": "FIO02-C",
        "name": "规范化来自污染源的路径名",
        "desc": "路径名，目录名和文件名可能包含使验证变得困难且不准确的字符。 此外，任何路径名组件都可以是符号链接，从而进一步掩盖了文件的实际位置或标识。 为了简化文件名验证，建议将名称转换为规范形式。 通过对名称进行规范化，可以比较名称，从而更轻松地验证路径，目录或文件名。由于规范形式在操作系统和文件系统之间可能会有所不同，因此最好使用特定于操作系统的机制进行规范化。",
        "msg_templ": "在${si.filename}行${si.line}行，函数${si.func}正在打开文件而不规范其名称，该名称可能来自受污染的源。",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n来源不受信任的路径名和目录名应该被规范化并验证。\n\n#### 解释\n路径名、目录名和文件名可能包含使验证变得困难且不准确的字符。 此外，任何路径名组件都可以是符号链接，从而进一步掩盖了文件的实际位置或标识。 为了简化文件名验证，建议将名称转换为规范形式。 通过对名称进行规范化，可以比较名称，从而更轻松地验证路径，目录或文件名。由于规范形式在操作系统和文件系统之间可能会有所不同，因此最好使用特定于操作系统的机制进行规范化。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n#include <stdlib.h>\n\nFILE* f_open(char* fname, FILE *fptr)\n{\n    fptr = fopen(fname, \"r\");\n    return fptr;\n}\n\nchar *sanitize(char *fname);\n\n\nint main(int argc, char **argv[])\n{\n  FILE *fptr;\n  \n  if (!verify_file(sanitize(*argv[1]))) {  // sanitize file name first\n    printf(\"error\n\");\n    exit(1);\n  }\n  else {\n    fptr = f_open(*argv[1], fptr);\n  }\n  printf(\"File opened %x\n\", fptr);\n  // ...\n  exit(0);\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n#include <stdlib.h>\n\nFILE* f_open(char* fname, FILE *fptr)\n{\n    fptr = fopen(fname, \"r\");\n    return fptr;\n}\n\nint main(int argc, char **argv[])\n{\n  FILE *fptr;\n  \n  if (!verify_file(*argv[1])) {\n    printf(\"error\n\");\n    exit(1);\n  }\n  else {\n    fptr = f_open(*argv[1], fptr);\n  }\n  printf(\"File opened %x\n\", fptr);\n  // ...\n  exit(0);\n}"
                ]
            }
        }
    },
    {
        "master_id": 75,
        "category": "VUL",
        "language": "c,c++",
        "code": "STR07-C",
        "name": "使用边界检查接口进行字符串操作",
        "desc": "",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 76,
        "category": "BAD_PRACTICE",
        "language": "c,c++",
        "code": "POS02-C",
        "name": "遵循最小特权原则",
        "desc": "",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "HIGH",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 77,
        "category": "VUL",
        "language": "c,c++",
        "code": "POS36-C",
        "name": "放弃特权时遵守正确的撤销顺序",
        "desc": "",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n#include <unistd.h>\n\nvoid func() {\n    int gid_stat = setgid(getgid());\n    int uid_stat = setuid(getuid());\n    \n    // Correct order of privilege relinquishment\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n#include <unistd.h>\n\nvoid func(){\n    int uid_stat = setuid(getuid());\n    int gid_stat = setgid(getfid());\n\n    // Possible to regain group privileges because of incorrect order\n    // Vulnerability allowing execution of arbitrary code\n}"
                ]
            }
        }
    },
    {
        "master_id": 80,
        "category": "VUL",
        "language": "java",
        "code": "MSC62-J",
        "name": "密码应使用安全的哈希值存储，以防止暴露给恶意用户。",
        "desc": "将密码用明文存储可能导致这些密码以各种方式暴露。建议使用计算上可行而其解码在计算上不可行的哈希函数加密，用户可以使用哈希值测试密码是否相等。",
        "msg_templ": "在${si.filename}行${si.line}行，函数${si.func}正在使用不安全的哈希值存储密码。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "LOW",
        "details": "#### 概要\n将密码用明文存储可能导致这些密码以各种方式暴露。建议使用计算上可行而其解码在计算上不可行的哈希函数加密，用户可以使用哈希值测试密码是否相等。\n\n#### 解释\n密码不应以明文存储。为防止密码泄露，通常使用哈希函数来进行密码存储，这种加密方法成本不高昂且允许直接比较。",
        "examples": {
            "good": {
                "java": [
                    "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\npublic class j_msc62_ex {\n  private void regUser1(String userName, byte[] passwd, String regType) {\n    try {\n      String salt = genSalt();\n      String combPasswd = salt + passwd;\n      byte[] secureHash = secureHash(combPasswd.getBytes());\n      byte[] noSaltPasswd = secureHash(passwd);\n      byte[] unsecureHash = unSecureHash(combPasswd.getBytes());\n      if(regType.equals(\"NO_SALT_HASH\")) {\n        handleError(\"NO_SALT_HASH\");;             // MSC62-J, no salt, no hash\n      } else if(regType.equals(\"NO_SALT\")) {\n        handleError(\"NO_SALT_HASH\");        // MSC62-J no salt\n      } else if(regType.equals(\"UNSECURE_HASH\")){\n        handleError(\"UNSECURE_HASH\");       // MSC62-J unsecure hash\n      } else {\n        saveUser(userName, secureHash);         \n      }\n    } catch (NoSuchAlgorithmException e) {\n      e.printStackTrace();\n    }\n  } \n  private byte[] unSecureHash(byte [] passwd) throws NoSuchAlgorithmException{\n    MessageDigest msgDigest = MessageDigest.getInstance(\"MD5\");  // not secure hash algorithm\n    return msgDigest.digest(passwd);\n  }\n  \n  private byte[] secureHash(byte [] passwd) throws NoSuchAlgorithmException{\n    MessageDigest msgDigest = MessageDigest.getInstance(\"SHA256\");  // secure hash algorithm\n    return msgDigest.digest(passwd);\n  }\n\n  private void testRegUser(String userName, String passwd, String regType) {\n    regUser1(userName, passwd.getBytes(), regType);\n    regUser2(userName, passwd);  // MSC62-J passwd is String type\n  }\n\n} "
                ]
            },
            "bad": {
                "java": [
                    "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\npublic class j_msc62_ex {\n  private void regUser1(String userName, byte[] passwd, String regType) {\n    try {\n      String salt = genSalt();\n      String combPasswd = salt + passwd;\n      byte[] secureHash = secureHash(combPasswd.getBytes());\n      byte[] noSaltPasswd = secureHash(passwd);\n      byte[] unsecureHash = unSecureHash(combPasswd.getBytes());\n      if(regType.equals(\"NO_SALT_HASH\")) {\n        saveUser(userName, passwd);             // MSC62-J, no salt, no hash\n      } else if(regType.equals(\"NO_SALT\")) {\n        saveUser(userName, noSaltPasswd);       // MSC62-J no salt\n      } else if(regType.equals(\"UNSECURE_HASH\")){\n        saveUser(userName, unsecureHash);       // MSC62-J unsecure hash\n      } else {\n        saveUser(userName, secureHash);         // \n      }\n    } catch (NoSuchAlgorithmException e) {\n      e.printStackTrace();\n    }\n  } \n  private byte[] unSecureHash(byte [] passwd) throws NoSuchAlgorithmException{\n    MessageDigest msgDigest = MessageDigest.getInstance(\"MD5\");  // not secure hash algorithm\n    return msgDigest.digest(passwd);\n  }\n  // .. other code\n  private byte[] secureHash(byte [] passwd) throws NoSuchAlgorithmException{\n    MessageDigest msgDigest = MessageDigest.getInstance(\"SHA256\");  // secure hash algorithm\n    return msgDigest.digest(passwd);\n  }\n\n  private void testRegUser(String userName, String passwd, String regType) {\n    regUser1(userName, passwd.getBytes(), regType);\n    regUser2(userName, passwd);  // MSC62-J passwd is String type\n  }\n\n} "
                ]
            }
        }
    },
    {
        "master_id": 81,
        "category": "VUL",
        "language": "java",
        "code": "IDS03-J",
        "name": "未经清理的用户输入不应出现在日志中",
        "desc": "包含未经清理的用户输入的日志条目可能导致日志注入攻击并导致跨信任边界的数据泄露。",
        "msg_templ": "",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 名称\n未经过清理的用户信息不应该被暴露\n\n#### 概要\n当未经过清理的用户输入被记录或者以stdout输出时，可能造成敏感信息泄漏\n\n#### 解释\n记录未经过清理的用户输入可能导致敏感信息在信任边界外泄漏。Log注入攻击会进一步引起信息泄漏。Java和C/C++程序都可能遭到类似的攻击（见示例）。",
        "examples": {
            "good": {
                "c": [
                    "\nusing namespace mychain;\nusing namespace MyContract::Sample;\n\nclass demoBranch:public Contract {\npublic:\n    TransferPtr m_ptransfer;\n\n    demoBranch() {\n        m_ptransfer = GetTransferM();\n    }\n    INTERFACE void Init() {\n        InitRoot();\n    }\n    \n    INTERFACE void LeakToLog(const std::string& sAccountName ) {\n        if(!m_ptransfer) {\n            Revert(\"error\");\n        }\n\n\t// get account, balance etc\n        AccountMMapPtr pAccountMap = m_ptransfer->get_accounts();\n        if (!pAccountMap) {\n            Revert(\"AcountMMapPtr Error.\");\n        }\n\n        // obtain user account number and name\n\t// ...\n\n\t//\n        int32_t iBalanceRmb = pBalance->get_rmb();\n        std::string sBalanceTopic = std::to_string(iBalanceRmb);\n        std::vector<std::string> leak_msg;\n        leak_msg.push_back(sAccountName);\n        leak_msg.push_back(sBalanceTopic);\n\n        if (iBalanceRmb < 1) {\n\t  // Sanitize and clean up message before logging\n          Log(std::string(\"acc_bal\"), SanitizeUser(leak_msg));\n        }\n    }\n};\nINTERFACE_EXPORT(demoBranch, (Init) (LeakToLog))\n"
                ],
                "java": [
                    "locationClient = new LocationClient(this, this, this);\nlocationClient.connect();\ncurrentUser.setLocation(locationClient.getLastLocation());\n... \n\ncatch (Exception e) {\n    AlertDialog.Builder builder = new AlertDialog.Builder(this);\n    builder.setMessage(\"Application Error.\");\n    AlertDialog alert = builder.create();\n    alert.show();\n\n    // user location is \"sanitized\" being written to log\n    Log.e(\"Example\", \"Caught exception: \" + e + \" User:\" + sanitizeUser(User.toString()));\n}\n"
                ]
            },
            "bad": {
                "c": [
                    "\nusing namespace mychain;\nusing namespace MyContract::Sample;\n\nclass demoBranch:public Contract {\npublic:\n    TransferPtr m_ptransfer;\n\n    demoBranch() {\n        m_ptransfer = GetTransferM();\n    }\n    INTERFACE void Init() {\n        InitRoot();\n    }\n    \n    INTERFACE void LeakToLog(const std::string& sAccountName ) {\n        if(!m_ptransfer) {\n            Revert(\"error\");\n        }\n\n\t// get account, balance etc\n        AccountMMapPtr pAccountMap = m_ptransfer->get_accounts();\n        if (!pAccountMap) {\n            Revert(\"AcountMMapPtr Error.\");\n        }\n\n        // obtain user account number and name\n\t// ...\n\n\t//\n        int32_t iBalanceRmb = pBalance->get_rmb();\n        std::string sBalanceTopic = std::to_string(iBalanceRmb);\n        std::vector<std::string> leak_msg;\n        leak_msg.push_back(sAccountName);\n        leak_msg.push_back(sBalanceTopic);\n\t\n        if (iBalanceRmb < 1) {\n          Log(std::string(\"acc_bal\"), leak_msg);\n        }\n    }\n};\nINTERFACE_EXPORT(demoBranch, (Init) (LeakToLog))\n"
                ],
                "java": [
                    "locationClient = new LocationClient(this, this, this);\nlocationClient.connect();\ncurrentUser.setLocation(locationClient.getLastLocation());\n... \n\ncatch (Exception e) {\n    AlertDialog.Builder builder = new AlertDialog.Builder(this);\n    builder.setMessage(\"Application Error.\");\n    AlertDialog alert = builder.create();\n    alert.show();\n\n    // user location is written to log\n    Log.e(\"Example\", \"Caught exception: \" + e + \" User:\" + User.toString());\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 82,
        "category": "VUL",
        "language": "c,c++",
        "code": "ARR38-C",
        "name": "数组在使用库函数时越界",
        "desc": "该程序正调用有指针和大小参数的库函数。当这两个参数组合在一起时，它们会在该对象的合法范围之外。",
        "msg_templ": "在${si.filename}行${si.line}行，函数${si.func}正在调用有指针和大小参数的库函数。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "",
        "examples": {
            "good": {
                "c": [
                    "#include <stdlib.h>\n#include <string.h>\n\nvoid func(size_t SIZE_LIMIT)\n{\n    char *p = (char *)malloc(SIZE_LIMIT);\n    /* ...  */\n\n    // ensures that it will not go past last element\n    const size_t n = SIZE_LIMIT - 1;\n    /* ...  */\n    memset(p, 0, n);\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdlib.h>\n#include <string.h>\n\nvoid func(size_t SIZE_LIMIT)\n{\n    char *p = (char *)malloc(SIZE_LIMIT);\n    /* ...  */\n\n    // adding 100 is out of bounds\n    const size_t n = SIZE_LIMIT + 100;\n    /* ...  */\n    memset(p, 0, n);\n}"
                ]
            }
        }
    },
    {
        "master_id": 83,
        "category": "VUL",
        "language": "c,c++",
        "code": "EXP34-C",
        "name": "不要使用空指针来解除引用",
        "desc": "该程序正通过带值的指针访问非法内存。该漏洞与鉴释NPD规则相同。",
        "msg_templ": "在${si.filename}行${si.line}行，函数${si.func}正通过带值的指针访问非法内存。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序正通过带值的指针访问非法内存。该漏洞与鉴释NPD规则相同。\n\n#### 解释\n请参考鉴释漏洞列表里的NPD规则以获得详细的解释和示例。\n",
        "examples": {
            "good": {},
            "bad": {
                "c": [
                    "extern int bar(int);\n\nint assign(int* a)\n{\n int i = bar(*a) // dereference a\n return i;\n}\n\nint foo(void)\n{\n int *p = 0; // p as a pointer has been initialized to 0 (null)\n assign(p);\n}"
                ],
                "java": [
                    "class User {\n public String getName() {\n return null;\n }\n}\n\nclass Bar {\n private User findUser(String uid) {\n if (user.containsKey(uid)) {\n return user.get(uid);\n }\n else\n return null;\n }\n public void Npd(String uid) {\n // do something\n // ...\n User user = findUser(uid); // Throws NPE if \\\"user\\\" has not been properly initialized\n String getName() {\n return null;\n }\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 84,
        "category": "VUL",
        "language": "c,c++",
        "code": "FIO47-C",
        "name": "避免对格式字符串使用有冲突的类型",
        "desc": "该程序正调用函数，其使用的参数个数与原型声明的参数个数不同。",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func}的参数与文件${si.filename}，第${si.line}行里的函数声明不匹配。",
        "severity": "HIGH",
        "likelihood": "UNLIKELY",
        "cost": "LOW",
        "details": "#### 概要\n该程序正调用函数，其使用的参数个数与原型声明的参数个数不同。\n\n#### 解释\n在调用点里，传递的实际参数个数与函数声明里的参数个数不同。如果传递的实际参数比声明的要少，缺失的实际参数最终会变成\\\"wild\\\"，并可能发生不可预测的后果。\n",
        "examples": {
            "good": {
                "c": [
                    "int foo(int a, int guard)\n{\n    int x = 0;\n    int result = 0;\n    if (guard != 0)\n        result = a * x;\n    foo(result, guard); // no parameters missing\n    return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "int foo(int a, int guard)\n{\n    int x = 0;\n    int result = 0;\n    if (guard != 0)\n        result = a * x;\n\n    // missing one parameter, and \\\"guard\\\" will have random value during execution at this point\n    foo(result); \n    return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 85,
        "category": "VUL",
        "language": "c,c++",
        "code": "MEM30-C",
        "name": "不应再次访问或使用已释放的内存",
        "desc": "该程序正访问已被释放的内存。",
        "msg_templ": "在${si.filename}行${si.line}行，函数${si.func}正访问已被释放的内存。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序正访问已被释放的内存。\n\n#### 解释\n使用已经释放的内存是悬空指针引用的一种形式。它通常会发生在内存对象被释放而其所指的指针未被更新的情况下。在再次使用指针时，指针会指向不正确的内存而导致未经授权的访问。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stddef.h>\n\nint g = 2;\n\nvoid my_free(void *p)\n{\n    if (p != NULL)\n        free(p); // free p\n}\n\nint main()\n{\n    int i, j, *p, *q;\n    p = malloc(10 * sizeof(int));\n    if (p == NULL)\n        return 1;\n    for (i = 0; i < 10; ++i)\n        p[i] = i;\n\n    // do not free p\n\n    j = 0;\n    for (i = 0; i < 10; ++i)\n        j += q[i]; \n    return j;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stddef.h>\n\nint g = 2;\n\nvoid my_free(void *p)\n{\n    if (p != NULL)\n        free(p); // free p\n}\n\nint main()\n{\n    int i, j, *p, *q;\n    p = malloc(10 * sizeof(int));\n    if (p == NULL)\n        return 1;\n    for (i = 0; i < 10; ++i)\n        p[i] = i;\n    q = p;\n    my_free(p); // p is freed\n    j = 0;\n    for (i = 0; i < 10; ++i)\n        j += q[i]; // Use after free here (note the statement q = p), read of q[i] is illegal\n    return j;\n}"
                ]
            }
        }
    },
    {
        "master_id": 86,
        "category": "VUL",
        "language": "c++",
        "code": "MEM50-CPP",
        "name": "不应访问己释放的内存",
        "desc": "程序读取已经释放的指针变量，这可能会导致未定义行为。",
        "msg_templ": "在${so.filename}，第${so.line}行，${so.func}里使用了变量${so.var}。然而，此变量在${so.filename}第${so.line}行已被释放。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序在已释放了内存后引用了该内存。这可能导致程序崩溃或不可预测的程序行为。\n\n#### 解释\n释放后重用是悬空指针引用的一种形式。它通常发生在指针所指向的内存对象已被释放而指针未被更新时。该指针将指向不正确的内存，这在使用指针时会引起未经授权的访问。\n",
        "examples": {
            "good": {},
            "bad": {
                "cpp": [
                    "int g = 2;\n\nvoid my_free(void *p) {\n if (p != NULL)\n free(p); // free p\n}\n\nint main() {\n int i, j, *p, *q;\n p = malloc(10 * sizeof(int));\n if (p == NULL)\n return 1;\n for (i=0; i < 10; ++i)\n p[i] = i;\n q = p;\n my_free(p); // p is freed\n j = 0;\n for (i=0; i < 10; ++i)\n j += q[i]; // Use after free here (note the statement q = p), read of q[i] is illegal\n return j;\n}"
                ]
            }
        }
    },
    {
        "master_id": 87,
        "category": "VUL",
        "language": "c++",
        "code": "MEM51-CPP",
        "name": "分配的资源需要适当的释放",
        "desc": "程序无法适当地释放动态分配的内存。",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func}里的变量${si.var}未被释放。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序已分配了堆内存，但未能释放那块内存。\n\n#### 解释\n分配了堆内存并且分配的内存地址存储在引用（指针）类型的变量里。该堆内存在其生命周期结束后从未被释放，其对应的引用仍然指向该内存空间。这可能会导致敏感数据泄漏或意外程序行为（例如拒绝服务）。\n",
        "examples": {
            "good": {},
            "bad": {
                "cpp": [
                    "struct S {\n int *p;\n};\n\nint main() {\n int *p;\n struct S *s;\n p = malloc(10 * sizeof(int)); // heap memory allocated and pointed to by p\n if (p == NULL)\n return 1;\n s = (struct S*)malloc(sizeof(struct S)); // heap memory allocated and pointed to by s\n if (s == NULL) {\n free(p);\n return 1;\n }\n s->p = p;\n free(s); // only s is freed\n // s->p, which is copied from p is not freed\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 88,
        "category": "VUL",
        "language": "c++",
        "code": "EXP53-CPP",
        "name": "禁止读取未初始化的内存",
        "desc": "程序尝试读取已声明但尚未初始化的内存。",
        "msg_templ": "在${so.filename}，第${so.line}行，已经使用了${so.func}里的变量${so.var}但从未对其赋值。",
        "severity": "MEDIUM",
        "likelihood": "UNLIKELY",
        "cost": "LOW",
        "details": "#### 概要\n该程序在变量初始化前使用该变量。\n\n#### 解释\nC和C++里的栈变量默认为非初始化，并且非静态全局变量不默认为零。它们的初始值取决于调用函数时它们在内存中的位置里恰好有的值。这么做会导致意外程序行为。\n",
        "examples": {
            "good": {},
            "bad": {
                "cpp": [
                    "int assign(int* a)\n{\n return *a; // dereference a\n}\n\nint main() {\n int a, b;\n b = assign(&a); // call assign with a uninitialized\n printf(\"value of b = %d\\\\\", b);\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 89,
        "category": "VUL",
        "language": "c++",
        "code": "EXP54-CPP",
        "name": "仅在对象的生存期内访问该对象",
        "desc": "程序试图在对象的生存期之外访问该对象，这将导致未定义的行为。",
        "msg_templ": "在${so.filename}，第${so.line}行，使用了${so.func}里的内存引用变量${so.var}。该变量首次被赋值为内存引用，这在${so.filename}的第${so.line}行可能无效。",
        "severity": "HIGH",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n已使用了悬空指针来引用无效的内存资源。\n\n#### 解释\n悬空指针是引用无效或不正确的内存资源的指针。引用这些内存资源可能会造成内存损坏，从而导致不可预测的程序行为或系统不稳定。\n",
        "examples": {
            "good": {},
            "bad": {
                "cpp": [
                    "int *assign()\n{\n int *c;\n c = 1;\n return &c;\n}\n\nint foo()\n{\n int *a;\n a = assign(); // return a stack address and assign to a\n printf(\\\"assigned value: %d\\\", a); // use dangling pointer\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 90,
        "category": "VUL",
        "language": "Java",
        "code": "ERR00-J",
        "name": "空的异常catch块",
        "desc": "该程序有带空catch块的异常构造。",
        "msg_templ": "在${si.filename}，${si.func}里第${si.line}行的catch块是空的。",
        "severity": "LOW",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n异常必须得到适当处理。\n\n#### 解释\n异常会破坏应用程序的预期控制流。 catch块必须从异常条件中恢复，或者抛出适合于catch块上下文的异常。\n\n",
        "examples": {
            "good": {
                "java": [
                    "import java.io.*;\n\npublic class j_err00_0 {\n\n public void foo0(String fileName) {\n try {\n BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));\n int b;\n while ((b = reader.read()) != -1) {\n System.out.println(\"byte: \" + b);\n }\n } catch (IOException ioe) {\n throw new IllegalIOException(ioe.toString()); // we assume there is such exception handler here\n }\n }\n\n public void foo1(String fileName) {\n // indentation preserved to better show the difference with \\\"avoid\\\" example\n BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));\n int b;\n while ((b = reader.read()) != -1) {\n System.out.println(\"byte: \" + b);\n }\n\n }\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "import java.io.*;\n\npublic class j_err00_0 {\n\n public void foo0(String fileName) {\n try {\n BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));\n int b;\n while ((b = reader.read()) != -1) {\n System.out.println(\"byte: \" + b);\n }\n } catch (IOException ioe) {\n ioe.printStackTrace(); // print will not recover nor throw exception \n }\n }\n\n public void foo1(String fileName) {\n try {\n BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));\n int b;\n while ((b = reader.read()) != -1) {\n System.out.println(\"byte: \" + b);\n }\n } catch (IOException ioe) {\n // do nothing - no recovery of any kind\n }\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 91,
        "category": "VUL",
        "language": "Java",
        "code": "FIO08-J",
        "name": "从流读取的字符或字节与-1是不同的",
        "desc": "程序无法区分read（）方法读取的字符和流结束指示符。",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func}无法区分read()方法读取的字符和流结束指示符。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n程序无法区分read()方法读取的字符和流结束指示符。\n\n#### 解释\n用InputStream.read()和Reader.read()来读字节流，字节流以32位的数值-1结尾。正确的检查应当在字节流转换成字节或者字符之前。",
        "examples": {
            "good": {
                "java": [
                    "// read result is cast to byte after read and check for end of stream\npublic class j_fio08_0 {\n\n  // ...\n\n  static void readData(String fileName) throws FileNotFoundException, IOException {\n    FileInputStream t = new FileInputStream(fileName);\n    try {\n      int inputbuf;\n      byte data;\n      StringBuffer value = new StringBuffer();\n      while((inputbuf = t.read()) != -1) {\n\tdata = (byte) inputbuf;\n        value.append(data);\n      }\n      System.out.println(value.toString());\n    } finally {\n      t.close();\n    }\n  }\n\n  static void readData2(String fileName) throws IOException {\n    FileReader fr = new FileReader(fileName);\n    try {\n      int inputbuf;\n      char data;\n      StringBuffer sb = new StringBuffer();\n      while (inputbuf = fr.read()) != -1) {\n\tdata = (char)inputbuf;\n        sb.append(data);\n      }\n    } finally {\n      fr.close();\n    }\n  }\n\n  static void readData3(String fileName) throws IOException {\n    FileReader fr = new FileReader(fileName);\n    try {\n      byte data;\n      StringBuffer sb = new StringBuffer();\n      while (true) {\n        int i = fr.read();\n        int j = i;\n        data = (byte) j;\n        if (data == -1) {\n          break;\n        }\n        sb.append(data);\n      }\n    } finally {\n      fr.close();\n    }\n  }"
                ]
            },
            "bad": {
                "java": [
                    "// read result is cast to byte, loop will halt prematurely if 0xFF is reached\npublic class j_fio08_0 {\n  // ... \n  static void readData(String fileName) throws FileNotFoundException, IOException {\n    FileInputStream t = new FileInputStream(fileName);\n    try {\n      byte data;\n      StringBuffer value = new StringBuffer();\n      while((data = (byte) t.read()) != -1) {\n        value.append(data);\n      }\n      System.out.println(value.toString());\n    } finally {\n      t.close();\n    }\n  }\n\n  static void readData2(String fileName) throws IOException {\n    FileReader fr = new FileReader(fileName);\n    try {\n      char data;\n      StringBuffer sb = new StringBuffer();\n      while ((data = (char) fr.read()) != -1) {\n        sb.append(data);\n      }\n    } finally {\n      fr.close();\n    }\n  }\n\n  static void readData3(String fileName) throws IOException {\n    FileReader fr = new FileReader(fileName);\n    try {\n      byte data;\n      StringBuffer sb = new StringBuffer();\n      while (true) {\n        int i = fr.read();\n        int j = i;\n        data = (byte) j;\n        if (data == -1) {\n          break;\n        }\n        sb.append(data);\n      }\n    } finally {\n      fr.close();\n    }\n  }"
                ]
            }
        }
    },
    {
        "master_id": 92,
        "category": "VUL",
        "language": "c,c++",
        "code": "FIO30-C",
        "name": "格式规范中的字符串参数来自不受信任的源头",
        "desc": "该程序含有的格式规范包含了char类型（即字符串）参数，其来源不受信任，因此被认定为已受污染。",
        "msg_templ": "在${si.filename}，第${si.line}行的函数${si.func}，在${si.var}调用了printf调用函数族，它有来自用户输入的未经清理的格式字符串。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序含有的格式规范包含了char类型（即字符串）参数，其来源不受信任，因此被认定为已受污染。\n\n#### 解释\n格式化的I/O函数可能会被诱导去覆盖或读取任意内存位置的值。当输入来源不受信任时，最好不要使用格式字符串以及相关函数来执行I/O操作。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n int var_to_hold_content; // the variable where printf will store content of an address\n if (argc > 2) {\n scanf(argv[1]); // get a string from stdin (user input)\n fputs(argv[1, stdout]); // do not use printf with format specification\n }\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n int var_to_hold_content; // the variable where printf will store content of an address\n if (argc > 2) {\n scanf(argv[1]); // get a string from stdin (user input)\n printf(argv[1]); // user can read any address to a variable using a format specification\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 93,
        "category": "VUL",
        "language": "c,c++",
        "code": "MSC41-C",
        "name": "不应暴露程序中硬编码的敏感信息",
        "desc": "该程序有可读取形式的硬编码敏感信息（例如密码、密钥）。",
        "msg_templ": "在${si.filename}，第${si.line}行的函数${si.func}，有可读取的硬编码敏感信息。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序有可读取形式的硬编码敏感信息（例如密码、密钥）。\n\n#### 解释\n即使在可执行文件里，字符串或其它可读取形式的敏感信息都是可以被检查到的。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n\nint check_passwd(const char *s);\n\nint func(void)\n{\n    // user inputs password so no sensitive\n    // data leaked\n    #define PASSWORD_LEN 10\n    char password[PASSWORD_LEN];\n    printf(\"Please enter your password:\\n\");\n    fgets(password, sizeof(password), stdin);\n\n    int check = check_passwd(password);\n    memset_s(password, 0, sizeof(password));\n    // program logic\n    // ...\n    if (check)\n    {\n        // ... continue\n    }\n    else\n    {\n        // handle error\n        // ...\n    }\n}\n\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n\n#define BUF_SZ 1024\n\nint check_passwd(const char *s);\n\nint func(void)\n{\n    // program logic\n    // ...\n\n    // sensitive data is revealed below \n    if (check_passwd(\"admin\"))\n    {\n        // ... continue\n    }\n    else\n    {\n        // handle error\n        // ...\n    }\n}"
                ]
            }
        }
    },
    {
        "master_id": 94,
        "category": "VUL",
        "language": "Java",
        "code": "FIO52-J",
        "name": "存储在客户端的敏感信息，应进行加密",
        "desc": "程序在客户端存储了未加密的敏感信息。",
        "msg_templ": "在${si.filename}，${si.func} 第${si.line}行，未加密的敏感数据经過${si.var}存储在客户端。",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n程序在客户端存储了未加密的敏感信息。\n\n#### 解释\n如果在客户端提供并存储了未加密的敏感信息，则攻击者可以直接或间接地获取这些信息来攻击客户端计算机。\n",
        "examples": {
            "good": {
                "java": [
                    "import javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.Cookie;\ninterface Login {\n public Boolean isUserValid(String userName, char[] passwd);\n}\n\nclass LoginImpl implements Login {\n public Boolean isUserValid(String userName, char[] passwd) {\n // do the checking\n return true;\n }\n}\n\npublic class fio52_0 {\n protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n \n String username = request.getParameter(\"username\");\n char[] password = request.getParameter(\"password\").toCharArray();\n String userInfo = request.getParameter(\"userInfo\");\n \n Login login = new LoginImpl();\n \n if (request.getCookies()[0] != null &&\n request.getCookies()[0].getValue() != null) {\n String[] value = request.getCookies()[0].getValue().split(\";\");\n \n if (!login.isUserValid(value[0], value[1].toCharArray())) {\n // Set error and return\n } else {\n // Forward to welcome page\n }\n } else {\n boolean validated = login.isUserValid(username, password);\n \n if (validated) {\n Cookie loginCookie = new Cookie(\"MyCookie\", username + \";\" + new String(password));\n Cookie infoCookie = new Cookie(\"userInfo\", username + \":\" + userInfo);\n loginCookie.setHttpOnly(true); // use http protocol only\n loginCookie.setSecure(true); // set loginCookie through secure protocol\n response.addCookie(loginCookie); // sensitive cookie is encrypted and sent through secure protocol \n infoCookie.setSecure(true); // set infoCookie sent by secure protocol\n response.addCookie(infoCookie);\n  \n // ... Forward to welcome page\n } else {\n // Set error and return\n }\n }\n } \n}"
                ]
            },
            "bad": {
                "java": [
                    "import javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.Cookie;\ninterface Login {\n public Boolean isUserValid(String userName, char[] passwd);\n}\n\nclass LoginImpl implements Login {\n public Boolean isUserValid(String userName, char[] passwd) {\n // do the checking\n return true;\n }\n}\n\npublic class fio52_0 {\n protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n \n String username = request.getParameter(\"username\");\n char[] password = request.getParameter(\"password\").toCharArray();\n String userInfo = request.getParameter(\"userInfo\");\n \n Login login = new LoginImpl();\n \n if (request.getCookies()[0] != null &&\n request.getCookies()[0].getValue() != null) {\n String[] value = request.getCookies()[0].getValue().split(\";\");\n \n if (!login.isUserValid(value[0], value[1].toCharArray())) {\n // Set error and return\n } else {\n // Forward to welcome page\n }\n } else {\n boolean validated = login.isUserValid(username, password);\n \n if (validated) {\n Cookie loginCookie = new Cookie(\"MyCookie\", username + \";\" + new String(password));\n Cookie infoCookie = new Cookie(\"userInfo\", username + \":\" + userInfo);\n loginCookie.setSecure(false); // set loginCookie sent by any protocol\n response.addCookie(loginCookie); // [FIO52-J] sensitive cookie, should be encrypted or sent through secure protocol \n infoCookie.setSecure(true); // set infoCookie sent by secure protocol\n \\t response.addCookie(infoCookie);\n \\t \n // ... Forward to welcome page\n } else {\n // Set error and return\n }\n }\n } \n}"
                ]
            }
        }
    },
    {
        "master_id": 95,
        "category": "VUL",
        "language": "Java",
        "code": "IDS07-J",
        "name": "请勿把不受信任数据作为输入传递给Runtime.exec()方法",
        "desc": "该程序将不受信任数据作为输入传递给了Runtime.exec()方法。",
        "msg_templ": "在${si.filename}，第${si.line}行的字符串${si.var}在传递给runtime()之前未经过清理。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序将不受信任数据作为输入传递给了Runtime.exec()方法。\n\n#### 解释\n传递给Runtime.exec()的不受信任数据会暴露系统使其受到参数注入攻击。字符串必须经过安全清理来删除像空格、双引号和“-”这样的字符。\n",
        "examples": {
            "good": {
                "java": [
                    "import java.io.InputStream;\n\npublic class ids07_0 { // example from CERT-J\n public static void main(String[] args) throws Exception {\n \n // dir is input from environment in which the app is running\n String dir = System.getProperty(\\\"dir\\\");\n if (!Pattern.matches(\\\"[0-9A-Za-z@.]+\\\", dir) { // whitelist characters allowed\n // report error and exit\n ...\n }\n Runtime rt = Runtime.getRuntime();\n \n // input from environment is directly concatenated and fed to Runtime.exec\n // Subject to command line injection\n Process proc = rt.exec(\\\"bash -c ls \\\" + dir);\n \n int result = proc.waitFor();\n if (result != 0) {\n System.out.println(\\\"process error: \\\" + result);\n }\n // continue processing\n // ...\n }\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "import java.io.InputStream;\n\npublic class ids07_0 { // example from CERT-J\n public static void main(String[] args) throws Exception {\n \n // dir is input from environment in which the app is running\n String dir = System.getProperty(\\\"dir\\\");\n Runtime rt = Runtime.getRuntime();\n \n // input from environment is directly concatenated and fed to Runtime.exec\n // Subject to command line injection\n Process proc = rt.exec(\\\"bash -c ls \\\" + dir);\n \n int result = proc.waitFor();\n if (result != 0) {\n System.out.println(\\\"process error: \\\" + result);\n }\n // continue processing\n // ...\n }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 96,
        "category": "VUL",
        "language": "Java",
        "code": "IDS15-J",
        "name": "应安全清理/规范化敏感数据（输入和输出）",
        "desc": "应该要保持敏感数据的安全性，这包括输入和输出数据。",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func}中的敏感数据${si.var}有跨越信任边界而泄漏的情况。",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "HiGH",
        "details": "#### 概要\n应该要保持敏感数据的安全性，包括输入和输出数据边界泄漏。\n\n#### 解释\n敏感信息不应该被允许跨越信任边界而泄漏，这有助于保持复杂系统里不同子系统的完整性和安全性。 \n",
        "examples": {
            "good": {},
            "bad": {
                "java": [
                    "import javax.servlet.http.HttpServletRequest;\n\npublic class j_ids15_0\n{\n public void setSession(HttpServletRequest request, String attrName, String attrValue) {\n request.getSession().setAttribute(attrName, attrValue);\n }\n\n public void configSession(HttpServletRequest request) {\n String value = request.getParameter(\\\"Config\\\");\n String data = System.getenv(\\\"APP_DATA\\\");\n if(value.startsWith(\\\"APP_DATA\\\")) {\n setSession(request, \\\"APP_DATA\\\", data); // sensitive data\n } else if(value.startsWith(\\\"SAFE_DATA\\\")) {\n String safeData = Encryption(data);\n setSession(request, \\\"SAFE_DATA\\\", safeData); // data sanitized\n } else {\n setSession(request, \\\"attr\\\", \\\"value\\\");\n }\n }\n\n public String Encryption(String data) {\n // encrypt the input data\n // ...\n String safeData = data.replace(\\\"a\\\", \\\"z\\\");\n return safeData;\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 97,
        "category": "VUL",
        "language": "Java",
        "code": "MSC03-J",
        "name": "不要把敏感信息硬编码在程序中",
        "desc": "该程序硬编码了敏感信息。",
        "msg_templ": "在${si.filename}，第${si.line}行，函数${si.func}中，${si.var}有硬编码的敏感信息。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n该程序硬编码了敏感信息。\n\n#### 解释\n安全和隐私敏感型信息应该在执行时从安全的文件里取回。Java可执行文件是字节码的形式，它能轻易地转换回有纯文本形式信息的源代码形式。\n",
        "examples": {
            "good": {
                "java": [
                    "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class msc03_0 {\n public final Connection getConnection() throws SQLException, UnknownHostException {\n \n // IP address class to fill in at runtime. The address should be cleared immediately after use\n class IPAddress {\n // IP address in string\n char[] ipAddress = new char[128];\n try {\n // read in from some secure channel or file\n ...\n }\n finally {\n // clear after use\n Arrys.fill(ipAddress, (byte)0);\n // close file or channel\n ...\n }\n \n }\n if (InetAddress.getByName(ipAddress).isAnyLocalAddress()){\n // hard coded username and password\n String username, password;\n // Username and password should be read from a secure config file/channel at rungime\n return DriverManager.getConnection(\\\"dbhost:mysql://localhost/mydb\\\", username, password);\n }\n return DriverManager.getConnection(\\\"dbhost:mysql://localhost/dbName\\\", \\\"username\\\", \\\"password\\\");\n }\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class msc03_0 {\n public final Connection getConnection() throws SQLException, UnknownHostException {\n \n // hard coded IP address in String\n String ipAddress = new String(\\\"184.15.254.1\\\");\n if (InetAddress.getByName(ipAddress).isAnyLocalAddress()){\n // hard coded username and password\n return DriverManager.getConnection(\\\"dbhost:mysql://localhost/mydb\\\", \\\"7f4j9vj\\\", \\\"xsi9j2nn8\\\");\n }\n return DriverManager.getConnection(\\\"dbhost:mysql://localhost/dbName\\\", \\\"username\\\", \\\"password\\\");\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 98,
        "category": "VUL",
        "language": "Java",
        "code": "OBJ07-J",
        "name": "具有敏感数据的类应受到保护，防止被复制或克隆",
        "desc": "具有敏感数据的类应受到保护, 不被复制或克隆。",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.var}是可以被复制或克隆的。",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n具有敏感数据的类应受到保护, 不被复制或克隆.\n\n#### 解释\n具有敏感数据的类在被恶意克隆或复制时，可能会导致违反关键数据不变属性的线程安全问题。\n",
        "examples": {
            "good": {
                "java": [
                    "public class j_obj07_fp_1 \n{\n private String userName;\n private char[] passwd;\n\n public j_obj07_fp_1(String name, String pass) {\n userName = name;\n passwd = pass.toCharArray();\n }\n\n // [certj pages]\n // sensitive class define clone() and throws CloneNotSupportedException\n // and clone() method marked finalclone\n // Well behaved clone that prevents subclasses from being made cloneable by defining a final clone that always fails\n public final j_obj07_fp_1 clone() throws CloneNotSupportedException {\n throw new CloneNotSupportedException();\n }\n\n void resetPasswd() {\n for(int i = 0; i < passwd.length; i++) {\n passwd[i] = 'a';\n } \n }\n\n void display() {\n System.out.println(\\\"UserName addr:\\\" + System.identityHashCode(userName));\n System.out.println(\\\"Passwd addr:\\\" + System.identityHashCode(passwd));\n System.out.print(\\\"User:\\\" + userName + \\\" passwd:\\\");\n System.out.println(passwd);\n }\n\n public static void main(String[] args) {\n j_obj07_fp_1 obj1= new j_obj07_fp_1(\\\"user1\\\", \\\"abcdef\\\");\n try {\n j_obj07_fp_1 obj2 = (j_obj07_fp_1)obj1.clone();\n obj2.resetPasswd();\n obj1.display();\n obj2.display();\n } catch (CloneNotSupportedException e) {\n System.out.println(\\\"Error: clone is not allowed for sensitive class\\\");\n }\n }\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "public class j_obj07_sensitive\n{\n private String userName;\n private char[] passwd;\n\n public j_obj07_sensitive(String name, char[] pass) { // OBJ07-J: class not provide clone throw exception and mark final\n userName = name;\n passwd = pass;\n } \n\n public String getUserName() {\n return userName;\n }\n\n public char[] getPasswd() {\n return passwd;\n }\n\n protected void resetPasswd() {\n for(int i = 0; i < passwd.length; i++) {\n passwd[i] = 'a';\n }\n }\n\n void display() {\n System.out.println(\\\"UserName addr:\\\" + System.identityHashCode(userName));\n System.out.println(\\\"Passwd addr:\\\" + System.identityHashCode(passwd));\n System.out.print(\\\"User:\\\" + userName + \\\" passwd:\\\");\n System.out.println(passwd);\n }\n\n}"
                ]
            }
        }
    },
    {
        "master_id": 99,
        "category": "VUL",
        "language": "Java",
        "code": "SEC01-J",
        "name": "不允许在权限代码块里有不受信任数据",
        "desc": "该程序在权限代码块里有不受信任数据。",
        "msg_templ": "在${si.filename}，第${si.line}行，敏感信息可能已经通过${si.func}中的${si.var}被泄露。 ",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### 概要\n该程序在权限代码块里有不受信任数据。\n\n#### 解释\n不受信任数据可能含有特殊字符，它最终会形成受污染的路径或文件名。攻击者能利用进入权限代码块的受污染数据以达到恶意企图。\n",
        "examples": {
            "good": {
                "java": [
                    "import java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.security.AccessController;\nimport java.security.PrivilegedActionException;\nimport java.security.PrivilegedExceptionAction;\n\npublic class sec01_0 { // edited from CERT-J example\n // input file name gone through sanitization and normalization before \n // enter the doPrivileged() block\n }\n private void privilegedMethod(final String filename)\n throws FileNotFoundException {\n \n final String sanitizeFilename;\n try {\n sanitizeFilename = sanitizeFilename(filename);\n } catch {\n // call handler appropriately \n ...\n }\n \n try {\n FileInputStream fis =\n (FileInputStream) AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () -> {\n return new FileInputStream(filename);\n });\n // Do something with the file and then close it\n } catch (PrivilegedActionException e) {\n // Forward to handler\n }\n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "import java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.security.AccessController;\nimport java.security.PrivilegedActionException;\nimport java.security.PrivilegedExceptionAction;\n\npublic class sec01_0 { // edited from CERT-J example\n // input file name may be tainted since origin is unknown\n // should have gone through sanitization and normalization before \n // enter the doPrivileged() block\n private void privilegedMethod(final String filename)\n throws FileNotFoundException {\n try {\n FileInputStream fis =\n (FileInputStream) AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () -> {\n return new FileInputStream(filename);\n });\n // Do something with the file and then close it\n } catch (PrivilegedActionException e) {\n // Forward to handler\n }\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 100,
        "category": "VUL",
        "language": "c++",
        "code": "DCL55-CPP",
        "name": "当跨信任边界传输类对象时发生信息泄漏",
        "desc": "程序中有类别的填充位可能含有敏感数据。使用后,它们并未被清除。",
        "msg_templ": "",
        "severity": "LOW",
        "likelihood": "UNLIKELY",
        "cost": "LOW",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 101,
        "category": "VUL",
        "language": "Java",
        "code": "ENV01-J",
        "name": "应在单个JAR里签名并密封对安全性敏感的代码",
        "desc": "程序经过代码签名以验证代码的来源。这样的代码会包含一些执行特权操作的代码。",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is code signed to authenticate the origin of the code. Such code should contain some code that performs privileged operations.\n\n#### Explanation\nCode signing is usually taken as trusted and safe to execute code. Many systems are configured to \\\"Always trust\\\". The implied permission can easily be exploited.\n\n",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 102,
        "category": "VUL",
        "language": "c,c++",
        "code": "FIO21-C",
        "name": "临时文件不应存储在共享目录中",
        "desc": "程序在共享目录中创建了临时文件，但没有删除或防止访问程序来避免共享目录受到攻击。",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "### 概要\n程序在共享目录中创建了临时文件，但没有删除或防止访问程序来避免共享目录受到攻击。\n\n#### 解释\n当数据需要从一个进程传输到另一个而不能保存在内存中的时候，创建临时文件通常被用作传输数据的一种方式。如果对于这些临时文件没有清理操作，或者临时文件名是可预测的，那么就容易造成攻击者攻击这些临时文件。要是这些临时文件包含敏感信息，那么后果将会非常严重。\n",
        "examples": {
            "good": {},
            "bad": {
                "c": [
                    "void func(const char * file_name) {\nFILE *fp=fopen(file_name),\"wb+\";\nif(fp == NULL){\nreturn\n}\n// write to file ...\nfclose(fp)\n}"
                ]
            }
        }
    },
    {
        "master_id": 103,
        "category": "VUL",
        "language": "c++",
        "code": "DCL56-CPP",
        "name": "静态对象的初始化不应具有循环依赖关系",
        "desc": "程序在初始化静态对象时进行递归调用。因此可能有无序的初始化，这样递归也可能会导致意外的行为。",
        "msg_templ": "",
        "severity": "LOW",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 104,
        "category": "VUL",
        "language": "c++",
        "code": "FIO51-CPP",
        "name": "在程序终止前应关闭文件",
        "desc": "在程序终止之前程序未有关闭已打开的文件。",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func}在程序终止之前未关闭已打开的文件。",
        "severity": "MEDIUM",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 105,
        "category": "VUL",
        "language": "c++",
        "code": "MEM52-CPP",
        "name": "内存分配失败应得到适当处理",
        "desc": "默认的allocators不会检查allocation的结果，即使它产生任何异常。任何错误都必须被捕捉和处理。",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "### 概要\n默认的allocators不会检查allocation的结果，即使它产生任何异常。任何错误都必须被捕捉和处理。\n\n#### 解释\nC++中最常用的内存分配操作程序为::operator new(std::size_t)， 当分配失败时，会抛出std::bad_alloc。新的分配操作程序也有不抛出错误的版本::operator new(std::size_t, const std::nothrow_t&)，会给出nullptr而不抛出异常。不论何种分配操作程序，都应该有对应错误检查的功能。异常必须通过catch来处理，而nullptr也应该被检查，来避免程序的突然终止  \n",
        "examples": {
            "good": {},
            "bad": {
                "cpp": [
                    "#include <cstring>\n#include <new>\n\n void f(std::size_t size) noexcept {\nint *var = new int[size];\nvar[0]=5;\ndelete[] var;\n}"
                ]
            }
        }
    },
    {
        "master_id": 106,
        "category": "VUL",
        "language": "c++",
        "code": "MSC50-CPP",
        "name": "使用比std :: rand（）更强的伪随机数生成器",
        "desc": "程序使用了std:：rand（），对于随机数序列不是一个好的选择。",
        "msg_templ": "",
        "severity": "MEDIUM",
        "likelihood": "UNLIKELY",
        "cost": "LOW",
        "details": "### 概要\n程序使用了std::rand()，对于随机数序列不是一个好的选择。\n\n#### 解释\n伪数字生成器譬如rand()运用数学算法使得产生的数字不是完全随机。由std::rand()产生的数字，由于其周期相对较短，因此对随机数序列来说质量还不够好。因此，不建议使用rand() \n",
        "examples": {
            "good": {},
            "bad": {
                "cpp": [
                    "#include <iostream>\n#include<string>\n\nvoid func(void){\nstd::string id{\\\"id\\\"};\nid += std::to_string(std::rand()%1000);\n}"
                ]
            }
        }
    },
    {
        "master_id": 107,
        "category": "VUL",
        "language": "c++",
        "code": "MSC52-CPP",
        "name": "有返回值的函数必须确保所有退出路径都返回一个值",
        "desc": "程序具有non-void return函数，但该函数有执行路径将到达出口而不会遇到“return”语句。",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func}虽然有non-void return但在该函数结束时都不会遇到return语句。",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "### 概要\n程序具有non-void return函数，但该函数有执行路径将到达出口而不会遇到“return”语句。 \n\n#### 解释\n当调用函数时会预期有返回指，然后不是所有的代码路径都会返回一个值，而这可能会造成未定义的行为。 \n",
        "examples": {
            "good": {},
            "bad": {
                "cpp": [
                    "int get_number(int x){\nif(x>=1 && x<=10) return x;\n}"
                ]
            }
        }
    },
    {
        "master_id": 108,
        "category": "VUL",
        "language": "Java",
        "code": "OBJ05-J",
        "name": "不应返回并暴露非公开且可变的类成员的引用",
        "desc": "程序正在返回声明为非公开的可变类成员的引用。",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n程序正在返回声明为非公开的可变类成员的引用。\n\n#### 解释\n返回声明为非公开的可变类成员的引用会造成解封并可能引发非公开对象被不可信任的方法操作调用。\n",
        "examples": {
            "good": {
                "java": [
                    "import java.util.Date;\n\npublic class obj05_0 {\n private Data private_d;\n\n // this class is mutable\n public obj05_0() {\n private_d = new Data();\n }\n\n // a copy is returned, hence, no leakage using this method\n public Data getDataSafe() {\n return (Data)d.clone();\n }\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "import java.util.Date;\n\npublic class obj05_0 {\n    private Data private_d;\n\n    // this class is mutable\n    public obj05_0() {\n        // private_d is declared private, and is being returned \n        // thus exposes the internal mutable component to untrustable caller\n        private_d = new Data();\n}\n\npublic Data getData() {\n    return private_d;\n}\n\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 109,
        "category": "VUL",
        "language": "Java",
        "code": "ENV02-J",
        "name": " 环境变量应视为不可信",
        "desc": "程序对环境变量的使用可能被利用为攻击的漏洞。",
        "msg_templ": "",
        "severity": "LOW",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 110,
        "category": "VUL",
        "language": "Java",
        "code": "ENV04-J",
        "name": "不应关闭字节码验证",
        "desc": "Java类有文件未进行验证, 这些文件可能来自不受信任的来源。",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 111,
        "category": "VUL",
        "language": "Java",
        "code": "ENV05-J",
        "name": "不应在产品中部署远程监视的应用程序",
        "desc": "程序无法禁用远程监视。",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "LOW",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 112,
        "category": "VUL",
        "language": "Java",
        "code": "JNI01-J",
        "name": "安全地调用标准API",
        "desc": "程序通过loadLibrary方法代表不受信任的代码来调用标准API。",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 113,
        "category": "VUL",
        "language": "Java",
        "code": "OBJ01-J",
        "name": "对象的字段访问必须正确管理",
        "desc": "程序可能通过使用公有成员修饰符暴露敏感字段。",
        "msg_templ": "",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n程序可能通过使用公有成员修饰符暴露敏感字段。\n",
        "examples": {
            "good": {
                "java": [
                    "import java.util.List;\n\npublic class j_obj01_0 {\n\n  private static final String[] items = {\"abc\", \"def\", \"ghj\"/* ... */};\n\n  public static final List<String> itemsList =\n    Collections.unmodifiableList(Arrays.asList(items));\n\n  public static final String[] getItems() {\n    return items.clone();\n  }\n  public static final String getItem(int index) {\n    return items[index];\n  }\n\n  public static final int getItemCount() {\n    return items.length;\n  }\n\n  private static final HashMap<Integer, String> hm = new HashMap<Integer, String>();\n\n  public static String getElement(int key) {\n    return hm.get(key);\n  }\n\n  private int total; // Declared private\n\n  public int getTotal () {\n    return total;\n  }\n\n}"
                ]
            },
            "bad": {
                "java": [
                    "import java.util.List;\n\npublic class j_obj01_0 {\n\n  private static final String[] items = {\"abc\", \"def\", \"ghj\"/* ... */};\n\n  public static final List<String> itemsList =\n    Collections.unmodifiableList(Arrays.asList(items));\n\n  public static final String[] getItems() {\n    return items.clone();\n  }\n  public static final String getItem(int index) {\n    return items[index];\n  }\n\n  public static final int getItemCount() {\n    return items.length;\n  }\n\n  private static final HashMap<Integer, String> hm = new HashMap<Integer, String>();\n\n  public static String getElement(int key) {\n    return hm.get(key);\n  }\n\n  public int total; // Unprotected\n\n  public int getTotal () {\n    return total;\n  }\n\n}"
                ]
            }
        }
    },
    {
        "master_id": 114,
        "category": "VUL",
        "language": "Java",
        "code": "OBJ13-J",
        "name": "对可变对象的引用不应显示给客户端",
        "desc": "程序会引用可变对象並且公开给用户端，在用户端可以自由修改。",
        "msg_templ": "",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 115,
        "category": "VUL",
        "language": "Java",
        "code": "SEC03-J",
        "name": "受信任类必须由受信任类加载器加载",
        "desc": "程序可以允许来自不受信任来源的类加载器加载受信任的类。",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 116,
        "category": "VUL",
        "language": "Java",
        "code": "SEC04-J",
        "name": "应该用适当的security manager来检查及保护敏感操作",
        "desc": "程序允许绕过安全管理器检查的敏感方法调用。",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 117,
        "category": "VUL",
        "language": "Java",
        "code": "SEC05-J",
        "name": "不要使用反射来修改类，方法或字段的可访问性",
        "desc": "程序有使用Java反射API来改变某些字段的可访问性。",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 118,
        "category": "VUL",
        "language": "Java",
        "code": "SER01-J",
        "name": "在生成自定义序列化方法时，请遵循正确的签名",
        "desc": "程序未正确使用序列化方法的签名。",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 119,
        "category": "VUL",
        "language": "Java",
        "code": "SER04-J",
        "name": "序列化和反序列化应通过安全管理器",
        "desc": "程序在不进行安全检查的情况下进行序列化，会导致允许不受信任的代码修改类的内部状态。",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 120,
        "category": "VUL",
        "language": "Java",
        "code": "SER05-J",
        "name": "避免内部类的序列化",
        "desc": "程序包含实现Serializable接口的内部类。",
        "msg_templ": "",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 121,
        "category": "VUL",
        "language": "Java",
        "code": "SER08-J",
        "name": "如果反序列化需要特权，应将权限剥离到预期使用的最低限度",
        "desc": "程序会在特权上下文中执行反序列化。",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 122,
        "category": "VUL",
        "language": "Java",
        "code": "IDS53-J",
        "name": "防止XPath注入",
        "desc": "用来从XML获取数据的字符串在输入前需要进行适当清理",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func}中的${si.var}在用来从XML获取数据前未经过适当清理。 ",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "LOW",
        "details": "#### 概要\n此程序正在使用字符串输入从XML文档中检索数据，然而此输入在检索前未经过适当清理。\n\n#### 解释\n此程序正在使用字符串输入从XML文档中检索数据，然而此输入并未经过充分清理和验证。这有可能会发生恶意用户定制SQL或者XML检索输入使得结果恒真，从而使攻击者访问到受限信息。",
        "examples": {
            "good": {
                "java": [
                    "import javax.xml.xpath.*;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\nimport java.io.FileInputStream;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NodeList;\npublic class j_ids53_0 {\n  private final String accountFile = \"account.xml\";\n  private DocumentBuilder docBuilder;\n  private XPath xpath;\n\n  // the code below trying to query account Info with given id\n  public String queryAccountInfo(String id) throws XPathExpressionException, SAXException, IOException {\n    Document accountDoc = docBuilder.parse(accountFile);\n    Map queryVars = new HashMap();\n\n    // validate input \"id\" using StringEscapeUtils\n    String filteredId = StringEscaptUtils.escapeXml(id);\n    String compileStr = \"/Accounts/account[@id='\" + filteredId + \"']\";\n    String res = xpath.evaluate(compileStr, accountDoc); \n    return res;\n  }\n}\n\n"
                ]
            },
            "bad": {
                "java": [
                    "package io.xc5.cert;\n\nimport javax.xml.xpath.*;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\nimport java.io.FileInputStream;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NodeList;\n\npublic class example_bad {\n  private final String accountFile = \"account.xml\";\n  private DocumentBuilder docBuilder;\n  private XPath xpath;\n\n  // the code below trying to query account Info with given id\n  public String queryAccountInfo(String id) throws XPathExpressionException, SAXException, IOException {\n    Document accountDoc = docBuilder.parse(accountFile);\n\n    // attacker can inject by provide id with '1'='1 causing evaluate to return \"true\"\n    String compileStr = \"/Accounts/account[@id='\" + id + \"']\"; \n    String res = xpath.evaluate(compileStr, accountDoc); // IDS53-J\n    return res;\n  }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 123,
        "category": "VUL",
        "language": "Java",
        "code": "IDS54-J",
        "name": "防止LDAP注入",
        "desc": "用来远程访问系统目录的字符串在输入前需要进行适当清理和验证",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func}中的${si.var}在用来远程访问系统目录前未经过适当清理和验证。 ",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "LOW",
        "details": "#### 概要\n此程序在使用LDAP进行远程操作，然而并未有充分的输入清理及验证。\n\n#### 解释\n此程序正在使用轻量型目录访问协议来进行远程操作，然而并未有充分的输入清理和验证，这可能会造成恶意用户访问到受限信息。",
        "examples": {
            "good": {
                "java": [
                    "import javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.InitialDirContext;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\n\npublic class example_good\n{\n  public NamingEnumeration<SearchResult> queryUserInfo(InitialDirContext ctx, String id) throws NamingException {\n    SearchControls sc = new SearchControls();\n    sc.setReturningAttributes(new String[]{\"balance\", \"phone\"});\n    sc.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n    String searchBase = \"dc=Users,dc=com\";\n\n    // check against special characters \n    if (!id.matches(\"[\\\\w\\\\s]*\") || !id.matches(\"[\\\\w]*\")) {\n      throw new IllegalArgumentException(\"Invalid input\");\n    }\n    \n    String filter = \"(id=\" + id + \")\"; // attacker can inject by provide id with \"*\"\n    return ctx.search(searchBase, filter, sc); // IDS54-J, query user info with id \n  }\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "import javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.InitialDirContext;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\n\npublic class example_bad\n{\n  public NamingEnumeration<SearchResult> queryUserInfo(InitialDirContext ctx, String id) throws NamingException {\n    SearchControls sc = new SearchControls();\n    sc.setReturningAttributes(new String[]{\"balance\", \"phone\"});\n    sc.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n    String searchBase = \"dc=Users,dc=com\";\n    String filter = \"(id=\" + id + \")\"; // attacker can inject by provide id with \"*\"\n    return ctx.search(searchBase, filter, sc); // IDS54-J, query user info with id \n  }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 124,
        "category": "VUL",
        "language": "Java",
        "code": "IDS06-J",
        "name": "从格式字符串中排除未经过滤的用户输入",
        "desc": "格式字符串不应包括未经适当清理和验证的输入",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func}中的${si.var}在包括未经适当清理和验证的输入。 ",
        "severity": "MEDIUM",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "#### 概要\n此程序中的格式字符串含有未经过清理的用户输入。\n\n#### 解释\n来源不受信任且未经过清理的输入，不应被包含在格式字符串中。否则会导致数据泄露或阻断服务攻击。",
        "examples": {
            "good": {
                "java": [
                    "\nimport java.util.Calendar;\nimport java.util.GregorianCalendar;\n\n// this example is taken from CERT-J site Dashboard\n// \npublic class example_bad {\n  static Calendar c = new GregorianCalendar(1995, GregorianCalendar.MAY, 23);\n  public static void main(String[] args) {\n    // simply compare input with c\n    System.out.format(\n      \"%s did not match! HINT: It was issued on %terd of some month\", args[0], c\n    );\n  }\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "\nimport java.util.Calendar;\nimport java.util.GregorianCalendar;\n\n// this example is taken from CERT-J site Dashboard\n// \npublic class example_bad {\n  static Calendar c = new GregorianCalendar(1995, GregorianCalendar.MAY, 23);\n  public static void main(String[] args) {\n    // Untrusted data is incorporated into the format string below.\n    // Attacker can expose the date against which input is compared against\n    // with some special input string, resulting in infomation leakage.\n    System.out.format(\n      args[0] + \"did not match! HINT: It was issued on %1$terd of some month\", c\n    );\n  }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 125,
        "category": "BAD_PRACTICE",
        "language": "c/c++",
        "code": "MSC30-C",
        "name": "不要使用rand（）函数生成伪随机数",
        "desc": "此程序正在使用伪随机数生成器，这有可能会生成可预测的数字序列",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func}程序正在使用伪随机数生成器，这有可能会生成可预测的数字序列。 ",
        "severity": "MEDIUM",
        "likelihood": "UNLIKELY",
        "cost": "LOW",
        "details": "#### 概要\n此程序正在使用伪随机数生成器，因此可能会生成可预测的数字序列。\n\n#### 解释\nrand()函数会生成不完全随机且周期较短的数字，使攻击者有可能会猜出下一个生成的数值。程序员应该使用更好且适当播种的随机函数。",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nvoid use_rand(void) {\n  int r;\n  int i;\n  time_t t;\n\n  // seeds the rand()\n  srand((unsigned) time(&t));\n  \n  // random is a better pseudorandom number generator\n  for (i = 0; i < 10; i++) {\n    r = random();\n    printf(\"Random %d is %d\\n\", i, r);\n  }\n  \n}\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n#include <stdlib.h>\n\nvoid use_rand(void) {\n  int r;\n  int i;\n\n  // the same sequence will be printed every time this function is called\n  for (i = 0; i < 10; i++) {\n    r = rand();\n    printf(\"Random %d is %d\\n\", i, r);\n  }\n  \n}\n"
                ]
            }
        }
    },
    {
        "master_id": 126,
        "category": "VUL",
        "language": "c/c++",
        "code": "INT32-C",
        "name": "确保对有符号整数的运算会被环绕或溢出",
        "desc": "程序在表达式中有符号整数运算会导致整数溢出或环绕",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func}在表达式中有符号整数运算。",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "HIGH",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 127,
        "category": "VUL",
        "language": "Java",
        "code": "IDS04-J",
        "name": "安全地从ZipInputStream中提取文件",
        "desc": "在未经过清理或者资源保护的情况下，此程序正在使用java.util.zip.ZipInputStream从zip文件中提取文件。",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func}在未经过清理或者资源保护的情况下从zip文件中提取文件。",
        "severity": "LOW",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "#### 概要\n在未经过清理或者资源保护的情况下，此程序正在使用java.util.zip.ZipInputStream从zip文件中提取文件\n\n#### 解释\n当使用java.util.zip从zip文件中提取文件时，文件名可能包含路径信息，这些文件名应做规范化处理并经过验证，以防止路径注入攻击。同时应注意监控资源使用情况，确保不会由于资源耗尽而造成服务中断。",
        "examples": {
            "good": {
                "java": [
                    "import java.util.zip.*;\nimport java.io.*;\n\n\npublic class IDS04J_good {\n    public static void main(String[] args) throws IOException, IllegalStateException {\n        String zipPath = args[0];\n        String destPath = args[1];\n        \n        // Fix vulnerability by canonicalizing path\n        File checkZip = new File(zipPath);\n        File checkDest = new File(destPath);\n        String canonicalZip =  checkZip.getCanonicalPath();\n        String canonicalDest =  checkDest.getCanonicalPath();\n\n        // Check result of canonicalization\n        if (!canonicalZip.startsWith(canonicalDest)) {\n            throw new IllegalStateException(\"Accesing Out of Bounds Area, set a correct path\");\n        }\n    \n        byte[] buffer = new byte[1024];\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(zipPath));\n        ZipEntry zipEntry = zis.getNextEntry();\n        File destDirectory = new File(destPath);\n\n        long sizeLimit = 0x6400000; \n        int fileLimit = 2000; \n        long currentSize =  0; \n        int entry = 0; \n\n        try {\n            // Limit size to avoid DoS attack through resource exhaustion      \n            while (zipEntry != null) {\n                // Limit number of files\n                if (entry > fileLimit){\n                    throw new IllegalStateException(\"Unzipped file exceed the allowed limit\");\n                } \n                // Limit size of file\n                if (currentSize > sizeLimit) {\n                    throw new IllegalStateException(\"Unzipped file exceed the allowed size\");\n                }\n\n                System.out.println(\"File being extracted: \" + zipEntry);\n                FileOutputStream fos = new FileOutputStream(destDirectory + \"/\" + zipEntry.getName());\n                \n                int len;\n                while ((len = zis.read(buffer)) > 0) {\n                    fos.write(buffer, 0, len);\n                    currentSize += len;\n                }\n                fos.close();\n                zipEntry = zis.getNextEntry();\n                entry++;\n            }\n        } \n        finally {\n        \tzis.close(); \t\n        }\n    }\n}\n\n\n"
                ]
            },
            "bad": {
                "java": [
                    "import java.util.zip.*;\nimport java.io.*;\n\n\npublic class IDS04J_bad {\n    public static void main(String[] args) throws IOException {\n        // Path may be manipulated to access areas outside of intended directory\n        String zipPath = args[0];\n        String destPath = args[1];\n\n        byte[] buffer = new byte[1024];\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(zipPath));\n        ZipEntry zipEntry = zis.getNextEntry();\n        File destDirectory = new File(destPath);\n\n        try {          \n            // Exhaustion of resource without limit to the size of zip files in while loop\n            while (zipEntry != null) {\n                System.out.println(\"File being extracted: \" + zipEntry);\n                FileOutputStream fos = new FileOutputStream(destDirectory + \"/\" + zipEntry.getName());\n\n                int len;\n                while ((len = zis.read(buffer)) > 0) {\n                    fos.write(buffer, 0, len);\n                }\n\n                fos.close();\n                zipEntry = zis.getNextEntry();\n            }\n        } \n        finally {\n        \tzis.close(); \t\n        }\n    }\n}\n\n\n"
                ]
            }
        }
    },
    {
        "master_id": 128,
        "category": "VUL",
        "language": "c,c++,java",
        "code": "IDS03-J",
        "name": "未经过清理的用户信息不应该被暴露",
        "desc": "当未经过清理的用户输入被记录或者以stdout输出时，可能造成敏感信息泄漏",
        "msg_templ": "",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 名称\n未经过清理的用户信息不应该被暴露\n\n#### 概要\n当未经过清理的用户输入被记录或者以stdout输出时，可能造成敏感信息泄漏\n\n#### 解释\n记录未经过清理的用户输入可能导致敏感信息在信任边界外泄漏。Log注入攻击会进一步引起信息泄漏。Java和C/C++程序都可能遭到类似的攻击（见示例）。",
        "examples": {
            "good": {
                "c": [
                    "\nusing namespace mychain;\nusing namespace MyContract::Sample;\n\nclass demoBranch:public Contract {\npublic:\n    TransferPtr m_ptransfer;\n\n    demoBranch() {\n        m_ptransfer = GetTransferM();\n    }\n    INTERFACE void Init() {\n        InitRoot();\n    }\n    \n    INTERFACE void LeakToLog(const std::string& sAccountName ) {\n        if(!m_ptransfer) {\n            Revert(\"error\");\n        }\n\n\t// get account, balance etc\n        AccountMMapPtr pAccountMap = m_ptransfer->get_accounts();\n        if (!pAccountMap) {\n            Revert(\"AcountMMapPtr Error.\");\n        }\n\n        // obtain user account number and name\n\t// ...\n\n\t//\n        int32_t iBalanceRmb = pBalance->get_rmb();\n        std::string sBalanceTopic = std::to_string(iBalanceRmb);\n        std::vector<std::string> leak_msg;\n        leak_msg.push_back(sAccountName);\n        leak_msg.push_back(sBalanceTopic);\n\n        if (iBalanceRmb < 1) {\n\t  // Sanitize and clean up message before logging\n          Log(std::string(\"acc_bal\"), SanitizeUser(leak_msg));\n        }\n    }\n};\nINTERFACE_EXPORT(demoBranch, (Init) (LeakToLog))\n"
                ],
                "java": [
                    "locationClient = new LocationClient(this, this, this);\nlocationClient.connect();\ncurrentUser.setLocation(locationClient.getLastLocation());\n... \n\ncatch (Exception e) {\n    AlertDialog.Builder builder = new AlertDialog.Builder(this);\n    builder.setMessage(\"Application Error.\");\n    AlertDialog alert = builder.create();\n    alert.show();\n\n    // user location is \"sanitized\" being written to log\n    Log.e(\"Example\", \"Caught exception: \" + e + \" User:\" + sanitizeUser(User.toString()));\n}\n"
                ]
            },
            "bad": {
                "c": [
                    "\nusing namespace mychain;\nusing namespace MyContract::Sample;\n\nclass demoBranch:public Contract {\npublic:\n    TransferPtr m_ptransfer;\n\n    demoBranch() {\n        m_ptransfer = GetTransferM();\n    }\n    INTERFACE void Init() {\n        InitRoot();\n    }\n    \n    INTERFACE void LeakToLog(const std::string& sAccountName ) {\n        if(!m_ptransfer) {\n            Revert(\"error\");\n        }\n\n\t// get account, balance etc\n        AccountMMapPtr pAccountMap = m_ptransfer->get_accounts();\n        if (!pAccountMap) {\n            Revert(\"AcountMMapPtr Error.\");\n        }\n\n        // obtain user account number and name\n\t// ...\n\n\t//\n        int32_t iBalanceRmb = pBalance->get_rmb();\n        std::string sBalanceTopic = std::to_string(iBalanceRmb);\n        std::vector<std::string> leak_msg;\n        leak_msg.push_back(sAccountName);\n        leak_msg.push_back(sBalanceTopic);\n\t\n        if (iBalanceRmb < 1) {\n          Log(std::string(\"acc_bal\"), leak_msg);\n        }\n    }\n};\nINTERFACE_EXPORT(demoBranch, (Init) (LeakToLog))\n"
                ],
                "java": [
                    "locationClient = new LocationClient(this, this, this);\nlocationClient.connect();\ncurrentUser.setLocation(locationClient.getLastLocation());\n... \n\ncatch (Exception e) {\n    AlertDialog.Builder builder = new AlertDialog.Builder(this);\n    builder.setMessage(\"Application Error.\");\n    AlertDialog alert = builder.create();\n    alert.show();\n\n    // user location is written to log\n    Log.e(\"Example\", \"Caught exception: \" + e + \" User:\" + User.toString());\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 129,
        "category": "",
        "language": "c/c++",
        "code": "FIO39-C",
        "details": "",
        "msg_templ": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 130,
        "category": "",
        "language": "c/c++",
        "code": "POS39-C",
        "details": "",
        "msg_templ": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 132,
        "category": "VUL",
        "language": "c/c++",
        "code": "MLU",
        "name": "缺少锁或者解锁函数的调用",
        "desc": "违反对互斥锁的锁和解锁函数须成对调用的惯用语法，缺少其一或另一个对应函数",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "LOW",
        "cost": "HIGH",
        "details": "#### 名称\n缺少锁或者解锁函数的调用\n\n#### 概要\n违反对互斥锁的锁和解锁函数须成对调用的惯用语法，缺少其一或另一个对应函数\n\n#### 解释\n线程必须通过正确调用对应的锁或者解锁函数来进入或者离开互斥区域，否则会导致其他线程饥饿问题。",
        "examples": {
            "good": {
                "c": [
                    "void hc1_good (int ret) {\n  int i;\n  for (i = 0; i < 100; i++){\n    pthread_mutex_lock(&g_struct[i].mutex);\n    if (ret > 0) {\n      if (ret < 100) {\n        printf(\"ret < 100\\n\");\n        pthread_mutex_unlock(&g_struct[i].mutex);\n        break;\n      }\n      else {\n\t// unlock before break \n        if (ret > 1000) {\n          printf(\"ret > 1000\\n\");\n          pthread_mutex_unlock(&g_struct[i].mutex);\n          break;\n        }\n      }\n    }\n    pthread_mutex_unlock(&g_struct[i].mutex);\n  }\n}\n \n"
                ]
            },
            "bad": {
                "c": [
                    "#include <pthread.h>\n#include <stdio.h>\n \ntypedef struct sMutex_Lock {\n  int index;\n  pthread_mutex_t mutex;\n} Mutex_Lock_Type;\n \nMutex_Lock_Type g_struct[100];\n \nvoid hc1_bad (int ret) {\n  int i;\n  for (i = 0; i < 100; i++){\n    pthread_mutex_lock(&g_struct[i].mutex);\n    if (ret > 0) {\n      if (ret < 100) {\n        printf(\"ret < 100\\n\");\n        pthread_mutex_unlock(&g_struct[i].mutex);\n        break;\n      }\n      else {\n\t// break statement exits the loop prematurely without calling unlock \n        if (ret > 1000) {\n          printf(\"ret > 1000\\n\");\n          break;\n        }\n      }\n    }\n    pthread_mutex_unlock(&g_struct[i].mutex);\n  }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 133,
        "category": "VUL",
        "language": "c/c++",
        "code": "DBLI",
        "name": "自旋锁初始化不能多于一次",
        "desc": "线程自旋锁在被取消初始化前已经被初始化了多于一次",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "LOW",
        "cost": "HIGH",
        "details": "#### 名称\n自旋锁初始化不能多于一次\n\n#### 概要\n线程自旋锁在被取消初始化前已经被初始化了多于一次\n\n#### 解释\n在初始化一个线程以后，应该在下一次初始化之前先取消初始化，否则会引起其他线程饥饿问题。",
        "examples": {
            "good": {
                "c": [
                    " \n#include <linux/spinlock.h>\n \nstruct sbuf_mgr {\n  int         sbuf_inited;\n  spinlock_t  sbuf_lock;\n  char       *sbuf;\n};\n \nint is_sbuf_inited(struct sbuf_mgr *p_sbuf_mgr);\nvoid sbuf_mgr_reset(struct sbuf_mgr *p_sbuf_mgr);\nvoid write_data(struct sbuf_mgr *p_sbuf_mgr);\n \n// thread 1\nint *worker1(void *args)\n{\n  struct sbuf_mgr * p_sbuf_mgr = args;\n  if (is_sbuf_inited(p_sbuf_mgr)) {\n     write_data(p_sbuf_mgr);\n  }\n  return 0;\n}\n \nint is_sbuf_inited( struct sbuf_mgr *p_sbuf_mgr )\n{\n    int tmp_inited;\n    unsigned long irq_flags;\n    spin_lock_irqsave( &p_sbuf_mgr->sbuf_lock, irq_flags );\n    tmp_inited = p_sbuf_mgr->sbuf_inited;\n    spin_unlock_irqrestore( &p_sbuf_mgr->sbuf_lock, irq_flags );\n    return tmp_inited;\n}\n \n// thread 2\nint *worker2(void *args)\n{\n  struct sbuf_mgr * p_sbuf_mgr = args;\n\n  // spin_lock_init called in thread2 with this call\n  sbuf_mgr_reset(p_sbuf_mgr);\n  return 0;\n}\n \nvoid sbuf_mgr_reset( struct sbuf_mgr *p_sbuf_mgr )\n{\n    int i;\n    unsigned long irq_flags;\n    \n    spin_lock_init(&(p_sbuf_mgr->sbuf_lock));  \n    spin_lock_irqsave(&p_sbuf_mgr->sbuf_lock, irq_flags);\n    // .. do the work \n}\n \nint test_init_in_thread(void)\n{\n  struct sbuf_mgr buf_mgr;\n  struct task_struct *worker1_task, *worker2_task;\n \n  worker1_task = kthread_create(worker1, (void*)&buf_mgr, \"thread1\");\n \n  worker2_task = kthread_create(worker2, (void*)&buf_mgr, \"thread2\");\n  // ,,, \n  \n  // start tasks\n  wake_up_process(worker1_task);\n  wake_up_process(worker2_task);\n  return 0;\n}\n \nvoid init(struct sbuf_mgr *buf_mgr)\n{\n  spin_lock_init(&(buf_mgr->sbuf_lock));\n}\n  \nint test_double_init(bool is_double_init)\n{\n  struct sbuf_mgr buf_mgr;\n\n  // initialization only if boolean is false\n  if (!is_double_init)\n    init(&buf_mgr);\n  \n  return;  \n}\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <linux/spinlock.h>\n \nstruct sbuf_mgr {\n  int         sbuf_inited;\n  spinlock_t  sbuf_lock;\n  char       *sbuf;\n};\n \nint is_sbuf_inited(struct sbuf_mgr *p_sbuf_mgr);\nvoid sbuf_mgr_reset(struct sbuf_mgr *p_sbuf_mgr);\nvoid write_data(struct sbuf_mgr *p_sbuf_mgr);\n \n// thread 1\nint *worker1(void *args)\n{\n  struct sbuf_mgr * p_sbuf_mgr = args;\n  if (is_sbuf_inited(p_sbuf_mgr)) {\n     write_data(p_sbuf_mgr);\n  }\n  return 0;\n}\n \nint is_sbuf_inited( struct sbuf_mgr *p_sbuf_mgr )\n{\n    int tmp_inited;\n    unsigned long irq_flags;\n    spin_lock_irqsave( &p_sbuf_mgr->sbuf_lock, irq_flags );\n    tmp_inited = p_sbuf_mgr->sbuf_inited;\n    spin_unlock_irqrestore( &p_sbuf_mgr->sbuf_lock, irq_flags );\n    return tmp_inited;\n}\n \n// thread 2\nint *worker2(void *args)\n{\n  struct sbuf_mgr * p_sbuf_mgr = args;\n\n  // spin_lock_init called in thread2 with this call\n  sbuf_mgr_reset(p_sbuf_mgr);\n  return 0;\n}\n \nvoid sbuf_mgr_reset( struct sbuf_mgr *p_sbuf_mgr )\n{\n    int i;\n    unsigned long irq_flags;\n    \n    spin_lock_init(&(p_sbuf_mgr->sbuf_lock));  \n    spin_lock_irqsave(&p_sbuf_mgr->sbuf_lock, irq_flags);\n    // .. do the work \n}\n \nint test_init_in_thread(void)\n{\n  struct sbuf_mgr buf_mgr;\n  struct task_struct *worker1_task, *worker2_task;\n \n  worker1_task = kthread_create(worker1, (void*)&buf_mgr, \"thread1\");\n \n  worker2_task = kthread_create(worker2, (void*)&buf_mgr, \"thread2\");\n  // ,,, \n  \n  // start tasks\n  wake_up_process(worker1_task);\n  wake_up_process(worker2_task);\n  return 0;\n}\n \nvoid init(struct sbuf_mgr *buf_mgr)\n{\n  spin_lock_init(&(buf_mgr->sbuf_lock));\n}\n  \nint test_double_init(bool is_double_init)\n{\n  struct sbuf_mgr buf_mgr;\n\n  // first initialization \n  init(&buf_mgr);\n  \n  if (is_double_init) {\n    // if true, call init, causing double init\n    init(&buf_mgr);\n  }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 134,
        "category": "VUL",
        "language": "c/c++",
        "code": "LIIT",
        "name": "不要在线程中调用自旋锁初始化",
        "desc": "在线程中调用自旋锁初始化可能导致线程被多次初始化",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "LOW",
        "cost": "HIGH",
        "details": "#### 名称\n不要在线程中调用自旋锁初始化\n\n#### 概要\n在线程中调用自旋锁初始化可能导致线程被多次初始化\n\n#### 解释\n线程不应被直接或间接地多次初始化，否则会导致其他线程饥饿问题。",
        "examples": {
            "good": {},
            "bad": {
                "c": [
                    "#include <linux/spinlock.h>\n \nstruct sbuf_mgr {\n  int         sbuf_inited;\n  spinlock_t  sbuf_lock;\n  char       *sbuf;\n};\n \nint is_sbuf_inited(struct sbuf_mgr *p_sbuf_mgr);\nvoid sbuf_mgr_reset(struct sbuf_mgr *p_sbuf_mgr);\nvoid write_data(struct sbuf_mgr *p_sbuf_mgr);\n \n// thread 1\nint *worker1(void *args)\n{\n  struct sbuf_mgr * p_sbuf_mgr = args;\n  if (is_sbuf_inited(p_sbuf_mgr)) {\n     write_data(p_sbuf_mgr);\n  }\n  return 0;\n}\n \nint is_sbuf_inited( struct sbuf_mgr *p_sbuf_mgr )\n{\n    int tmp_inited;\n    unsigned long irq_flags;\n    spin_lock_irqsave( &p_sbuf_mgr->sbuf_lock, irq_flags );\n    tmp_inited = p_sbuf_mgr->sbuf_inited;\n    spin_unlock_irqrestore( &p_sbuf_mgr->sbuf_lock, irq_flags );\n    return tmp_inited;\n}\n \n// thread 2\nint *worker2(void *args)\n{\n  struct sbuf_mgr * p_sbuf_mgr = args;\n\n  // spin_lock_init called with this call, can result in double init\n  sbuf_mgr_reset(p_sbuf_mgr);\n  return 0;\n}\n \nvoid sbuf_mgr_reset( struct sbuf_mgr *p_sbuf_mgr )\n{\n    int i;\n    unsigned long irq_flags;\n    \n    spin_lock_init(&(p_sbuf_mgr->sbuf_lock));  \n    spin_lock_irqsave(&p_sbuf_mgr->sbuf_lock, irq_flags);\n    // .. do the work \n}\n \nint test_init_in_thread(void)\n{\n  struct sbuf_mgr buf_mgr;\n  struct task_struct *worker1_task, *worker2_task;\n \n  worker1_task = kthread_create(worker1, (void*)&buf_mgr, \"thread1\");\n \n  worker2_task = kthread_create(worker2, (void*)&buf_mgr, \"thread2\");\n  // ,,, \n  \n  // start tasks\n  wake_up_process(worker1_task);\n  wake_up_process(worker2_task);\n  return 0;\n}\n \nvoid init(struct sbuf_mgr *buf_mgr)\n{\n  spin_lock_init(&(buf_mgr->sbuf_lock));\n}\n  \nint test_double_init(bool is_double_init)\n{\n  struct sbuf_mgr buf_mgr;\n\n  // first initialization \n  init(&buf_mgr);\n  \n  if (is_double_init) {\n    // if true, call init, causing double init\n    init(&buf_mgr);\n  }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 135,
        "category": "VUL",
        "language": "c/c++",
        "code": "SLAE",
        "name": "自旋锁变量的地址逃逸",
        "desc": "自旋锁变量的地址暴露可能会导致死锁",
        "msg_templ": "",
        "severity": "LOW",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "#### 名称\n自旋锁变量的地址逃逸\n\n#### 概要\n自旋锁变量的地址暴露可能会导致死锁\n\n#### 解释\n当自旋锁变量的地址暴露在线程之外时，线程可能因无法正确解锁而导致死锁。",
        "examples": {
            "good": {},
            "bad": {
                "c": [
                    "#include <linux/spinlock.h>\nvoid bad(int irq, spinlock_t lock)\n{\n  // \n  spin_lock(&lock);\n}\n \nvoid bad2(int irq, spinlock_t lock, spinlock_t lock2)\n{\n  spin_lock(&lock);\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 136,
        "category": "VUL",
        "language": "c/c++",
        "code": "LNR",
        "name": "",
        "desc": "",
        "msg_templ": "",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 137,
        "category": "VUL",
        "language": "c/c++",
        "code": "SAC",
        "name": "在原子上下文或者锁定区域中调用睡眠函数",
        "desc": "当程序在原子上下文状态或者锁定区域时，存在着操作使得程序因等待中断或调用睡眠函数而引发程序运行暂停或者延迟",
        "msg_templ": "",
        "severity": "LOW",
        "likelihood": "LOW",
        "cost": "HIGH",
        "details": "#### 名称\n在原子上下文或者锁定区域中调用睡眠函数\n\n#### 概要\n当程序在原子上下文状态或者锁定区域时，存在着操作使得程序因等待中断或调用睡眠函数而引发程序运行暂停或者延迟\n\n#### 解释\n当程序在原子上下文状态或者锁定区域时，任何运行都有可能因睡眠、中断或者等待而发生中止，从而导致死锁。",
        "examples": {
            "good": {
                "c": [
                    "#include <linux/spinlock.h>\nvoid test_isr1(int irq, spinlock_t *lock)\n{\n  // this guarantees interrupt state is saved and that\n  // the critical section will not be preempted by the kernel\n  spin_lock_irqsave(lock);  \n}\n \n \n// cross function check\nnoinline\nvoid call_spin(spinlock_t *lock)\n{\n  spin_lock(lock);\n}\n",
                    "#include <stdio.h>\n#include <pthread.h>\n\nint num = 8; // global variable\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; // initialise a mutex\n\nint main() {\n    pthread_mutex_lock(&lock); // enter mutex locked region\n    switch (num) {\n    case 0:\n            num = 0;\n            break;\n    case 1:\n            num++;\n            break;\n    case 2:\n            num--;\n            break;\n    default:\n            pthread_mutex_unlock(&lock); // exit mutex lock region\n            return 0;\n    }\n    pthread_mutex_unlock(&lock); // exit mutex lock region\n    return 0;\n}\n",
                    "#include <stdio.h>\n#include <pthread.h>\n#include <unistd.h>\n\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; // initialise a mutex\nint num; // global variable\n\nint main () {\n    pthread_mutex_lock(&lock); // enter mutex lock region\n    num++;\n    pthread_mutex_unlock(&lock); // exit mutex lock region\n    return 0;\n}\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <linux/spinlock.h>\nvoid test_isr1(int irq, spinlock_t *lock)\n{\n  spin_lock(lock);  // VUL: should use spin_lock_irqsave\n}\n \n// cross function check\nnoinline\nvoid call_spin(spinlock_t *lock)\n{\n  spin_lock(lock);\n}\n\n\n",
                    "#include <stdio.h>\n#include <pthread.h>\n\nint num = 8; // global variable\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; // initialise a mutex\n\nint main() {\n    pthread_mutex_lock(&lock); // enter mutex locked region\n    switch (num) {\n    case 0:\n            num = 0;\n            break;\n    case 1:\n            num++;\n            break;\n    case 2:\n            num--;\n            break;\n    default:\n            // does not exit mutex lock region before return\n            // can cause a deadlock because lock is never released\n            return 0;\n    }\n    pthread_mutex_unlock(&lock); // exit mutex lock region\n    return 0;\n}\n",
                    "\n#include <stdio.h>\n#include <pthread.h>\n#include <unistd.h>\n\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; // initialise a mutex\nint num; // global variable\n\nint main () {\n    pthread_mutex_lock(&lock); // enter mutex lock region\n    num++;\n    sleep(1); // thread goes to sleep within lock region, never want to do this\n    pthread_mutex_unlock(&lock); // exit mutex lock region\n    return 0;\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 138,
        "category": "VUL",
        "language": "c/c++",
        "code": "LLAT",
        "name": "本地线程在线程被停止后仍然存在",
        "desc": "当本地线程的地址被保存后，即使该线程被停止，仍可被其持有者调用",
        "msg_templ": "",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "#### 名称\n本地线程在线程被停止后仍然存在\n\n#### 概要\n当本地线程的地址被保存后，即使该线程被停止，仍可被其持有者调用\n\n#### 解释\n暴露本地线程变量的地址可能会引起对非法锁或者无效函数的调用。这会引起不可确定的行为。",
        "examples": {
            "good": {},
            "bad": {
                "c": [
                    " \nstruct completion {\n  int done;\n};\n \nstruct usb_request {\n  struct completion *context;\n  void (*complete)(struct usb_request *req);\n};\n \nvoid complete(struct completion *x)\n{\n  printf(\"%d\\n\", x->done);\n}\n \nvoid ffs_epfile_io_complete(struct usb_request *req)\n{\n  complete(req->context);\n}\n \nvoid usb_ep_queue(struct usb_request *req)\n{\n  req->complete(req);\n}\n \nvoid ffs_epfile_io(struct usb_request *req)\n{\n  struct completion done;\n  req->context = &done;\n  req->complete = ffs_epfile_io_complete;\n  usb_ep_queue(req);\n}\n \n"
                ]
            }
        }
    },
    {
        "master_id": 139,
        "category": "VUL",
        "language": "c/c++",
        "code": "UIL",
        "name": "锁未被初始化",
        "desc": "当自旋锁被调用时，锁未被初始化",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "LOW",
        "cost": "HIGH",
        "details": "#### 名称\n锁未被初始化\n\n#### 概要\n当自旋锁被调用时，锁未被初始化\n\n#### 解释\n使用自旋锁时需要有资源分配，并且需要被初始化到解锁状态，否则会导致不可确定的系统行为。",
        "examples": {
            "good": {},
            "bad": {
                "c": [
                    "#include <stddef.h>\n#include <pthread.h>\n \nvoid mutex_initialise(pthread_mutex_t *lock) {\n  pthread_mutex_init(lock, NULL);\n}\n \nvoid mutex_lock(pthread_mutex_t *lock) {\n  pthread_mutex_lock(lock);\n}\n \nvoid mutex_unlock(pthread_mutex_t *lock) {\n  pthread_mutex_unlock(lock);\n}\n \nint main(void) {\n    pthread_mutex_t mlock;\n    \n    // mutex_initialize, nor pthread_mutex_init has been invoked\n    mutex_lock(&mlock);\n    mutex_unlock(&mlock);\n    return 0;\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 140,
        "category": "VUL",
        "language": "c/c++",
        "code": "TASR",
        "name": "检查并设置场景下的竞态条件",
        "desc": "检查并设置场景下若没有锁保护将可能导致竞态条件",
        "msg_templ": "",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "#### Abstract\n检查和设置场景下若没有锁保护将可能导致竞态条件\n\n#### Explanation\n在检查和设置的场景下判断变量后，如果在分支修改变量且未有用锁保护这个场景，有可能导致竞态条件。",
        "examples": {
            "good": {},
            "bad": {
                "c": [
                    "extern int printf(const char*, ...);\nextern int get_int();\n \nvoid cmp_set_race_bad() {\n  int flag = get_int();\n  if (flag == 0) {\n    flag = 1;\n  }\n  else {\n    printf(\"\\n\");\n  }\n  printf(\"1st: get %d\\n\", flag);\n  flag = get_int();\n  if (flag != 0) {\n    printf(\"2nd: get %d\\n\", flag);\n  }\n  else {\n    flag = 1;\n  }\n  printf(\"final: %d\\n\", flag);\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 141,
        "category": "VUL",
        "language": "c/c++",
        "code": "PNC",
        "name": "配对未调用",
        "desc": "特定的函数应配对。 使用第一个函数时也必须使用成对中的第二个。",
        "msg_templ": "在${so.filename}，第${so.line}行，函数${so.func}，特定的函数对中仅仅使用了其中一个函数",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n特定的函数应配对。 使用第一个函数时也必须使用成对中的第二个。\n\n#### 解释\n如果调用了函数“irq_of_parse_and_map”，则在程序执行过程中必须调用相应的“irq_dispose_mapping”。",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n#include \"case.h\"\n\nstatic int sunxi_keyboard_startup(struct sunxi_key_data *key_data,\n                                struct platform_device *pdev)\n{\n        struct device_node *np = NULL;\n        int ret = 0;\n\n        key_data->reg_base = of_iomap(np, 0);\n        if (key_data->reg_base == 0) {\n                pr_err(\"%s:Failed to ioremap() io memory region.\", __func__);\n                ret = -1;\n                goto out_iounmap;\n        }\n\n        key_data->irq_num = irq_of_parse_and_map(np, 0);\n        if (key_data->irq_num == 0) {\n                pr_err(\"%s:Failed to map irq.\", __func__);\n                ret = -1;\n                goto out_dispose_mapping;\n        }\n\n        key_data->mclk = of_clk_get(np, 0);\n        if (IS_ERR_OR_NULL(key_data->mclk)) {\n                pr_debug(\"%s: keyboard has no clk.\", __func__);\n                goto out_clk;\n        } else{\n                if (clk_prepare_enable(key_data->mclk)) {\n                        pr_err(\"%s enable apb1_keyadc clock failed!\", __func__);\n                        ret = -1;\n                }\n        }\n\nout_clk:\n        clk_put(key_data->mclk);\nout_dispose_mapping:\n        irq_dispose_mapping(key_data->irq_num);\nout_iounmap:\n        iounmap(key_data->reg_base);\n\n        return ret;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n#include \\\"case.h\\\"\n\nstatic int sunxi_keyboard_startup(struct sunxi_key_data *key_data,\n                                struct platform_device *pdev)\n{\n        struct device_node *np = NULL;\n        int ret = 0;\n\n        key_data->reg_base = of_iomap(np, 0);\n        if (key_data->reg_base == 0) {\n                pr_err(\"%s:Failed to ioremap() io memory region.\", __func__);\n                ret = -1;\n        }\n\n        key_data->irq_num = irq_of_parse_and_map(np, 0);\n        if (key_data->irq_num == 0) {\n                pr_err(\"%s:Failed to map irq.\", __func__);\n                ret = -1;\n        }\n\n        key_data->mclk = of_clk_get(np, 0);\n        if (IS_ERR_OR_NULL(key_data->mclk)) {\n                pr_debug(\"%s: keyboard has no clk.\", __func__);\n        } else{\n                if (clk_prepare_enable(key_data->mclk)) {\n                        pr_err(\"%s enable apb1_keyadc clock failed!\", __func__);\n                        return -1;\n                }\n        }\n        \n        return ret;\n}"
                ]
            }
        }
    },
    {
        "master_id": 142,
        "category": "VUL",
        "language": "c/c++",
        "code": "LSO",
        "name": "生命周期错误阶段的资源操作",
        "desc": "不应在生命周期的错误阶段执行对资源的操作。",
        "msg_templ": "在${si.filename}，第${si.line}行，${si.func}在生命周期的错误阶段执行了对资源的操作。",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n不应在生命周期的错误阶段执行对资源的操作。\n\n#### 解释\n如果开发人员在生命周期的错误阶段初始化、使用或释放资源，可能会导致意外行为。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#define BUF_SZ 256\n\nint foo(void)\n{\n    int n;\n    char buffer[BUF_SZ];\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n\n    if (sockfd < 0)\n    {\n        perror(\"ERROR opening socket\");\n        exit(1);\n    }\n\n    struct sockaddr_in addr;\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    addr.sin_port = htons(3128);\n    if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0)\n    {\n        perror(\"ERROR binding socket\");\n        exit(1);\n    }\n\n    if (listen(sockfd, 0) < 0)\n    {\n        perror(\"ERROR listening socket\");\n        exit(1);\n    }\n\n    close(sockfd);\n    return n;\n}\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#define BUF_SZ 256\n\nint foo(void)\n{\n    int n;\n    char buffer[BUF_SZ];\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n\n    if (sockfd < 0)\n    {\n        perror(\"ERROR opening socket\");\n        exit(1);\n    }\n\n    struct sockaddr_in addr;\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    addr.sin_port = htons(3128);\n    if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0)\n    {\n        perror(\"ERROR binding socket\");\n        exit(1);\n    }\n\n    if (listen(sockfd, 0) < 0)\n    {\n        perror(\"ERROR listening socket\");\n        exit(1);\n    }\n\n    n = recv(sockfd, buffer, 255, 0);\n\n    // use buffer\n    // if buffer is used as argument to system() or to setenv()\n    // the buffer may contain untrusted commands or characters leading to unpredictable program behavior\n    // ...\n    close(sockfd);\n    return n;\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 143,
        "category": "VUL",
        "language": "c/c++",
        "code": "MBSP",
        "name": "多个套接字绑定相同的端口",
        "desc": "多个套接字不应绑定到同一个端口",
        "msg_templ": "在${si.filename}，多个套接字绑定了同一个端口。",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### 概要\n多个套接字不应绑定到同一个端口\n\n#### 解释\n如果多个套接字绑定到同一个端口，该端口的其他服务可能会被窃取。\n",
        "examples": {
            "good": {
                "c": [
                    "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nvoid func( void )\n{\n    // create socket one and bind to port\n    int sockfd_one;\n    int server_len;\n    struct sockaddr_in addr;\n    sockfd_one = socket(AF_INET, SOCK_STREAM, 0);\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    addr.sin_port = htons(6789);\n    server_len = sizeof(struct sockaddr_in);\n    bind(sockfd_one, (struct sockaddr *) &addr, server_len);\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nvoid func( void )\n{\n    // create socket one\n    int sockfd_one;\n    int server_len;\n    struct sockaddr_in addr;\n    sockfd_one = socket(AF_INET, SOCK_STREAM, 0);\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    addr.sin_port = htons(6789);\n    server_len = sizeof(struct sockaddr_in);\n\n    // set SO_REUSEADDR and bind socket one to port\n    int opt = 1;\n    setsockopt( sockfd_one, SOL_SOCKET,SO_REUSEADDR, (const void *)&opt, sizeof(opt) );\n    bind(sockfd_one, (struct sockaddr *) &addr, server_len);\n\n    // create socket two\n    int sockfd_two;\n    sockfd_two = socket(AF_INET, SOCK_DGRAM, 0);\n\n    // set SO_REUSEADDR and bind socket two to port\n    opt = 1;\n    setsockopt( sockfd_two, SOL_SOCKET,SO_REUSEADDR, (const void *)&opt, sizeof(opt) );\n    bind(sockfd_two, (struct sockaddr *) &addr, server_len);\n}"
                ]
            }
        }
    }
]