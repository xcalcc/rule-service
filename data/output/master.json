[
    {
        "master_id": 1,
        "category": "BAD_PRACTICE",
        "language": "c,c++",
        "code": "CSL",
        "name": "Call stack level exceeds limit",
        "desc": "The program has a call sequence that causes the runtime stack to exceed the call depth limit set by the user.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} has a call sequence that exceeds call level limit set from scan configuration.",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has a call sequence that causes the runtime stack to exceed the call depth limit set by the user.\n\n#### Explanation\nFunction A calls another function B. Function B may in turn call another function C. This call chain can go on infinitely. In embedded systems, when the call stack is too deep, it may cause unintended side effects like running out of memory, inefficient execution time, etc.\n",
        "examples": {
            "good": {},
            "bad": {
                "c": [
                    "int __attribute__((__noinline__)) f1() {\n  return 1;\n}\nint __attribute__((__noinline__)) f2() {\n  return 2 + f1();\n}\nint __attribute__((__noinline__)) f3() {\n  return 3 + f2();\n}\nint __attribute__((__noinline__)) f4() {\n  return 4 + f3();\n}\nint __attribute__((__noinline__)) f5() {\n  return 5 + f4();\n}\nint __attribute__((__noinline__)) f6() {\n  return 6 + f5();\n}\nint __attribute__((__noinline__)) f7() {\n  return 7 + f6();\n}\nint __attribute__((__noinline__)) f8() {\n  return 8 + f7();\n}\nint __attribute__((__noinline__)) f9() {\n  return 9 + f8();\n}\nint __attribute__((__noinline__)) f10() {\n  return 10 + f9();\n}\nint __attribute__((__noinline__)) f11() {\n  return 11 + f10();\n}\nint __attribute__((__noinline__)) f12() {\n  return 12 + f11();\n}\nint __attribute__((__noinline__)) f13() {\n  return 13 + f12();\n}\nint __attribute__((__noinline__)) f14() {\n  return 14 + f13();\n}\nint __attribute__((__noinline__)) f15() {\n  return 15 + f14();\n}\nint __attribute__((__noinline__)) f16() {\n  return 16 + f15();\n}\nint __attribute__((__noinline__)) f17() {\n  return 17 + f16();\n}\nint __attribute__((__noinline__)) f18() {\n  return 18 + f17();\n}\nint __attribute__((__noinline__)) f19() {\n  return 19 + f18();\n}\nint __attribute__((__noinline__)) f20() {\n  return 20 + f19();\n}\nint __attribute__((__noinline__)) f21() {\n  return 21 + f20();\n}\nint __attribute__((__noinline__)) f22() {\n  return 22 + f21();\n}\nint __attribute__((__noinline__)) f23() {\n  return 23 + f22();\n}\nint __attribute__((__noinline__)) f24() {\n  return 24 + f23();\n}\nint __attribute__((__noinline__)) f25() {\n  return 25 + f24();\n}\nint __attribute__((__noinline__)) f26() {\n  return 26 + f25();\n}\nint __attribute__((__noinline__)) f27() {\n  return 27 + f26();\n}\nint __attribute__((__noinline__)) f28() {\n  return 28 + f27();\n}\nint __attribute__((__noinline__)) f29() {\n  return 29 + f28();\n}\nint __attribute__((__noinline__)) f30() {\n  return 30 + f29();\n}\nint __attribute__((__noinline__)) f31() {\n  return 31 + f30();\n}\nint __attribute__((__noinline__)) f32() {\n  return 32 + f31();\n}\nint __attribute__((__noinline__)) f33() {\n  return 33 + f32();\n}\nint __attribute__((__noinline__)) f34() {\n  return 34 + f33();\n}\nint __attribute__((__noinline__)) f35() {\n  return 35 + f34();\n}\nint __attribute__((__noinline__)) f36() {\n  return 36 + f35();\n}\nint __attribute__((__noinline__)) f37() {\n  return 37 + f36();\n}\nint __attribute__((__noinline__)) f38() {\n  return 38 + f37();\n}\nint __attribute__((__noinline__)) f39() {\n  return 39 + f38();\n}\nint __attribute__((__noinline__)) f40() {\n  return 40 + f39();\n}\nint __attribute__((__noinline__)) f41() {\n  return 41 + f40();\n}\nint __attribute__((__noinline__)) f42() {\n  return 42 + f41();\n}\nint __attribute__((__noinline__)) f43() {\n  return 43 + f42();\n}\nint __attribute__((__noinline__)) f44() {\n  return 44 + f43();\n}\nint __attribute__((__noinline__)) f45() {\n  return 45 + f44();\n}\nint __attribute__((__noinline__)) f46() {\n  return 46 + f45();\n}\nint __attribute__((__noinline__)) f47() {\n  return 47 + f46();\n}\nint __attribute__((__noinline__)) f48() {\n  return 48 + f47();\n}\nint __attribute__((__noinline__)) f49() {\n  return 49 + f48();\n}\nint __attribute__((__noinline__)) f50() {\n  return 50 + f49();\n}\n"
                ],
                "general": [
                    "// This case does not need an example.\n// The complete call level from function A to Z, i.e. A() ==> B() ==> .... ==> Z(), is too deep."
                ]
            }
        }
    },
    {
        "master_id": 2,
        "category": "BAD_PRACTICE",
        "language": "c,c++",
        "code": "CSS",
        "name": "Call stack size exceeds limit",
        "desc": "The program has a call sequence that causes the runtime stack size to exceed the set limit.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} has a call sequence that exceeds stack size limit set at scan configuration time.",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has a call sequence that causes the runtime stack size to exceed the set limit.\n\n#### Explanation\nWhen function A calls another function B, the parameters passed to the called function, and the return value from the called function to the caller function will be placed on the execution stack. Local variables will also be placed on the execution stack.\n",
        "examples": {
            "good": {
                "c": [
                    "// Assume that stack size is 8 bytes for parameter, 4 bytes for return value (assume) 32 bit ABI\n// Assume we limit the size of stack to that of 32 bytes\n\nint func_callee(int *a, int i)\n{\n    return a[i];\n}\n\n// stack size is 0 byte (no parameter), 12 byte for local variable, 4 bytes for return value\nint func_caller()\n{\n    int a[3] = {0, 1}, b;\n    b = func_callee(a, 1);\n    // callee stack size if 12 bytes\n    return 0;\n}\n\n// total stack size for the call sequence func_caller -> func_callee is 28 bytes\n// (assume ABI specifies all parameters uses stack and not register)"
                ]
            },
            "bad": {
                "c": [
                    "extern void init_buf(char *buf, int sz);\nint f1() {\n  char buf[8192];\n  init_buf(buf, sizeof(buf));\n  return buf[1];\n}\n\nint f2() {\n  char buf[8192];\n  init_buf(buf, sizeof(buf));\n  return buf[2] + f1();\n}\n\nint f3() {\n  char buf[8192];\n  init_buf(buf, sizeof(buf));\n  return buf[3] + f2();\n}\n\nint f4() {\n  char buf[8192];\n  init_buf(buf, sizeof(buf));\n  return buf[4] + f3();\n}\n\n"
                ],
                "general": [
                    "// Assuming that stack size is 8 bytes for parameter, 4 bytes for return value (assume) 32 bit ABI\nint func_callee(int* a, int i)\n{\n return a[i];\n}\n\n// stack size is 0 byte (no parameter), 12 byte for local variable, 4 bytes for return value\nint func_caller() {\n int a[3] = {0, 1}, b;\n b = assign(a, 1); /* callee stack size if 12 bytes\n return 0;\n}\n\n// total stack size for the call sequence func_caller -> func_callee is 28 bytes\n// (assume ABI specifies all parameters uses stack and not register)"
                ]
            }
        }
    },
    {
        "master_id": 3,
        "category": "VUL",
        "language": "c,c++",
        "code": "DBF",
        "name": "Resource was freed multiple times",
        "desc": "The program has freed some resources (e.g. heap memory, I/O stream object, etc.) on multiple occasions.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, resource variable ${si.var} at function ${si.func} has been released multiple times. Such variable is first released at file  ${so.filename}, line ${so.line}.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has freed some resources (e.g. heap memory, I/O stream object, etc.) multiple times.\n\n#### Explanation\nThe program has called functions such as free(), close() multiple times to release the same resource object. This could cause system inconsistencies such as corruption of the system's heap management data strutures or I/O stream subclasses. This in turn may allow malicious users to access arbitrary memory or cause an IOException.\n\n",
        "examples": {
            "good": {
                "general": [
                    "int func_1(void *p) {\n if (p != NULL) {\n free(p); // free p\n }\n}\n\nint func_2(void *p) {\n if (p != NULL) {\n free(p); // free p\n }\n}\n\nint main() {\n int i, *p, *q;\n p = malloc(10 * sizeof(int));\n if (p == NULL)\n return 1;\n for (i=0; i < 10; ++i)\n p[i] = i;\n q = p;\n func_1(p); // free p the first time and only time\n return 0;\n}"
                ]
            },
            "bad": {
                "general": [
                    "int func_1(void *p) {\n if (p != NULL) {\n free(p); // free p\n }\n}\n\nint func_2(void *p) {\n if (p != NULL) {\n free(p); // free p\n }\n}\n\nint main() {\n int i, *p, *q;\n p = malloc(10 * sizeof(int));\n if (p == NULL)\n return 1;\n for (i=0; i < 10; ++i)\n p[i] = i;\n q = p;\n func_1(p); // free p the first time\n func_2(q); // free p the second time due to value of p copied into q\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 4,
        "category": "VUL",
        "language": "c,c++",
        "code": "FMT",
        "name": "Format string overflow",
        "desc": "The program is calling one of the printf families with a number (or type) of parameter(s) that are used differently from the format string declaration.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, the format specification in function ${si.func}, argument ${si.var} has unknown format characters in the format string declaration.",
        "severity": "HIGH",
        "likelihood": "UNLIKELY",
        "cost": "LOW",
        "details": "#### Abstract\nThe program is calling one of the printf families with a number (or type) of parameter(s) used differently from format string declaration.\n\n#### Explanation\nIn a printf (or family with this type of system call), the format string specifier is inconsistent with the actual parameters or, that specifier has unsupported characters in the format string. When the actual parameters being passed are different, what is printed out will be unpredictable.\n",
        "examples": {
            "good": {
                "c": [
                    "\nfoo(int a, int guard)\n{  int x = 0;\n  int int_result = 0;\n  if (guard != 0) int_result = a * x;\n\n  // number of actuals match that with format statement\n  printf(\"result %d is %x truncated\", int_result, int_result); \n  return 0;\n}\n\n"
                ]
            },
            "bad": {
                "c": [
                    "foo(int a, int guard)\n{\n  int x = 0;\n  int int_result = 0;\n  if (guard != 0) int_result = a * x;\n  \n  // The format string specified two values to be printed,\n  // only one actual parameter is passed. The second output is unpredictable\n  printf(\"result %d is %x truncated\", int_result); \n  return 0;\n}\n\n"
                ]
            }
        }
    },
    {
        "master_id": 5,
        "category": "ROBUSTNESS",
        "language": "c,c++",
        "code": "MSF",
        "name": "Missing free",
        "desc": "The program has allocated heap memory but failed to free that piece of memory.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, variable ${si.var} in function ${si.func} has not been freed. Such variable is first assigned heap memory acquired in file ${so.filename} at line ${so.line}.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has allocated heap memory but failed to free that piece of memory.\n\n#### Explanation\nHeap memory has been allocated and the allocated memory address is stored in a variable of reference (pointer) type. That heap memory has never been released after its lifetime has effectively ended, and its corresponding reference still points to that memory space. This could result in sensitive data leakage or unexpected program behavior such as denial of service.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n\nstruct S\n{\n    int *p;\n};\n\nint main()\n{\n    int *p;\n    struct S *s;\n    p = malloc(10 * sizeof(int)); // heap memory allocated and pointed to by p\n    if (p == NULL)\n    {\n        return 1;\n    }\n    s = (struct S *)malloc(sizeof(struct S)); // heap memory allocated and pointed to by s\n    if (s == NULL)\n    {\n        free(p);\n        return 1;\n    }\n    s->p = p;\n    // both s and p are freed\n    free(s); \n    free(p); \n    return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n\nstruct S\n{\n    int *p;\n};\n\nint main()\n{\n    int *p;\n    struct S *s;\n    p = malloc(10 * sizeof(int)); // heap memory allocated and pointed to by p\n    if (p == NULL)\n    {\n        return 1;\n    }\n    s = (struct S *)malloc(sizeof(struct S)); // heap memory allocated and pointed to by s\n    if (s == NULL)\n    {\n        free(p);\n        return 1;\n    }\n    s->p = p;\n    free(s); // only s is freed\n    // s->p, which is copied from p is not freed\n    return 0;\n}"
                ],
                "general": [
                    "struct S {\n int *p;\n};\n\nint main() {\n int *p;\n struct S *s;\n p = malloc(10 * sizeof(int)); // heap memory allocated and pointed to by p\n if (p == NULL)\n return 1;\n s = (struct S*)malloc(sizeof(struct S)); // heap memory allocated and pointed to by s\n if (s == NULL) {\n free(p);\n return 1;\n }\n s->p = p;\n free(s); // only s is freed\n // s->p, which is copied from p is not freed\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 6,
        "category": "VUL",
        "language": "c,c++",
        "code": "RAL",
        "name": "Return address of local",
        "desc": "The function returns the address of a stack variable and will cause unintended program behavior.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, address of the local variable ${si.var} has been returned to the caller.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### Abstract\nThe function returns the address of a stack variable and will cause unintended program behavior.\n\n#### Explanation\nBecause local variables are allocated to the stack, when a function returns to the caller, the callee's stack address is no longer valid. A subsequent function call is likely to re-use this same stack address, thereby overwriting the previous value.\n",
        "examples": {
            "good": {
                "c": [
                    "int foo()\n{\n    int *c;\n    return *c; // item *c is pointing to returned\n}"
                ]
            },
            "bad": {
                "c": [
                    "extern void bar(int);\n\nint *foo()\n{\n    int c = 0;\n    bar(c);\n    return &c; //return a local address to caller\n}\n"
                ],
                "general": [
                    "int foo()\n{\n int *c;\n return &c; //return a local address to caller\n}"
                ]
            }
        }
    },
    {
        "master_id": 7,
        "category": "VUL",
        "language": "c,c++",
        "code": "RXS",
        "name": "Read from external socket",
        "desc": "The program has read from external sockets which may include untrusted data.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} is receiving untrusted data from external socket. The socket has been created in file ${si.filename} at line ${si.line}.",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### Abstract\nThe program has read from external sockets which may include untrusted data.\n\n#### Explanation\nThe external interface allows the program to interact with the external world, so it is very important to ensure that the external interface does not receive security sensitive or untrusted input.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <sys/socket.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#define BUF_SZ 256\n\nint foo(void)\n{\n    int n;\n    char buffer[BUF_SZ];\n    char *cp = buffer; \n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n\n    if (sockfd < 0)\n    {\n        perror(\"ERROR opening socket\");\n        exit(1);\n    }\n\n    // filter out untrusted data and characters\n    static char approved[] = \"abcdefghijklmnopqrstuvwxyz\"\n                             \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                             \"1234567890_-.@\";\n    const char *end = buffer + strlen(buffer);\n    for (cp += strspn(cp, approved); cp != end; cp += strspn(cp, approved))\n    {\n        *cp = '_';\n    }\n\n    n = read(sockfd, buffer, 255);\n\n    // use buffer\n    // if buffer is used as argument to system() or to setenv()\n    // the buffer may contain untrusted commands or characters leading to unpredictable program behavior\n    // ...\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <sys/socket.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#define BUF_SZ 256\n\nint foo(void)\n{\n    int n;\n    char buffer[BUF_SZ];\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n\n    if (sockfd < 0)\n    {\n        perror(\"ERROR opening socket\");\n        exit(1);\n    }\n\n    n = read(sockfd, buffer, 255);\n\n    // use buffer\n    // if buffer is used as argument to system() or to setenv()\n    // the buffer may contain untrusted commands or characters leading to unpredictable program behavior\n    // ...\n}"
                ],
                "general": [
                    "#include <sys/socket.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#define BUF_SZ 256\n\nint foo(void)\n{\n int n;\n char buffer[BUF_SZ];\n sockfd = socket(AF_INET, SOCK_STREAM, 0);\n\n if (sockfd < 0) {\n perror(\\\"ERROR opening socket\\\");\n exit(1);\n }\n\n n = read(sockfd,buffer,255);\n\n // use buffer\n // if buffer is used as argument to system() or to setenv()\n // the buffer may contain untrusted commands or characters leading to unpredictable program behavior\n // ...\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 8,
        "category": "VUL",
        "language": "c,c++",
        "code": "UAF",
        "name": "Use after free",
        "desc": "The program has referenced memory after it has been freed. It can cause the program to crash or lead to an unexpected program behavior.",
        "msg_templ": "In file ${so.filename}, line ${so.line}, variable ${so.var} in function ${so.func} was used. However, it has been freed at line ${so.line} in file ${so.filename}.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has referenced memory after it has been freed. It can cause the program to crash or an unexpected program behavior.\n\n#### Explanation\nUse after free is a variation of dangling pointer reference. It typically occurs when the pointer is not updated after the memory object it points to has been freed. This pointer will be pointing to inappropriate memory leading to unauthorized access when the pointer is used.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n\nint g = 2;\n\nvoid my_free(void *p)\n{\n    if (p != NULL) \n    {\n        free(p); // free p\n    }\n        \n}\n\nint main()\n{\n    int i, j, *p, *q;\n    p = malloc(10 * sizeof(int));\n    if (p == NULL)\n    {\n        return 1;\n    }\n    for (i = 0; i < 10; ++i) \n    {\n        p[i] = i;\n    }    \n    q = p;\n    my_free(p); // p is freed\n    j = 0;\n\n    // checks if q is illegal before running the for loop\n    if (q == 0 || q == NULL)\n    {\n        exit(1);\n    }\n    \n    for (i = 0; i < 10; ++i)\n    {\n        // Use after free here (note the statement q = p), read of q[i] is illegal\n        j += q[i]; \n    }\n        \n    return j;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n\nint g = 2;\n\nvoid my_free(void *p)\n{\n    if (p != NULL) \n    {\n        free(p); // free p\n    }\n}\n\nint main()\n{\n    int i, j, *p, *q;\n    p = malloc(10 * sizeof(int));\n    if (p == NULL)\n    {\n        return 1;\n    }\n    for (i = 0; i < 10; ++i) \n    {\n        p[i] = i;\n    }\n    q = p;\n    my_free(p); // p is freed\n    j = 0;\n    for (i = 0; i < 10; ++i)\n    {\n        j += q[i]; // Use after free here (note the statement q = p), read of q[i] is illegal\n    }\n    return j;\n}"
                ],
                "general": [
                    "#include <stdio.h>\n\nint g = 2;\n\nvoid my_free(void *p) {\n if (p != NULL)\n free(p); // free p\n}\n\nint main() {\n int i, j, *p, *q;\n p = malloc(10 * sizeof(int));\n if (p == NULL)\n return 1;\n for (i=0; i < 10; ++i)\n p[i] = i;\n q = p;\n my_free(p); // p is freed\n j = 0;\n for (i=0; i < 10; ++i)\n j += q[i]; // Use after free here (note the statement q = p), read of q[i] is illegal\n return j;\n}"
                ]
            }
        }
    },
    {
        "master_id": 9,
        "category": "VUL",
        "language": "c,c++",
        "code": "UDR",
        "name": "Use dangling reference",
        "desc": "Dangling pointer has been used to refer to an invalid memory resource.",
        "msg_templ": "In file ${so.filename}, line ${so.line}, the memory reference variable ${so.var} in function ${so.func} is used. Such variable is first assigned as a memory reference that may not be valid in file ${so.filename}, line ${so.line}.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "HIGH",
        "details": "#### Abstract\nDangling pointer has been used to refer to an invalid memory resource.\n\n#### Explanation\nDangling pointers are pointers that refer to invalid or inappropriate memory resources. Referencing these memory resources may create memory corruption, resulting in unpredictable program behavior or system instablity.\n",
        "examples": {
            "good": {
                "c": [
                    "void assign(int *c)\n{\n    *c = 1;\n    return;\n}\n\nint foo()\n{\n    int a;\n    assign(&a); \n    printf(\"assigned value: %d\", a); // pointer is not dangling\n    return 0;\n}\n\n"
                ]
            },
            "bad": {
                "c": [
                    "int *assign()\n{\n    int *c;\n    c = 1;\n    return &c;\n}\n\nint foo()\n{\n    int *a;\n    a = assign(); // return a stack address and assign to a\n    printf(\"assigned value: %d\", a); // use dangling pointer\n    return 0;\n}",
                    "#include <alloca.h>\n#include <stdlib.h>\n\nvoid extern fill(char *data, int num);\nvoid dangling_ptr_func(int sz, char *data_buf)\n{\n  data_buf = alloca(sz);\n  fill(data_buf, sz);  // fill data buffer\n  // more manipulation of data buffer ...\n\n\n  // free does not really free data_buf\n  // data_buf points to memory that is out of scope after\n  free(data_buf);\n  return;\n}"
                ],
                "general": [
                    "int *assign()\n{\n int *c;\n c = 1;\n return &c;\n}\n\nint foo()\n{\n int *a;\n a = assign(); // return a stack address and assign to a\n printf(\\\"assigned value: %d\\\", a); // use dangling pointer\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 10,
        "category": "VUL",
        "language": "c,c++",
        "code": "WRF",
        "name": "Write to file for read only",
        "desc": "The program is performing write operations to a file that is available for read only.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} is performing write operations to a read-only file .",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is performing a write operation to a file that is available for read only\n\n#### Explanation\nWhen the file that is opened for read and later then written upon, the fwrite will report an error. If the result of fwrite is not checked, the program will continue and the file may not be updated as expected.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint file_operation()\n{\n    struct stat statBefore, statAfter;\n\n    lstat(\"/tmp/x\", &statBefore);\n\n    // file open for read\n    FILE *fp_open_readonly = fopen(\"/tmp/x\", \"w\");\n    lstat(\"/tmp/x\", &statAfter);\n\n    if (statAfter.st_ino == statBefore.st_ino)\n    {\n        if (fp_open_readonly != NULL)\n        {\n            // writing to the file\n            fwrite(\"HELLO!\", 1, 5, fp_open_readonly);\n        }\n    }\n\n    fclose(fp_open_readonly);\n    return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint file_operation()\n{\n    struct stat statBefore, statAfter;\n\n    lstat(\"/tmp/x\", &statBefore);\n\n    // file open for read\n    FILE *fp_open_readonly = fopen(\"/tmp/x\", \"r\");\n    lstat(\"/tmp/x\", &statAfter);\n\n    if (statAfter.st_ino == statBefore.st_ino)\n    {\n        if (fp_open_readonly != NULL)\n        {\n            // writing to the file\n            fwrite(\"HELLO!\", 1, 5, fp_open_readonly);\n        }\n    }\n\n    fclose(fp_open_readonly);\n    return 0;\n}"
                ],
                "general": [
                    "int file_operation(two_level *p, two_level *q)\n{\n struct stat statBefore, statAfter;\n\n lstat(\\\"/tmp/x\\\", &statBefore);\n\n // file open for read\n FILE *fp_open_readonly = fopen(\\\"/tmp/x\\\", \\\"r\\\");\n lstat(\\\"/tmp/x\\\", &statAfter);\n\n if (statAfter.st_ino == statBefore.st_ino) {\n if (fp_open_readonly != NULL) {\n // writing to the file\n fwrite(\\\"HELLO!\\\", 1, 5, fp_open_readonly);\n }\n }\n\n fclose(fp_open_readonly);\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 11,
        "category": "VUL",
        "language": "c,c++,java",
        "code": "AOB",
        "name": "Array out of bounds",
        "desc": "The program is accessing data outside the declared boundary (before or after) of the intended buffer.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, an array out of bound has been detected for variable ${si.var} in function ${si.func}. ",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "HIGH",
        "details": "#### Abstract\nThe program is accessing data outside (i.e. before or after) the declared boundary of the intended buffer.\n\n#### Explanation\nTypically, this can allow attackers to cause a crash during program execution. A crash can occur when the code reads sensitive information from other memory locations or causable amount of data and assumes that a sentinel exists to stop the read operation, such as a NUL in a string. The expected sentinel might not be located in the out-of-bounds memory, causing excessive data to be read, leading to a segmentation fault or a buffer overflow. The software may modify an index or perform pointer arithmetic that references a memory location that is outside of the boundaries of the buffer. A subsequent read operation then produces undefined or unexpected results.\n",
        "examples": {
            "good": {
                "c": [
                    "int assign(int* a, int i)\n{\n    return a[i];    /* called by main\n    a only has 2 elements but i is 2 */\n}\n\n#define ARR_SZ 2\nint main()\n{\n    int a[ARR_SZ] = {0, 1}, b;\n    b = assign(a, (ARR_SZ-1)); // call assign with a and i\n    // a has two elements and i is 2\n    // a[2] is out-of-bound and also uninitialized\n    printf(\"value of b = %d\\\\\", b);\n    return 0;\n}"
                ],
                "general": [
                    "int assign(int* a, int i)\n{\n return a[i]; /* called by main\n a only has 2 elements but i is 2 */\n}\n\n#define ARR_SZ 2\nint main() {\n int a[ARR_SZ] = {0, 1}, b;\n if ()\n b = assign(a, (ARR_SZ-1)); // call assign with a and i\n // a has two elements and i is 2\n // a[2] is out-of-bound and also uninitialized\n printf(\"value of b = %d\\\\\", b);\n return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "int assign(int* a, int i)\n{\n return a[i]; /* called by main\n a only has 2 elements but i is 2 */\n}\n\nint main() {\n int a[2] = {0, 1}, b;\n b = assign(a, 2); // call assign with a and i\n // a has two elements and i is 2\n // a[2] is out-of-bound and also uninitialized\n printf(\"value of b = %d\\\\\", b);\n return 0;\n}"
                ],
                "general": [
                    "int assign(int* a, int i)\n{\n return a[i]; /* called by main\n a only has 2 elements but i is 2 */\n}\n\nint main() {\n int a[2] = {0, 1}, b;\n b = assign(a, 2); // call assign with a and i\n // a has two elements and i is 2\n // a[2] is out-of-bound and also uninitialized\n printf(\"value of b = %d\\\\\", b);\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 12,
        "category": "BAD_PRACTICE",
        "language": "c,c++,java",
        "code": "CRF",
        "name": "Use recursive function",
        "desc": "The program has a call sequence that results in recursion at runtime.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} is calling itself. ",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has a call sequence that results in recursion at runtime\n\n#### Explanation\nRecursion happens when a function (e.g. A) calls another function in such a way that the call sequence eventually calls A again. In its most simple form, a function simply calls itself during the execution. If not programmed correctly, this could lead to an infinite loop. It can also cause an excessive use of stack space and may lead to running out of memory or stack space problems.\n",
        "examples": {
            "good": {
                "c": [
                    "// suppose first call to func_recurse is (p_glbl, 6)\n\nconst int MAXIMUM_LIMIT = 100;\nint global = 5;\nstatic *p_glbl = &global;\nint func_recurse(int *p, int i)\n{\n    if (i > MAXIMUM_LIMIT) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (i != 0) {\n        // recursion bottoms out when second argument tends to 0\n        return func_recurse(p_glbl, i - 1);                                           \n    }\n    return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "// Most simple forms of recursion.\n// if first call to func_recurse is: func_recurse(p_glbl, 6)\n// this code segment will recurse and get into an infinite loop\n\nint global = 5;\nstatic *p_glbl = &global;\nint func_recurse(int *p, int i)\n{\n    if ((p != 0) && (*p != i))\n    {\n        return func_recurse(p, 2); // calls itself directly\n    }\n    return 0;\n}"
                ],
                "general": [
                    "// Most simple forms of recursion.\n// if first call to func_recurse is: func_recurse(p_glbl, 6)\n// this code segment will recurse and get into an infinite loop\n\nint global = 5;\nstatic *p_glbl = &global;\nint func_recurse(int* p, int i)\n{\n if ((p != 0) && (*p != i))\n return func_recurse(p, 2); // calls itself directly\n return 0;\n}",
                    "// Indirect recursion.\n// if first call to func_recurse is: func_recurse(p_glbl, 6)\n// this code segment will call func_recurse inside func_b\n\nint global = 5;\nstatic *p_glbl = &global;\n\nint func_b(int *q, int j)\n{\n if (q != 0) {\n return func_recurse(q, 5);\n }\n else\n return 5;\n}\n\nint func_recurse(int *p, int i)\n{\n if ((p != 0) && (*p != i))\n return func_b(p, i); // calls func_recurse indirectly\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 13,
        "category": "CORRECTNESS",
        "language": "c,c++,java",
        "code": "DBZ",
        "name": "Division by zero",
        "desc": "The program is trying to divide a value by zero.",
        "msg_templ": "In file ${so.filename}, line ${so.line}, variable ${so.var} in function ${so.func}, a division by zero has been detected. Such variable has a value of zero.",
        "severity": "LOW",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "#### Abstract\nThe program is trying to divide a value by zero.\n\n#### Explanation\nThis can occur when an unexpected constant zero is assigned to the divisor, or if an error occurs that is not properly detected (for example, return value of a function call).\n\n",
        "examples": {
            "good": {
                "c": [
                    "int divide(int num, int denom) {\n\n    // checks if denom is 0, and always throws an\n    // error when trying to divide by 0\n    if (denom == 0) \n    {\n        printf(\"Cannot divide a number by 0\");\n        exit(133);\n    }\n\n    return num/denom;\n}"
                ]
            },
            "bad": {
                "c": [
                    "int divide(int num, int denom)\n{\n    // denom could be of value 0, and dividing \n    // by 0 results in undefined behavior\n    return num / denom;\n}\n\nint func(void)\n{\n    return divide(3, 0); // non-compliant\n}"
                ],
                "general": [
                    "int foo(int a, int guard)\n{\n int x = 0;\n int result = 0;\n if (guard != 0)\n result = a / x; // did not check for zero\n printf(\\\"result is %d\\\", result);\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 14,
        "category": "BAD_PRACTICE",
        "language": "c,c++,java",
        "code": "DDC",
        "name": "Unreachable code after jump",
        "desc": "Unreachable code after a jump statement.",
        "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line} has unreachable code during execution.",
        "severity": "LOW",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nUnreachable code after a jump statement.\n\n#### Explanation\nExecution will never reach statements that come immediately after a jump statement or function calls that do not return. This could be due to unintended edits and is a code quality issue.\n",
        "examples": {
            "good": {
                "c": [
                    "void abort();\nvoid exit();\nint foo();\n\nint f1()\n{\n    foo(); // reachable\n}\nint f2()\n{\n    foo(); // reachable\n}\n\nint f3()\n{\n    foo();\n    goto L;\n    L:\n        foo();  // reachable\n}\n"
                ]
            },
            "bad": {
                "c": [
                    "void abort();\nvoid exit();\nint foo();\n\nint f1()\n{\n    abort();\n    foo(); // unreachable\n}\nint f2()\n{\n    exit();\n    foo(); // unreachable\n}\n\nint f3()\n{\n    foo();\n    goto L;\n    foo(); // unreachable\nL:\n    foo();\n}\n\nint f4(int x)\n{\n    foo();\n    goto L;\n    if (x > 5)\n    { // unreachable\n    L:\n        foo();\n    }\n}\n"
                ],
                "general": [
                    "void abort();\nvoid exit();\nint foo();\n\nint f1() {\n abort();\n foo(); // unreachable\n}\nint f2() {\n exit();\n foo(); // unreachable\n}\n\nint f3() {\n foo();\n goto L;\n foo(); // unreachable\nL:\n foo();\n}\n\nint f4(int x) {\n foo();\n goto L;\n if (x>5) { // unreachable\nL:\n foo();\n }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 15,
        "category": "PFM",
        "language": "c,c++,java",
        "code": "DDV",
        "name": "Dead variable",
        "desc": "Execution of this statement will be nullified by another statement following it, or the result of this statement is never used.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, variable ${si.var} in function ${si.func}, a dead assignment has been detected.",
        "severity": "LOW",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nExecution of this statement will be nullified by another statement following it, or the result of this statement is never used.\n\n#### Explanation\nSuch error usually indicates either a typo or that some type of statement has been removed through time.\n",
        "examples": {
            "good": {
                "c": [
                    "void assign(int input)\n{\n    int a = input; // a is only used once and does not get nullified\n    printf(\"a value: %d\", a);\n}"
                ]
            },
            "bad": {
                "c": [
                    "void assign(int input)\n{\n    int a = 0; // dead code\n    a = input; // result of \\\"a = 0\\\" will be nullified by this statement\n    printf(\"a value: %d\", a);\n}"
                ],
                "general": [
                    "void assign(int input)\n{\n int a = 0; // dead code\n a = input; // result of \\\"a = 0\\\" will be nullified by this statement\n printf(\\\"a value: %d\\\", a);\n}"
                ]
            }
        }
    },
    {
        "master_id": 16,
        "category": "VUL",
        "language": "c,c++,java",
        "code": "FAM",
        "name": "Formal and actual parameter mismatch",
        "desc": "The program is calling a function with a number of parameter(s) that are used differently from the prototype declaration.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, the arguments in function ${si.func} do not match the function declaration in file ${si.filename}, line ${si.line}.",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "#### Abstract\nThe program is calling a function with number of parameter(s) that are used different from that of the prototype declaration.\n\n#### Explanation\nIn a call site, the number of actual parameters passed is different from that of the function declaration. If the actuals passed is less than that of the declaration, the missing actual will ended up being \\\"wild\\\" and could cause unpreditable behavior.\n",
        "examples": {
            "good": {
                "c": [
                    "int foo(int a, int guard)\n{\n    int x = 0;\n    int result = 0;\n    if (guard != 0)\n    {\n        result = a * x;\n    }\n    foo(result, guard); // no parameters missing\n    return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "int foo(int a, int guard)\n{\n    a++;\n    guard++;\n    return 0;\n}\n\nint func(void)\n{\n    int t = 1;\n    /* \n    missing one parameter, and \\\"guard\\\" will have \n    random value during execution at this point;\n    compilation error would be raised here\n    */\n    foo(t);\n    return 1;\n}"
                ],
                "general": [
                    "int foo(int a, int guard)\n{\n int x = 0;\n int result = 0;\n if (guard != 0)\n result = a * x;\n foo(result); // missing one parameter, and \\\"guard\\\" will have random value during execution at this point\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 17,
        "category": "ROBUSTNESS",
        "language": "c,c++,java",
        "code": "NPD",
        "name": "Null pointer dereference",
        "desc": "The program is accessing memory through a pointer with NULL value. This could cause a segmentation fault or unpredictable program behavior.",
        "msg_templ": "In file ${so.filename}, line ${so.line}, an NPD defect has been detected in function ${so.func} for variable ${so.var}. Such variable has a value of zero.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is accessing memory through a pointer with a NULL value. This will cause a segmentation fault or unpredictable program behavior. This vulnerability is equivalent to EXP34-C\n\n#### Explanation\nOn a system with memory protection, such as Linux, dereferencing a null pointer will cause a segmentation fault. For embedded systems, it will cause unpredicted program behavior. In Java, a null pointer dereference will trigger a null pointer exception.\n",
        "examples": {
            "good": {
                "c": [
                    "extern int bar(int);\n\nint assign(int* a)\n{\n int i;\n if (a != 0)\n i = bar(*a); // dereference a\n else {\n // handle error and exit gracefully (such exit program)\n exit(1);\n }\n return i;\n}\n\nint foo(void)\n{\n int *p = 0; // p as a pointer has been initialized to 0 (null)\n assign(p);\n}"
                ],
                "java": [
                    "class User {\n public String getName() {\n return null;\n }\n}\n\nclass Bar {\n private User findUser(String uid) {\n if (user.containsKey(uid)) {\n return user.get(uid);\n }\n else\n return null;\n }\n public void Npd(String uid) {\n // program continues\n // ...\n User user = findUser(uid); \n if (user == null) {\n throw new RuntimeException(\\\"Null String\\\");\n }\n String getName() {\n return null;\n }\n }\n}"
                ]
            },
            "bad": {
                "c": [
                    "extern int bar(int);\n\nint assign(int* a)\n{\n int i = bar(*a) // dereference a\n return i;\n}\n\nint foo(void)\n{\n int *p = 0; // p as a pointer has been initialized to 0 (null)\n assign(p);\n}"
                ],
                "java": [
                    "class User {\n public String getName() {\n return null;\n }\n}\n\nclass Bar {\n private User findUser(String uid) {\n if (user.containsKey(uid)) {\n return user.get(uid);\n }\n else\n return null;\n }\n public void Npd(String uid) {\n // program continues\n // ...\n User user = findUser(uid); // Throws NPE if \\\"user\\\" has not been properly initialized\n String getName() {\n return null;\n }\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 18,
        "category": "BAD_PRACTICE",
        "language": "c,c++,java",
        "code": "RCD",
        "name": "Redundant control dependency",
        "desc": "Redundant statements that are control dependent.",
        "msg_templ": "In file ${si.filename}, function ${si.func}, the statement at line ${si.line} is redundant.",
        "severity": "LOW",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nRedundant statements that are control dependent.\n\n#### Explanation\nWhen there are two conditional statements that are dependent in execution flow, then one conditional can logically subsume the other conditional statement. In that case, the other conditional is redundant and unnecessary. This could be due to an editing error and is a code quality issue.\n",
        "examples": {
            "good": {
                "c": [
                    "int foo();\nint bar();\n\nint f1(int x)\n{\n    if (x > 16) // removed x>15 since unnecessary\n        foo();\n}\n\nint f2(int x)\n{\n    if (x > 16) // removed x>15 since unnecessary\n        foo();\n}\n\nint f3(int x)\n{\n    if (x > 16)\n    {\n        foo();\n        bar(); // bar will always run anyways so no need an if statement\n    }\n}\n\nint f4(int x)\n{\n    if (x > 15)\n    {\n        foo();\n        if (x > 16) \n        {\n            bar();\n        }\n    }\n}"
                ]
            },
            "bad": {
                "c": [
                    "int foo();\nint bar();\n\nint f1(int x)\n{\n    if (x > 15 && x > 16) // x>16 will subsume x>15\n        foo();\n}\n\nint f2(int x)\n{\n    if (x > 16 && x > 15) // x>16 implies x>15, hence x>15 is redundant\n        foo();\n}\n\nint f3(int x)\n{\n    if (x > 16)\n    {\n        foo();\n        if (x > 15) // x>16 implies x>15, hence this check is unnecessary\n            bar();\n    }\n}\n\nint f4(int x)\n{\n    if (x > 15)\n    {\n        foo();\n        if (x > 16) // x>15 does not imply x>16, this check is not redundant\n            bar();\n    }\n}"
                ],
                "general": [
                    "int foo();\nint bar();\n\nint f1(int x) {\n if (x>15 && x>16) // x>16 will subsume x>15\n foo();\n}\n\nint f2(int x) {\n if (x>16 && x>15) // x>16 implies x>15, hence x>15 is redundant\n foo();\n}\n\nint f3(int x) {\n if (x>16) {\n foo();\n if (x>15) // x>16 implies x>15, hence this check is unnecessary\n bar();\n }\n}\n\nint f4(int x) {\n if (x>15) {\n foo();\n if (x>16) // x>15 does not imply x>16, this check is not redundant\n bar();\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 19,
        "category": "BAD_PRACTICE",
        "language": "c,c++,java",
        "code": "SCB",
        "name": "Same code block",
        "desc": "Same code blocks inside a conditional statement.",
        "msg_templ": "In file ${si.filename}, function ${si.func}, the blocks of code are the same on either side of the conditional statement at line ${si.line}.",
        "severity": "LOW",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nSame code block inside conditional statements.\n\n#### Explanation\nTwo code blocks are the same inside a conditional statement. This is likely due to an editing error. It is a code quality issue.\n",
        "examples": {
            "good": {
                "c": [
                    "int foo();\nint a, b;\n\nint f1(int x)\n{\n    foo(); // no dead code\n}\n\nint f2(int x)\n{\n    return foo();\n}\n"
                ]
            },
            "bad": {
                "c": [
                    "int foo();\nint a, b;\n\nint f1(int x)\n{\n    if (a) \n    {\n        foo();\n    } \n    else \n    {\n        foo();\n    }\n}\n\nint f2(int x)\n{\n    return x ? foo() : foo();  // equivalent to above\n}\n\nint f3(int x)\n{\n    if (x);  // both then and else blocks are empty\n}\n"
                ],
                "general": [
                    "int foo();\nint a, b;\n\nint f1(int x) {\n if (x) // in this condition (if-then-else, block 1 and block 2 are the same. Effectively making the conditional statement useless)\n foo(); // block 1\n else\n foo(); // block 2\n}\n\nint f2(int x) {\n return x ? foo() : foo(); // similar code written differently\n}\n\nint f3(int x) {\n  if (x);  // both then and else blocks are empty\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 20,
        "category": "BAD_PRACTICE",
        "language": "c,c++,java",
        "code": "SSE",
        "name": "Same sub-expression",
        "desc": "The program has the same sub-expressions.",
        "msg_templ": "In file ${si.filename}, function ${si.func}, line ${si.line} has sub-expressions that are conditionally the same.",
        "severity": "LOW",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has the same sub-expressions. \n\n#### Explanation\nThe same expressions are found in a statement, where the value of variables in the expression has not changed in value. It could be due to a typo in the program. This is a code quality issue.\n",
        "examples": {
            "good": {
                "c": [
                    "int foo();\nint a, b;\n\nint f3(int x, int *p)\n{\n    if (*p && *p) // same sub-expression\n        foo();\n}\n\nint f4(int x, int y)\n{\n    if ((x + y++) && (y + x)) // not same sub-expression due to y++\n        foo();\n}"
                ]
            },
            "bad": {
                "c": [
                    "int foo();\nint a, b;\n\nint f3(int x, int *p)\n{\n    if (*p && x) // both expressions are not the same \n    {\n        foo();\n    }  \n}\n\nint f4(int x, int y)\n{\n    if ((x + y++) && (y + x)) \n    {\n        foo();\n    }\n        \n}"
                ],
                "general": [
                    "int foo();\nint a, b;\n\n\nint f3(int x, int *p) {\n if (*p && *p) // same sub-expression\n foo();\n}\n\nint f4(int x, int y) {\n if ((x+y++) && (y+x)) // not same sub-expression due to y++\n foo();\n}"
                ]
            }
        }
    },
    {
        "master_id": 21,
        "category": "BAD_PRACTICE",
        "language": "c,c++,java",
        "code": "UIC",
        "name": "Uninitialized field in constructor",
        "desc": "A field of a class is not initialized in its constructor.",
        "msg_templ": "In file ${si.filename}, constructor ${si.func} at line ${si.line} has a field ${si.var} that is not initialized.",
        "severity": "LOW",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### Abstract\nA field of a class is not initialized in its constructor.\n\n#### Explanation\nConstructor of a class typically includes initialization of fields inside the class. When a field is not initialized, it is likely due to an editing error and is a code quality issue.\n",
        "examples": {
            "good": {
                "cpp": [
                    "#include <stdio.h>\n\nclass Construct_Init\n{\nprivate:\n    int a;\n    int b;\n\npublic:\n    // all variables in all constructors are\n    // initialized\n    Construct_Init()\n    {\n        a = 0;\n        b = 0;\n    };\n    Construct_Init(int i)\n    {\n        a = i;\n        b = 0;\n    }\n    Construct_Init(int i, int j)\n    {\n        a = i;\n        b = j;\n    }\n\n    void CI_Run() { printf(\"%d:%d\", a, b); }\n};\n\nint main(int argc, char **argv)\n{\n    Construct_Init ci;\n    ci.CI_Run();\n    Construct_Init ci1(1);\n    ci1.CI_Run();\n    Construct_Init ci2(1, 2);\n    ci2.CI_Run();\n}"
                ]
            },
            "bad": {
                "cpp": [
                    "#include <stdio.h>\n\nclass Construct_Init\n{\nprivate:\n    int a;\n    int b;\n\npublic:\n    // all variables in all constructors are\n    // initialized\n    Construct_Init();\n    Construct_Init(int i);\n    Construct_Init(int i, int j);\n\n    void CI_Run() { printf(\"%d:%d\", a, b); }\n};\n\nConstruct_Init::Construct_Init()\n{\n}\n\nConstruct_Init::Construct_Init(int i)\n{\n    a = i;\n}\n\nConstruct_Init::Construct_Init(int i, int j)\n{\n    a = i;\n    b = j;\n}\n\nint main(int argc, char **argv)\n{\n    Construct_Init ci;\n    ci.CI_Run();\n    Construct_Init ci1(1);\n    ci1.CI_Run();\n    Construct_Init ci2(1, 2);\n    ci2.CI_Run();\n}\n"
                ],
                "general": [
                    "#include <stdio.h>\n\nclass Construct_Init{\nprivate:\n int a;\n int b;\npublic:\n Construct_Init();\n Construct_Init(int i): a(i) {}; // did not initialize b\n Construct_Init(int i, int j) { a = i; b = j; }\n\n void CI_Run() { printf(\\\"%d:%d\\\n\\\", a, b); }\n};\n\nint main(int argc, char**argv)\n{\n Construct_Init ci;\n ci.CI_Run();\n Construct_Init ci1(1);\n ci1.CI_Run();\n Construct_Init ci2(1,2);\n ci2.CI_Run();\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 22,
        "category": "CORRECTNESS",
        "language": "c,c++,java",
        "code": "UIV",
        "name": "Uninitialized variable",
        "desc": "The program is using a variable before it has been initialized.",
        "msg_templ": "In file ${so.filename}, line ${so.line}, variable ${so.var} in function ${so.func} has been used but never assigned a value. ",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is using a variable before it has been initialized.\n\n#### Explanation\nStack variables in C and C++ are not initialized by default. Non-static global variables are not guaranteed to be zeroed. Their initial values are determined by the values that happen to be in their location in memory at the time the function is invoked. Doing so will cause an unexpected program behavior.\n",
        "examples": {
            "good": {
                "c": [
                    "int assign(int *a)\n{\n    return *a; // dereference a\n}\n\nint main()\n{\n    int a = 100; // a is assigned as 100\n    int b;\n    b = assign(&a); \n    printf(\"value of b = %d\", b);\n    return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "int assign(int *a)\n{\n    return *a; // dereference a\n}\n\nint main()\n{\n    int a, b;\n    b = assign(&a); // call assign with a uninitialized variable\n    printf(\"value of b = %d\", b);\n    return 0;\n}"
                ],
                "general": [
                    "int assign(int* a)\n{\n return *a; // dereference a\n}\n\nint main() {\n int a, b;\n b = assign(&a); // call assign with a uninitialized\n printf(\\\"value of b = %d\\\n\\\", b);\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 23,
        "category": "BAD_PRACTICE",
        "language": "c++,java",
        "code": "ECB",
        "name": "Empty catch block",
        "desc": "The program has an exception construct with an empty catch block.",
        "msg_templ": "In file ${si.filename}, function ${si.func}, the catch block in line ${si.line} is empty.",
        "severity": "LOW",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has an exception construct with an empty catch block.\n\n#### Explanation\nEmpty catch block effectively suppressed an exception from being correctly handled by another try block. The \\\"uncaught\\\" exception may cause unintended program behavior.\n",
        "examples": {
            "good": {
                "cpp": [
                    "#include <iostream>\n\nint integer_divide(int a, int b) {\n    if (b == 0) {\n        throw \"division by zero error\";\n    }\n    else return (a/b);\n}\n\nint foo(int x, int y) {\n    try {\n        int z = integer_divide(x, y);\n        std::cout << z << std::endl;\n    }\n    catch (const char* msg) {\n    // non-empty catch body and return error\n        std::cout << \"division exception\" << std::endl;\n        return 1;\n    }\n    return 0;\n}"
                ],
                "general": [
                    "#include <iostream>\n\nint integer_divide(int a, int b) {\n if (b == 0) {\n throw \\\"division by zero error\\\";\n }\n else return (a/b);\n}\n\nint foo(int x, int y) {\n try {\n int z = integer_divide(x, y);\n std::cout << z << std::endl;\n }\n catch (const char* msg) {\n // non-empty catch body and return error\n std::cout << \\\"division exception\\\" << std::endl;\n return 1;\n }\n return 0;\n}"
                ]
            },
            "bad": {
                "cpp": [
                    "#include <iostream>\n\nint integer_divide(int a, int b) \n{\n    if (b == 0) \n    {\n        throw \"division by zero error\";\n    }\n    else return (a/b);\n}\n\nint foo(int x, int y) {\n    try {\n        int z = integer_divide(x, y);\n        std::cout << z << std::endl;\n    }\n    catch (const char* msg) {\n    // empty catch body, zero as divisor notice suppressed\n    }\n    return 0;\n}"
                ],
                "general": [
                    "#include <iostream>\n\nint integer_divide(int a, int b) {\n if (b == 0) {\n throw \\\"division by zero error\\\";\n }\n else return (a/b);\n}\n\nint foo(int x, int y) {\n try {\n int z = integer_divide(x, y);\n std::cout << z << std::endl;\n }\n catch (const char* msg) {\n // empty catch body, zero as divisor notice suppressed\n }\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 24,
        "category": "VUL",
        "language": "c,c++",
        "code": "FIO37-C",
        "name": "fgets() and fgetws() may return an empty string",
        "desc": "The program is calling fgets() or fgetws(), assuming the string returned is a non-empty string.",
        "msg_templ": "In file ${si.filename}, line ${si.line},  ${si.func} may return a null string.",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is calling fgets() or fgetws() and assuming the string returned is a non-empty string.\n\n#### Explanation\nThe two functions may return a null string (e.g. the file may be a binary file).\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n\n#define BUF_SZ 1024\n\nvoid read_string(void)\n{\n char buf[BUF_SZ];\n FILE *fp = fopen(\"/myfile\", \"+r\");\n // check fp valid\n // ...\n\n if (fgets(buf, BUF_SZ, fp) != 0) {\n // replace newline character if it is there\n char *pchar = strchr(buf, '');\n if (pchar) *pchar = '\\\\0';\n\n printf(\"Size of string read = %d\", strlen(buf)-1);\n }\n\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n\n#define BUF_SZ 1024\n\nvoid read_string(void)\n{\n char buf[BUF_SZ];\n FILE *fp = fopen(\"/myfile\", \"+r\");\n // check fp valid\n // ...\n\n if (fgets(buf, BUF_SZ, fp) != 0) {\n // if the first character of buf is '\\\\0', a random meaningless large number will be printed\n printf(\"Size of string read = %d\", strlen(buf)-1);\n }\n\n}"
                ]
            }
        }
    },
    {
        "master_id": 25,
        "category": "VUL",
        "language": "c,c++",
        "code": "MSC32-C",
        "name": "Pseudo-random number generators should be properly seeded before use",
        "desc": "The program is using a pseudo random number generator with seeding (initial state) that will produce a deterministic sequence of numbers.",
        "msg_templ": "In file ${si.filename}, ${si.func}, line ${si.line} is calling variable ${si.var}. This generator will produce a deterministic sequence.",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### Abstract\nThe program is using a pseudo random number generator with seeding (initial state) that will produce a deterministic sequence of numbers.\n\n#### Explanation\nA properly seeded PRNG will generate a different number sequence each time it runs (e.g. call srandom() before invoking the random function). This prevents potential attackers to predict the number sequence generated. Alternatively, use random number generators that cannot be seeded.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n#include <stdlib.h>\n\n// function calls random() with proper seeding\nvoid print_rand(void)\n{\n    srandom(time(NULL));\n    for (int i = 0; i < 20; i++)\n    {\n        printf(\"%lx \\n\", random());\n    }\n}\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n#include <stdlib.h>\n\n// this function calls random() without proper seeding it\n// output of this function will be the same each time it is called\nvoid print_rand(void)\n{\n    for (int i = 0; i < 20; i++)\n    {\n        printf(\"%lx \\n\", random());\n    }\n}\n\n\n\n"
                ]
            }
        }
    },
    {
        "master_id": 26,
        "category": "VUL",
        "language": "c,c++",
        "code": "ENV32-C",
        "name": "Exit handlers must return normally",
        "desc": "The program is using an exit handler that does not return normally.",
        "msg_templ": "In file ${si.filename}, function ${si.func} is registered at line ${si.line} as exit handler. The program will exit and not return normally.",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is using some exit handler that does not return normally.\n\n#### Explanation\nThe following three functions _Exit(), exit(), quick_exit() are C standard exit functions. exit() and quick_exit() will call exit handlers atexit() and at_quick_exit() respectively for cleanup purposes, while _Exit() will not. User can define their own handlers and register with the system provided handlers. These exit handlers must return normally so that all exit handlers (thus all cleanup tasks) are properly performed. Furthermore, all exit handlers should not call exit().\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdlib.h>\n#include <stdio.h>\n\nstatic int file_opened;\n\nvoid my_exit1(void)\n{\n // some clean up code for opened file\n fprintf(stderr, \"abnormal exit from my_exit1() with file closed\\\\\");\n exit(0); // this exit handler does not return normally. exit() is called the second time when value of file_opened is 1.\n}\n\nvoid my_exit2(void)\n{\n if (file_opened == 1) {\n my_exit1();\n }\n fprintf(stderr, \"abnormal exit with errno %d\", errno());\n // other cleanup code\n // if file_opened is 1, the clean up code here will not be executed\n // ...\n return;\n\n}\n\nint main() {\n // ...\n file_opened = 1;\n if (atexit(my_exit2) != 0) {\n // handle error\n }\n}\n return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdlib.h>\n#include <stdio.h>\n\nextern int file_opened;\n\nint my_exit1(void)\n{\n // some clean up code for opened file\n fprintf(stderr, \"abnormal exit from my_exit1() with file closed\\\\\");\n exit(0); // this exit handler does not return normally. exit() is called the second time when value of file_opened is 1.\n}\n\nint my_exit2(void)\n{\n if (file_opened == 1) {\n my_exit1();\n }\n fprintf(stderr, \"abnormal exit with errno %d\", errno());\n // other cleanup code\n // if file_opened is 1, the clean up code here will not be executed\n // ...\n return 1;\n\n}\n\nint main() {\n // ...\n if (atexit(my_exit2) != 0) {\n // handle error\n }\n}\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 27,
        "category": "VUL",
        "language": "c,c++",
        "code": "ENV33-C",
        "name": "Please pay attention to the direct call to system()",
        "desc": "The program is calling the C standard system() function. When not properly protected, it could lead to various types of exploitation.",
        "msg_templ": "In file ${si.filename}, function ${si.func}, system() at line ${si.line} carries input parameters that have not been sanitized.",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is calling the C standard system() function. When not properly protected, it could lead to various exploitations.\n\n#### Explanation\nThe program is calling the system() function where the parameter is a character string. Such a string must be properly protected (examples: sanitized string, normalized path). Failure to do so will cause arbitrary program execution, privilege elevation or other unpredictable behavior.\n\n",
        "examples": {
            "good": {
                "c": [
                    "void func_call_sys(const char *in)\n{\n // system() is called with a string \\\"in\\\" passed from outside of this function\n // There is no evidence that \\\"in\\\" has been sanitized\n // Sanitize input to system()\n // use full path name for directory for example\n sanitise(in); // e.g. for file or directory name, do not include \\\"../\\\" substring\n system(in);\n}"
                ]
            },
            "bad": {
                "c": [
                    "void func_call_sys(const char *in)\n{\n // system() is called with a string \\\"in\\\" passed from outside of this function\n // There is no evidence that \\\"in\\\" has been sanitized\n // for example, if \\\"in\\\" is the string \\\"rm *\\\"\n // executing the system() call could be devastating\n system(in);\n}"
                ]
            }
        }
    },
    {
        "master_id": 28,
        "category": "VUL",
        "language": "c,c++",
        "code": "ERR33-C",
        "name": "Please check and handle standard library return errors",
        "desc": "The program is calling the standard library function but failed to check and handle the function error returns.",
        "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line}, the system library call ${si.var} is used without checking for error return.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is calling the standard library function but failed to check and handle the function error returns.\n\n#### Explanation\nThe program is calling a standard library function(s). These functions typically return a valid value, or some form of value that indicates an error. Failure to check if the call is successful leads to an unexpected or undefined behavior. Please refer to the language or system specification for a full description of the standard interface. Please note that there are system functions for which return values do not need to be checked. The list of these functions can also be found in the system or language specification. Notably the most popular ones are printf, vprintf, memcpy, memmove, strcpy, strcat, memset (and their wide char versions).\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n int len;\n int *data;\n} vec_rec, *vec_rec_ptr;\n\nenum { VEC_SZ = 32 };\n\nvec_rec vr[VEC_SZ] = { 0 }; // initialize table content\nvec_rec_ptr func_call_stdlib(int len, vec_rec_ptr in_vec)\n{\n vec_rec_ptr vrp = (vec_rec_ptr)(malloc(sizeof(vec_rec) * len));\n\n // Checks if vrp is NULL, such as when malloc failed\n if (vrp == NULL) \n {\n  printf(\"Malloc has failed, the program will terminate.\");\n  return NULL;\n }\n\n // this memcpy may enable an attacker to access memory causing remote code execution\n memcpy(vrp, in_vec, len);\n\n}\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n int len;\n int *data;\n} vec_rec, *vec_rec_ptr;\n\nenum { VEC_SZ = 32 };\n\nvec_rec vr[VEC_SZ] = { 0 }; // initialize table content\nvec_rec_ptr func_call_stdlib(int len, vec_rec_ptr in_vec)\n{\n vec_rec_ptr vrp = (vec_rec_ptr)(malloc(sizeof(vec_rec) * len));\n // vrp may be NULL if malloc failed\n // this code did not check that vrp may be invalid\n\n // this memcpy may enable an attacker to access memory causing remote code execution\n memcpy(vrp, in_vec, len);\n\n}"
                ]
            }
        }
    },
    {
        "master_id": 29,
        "category": "VUL",
        "language": "c,c++",
        "code": "FIO34-C",
        "name": "EOF or WEOF as \"char\" size objects are different from chars read from a file",
        "desc": "The program is using a return value of file read (such as getchar(), getc(), getwc()...) to check for EOF/WEOF as an end of file read operation.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} is using a return value of file read to check for EOF.",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is using a return value of file read (such as getchar(), getc(), getwc(),..) to check for EOF/WEOF as an end of file read operation.\n\n#### Explanation\nThe function that read characters from a file returned an int type. Directly comparing the character read with EOF/WEOF may cause an unexpected result because EOF and WEOF are implementation defined.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n\nvoid read_char(void)\n{\n\tFILE *fp = fopen(\"/tmp/myfile\", \"+r\");\n\t// check fp valid\n\t// ...\n\t\n\tint c = getc(fp);\n\t\n\t// make sure it is really an EOF character and that the EOF is due to end-of-file\n\t\n\twhile (c != EOF || (feof(stdin) && !ferror(stdin)) \n\t{\n\tputchar(c); // echo what is read in\n\tc = getc(fp);\n\t}\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n\nvoid read_char(void)\n{\n FILE *fp = fopen(\"/tmp/myfile\", \"+r\");\n // check fp valid\n // ...\n\n int c = getc(fp);\n while (c != EOF) // this check does not guarantee read has reached end of file\n {\n putchar(c); // echo what is read in\n c = getc(fp);\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 30,
        "category": "VUL",
        "language": "c,c++",
        "code": "FIO42-C",
        "name": "Close files when done with them",
        "desc": "The program has opened a file but then failed to close it when done or before the program terminated.",
        "msg_templ": "In file ${si.filename}, function ${si.func}, line ${si.line}, file ${si.var} was opened and not closed.",
        "severity": "MEDIUM",
        "likelihood": "UNLIKELY",
        "cost": "MEDiUM",
        "details": "#### Abstract\nThe program has opened a file but then failed to close the file when finished or before the program has terminated.\n\n#### Explanation\nIt is important to close a file when it is no longer needed. Failure to do so may expose resource (such as non-flushed data) associated with the file to attackers.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n\nint open_file(const char *fname)\n{\n FILE *fp = fopen(fname, \"+r\");\n if (fp == NULL) return -1;\n\n // program continues\n\n if (fclose(fp) == EOF) {\n // handle error\n ...\n }\n return 0; // file is properly closed on return\n\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n\nint open_file(const char *fname)\n{\n FILE *fp = fopen(fname, \"+r\");\n if (fp == NULL) return -1;\n\n // program continues\n return 0; // file is not properly closed on return\n\n}"
                ]
            }
        }
    },
    {
        "master_id": 31,
        "category": "VUL",
        "language": "c,c++",
        "code": "FIO45-C",
        "name": "File access may have race conditions and should be avoided",
        "desc": "Race conditions while accessing files (time of check, time of use) may happen and should be avoided.",
        "msg_templ": "In file ${si.filename} function ${si.func}, line ${si.line}, the file ${si.var} has TOCTOU problem.",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "#### Abstract\nRace conditions while accessing files (time of check, time of use) may happen and should be avoided.\n\n#### Explanation\nIn a shared file system, two or more processes may access the same file, causing a race condition. Attackers can change the file between two accesses or replace the file (symbolic or hard linked) with a different file.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\nint file_s1(char *p, char *q)\n{\n    struct stat statBefore, statAfter;\n\n    lstat(\"/tmp/x\", &statBefore);\n    \n    // \"x\" mode will cause fopen() to fail\n    // if the file exists.  \n    // NOTE: Only works for C11 and above or\n    // systems that support this feature\n    FILE *f = fopen(\"/tmp/x\", \"wx\");\n    if (statAfter.st_ino == statBefore.st_ino)\n    {\n        if (f != NULL)\n            fwrite(\"HELLO!\", 1, 5, f);\n    }\n\n    fclose(f);\n    return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n// This example is modified from example in \n// CERT-C FIO45 site\nint file_s1(char *p, char *q)\n{\n    struct stat statBefore, statAfter;\n\n    lstat(\"/tmp/x\", &statBefore);\n    // previous contents of file gets destroyed \n    // with \"w\" mode\n    FILE *f = fopen(\"/tmp/x\", \"w\");\n    lstat(\"/tmp/x\", &statAfter);\n    if (statAfter.st_ino == statBefore.st_ino)\n    {\n        if (f != NULL)\n            fwrite(\"HELLO!\", 1, 5, f);\n    }\n\n    fclose(f);\n    return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 32,
        "category": "VUL",
        "language": "c,c++",
        "code": "MEM35-C",
        "name": "Make sure sufficient memory has been allocated for an object",
        "desc": "The program has used the malloc family of functions to allocate memory that is smaller than the memory required by the program.",
        "msg_templ": "In file ${si.filename}, function ${si.func}, line ${si.line}, out of range memory access occurs. ",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "#### Abstract\nThe program has used malloc family of functions to allocate memory that is smaller than the memory required by the program.\n\n#### Explanation\nThe parameter corresponding to size arguments to the malloc functions should have sufficient range to represent the size of objects to be stored. Failure to do so will cause a buffer overflow leading to an unexpected program behavior.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdlib.h>\n\ntypedef struct\n{\n    size_t len;\n    int *data;\n} vect_record, *vect_ptr;\n\nvect_record *vector_new(size_t len)\n{\n    vect_record *vect;\n    // dereferenced pointer type means correct amount \n    // of memory is allocated for the struct tm object\n    vect_ptr result = (vect_ptr)malloc(sizeof(*vect));\n    if (result == NULL)\n    {\n        // handle error and return\n        return NULL;\n    }\n\n    // initialize vector\n    result[0].len = 1;\n    result[1].len = 2;\n    // ...\n    return result;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdlib.h>\n\ntypedef struct\n{\n    size_t len;\n    int *data;\n} vect_record, *vect_ptr;\n\nvect_record *vector_new(size_t len)\n{\n    vect_record *vect;\n    // size of pointer used to determine size of pointed-to object\n    vect_ptr result = (vect_ptr)malloc(sizeof(vect));\n    if (result == NULL)\n    {\n        // handle error and return\n        return NULL;\n    }\n\n    // initialize vector\n    result[0].len = 1;\n    result[1].len = 2;\n    // ...\n    return result;\n}"
                ]
            }
        }
    },
    {
        "master_id": 33,
        "category": "VUL",
        "language": "c,c++",
        "code": "MEM36-C",
        "name": "Calling realloc() may cause misalignment for previously aligned objects",
        "desc": "The program has used realloc() that causes a pointer with alignment which is less restrictive than before the memory reallocation.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} has used realloc().",
        "severity": "LOW",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "#### Abstract\nThe program has used realloc() that causes a pointer with alignment which is then less restrictive than before the memory reallocation.\n\n#### Explanation\nrealloc() will allocate new memory and set the previously allocated memory pointer to the newly allocated area. If the previously allocated memory has more restricted alignment (e.g. 16B), the memory that is newly pointed to it will not satisfy this restriction resulting in an unexpected program behavior.\n",
        "examples": {
            "good": {},
            "bad": {
                "c": [
                    "#include <stdlib.h>\n\nint *vector_calc(size_t vec_sz, int elements)\n{\n size_t align_vec = 1 << vec_sz;\n int *ptr_align;\n\n if ((ptr_align = (int *)aligned_alloc(align_vec, sizeof(int)*elements)) == NULL) {\n // handle error and return;\n // ...\n }\n\n // program continues\n // ...\n if ((ptr1 = (int *) realloc(ptr_align, sizeof(int)*elements * 2)) == NULL) {\n // handle error and return\n //...\n }\n\n // program continues\n // but ptr1 is not guaranteed to properly aligned with the vector objects previous allocated\n\n return ptr1;\n\n}"
                ]
            }
        }
    },
    {
        "master_id": 34,
        "category": "VUL",
        "language": "c,c++",
        "code": "MSC33-C",
        "name": "Use of asctime() function must pass the parameter needed with valid ranges",
        "desc": "The program is calling an asctime() function. However, the input parameter for that function is from an untrusted source.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, function asctime is called with ${si.var} as parameter, which may not have been sanitized.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### Abstract\nThe program is calling asctime() function, however the input parameter for that function is from an untrusted source.\n\n#### Explanation\nThe function asctime() does not validate the value or range of its input parameter. The subsequent use of the result from this function may cause a buffer overflow and other security violations when trying to print to a string.\n",
        "examples": {
            "good": {
                "c": [
                    "#define __STDC_WANT_LIB_EXT1__ 1\n#include <time.h>\n#include <stdio.h>\n\nenum\n{\n    max = 50\n};\n\nvoid read_time(struct tm *time_info)\n{   \n    // checks for invalid data below and handles \n    // error if exists\n    char buffer[max];\n    if (asctime_s(buffer, max, &time_info))\n    {\n        /* Handle error */\n    }\n\n    char *time = asctime(time_info);\n    printf(\"time is %s\", time);\n}\n    \n\n\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <time.h>\n#include <stdio.h>\n\nvoid read_time(struct tm *time_info)\n{\n    // does not check for invalid or potentially\n    // unsanitised data\n    char *time = asctime(time_info);\n    printf(\"time is %s\", time);\n}"
                ]
            }
        }
    },
    {
        "master_id": 35,
        "category": "VUL",
        "language": "c,c++",
        "code": "MSC37-C",
        "name": "Non-void functions should always exit this function through a return statement",
        "desc": "The program has an execution path that might reach the exit point of a non-void function without going through a \"return\" statement.",
        "msg_templ": "In file ${si.filename} at line ${si.line}, function ${si.func} is declared to return non-void but has reached end of function without a return statement.",
        "severity": "HIGH",
        "likelihood": "UNLIKELY",
        "cost": "LOW",
        "details": "#### Abstract\nThe program has an execution path that might reach the exit point of a non-void function without going through a \\\"return\\\" statement.\n\n#### Explanation\nWhen the program exits that function on an execution path without a return statement, then the return value will be non-deterministic causing an unexpected program behavior. If the function happens to be \\\"main\\\", or if the function is marked with \\\"no-return\\\" attribute, then there is no problem.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <string.h>\n#define BUF_SZ 1024\nint has_char(const char *s)\n{\n    if (s != NULL)\n    {\n        int l = strlen(s);\n        int i;\n        for (i = 0; i < l; i++)\n        {\n            if (s[i] == 'c')\n                return i;\n        }\n    }\n    // return statement ensures control never reaches end of\n    // the function, returns -1 if no letter 'c'\n    return -1;\n}\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <string.h>\n\n#define BUF_SZ 1024\n\nint has_char(const char *s)\n{\n    if (s != NULL)\n    {\n        int l = strlen(s);\n        int i;\n        for (i = 0; i < l; i++)\n        {\n            if (s[i] == 'c')\n                return i;\n        }\n    }\n    // missing return here, return value will be undefined\n}"
                ]
            }
        }
    },
    {
        "master_id": 36,
        "category": "VUL",
        "language": "c,c++",
        "code": "POS30-C",
        "name": "The readlink() function will only fill the buffer in the second argument not including the null terminator",
        "desc": "The program has called function readlink() and the number of characters written on the buffer (second argument) is not enough to hold a valid string.",
        "msg_templ": "In file ${si.filename} at line ${si.line}, the function readlink() is called and assigned to ${si.var}. The string read is not null terminated.",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has called function readlink() and the number of characters written on the buffer (second argument) is not enough to hold a valid string.\n\n#### Explanation\nThe number of characters written by readlink() may overflow the buffer specified in the second parameter. Also one needs to ensure that the end of the string is null terminated.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n\n#define BUF_SZ 1024\n\nint func(char *env_str)\n{\n    char buf[BUF_SZ];\n\n    // if len is >= sizeof(buf), up till the last byte of buf is non-null\n    ssize_t len = readlink(\"/usr/somedir/symlinkfile\", buf, sizeof(buf)); \n\n    // case handled when len is an invalid value\n    if (len >= sizeof(buf) || len == -1) {\n        // Handle Exception \n        return;\n    }\n\n    buf[len] = '\\0'; // len is always within buf size range\n    return;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n\n#define BUF_SZ 1024\n\nint func(char *env_str)\n{\n    char buf[BUF_SZ];\n\n    // if len is >= sizeof(buf), up till the last byte of buf is non-null\n    ssize_t len = readlink(\"/usr/somedir/symlinkfile\", buf, sizeof(buf));\n\n    // len is outside of buf size range (i may be -1 or i >= sizeof(buf))\n    buf[len] = '\\0'; \n    return;\n}"
                ]
            }
        }
    },
    {
        "master_id": 37,
        "category": "VUL",
        "language": "c,c++",
        "code": "POS34-C",
        "name": "The pointer argument in the putenv() call should not point to local objects",
        "desc": "The program has called putenv() with an argument that points to a local object.",
        "msg_templ": "In file ${si.filename} at line ${si.line}, the system function putenv() is called with variable ${si.var} as a parameter.",
        "severity": "HIGH",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has called putenv() with an argument that points to a local object.\n\n#### Explanation\nThe system that calls putenv() will save the argument (which is a pointer to the intended string) into the environment array. When the function returns to the caller, the local object with the environment string may be overwritten. This will cause an unpredictable program behavior.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <string.h>\n\n#define BUF_SZ 1024\n\nint func(char *env_str)\n{\n    // use a static array so that call to putenv() is \n    // only necessary the first time func() is called\n    static char buf[BUF_SZ];\n    // ...\n    if (strlen(env_str) < BUF_SZ)\n    {\n        strcpy(buf, env_str);\n        return putenv(buf);\n    }\n    else\n    {\n        // handle error\n        // ...\n    }\n    return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <string.h>\n\n#define BUF_SZ 1024\n\n// TEST environment variable may take on unintended value\n\nint func(char *env_str)\n{\n    char buf[BUF_SZ];\n    // ...\n    if (strlen(env_str) < BUF_SZ)\n    {\n        strcpy(buf, env_str);\n        return putenv(buf);\n    }\n    else\n    {\n        // handle error\n        // ...\n    }\n    return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 38,
        "category": "VUL",
        "language": "c,c++",
        "code": "POS35-C",
        "name": "When checking for validity of a symbolic link, there could be a race condition that may nullify the checked result",
        "desc": "The program has called function lstat() to check the named file for symbolic linkage. Results of this check may not be valid when the file is later accessed.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} has called lstat() to check the named file for symbolic linkage.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has called function lstat() to check the named file for symbolic linkage. Result of this check may not be valid when the file is later accessed.\n\n#### Explanation\nChecking that a file is a symbolic link suffers from time of call, time of use (TOCTOU) problem. In other words, when the file is finally opened for access, that the file is of symbolic link status may not be valid anymore.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n\n#define BUF_SZ 1024\n\nstruct stat link_info;\nint val;\n\nint func(char *fname)\n{\n    FILE *fp;\n    // Race condition eliminated by using O_NOFOLLOW \n    // to cause open() to fail if passed a symbolic link\n    int fd = open(fp, \"O_RDWR\"|\"O_NOFOLLOW\");\n    if (fd == -1)\n    {\n        /* Handle error */\n        return 0;\n    }\n\n    return 1;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n#include <stdlib.h>\n#include <sys/stat.h>\n\n#define BUF_SZ 1024\n\nstruct stat link_info;\nint val;\n\nint func(char *fname)\n{\n    FILE *fp;\n    if (lstat(fname, &link_info) == -1)\n    {\n        // handle error\n        // ...\n        printf(\"lstat return error\");\n        return 0;\n    }\n    else if (S_ISLNK(link_info.st_mode))\n    {\n\n        // both fopen and lstat operate on a file name\n        // the name can be manipulated asynchronously such that\n        // lstat and fopen referred to different files in reality\n        fp = fopen(fname, \"O_RDWR\"); \n        if (fp == 0)\n        {\n            // handle error\n            return 0;\n        }\n\n        size_t i = fread(&val, sizeof(int), 1, fp);\n        // ...\n    }\n    return 1;\n}"
                ]
            }
        }
    },
    {
        "master_id": 39,
        "category": "VUL",
        "language": "c,c++",
        "code": "POS37-C",
        "name": "When manipulating system privilege through the set/set uid/euid functions, please make sure that privileges are relinquished successfully",
        "desc": "The program has one of the get/set uid/euid set of functions which manipulates user ID privileges. The result of calling such functions is not checked which can cause the program's privilege to be in an unexpected state.",
        "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line}, privilege has not been properly restored.",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "LOW",
        "details": "#### Abstract\nThe program has one of the get/set uid/euid set of functions which manipulates user id privileges. The result of calling such functions is not checked which will cause the program's privilege to be in an unexpected state.\n\n#### Explanation\nPrivilege capabilities are implementation defined. To ensure that the privileges are set and relinquished as expected, it is important to check the error conditions on return. Failure to do this may result in the program being run with root permission.\n",
        "examples": {
            "good": {
                "c": [
                    " // ...\n\n // the following check alone is not sufficient. need to make sure privilege can be restored\n if (setuid(getuid()) != 0) {\n // Handle error\n }\n\n // check for failure to set uid when the caller is UID 0\n // failure to do this will result in a serious security risk\n if (setuid(0) != -1) {\n // privilege can be restored. Handle error\n }"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n#include <unistd.h>\n\nvoid func()\n{\n    // Permanently drop privileges\n    if (setuid(getuid()) != 0) {\n        // Handle error\n    }\n    \n    // Check for failure of privilege relinquishmnet has to be done here\n    // Else, attacker can regain elevated privileges    \n}"
                ]
            }
        }
    },
    {
        "master_id": 40,
        "category": "VUL",
        "language": "c,c++",
        "code": "POS54-C",
        "name": "When using POSIX library, please make sure to detect and appropriately handle errors on function returns",
        "desc": "The program has called some POSIX library functions but failed to check and handle the return error condition.",
        "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line} a POSIX function is called, and the call result was used without being validated.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### Abstract\nThe program has called some POSIX library function but failed to check and handle the return error condition.\n\n#### Explanation\nEach POSIX library has a well defined error return. Failure to check the return value for an indication of an error condition and handle the error appropriately will lead to an unexpected program behavior.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <sys/types.h>\n#include <sys/mman.h>\n#include <err.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main(void)\n{\n    const char str1[] = \"string 1\";\n    int fd = -1;\n    void *rwrite;\n\n    if ((fd = open(\"/usr/somefile\", O_RDWR, 0)) == -1)\n    {\n        err(1, \"open\");\n    }\n\n    rwrite = (char *)mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n\n    // checks if rwrite fails and handles error so that\n    // strcpy() works properly below\n    if (rwrite == NULL) \n    {\n        // Handle error\n    }\n\n    strcpy(rwrite, str1);\n\n    // ... continue\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <sys/types.h>\n#include <sys/mman.h>\n#include <err.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main(void)\n{\n    const char str1[] = \"string 1\";\n    int fd = -1;\n    void *rwrite;\n\n    if ((fd = open(\"/usr/somefile\", O_RDWR, 0)) == -1)\n    {\n        err(1, \"open\");\n    }\n\n    rwrite = (char *)mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n\n    // rwrite may not be valid pointer since mmap may have failed\n    strcpy(rwrite, str1);\n\n    // ... continue\n}"
                ]
            }
        }
    },
    {
        "master_id": 41,
        "category": "VUL",
        "language": "c,c++",
        "code": "SIG30-C",
        "name": "Signal handlers can only invoke asynchronous safe functions",
        "desc": "The program is calling non-asynchronous safe functions inside signal handlers.",
        "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line}, a call to signal with handler ${si.var} occurs. Such handler will call functions that are not asynchronous-safe.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is calling non-asynchronous safe functions inside signal handlers.\n\n#### Explanation\nThe table of asynchronous safe functions are functions that can be called safely without side effects by a signal handler. Non-reentrant functions are typically not safe. Users can check the system user manual for a full list of all safe functions to use.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nchar *messg = NULL;\n// sets flag of type volatile\nvolatile sig_atomic_t eflag = 0;\nint errflag;\n\n#define BUF_SZ 1024\n\nvoid put_messg(void)\n{\n    fputs(messg, stderr);\n}\n\nvoid handler(int signum)\n{\n    errflag = 1;\n}\n\nint main(void)\n{\n    if (signal(SIGINT, handler) == SIG_ERR)\n    {\n        // handle error\n    }\n    messg = (char *)malloc(BUF_SZ);\n    if (messg == 0)\n    {\n        // handle error\n    }\n\n    while (!errflag)\n    {\n        put_messg();\n        // ...\n    }\n\n    // put_messg() and free() are directly called from main()\n    put_messg();\n    free(messg);\n    messg = NULL;\n\n    return 0;\n}\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nchar *messg = NULL;\nint errflag;\n\n#define BUF_SZ 1024\n\nvoid put_messg(void)\n{\n    fputs(messg, stderr);\n}\n\nvoid handler(int signum)\n{\n    put_messg(); // this is not asynchronous safe\n    free(messg); // this is not asynchronous safe\n    errflag = 1;\n}\n\nint main(void)\n{\n    if (signal(SIGINT, handler) == SIG_ERR)\n    {\n        // handle error\n    }\n    messg = (char *)malloc(BUF_SZ);\n    if (messg == 0)\n    {\n        // handle error\n    }\n\n    if (!errflag)\n    {\n        put_messg();\n        // ...\n    }\n    return 0;\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 42,
        "category": "VUL",
        "language": "c,c++",
        "code": "SIG31-C",
        "name": "Signal handlers accessing shared variables or objects may result in race conditions",
        "desc": "The program is accessing a shared variable or an object inside a signal handler.",
        "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line}, a call to signal with handler ${si.var} is made. Such handler eventually will access a sharable memory object.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "HIGH",
        "details": "#### Abstract\nThe program is accessing a shared variable or object inside a signal handler.\n\n#### Explanation\nOther than variables of type \\\"volatile sig_atomic_t\\\", accessing any other type of objects from a signal handler may cause a race condition resulting in an undefined behavior.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <signal.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n\nchar *messg = NULL;\n#define BUF_SZ 1024\nint sockfd; // as a simple example, we assume sockfd has been properly initialized and connected\n\nint errflag; // this is a shared variable\n\nssize_t put_messg(void)\n{\n    ssize_t err = send(sockfd, (const void *)messg, BUF_SZ, MSG_DONTWAIT);\n    return err;\n}\n\nvoid handler(int signum)\n{\n    errflag = 1; // access shared variable inside handler\n}\n\nint main(void)\n{\n    messg = (char *)malloc(1024);\n    if (messg == 0)\n    {\n        // handle error\n    }\n\n    if (signal(SIGINT, handler) == SIG_ERR)\n    {\n        // handle error\n    }\n\n    if (!errflag)\n    {\n        if (put_messg() >= 0)\n        {\n            // messg sent\n            // ...\n        }\n        else\n        {\n            // ...\n        }\n    }\n    return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <signal.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n\nchar *messg = NULL;\n#define BUF_SZ 1024\nint sockfd; // as a simple example, we assume sockfd has been properly initialized and connected\n\nvolatile sig_atomic_t errflag = 0;\n\nssize_t put_messg(void)\n{\n    ssize_t err = send(sockfd, (const void *)messg, BUF_SZ, MSG_DONTWAIT);\n    return err;\n}\n\nvoid handler(int signum)\n{\n    errflag = 1; // access shared variable inside handler\n}\n\nint main(void)\n{\n    messg = (char *)malloc(1024);\n    if (messg == 0)\n    {\n        // handle error\n    }\n\n    if (signal(SIGINT, handler) == SIG_ERR)\n    {\n        // handle error\n    }\n\n    if (!errflag)\n    {\n        if (put_messg() >= 0)\n        {\n            // messg sent\n            // ...\n        }\n        else\n        {\n            // ...\n        }\n    }\n    return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 43,
        "category": "VUL",
        "language": "c,c++",
        "code": "STR02-C",
        "name": "Data passed to external packages or subsystems should be sanitized",
        "desc": "The program is passing string data to external packages or subsystems. These data as strings need to be sanitized.",
        "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line}, {si.var} is passed to a system call. This variable is declared and considered unsanitized through the program flow.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is passing string data to external packages or subsystems, these data strings need to be sanitized.\n\n#### Explanation\nWhen data containing sensitive information is passed to system calls, databases or other external third party components, it is important to ensure that only data that is acceptable to both producer and consumer will be passed.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdlib.h>\n#include <stdio.h>\n\nchar *messg = NULL;\n#define BUF_SZ 1024\n\nvoid foo(char *argv)\n{\n    int len;\n    char buf[BUF_SZ];\n\n\n    // filter out invalid data and characters\n    static char approved[] = \"abcdefghijklmnopqrstuvwxyz\"\n                             \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n                             \"1234567890_-.@\";\n    const char *end = *argv + strlen(*argv);\n    for (argv += strspn(argv, approved); argv != end; argv += strspn(argv, approved))\n    {\n        *argv = '_';\n    }\n\n    if (*argv != 0)\n        len = snprintf(buf, BUF_SZ, \"%s\", *argv); \n    if (len < 0)\n    {\n        // report error\n        return;\n    }\n    else\n    {\n        if (system(buf) == -1)\n        {\n            // report error\n            return;\n        }\n    }\n}\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdlib.h>\n#include <stdio.h>\n\nchar *messg = NULL;\n#define BUF_SZ 1024\n\nvoid foo(char *argv)\n{\n    int len;\n    char buf[BUF_SZ];\n\n    if (*argv != 0)\n        len = snprintf(buf, BUF_SZ, \"%s\", *argv); // buf will be fed into system call later. \\\"argv\\\" needs to be sanitized\n    if (len < 0)\n    {\n        // report error\n        return;\n    }\n    else\n    {\n        if (system(buf) == -1)\n        {\n            // report error\n            return;\n        }\n    }\n}"
                ]
            }
        }
    },
    {
        "master_id": 44,
        "category": "VUL",
        "language": "c,c++",
        "code": "STR31-C",
        "name": "Strings should have sufficient storage for all characters including the null terminator",
        "desc": "Ensure that the destination storage of a string is sufficiently large that it includes the terminating null.",
        "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line}, a pointer to character ${si.var} was used to fill another character array/pointer. ${si.var} is not large enough to hold all data including null terminator and may cause memory access error.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nEnsure that the destination storage of a string is sufficiently large that it includes the terminating null.\n\n#### Explanation\nA string is terminated by the null character and should be part of the string size/length. If the storage for the string is not sufficiently large enough, it will cause a buffer overflow or other spurious errors.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nvoid get_passwd(void)\n{\n    // length is not fixed, so no buffer overflow\n    \n    char *buf;\n    char *passwd = getenv(\"PASSWORD\");\n    if (passwd == NULL)\n    {\n        printf(\"Error getting password\");\n        exit(1);\n    }\n\n    size_t length = strlen(passwd) + 1;\n    buf = (char *)malloc(length);\n    if (buf == NULL)\n    {\n        // handle error\n    }\n\n    memcpy(buf, passwd, length);\n    free(buf);\n}\n\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nvoid get_passwd(void)\n{\n    char buf[256];\n    char *passwd = getenv(\"PASSWORD\");\n    if (passwd == NULL)\n    {\n        printf(\"Error getting password\");\n        exit(1);\n    }\n    //\n    // copy environmental string to a fixed-length can cause buffer overflow\n    //\n    strcpy(buf, passwd);\n}"
                ]
            }
        }
    },
    {
        "master_id": 45,
        "category": "VUL",
        "language": "c,c++",
        "code": "STR32-C",
        "name": "String parameters to library functions should be properly null-terminated",
        "desc": "The program is calling a library function with a string parameter. That string may not be properly terminated.",
        "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line}, ${si.var} is passed to a library function. This variable is not null terminated.",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is calling a library function with a string parameter. That string may not be properly terminated.\n\n#### Explanation\nLibrary functions that operate on a string that is not null terminated can result in accessing memory outside of the string object. This in turn will cause an unexpected program behavior.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdlib.h>\n#include <stdio.h>\n\nchar *messg = NULL;\n#define BUF_SZ 3\n\nvoid foo(void)\n{\n    char buf[] = \"123\";\n\n    printf(\"string is %s\", buf); \n\n    // ...\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdlib.h>\n#include <stdio.h>\n\nchar *messg = NULL;\n#define BUF_SZ 3\n\nvoid foo(void)\n{\n    char buf[BUF_SZ] = \"123\";\n\n    printf(\"string is %s\", buf); // buf may not be null terminated since the array is a local array\n\n    // ...\n}"
                ]
            }
        }
    },
    {
        "master_id": 46,
        "category": "VUL",
        "language": "c,c++",
        "code": "STR38-C",
        "name": "Do not confuse narrow and wide character strings and functions",
        "desc": "The program is using functions and parameters with mismatching character size or type for the size of characters in the string.",
        "msg_templ": "In file ${si.filename}, at line ${si.line}, ${si.var} is erroneously used for function ${si.func}.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### Abstract\nThe program is using functions and parameter with mismatching character size or type for the size of characters in the string.\n\n#### Explanation\nThe program is passing a pointer to an object and a size parameter to the library function. The two parameters, when combined, will cause the library function to access this object but outside its valid range, resulting in an undefined behavior.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stddef.h>\n#include <stdlib.h>\n#include <wchar.h>\n\n#define ARRAY_SZ 2\nint mismatch_char_type()\n{\n    char char_array[] = \"0123456789\";\n    char char_array_2[] = \"0123456789\";\n\n    // char type is the same, so comparing is acceptable\n    strncpy(&char_array[0], &char_array[2], sizeof(char_array));\n    return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stddef.h>\n#include <stdlib.h>\n#include <wchar.h>\n\n#define ARRAY_SZ 2\nint mismatch_char_type()\n{\n    char char_array[] = \"0123456789\";\n    wchar_t wchar_array[] = \"0123456789\";\n\n    // size of char_array is smaller than wchar_array due to different char type\n    memcpy(&char_array[0], &wchar_array[0], sizeof(wchar_array));\n    return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 47,
        "category": "VUL",
        "language": "c++",
        "code": "STR50-CPP",
        "name": "Ensure string storage is adequate for the content",
        "desc": "The program is using inappropriate string methods to process characters which may lead to validation checks that are bypassed or a memory leakage.",
        "msg_templ": "In file ${si.filename} at line ${si.line}, copying data into the buffer may result to buffer overflow.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is using inappropriate string methods to process characters which may lead to validation checks that are bypassed or a memory leakage.\n\n#### Explanation\nWhen trying to construct a string of char type in C or C++ , we must declare the maximum length if it is not initialized. When trying to input more characters into the variable (i.e. from console) than the variable can handle, a buffer overflow will occur. A buffer overflow will expose programs to attacks.\n",
        "examples": {
            "good": {
                "cpp": [
                    "void f(){\nstd:;string x;\nstd::cin >> x;\n}"
                ]
            },
            "bad": {
                "cpp": [
                    "#include <string>\n#include <iostream>\nvoid f(){\nchar x[5];\nstd::cin>>x;\n}"
                ]
            }
        }
    },
    {
        "master_id": 48,
        "category": "VUL",
        "language": "c++",
        "code": "ERR54-CPP",
        "name": "Order the catch handlers from most specific to the least specific",
        "desc": "Program fails to manage the catch handlers for exceptions in the correct order after a try statement. The current order is from the least derived (more general) to the most derived (more specific). Hence, catch handlers for the most derived will never be executed.",
        "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line}, the order of catch handler is not properly arranged. ",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### Abstract\nProgram fails to manage the catch handlers for exceptions in the correct order after a try statement. The current order is from least derived(more general) to most derived(more specific).\n \n#### Explanation\nCatch handlers go in order of declaration after a try statement. The correct order should be from the most derived to the least derived, from the most specific to the least specific.\nIf the catch starts from the least derived which may possibly be a problem caught from the most derived. This way, the catch handler for the most derived will never be executed, and that behaviour is not desirable.\n",
        "examples": {
            "good": {
                "cpp": [
                    "// Classes used for exception handling\n#include <iostream>\n \nclass Base {};\n \nclass Derived1 : public Base {};\nclass Derived2 : public Derived1 {};\n \nvoid foo();\nvoid bar();\n \nvoid foo()\n{\n std::cout << \"foo\" << std::endl;\n}\nvoid bar() {\n std::cout << \"bar\" << std::endl;\n}\n \nvoid f()\n{\n try {\n foo();\n bar();\n // ...\n }\n catch (Derived1 &) {\n // ...\n }\n catch (Base &)\n {\n // ...\n }\n try {\n foo();\n bar();\n // ...\n }\n catch (Derived2 &) {\n // ...\n }\n catch (Base &) //\n {\n // ...\n }\n \n try {\n foo();\n bar();\n // ...\n }\n catch (Derived1 *) {\n // ...\n }\n catch (Base *) { //\n // ...\n }\n}\n \nint main() {\n f();\n}"
                ]
            },
            "bad": {
                "cpp": [
                    "// Classes used for exception handling\n#include <iostream>\n \nclass Base {};\n \nclass Derived1 : public Base {};\nclass Derived2 : public Derived1 {};\n \nvoid foo();\nvoid bar();\n \nvoid foo()\n{\n std::cout << \"foo\" << std::endl;\n}\nvoid bar()\n{\n std::cout << \"bar\" << std::endl;\n}\n \nvoid f()\n{\n try {\n foo();\n bar();\n // ...\n }\n catch (Base &) {\n // ...\n }\n catch (Derived1 &) { // violation here in Line 19\n // ...\n }\n try {\n foo();\n bar();\n // ...\n }\n catch (Base &) {\n // ...\n }\n catch (Derived2 &) // violation here in Line 31\n {\n // ...\n }\n \n try {\n foo();\n bar();\n // ...\n }\n catch (Base *) {\n // ...\n }\n catch (Derived1 *) { // violation here in Line 44\n // ...\n }\n}\n \nint main() {\n f();\n}"
                ]
            }
        }
    },
    {
        "master_id": 49,
        "category": "VUL",
        "language": "c++",
        "code": "MEM55-CPP",
        "name": "User-defined dynamic storage management should follow the language requirements",
        "desc": "The program has replaced the function for dynamic memory allocation or deallocation that does not meet the semantic requirements specified by the C++ standard.",
        "msg_templ": "In file ${si.filename}, function${si.func}, line ${si.line}, the replacement function for allocation/deallocation violates the required semantics specified by the C++ standard.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has replaced the function for a dynamic memory allocation or a deallocation that does not meet the semantic requirements specified by the C++ standard.\n\n#### Explanation\nThe replacement function for allocation contains an external declaration that may return nullptr. The function \\\"new\\\" will instead return a nullptr instead of the supposed \\\"std::bad_alloc\\\". \n",
        "examples": {
            "good": {
                "cpp": [
                    "#include <cstdio>\n#include <cstdlib>\n#include <new>\n#include <iostream>\n\nextern void* cust_allocator(std::size_t);\n\nclass Person {\n int age; \n std::string name;\n \npublic:\n Person(){}\n void* operator new(size_t s)\n {\n if (((void*) ret = cust_allocator) == 0)\n return ret;\n return cust_allocator(s);\n }\n};"
                ]
            },
            "bad": {
                "cpp": [
                    "#include <cstdio>\n#include <cstdlib>\n#include <new>\n#include <iostream>\n\nextern void* cust_allocator(std::size_t);\n\nclass Person {\n int age; \n std::string name;\n \npublic:\n Person(){}\n void* operator new(size_t s)\n {\n return cust_allocator(s);\n }\n};"
                ]
            }
        }
    },
    {
        "master_id": 50,
        "category": "VUL",
        "language": "c++",
        "code": "MSC51-CPP",
        "name": "A proper seeding of pseudorandom generator is required",
        "desc": "The program doesn't properly seed the pseudorandom number generator. It has used a constant seed OR a non-constant seed that is predictable (i.e. time).",
        "msg_templ": "In file ${si.filename}, function ${si.func}, line ${si.line} uses a pseudorandom number generator that is not properly seeded. Seed is either constant or predictable.",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### Abstract\nThe program doesn't properly seed the pseudorandom number generator. It has used a constant seed OR it has used a seed that is predictable creating the same sequence over and over.\n\n#### Explanation\nWhen calling a pseudorandom number generator (PRNG) with the same initial state, like using the same seed, it will always generate the exact same sequence of numbers. An attacker will be able to easily predict the sequence of numbers and cause security issues.\n",
        "examples": {
            "good": {
                "cpp": [
                    "#include <stdlib.h>\n#include <iostream>\n#include <vector>\n\n#define MAX_VALUE 100\n#define VECTOR_SIZE 10\n\nint main() \n{\n std::vector<int> vec;\n std::random_device rd;\n\n srand(rd()); // seed is randomized again for every execution\n for(int i = 0 ; i < VECTOR_SIZE; ++i) {\n vec.push_back(rand()%MAX_VALUE); // no repeated sequence \n }\n\n for(int j=0 ; j < vec.size() ; ++j ) {\n std::cout << vec[j] << \\\" \\\";\n }\n std::cout << '\\\n';\n}"
                ]
            },
            "bad": {
                "cpp": [
                    "#include <stdlib.h>\n#include <iostream>\n#include <vector>\n\n#define MAX_VALUE 100\n#define VECTOR_SIZE 10\nint main()\n{ \n std::vector<int> vec;\n \n for(int i = 0 ; i < VECTOR_SIZE; ++i) {\n vec.push_back(rand()%MAX_VALUE); // using the same initial seed \n }\n\n // printing\n for(int j=0 ; j < vec.size() ; ++j ) {\n std::cout << vec[j] << \\\" \\\";\n }\n std::cout << '\\\n';\n}"
                ]
            }
        }
    },
    {
        "master_id": 51,
        "category": "VUL",
        "language": "c++",
        "code": "MSC54-CPP",
        "name": "Ensure signal handlers are a plain old function",
        "desc": "The signal handler function in the program is not a plain old function. The particular signal handler function uses pure C++ linkage with no linkage with C.",
        "msg_templ": "In file ${si.filename}, function ${si.func}, it is not a POF (plain old function) even though it exhibits a signal handler behaviour.",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "#### Abstract\nThe signal handler function in the program is not a plain old function. The particular signal handler function uses pure C++ linkage and no linkage with C. \n\n#### Explanation\nPOF or 'Plain Old Function' is a function that uses a feature on the common subset between C and C++ language. All signal handlers declared in a C++ source code must have a C linkage, otherwise it may cause an undefined behaviour.\n",
        "examples": {
            "good": {
                "cpp": [
                    "#include <iostream>\n#include <csignal>\nusing namespace std;\n\n// use C signature\nextern \\\"C\\\" void handle_signal(int signum)\n{\n cout << \\\"Signal to interrupt \\\" << signum << endl;\n exit(signum);\n}\n\nint main() \n{\n signal(SIGINT, handle_signal);\n // ....\n\n}"
                ]
            },
            "bad": {
                "cpp": [
                    "#include <iostream>\n#include <csignal>\nusing namespace std;\n\n\n\nvoid handle_signal(int signum) \n{\n cout << \\\"Signal to interrupt \\\" << signum << endl;\n exit(signum);\n}\n\nint main() \n{\n signal(SIGINT, handle_signal);\n // ....\n\n}"
                ]
            }
        }
    },
    {
        "master_id": 52,
        "category": "VUL",
        "language": "Java",
        "code": "IDS16-J",
        "name": "XMLStrings intended for XML processing must be validated before processing",
        "desc": "The program is manipulating XMLStrings intended for XML processing without validating the string.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, the string ${si.var} in function ${si.func} is not sanitized before being passed to XML query.",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is manipulating XMLString objects intended for XML processing without validating the string.\n\n#### Explanation\nWhen XMLString objects are not sanitized, the XML string could be maliciously injected and mistaken for valid XML, resulting in an XML injection attack.\n",
        "examples": {
            "good": {
                "java": [
                    "import java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\n \npublic class j_ids16_1 {\n public static void createXMLStreamBad(final BufferedOutputStream outStream,\n final String number) throws IOException {\n String xmlString = \\\"<item>\\\n<description>Widget</description>\\\n\\\"\n + \\\"<level>500</>\\\n\\\";\n\n if (number != null) {\n int sanitizedNumber = Integer.parseUnsignedInt(number);\n // the string xmlString should be validated\n // to prevent XML injection\n\\t xmlString = xmlString + \\\"<number>\\\" + sanitizedNumber\n + \\\"</number></item>\\\";\n }\n outStream.write(xmlString.getBytes());\n outStream.flush();\n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "import java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\n \npublic class j_ids16_1 {\n public static void createXMLStreamBad(final BufferedOutputStream outStream,\n final String number) throws IOException {\n String xmlString = \\\"<item>\\\n<description>Widget</description>\\\n\\\"\n + \\\"<level>500</>\\\n\\\";\n\n if (number != null) {\n // the string xmlString should be validated\n // to prevent XML injection\n\\t xmlString = xmlString + \\\"<number>\\\" + number\n + \\\"</number></item>\\\";\n }\n outStream.write(xmlString.getBytes());\n outStream.flush();\n }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 53,
        "category": "VUL",
        "language": "Java",
        "code": "MSC02-J",
        "name": "Use strong random number generators",
        "desc": "The program has used random number generators (PRNG) that are not strong enough.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, the method ${si.var} in function ${si.func} does not generate strong random numbers.",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has used random number generators (PRNG) that are not strong.\n\n#### Explanation\nJava API provides a PRNG in java.util.Random class which generates the same sequence when the same seed is used. For security sensitive programs, a more secure PRNG such as java.security.SecureRandom class should be used.\n",
        "examples": {
            "good": {
                "java": [
                    "// The Random() generates identical sequences in the following cases\nimport java.util.Random;\nimport java.lang.Math;\n\npublic class msc02_0 {\n\n public void foo0() {\n Random number = new SecureRandom(); // use SecureRandom class \n for (int i = 0; i < 20; i++) {\n int n = number.nextInt();\n System.out.println(n);\n }\n }\n\n public void foo1() {\n Random number = new SecureRandom.getInstanceStrong(); // use strong algorithm \n System.out.println(number.nextLong());\n }\n\n}"
                ]
            },
            "bad": {
                "java": [
                    "// The Random() generates identical sequences in all three cases\nimport java.util.Random;\nimport java.lang.Math;\n\npublic class msc02_0 {\n\n public void foo0() {\n Random number = new Random(123L);\n for (int i = 0; i < 20; i++) {\n int n = number.nextInt();\n System.out.println(n);\n }\n }\n\n public void foo1() {\n Random number = new Random();\n System.out.println(number.nextLong());\n }\n\n}"
                ]
            }
        }
    },
    {
        "master_id": 54,
        "category": "VUL",
        "language": "Java",
        "code": "SEC07-J",
        "name": "Call the superclass' getPermissions() method to implement a custom class loader",
        "desc": "The program has a custom class loader and failed to call the super.getPermission() method.",
        "msg_templ": "In file ${si.filename} at line ${si.line}, function ${si.func}, ${si.var} overrides getPermission() without invoking superclass' permission.",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "LOW",
        "details": "#### Abstract\nThe program has a custom class loader and failed to call super.getPermission() method. \n\n#### Explanation\nThe program has a custom class loader to override the getPermission() method. The implementation should invoke the superclass's getPermission() to get the default system policy before assigning custom permission to the program. This way, both system wide security policies are also applied.\n",
        "examples": {
            "good": {
                "java": [
                    "import java.net.URL;\nimport java.net.URLClassLoader;\nimport java.security.CodeSource;\nimport java.security.PermissionCollection;\nimport java.security.Permissions;\n\npublic class j_sec07_0 extends URLClassLoader { \n\n public j_sec07_0(URL[] urls) {\n super(urls);\n }\n\n protected PermissionCollection getPermissions(CodeSource cs) {\n // apply default system wide security policy\n PermissionCollection pc = superPermissions(cs);\n // Allow exit from the VM anytime\n pc.add(new RuntimePermission(\\\"exitVM\\\"));\n return pc;\n }\n\n public static boolean checkRtPermission(URL[] urls, String tag) {\n j_sec07_0 loader = new j_sec07_0(urls);\n PermissionCollection pc = loader.getPermissions(null);\n RuntimePermission rp = new RuntimePermission(tag);\n if(pc.implies(rp)) {\n System.out.println(\\\"Able to exit vm\\\");\n return true;\n } else {\n System.out.println(\\\"Not Able to exit VM\\\");\n return false;\n }\n }\n\n public static void main(String[] args) {\n URL[] urls = new URL[0];\n checkRtPermission(urls, \\\"exitVM\\\");\n checkRtPermission(urls, \\\"stopVM\\\");\n }\n\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "import java.net.URL;\nimport java.net.URLClassLoader;\nimport java.security.CodeSource;\nimport java.security.PermissionCollection;\nimport java.security.Permissions;\n\npublic class j_sec07_0 extends URLClassLoader { \n\n public j_sec07_0(URL[] urls) {\n super(urls);\n }\n\n protected PermissionCollection getPermissions(CodeSource cs) {\n PermissionCollection pc = new Permissions();\n // Allow exit from the VM anytime\n pc.add(new RuntimePermission(\\\"exitVM\\\"));\n return pc;\n }\n\n public static boolean checkRtPermission(URL[] urls, String tag) {\n j_sec07_0 loader = new j_sec07_0(urls);\n PermissionCollection pc = loader.getPermissions(null);\n RuntimePermission rp = new RuntimePermission(tag);\n if(pc.implies(rp)) {\n System.out.println(\\\"Able to exit vm\\\");\n return true;\n } else {\n System.out.println(\\\"Not Able to exit VM\\\");\n return false;\n }\n }\n\n public static void main(String[] args) {\n URL[] urls = new URL[0];\n checkRtPermission(urls, \\\"exitVM\\\");\n checkRtPermission(urls, \\\"stopVM\\\");\n }\n\n}"
                ]
            }
        }
    },
    {
        "master_id": 55,
        "category": "VUL",
        "language": "Java",
        "code": "DCL00-J",
        "name": "Program should not have a class initialization cycle",
        "desc": "The program has a class initialization that forms a cycle.",
        "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line}, the class ${si.var} forms an initialization cycle.",
        "severity": "LOW",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has class initialization that forms a cycle.\n\n#### Explanation\nStatic field triggers the initialization of a class. When the static field is dependent on the initialization of another class, a cycle will be created.\n",
        "examples": {
            "good": {
                "java": [
                    "import java.util.Calendar;\npublic class j_dcl00_0 {\n private int elapse;\n private static final int curr_year = Calendar.getInstance().get(Calendar.YEAR);\n private static final j_dcl00_0 obj = new j_dcl00_0(); // curr_year is initialized before used in constructor\n \n public j_dcl00_0() {\n if(200 > Calendar.getInstance().get(Calendar.YEAR))\n elapse = curr_year - 2000; \n }\n\n public static void main(String[] args) {\n System.out.println(\\\"It was \\\" + obj.elapse + \\\" years since 2000\\\");\n }\n \n}"
                ]
            },
            "bad": {
                "java": [
                    "import java.util.Calendar;\npublic class j_dcl00_0 {\n private int elapse;\n private static final j_dcl00_0 obj = new j_dcl00_0(); // self cycle (call constructor)\n private static final int curr_year = Calendar.getInstance().get(Calendar.YEAR);\n \n public j_dcl00_0() {\n if(200 > Calendar.getInstance().get(Calendar.YEAR))\n elapse = curr_year - 2000; // curr_year not initialized yet, due to constructor is called before curr_year assignment in line 73. \n // ( Remediate suggestion: swap lines 72 and line 73 will ensure initialized)\n }\n\n public static void main(String[] args) {\n System.out.println(\\\"It was \\\" + obj.elapse + \\\" years since 2000\\\");\n }\n \n}"
                ]
            }
        }
    },
    {
        "master_id": 56,
        "category": "VUL",
        "language": "Java",
        "code": "ENV03-J",
        "name": "Permissions should be granted explicitly and judiciously",
        "desc": "The program has called methods to grant permissions or a combination of permissions to the code.",
        "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line} with method ${si.var}, we detected a dangerous combination of permissions granted to an object.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### Abstract\nThe program has called methods to grant permissions or a combination of permissions to code, and this could be dangerous.\n\n#### Explanation\nA combination of permissions granting code could be dangerous. For example, when RuntimePermission is applied to createClassLoader it can create a custom class loader and assign arbitrary permissions. ReflectPermission and suppressAccessChecks together will suppress all standard checks. \n",
        "examples": {
            "good": {
                "java": [
                    "import java.net.URL;\nimport java.net.URLClassLoader;\nimport java.net.MalformedURLException;\nimport java.security.cert.Certificate;\nimport java.security.CodeSource;\nimport java.security.PermissionCollection;\nimport java.security.Permissions;\nimport java.lang.reflect.*;\n\npublic class env03_0 extends URLClassLoader {\n\n public env03_0(URL[] urls) {\n super(urls);\n }\n\n protected PermissionCollection getPermissions(CodeSource cs) {\n PermissionCollection pc = super.getPermissions(cs);\n // ...\n // other permissions\n return pc;\n }\n\n public static boolean checkRtPermission(URL[] urls, String tag) throws MalformedURLException{\n env03_0 loader = new env03_0(urls);\n Certificate[] cert = null;\n CodeSource cs = new CodeSource(new URL(\"http://abc\"), cert);\n PermissionCollection pc = loader.getPermissions(cs);\n ReflectPermission rp = new ReflectPermission(tag);\n if(pc.implies(rp)) {\n System.out.println(\"Able to get suppressAccessChecks\");\n return true;\n } else {\n System.out.println(\"Not Able to get suppressAccessChecks\");\n return false;\n }\n }\n\n public static void main(String[] args) throws MalformedURLException{\n URL[] urls = new URL[0];\n checkRtPermission(urls, \"suppressAccessChecks\");\n }\n\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "import java.net.URL;\nimport java.net.URLClassLoader;\nimport java.net.MalformedURLException;\nimport java.security.cert.Certificate;\nimport java.security.CodeSource;\nimport java.security.PermissionCollection;\nimport java.security.Permissions;\nimport java.lang.reflect.*;\n\npublic class env03_0 extends URLClassLoader {\n\n public env03_0(URL[] urls) {\n super(urls);\n }\n\n protected PermissionCollection getPermissions(CodeSource cs) {\n PermissionCollection pc = super.getPermissions(cs); \n pc.add(new ReflectPermission(\"suppressAccessChecks\")); // add permission to create a class loader\n // includes granting \"suppressAccessChecks\"\n // ...\n // other permissions\n return pc;\n }\n\n public static boolean checkRtPermission(URL[] urls, String tag) throws MalformedURLException{\n env03_0 loader = new env03_0(urls);\n Certificate[] cert = null;\n CodeSource cs = new CodeSource(new URL(\"http://abc\"), cert);\n PermissionCollection pc = loader.getPermissions(cs);\n ReflectPermission rp = new ReflectPermission(tag);\n if(pc.implies(rp)) {\n System.out.println(\"Able to get suppressAccessChecks\");\n return true;\n } else {\n System.out.println(\"Not Able to get suppressAccessChecks\");\n return false;\n }\n }\n\n public static void main(String[] args) throws MalformedURLException{\n URL[] urls = new URL[0];\n checkRtPermission(urls, \"suppressAccessChecks\");\n }\n\n}"
                ]
            }
        }
    },
    {
        "master_id": 57,
        "category": "VUL",
        "language": "Java",
        "code": "ENV06-J",
        "name": "Debugged entry points should not remain in product code",
        "desc": "The program should strip all code used for debugging and is not intended to be shipped or deployed with the application.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, \\\"main\\\" is found, possibly left over for debugging purposes.",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "LOW",
        "details": "#### Abstract\nThe program should strip all code used for debugging that is not intended to be shipped or deployed with the application. \n\n#### Explanation\nAlthough it is an acceptable practice to include \\\"main\\\" development, leaving that in production code could leave a backdoor entry point for an attacker. Methods that include \\\"main\\\" should be removed from production applications.\n",
        "examples": {
            "good": {
                "java": [
                    "public class my_code {\n // DEBUG is set to false, but \\\"main\\\" is left behind\n private static final boolean DEBUG = false;\n // remove the following statement if DEBUG is set to FALSE\n // public static void main(String[] args) {\n // my_code f = new my_code();\n // }\n}"
                ]
            },
            "bad": {
                "java": [
                    "public class my_code {\n // DEBUG is set to false, but \\\"main\\\" is left behind\n private static final boolean DEBUG = false;\n public static void main(String[] args) {\n my_code f = new my_code();\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 58,
        "category": "VUL",
        "language": "Java",
        "code": "ERR08-J",
        "name": "NullPointerException or any of its ancestors should not be caught",
        "desc": "The program is catching a NullPointerException.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, a NullPointerException is caught at the try block in function ${si.func}.",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is catching a NullPointerException. \n\n#### Explanation\nA NullPointerException thrown at runtime indicates an underlying defect that must be fixed in the application code. Catching this exception (or others like RuntimeException, Exception or Throwable) adds more runtime performance overhead. Furthermore, when this happens, the program is likely to be in an unknown state and any continued execution will cause unexpected results.\n",
        "examples": {
            "good": {
                "java": [
                    "public class err08_0 {\n boolean isName(String s) {\n try {\n String names = s.concat(\"abc\");\n if (names.length() != 5) {\n return false;\n }\n return true;\n } \n }\n\n boolean foo1() {\n try {\n throw new RuntimeException(\"xyz\");\n } catch (RuntimeException e) {\n // this catch RuntimeException is ancestor of the NullPointerException\n return false;\n }\n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "public class err08_0 {\n boolean isName(String s) {\n try {\n String names = s.concat(\"abc\");\n if (names.length() != 5) {\n return false;\n }\n return true;\n } catch (NullPointerException e) {\n // catch Null pointer exception \n return false;\n }\n \n }\n\n boolean foo1() {\n try {\n throw new RuntimeException(\"xyz\");\n } catch (RuntimeException e) {\n // this catch RuntimeException is ancestor of the NullPointerException\n return false;\n }\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 59,
        "category": "VUL",
        "language": "Java",
        "code": "EXP02-J",
        "name": "The Object.equals() should not be used to compare two arrays",
        "desc": "The program is comparing two arrays using an Object.equals() method.",
        "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line}, Object.equals() has been used to compare ${si.var}. ",
        "severity": "LOW",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### Abstract\nThe program is comparing two arrays using the Object.equals() method.\n\n#### Explanation\nTwo arrays are equal if they contain equivalent elements and in the same order. Using Object.equals() on arrays only compares array references, not their content.\n",
        "examples": {
            "good": {
                "java": [
                    "// this example is modified from CERT-J site\nimport java.util.Arrays;\n\npublic class exp02_example {\n\n public static void println(int[] ar1, int[] ar2) {\n System.out.println(Arrays.equals(arr1, arr2)); // prints true\n }\n \n public static void main(String[] args) {\n int[] arr1 = new int[20]; // Initialized to 0\n int[] arr2 = new int[20]; // Initialized to 0\n println(arr1, arr2); \n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "// this example is modified from CERT-J site\nimport java.util.Arrays;\n\npublic class exp02_example {\n\n public static void println(int[] ar1, int[] ar2) {\n System.out.println(ar1.equals(ar2)); // prints false\n }\n \n public static void main(String[] args) {\n int[] arr1 = new int[20]; // Initialized to 0\n int[] arr2 = new int[20]; // Initialized to 0\n println(arr1, arr2); \n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 60,
        "category": "VUL",
        "language": "Java",
        "code": "FIO02-J",
        "name": "File related errors should be checked and handled",
        "desc": "The program is attempting to manipulate a file but failed to check the validity of the return values from the method.",
        "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line}, a new file object ${si.var} is requested. Subsequent call to such object at line ${si.line} fails to check if file manipulation is successful.",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is attempting to manipulate a file but failed to check validity of the return values from the method.\n\n#### Explanation\nFile I/O operations in Java must check the return values of methods that perform the file I/O. For example, if not checked, File.delete() will silently fail.\n",
        "examples": {
            "good": {
                "java": [
                    "import java.io.File;\nimport java.io.IOException;\n\npublic class j_fio02_0 {\n void foo(boolean b) {\n try {\n File f = new File(\"file\");\n if (b) {\n if (f.delete()) {\n System.out.println(\"Deletion error\");\n }\n }\n else {\n if (f.delete()) {\n System.out.println(\"Deletion error\");\n }\n \n }\n }\n catch(Exception e) {\n System.out.println(\"Exception\");\n }\n }\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "import java.io.File;\nimport java.io.IOException;\n\npublic class j_fio02_0 {\n void foo(boolean b) {\n try {\n File f = new File(\"file\");\n if (b) {\n if (f.delete()) {\n System.out.println(\"Deletion error\");\n }\n }\n else {\n f.delete(); // failed to check return value of delete()\n }\n }\n catch(Exception e) {\n System.out.println(\"Exception\");\n }\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 61,
        "category": "VUL",
        "language": "Java",
        "code": "FIO05-J",
        "name": "Buffers created with wrap() or duplicate() should not be exposed to untrusted code",
        "desc": "The program is using wrap() or duplicate() methods in buffer class in the java.nio package. These buffers are exposed to untrusted code in the program.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, the backing array of the buffer class ${si.var} can be exposed to untrusted code through function ${si.func}.",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### Abstract\nThe program is using wrap() or duplicate() methods in buffer class in the java.nio package. These buffers are exposed to untrusted code in the program.\n\n#### Explanation\nThe methods will create a new Buffer object, backed by the given input array. Hence, the new Buffer object can be maliciously modified. It is important to use a read only Buffer or make sure the original buffer will not be modified. \n",
        "examples": {
            "good": {
                "java": [
                    "// this example is modified from CERT-J example\nimport java.nio.CharBuffer;\n\npublic class j_fio05_0 {\n private char[] dataArray;\n private CharBuffer cb;\n\n public j_fio05_0() {\n dataArray = new char[10];\n }\n\n public CharBuffer getBufferCopy() {\n return CharBuffer.wrap(dataArray).asReadOnlyBuffer(); // attemp to modify will result in exception\n }\n}",
                    "import java.nio.CharBuffer;\n\npublic class j_fio05_0 {\n private char[] dataArray;\n private CharBuffer cb;\n\n public j_fio05_0() {\n dataArray = new char[10];\n }\n\n public CharBuffer getBufferCopy() {\n return CharBuffer.wrap(dataArray).asReadOnlyBuffer();; // attempt to modify will result in exception\n }\n\n private void storeBuffer() {\n cb = CharBuffer.wrap(dataArray).asReadOnlyBuffer();; // attempt to modify will result in exception\n }\n\n public CharBuffer getBufferCopy2() {\n storeBuffer();\n return cb; \n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "// this example is modified from CERT-J example\nimport java.nio.CharBuffer;\n\npublic class j_fio05_0 {\n private char[] dataArray;\n private CharBuffer cb;\n\n public j_fio05_0() {\n dataArray = new char[10];\n }\n\n public CharBuffer getBufferCopy() {\n return CharBuffer.wrap(dataArray); // dataArray (private) is exposed through this wrap\n }\n}",
                    "import java.nio.CharBuffer;\n\npublic class j_fio05_0 {\n private char[] dataArray;\n private CharBuffer cb;\n\n public j_fio05_0() {\n dataArray = new char[10];\n }\n\n public CharBuffer getBufferCopy() {\n return CharBuffer.wrap(dataArray); // dataArray (private) is exposed through this wrap\n }\n\n private void storeBuffer() {\n cb = CharBuffer.wrap(dataArray); // dataArray (private) is exposed, see comment in return statement below\n }\n\n public CharBuffer getBufferCopy2() {\n storeBuffer();\n return cb; // dataArray is exposed through cb which is assigned in storeBuffer()\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 62,
        "category": "VUL",
        "language": "Java",
        "code": "FIO14-J",
        "name": "At program termination, proper cleanup should be performed through Runtime.exit()",
        "desc": "The program did not perform a proper cleanup when the program terminated.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, resource associated with ${si.var} will not be properly cleaned up when the program is terminated.",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program did not perform a proper cleanup when the program terminated.\n\n#### Explanation\nWhen irrecoverable errors are detected, it is common to quickly shut down the system and allow the operator to start over in a determinate state. This should include cleanup of the external resources. Failure to do so may leave important and sensitive data behind in the system.\n",
        "examples": {
            "good": {
                "java": [
                    "import java.io.*;\n\npublic class fio14_example {\n public static void reg_hook(PrintStream out) {\n // shut down hook will be called when Runtime.exit(),\n // make sure in call hierarchy,\n // there is an edge from Runtime.exit() to Runtime.addShutdownHook\n Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {\n public void run() {\n System.out.println(\"exit without closing file, need out.close()\");\n out.close(); // report double close\n }\n }\n ));\n }\n\n public static void close2() throws FileNotFoundException {\n final PrintStream out =\n new PrintStream(new BufferedOutputStream(\n new FileOutputStream(\"foo.txt\")));\n reg_hook(out);\n out.println(\"hello\");\n Runtime.getRuntime().exit(1);\n }\n public static void main(String[] args) throws FileNotFoundException{\n close2();\n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "import java.io.*;\n\npublic class fio14_example {\n public static void reg_hook(PrintStream out) {\n // shut down hook will be called when Runtime.exit(),\n // make sure in call hierarchy,\n // there is an path from Runtime.exit() to Runtime.addShutdownHook\n Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {\n public void run() {\n System.out.println(\"exit without closing file, need out.close()\");\n out.close(); // report double close\n }\n }\n ));\n }\n\n public static void close2() throws FileNotFoundException {\n final PrintStream out =\n new PrintStream(new BufferedOutputStream(\n new FileOutputStream(\"foo.txt\")));\n reg_hook(out);\n out.println(\"register hook\");\n Runtime.getRuntime().exit(1);\n }\n public static void main(String[] args) throws FileNotFoundException{\n close2();\n }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 63,
        "category": "VUL",
        "language": "Java",
        "code": "FIO16-J",
        "name": "Please canonicalize path names before validating them",
        "desc": "The program is validating pathnames without first canonicalizing them.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, the file name string ${si.var} in function ${si.func} is not canonicalized before the file is opened.",
        "severity": "MEDIUM",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is validating pathnames without first canonicalizing them.\n\n#### Explanation\nPathnames may contain special characters that make validation difficult. Also, a pathname may be symbolic links or shadows which attackers could use to bypass security check. It is important to fully resolve/canonicalize a pathname before validation. \n",
        "examples": {
            "good": {
                "java": [
                    "import javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.*;\n\npublic class fio16_example\n{\n\n public void bad_1(HttpServletRequest request, HttpServletResponse response) throws IOException\n {\n String fname = request.getParameter(\"FileName\");\n String info = request.getParameter(\"Info\");\n File fp = new File(fname);\n \n { \n String uniqPath = fp.getCanonicalPath();\n // va;odate after calling getCanonicalPath\n if (fp.exists() && is_safe(uniqPath) { \n FileOutputStream writer = new FileOutputStream(uniqPath);\n writer.write(info.getBytes());\n writer.close(); // info is written to validated location\n }\n }\n }\n \n private Boolean is_safe(String path)\n {\n // do path validation\n if(path.startsWith(\"/share/user\")) {\n return true;\n } else {\n return false;\n }\n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "import javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.*;\n\npublic class fio16_example\n{\n\n public void bad_1(HttpServletRequest request, HttpServletResponse response) throws IOException\n {\n String fname = request.getParameter(\"FileName\");\n String info = request.getParameter(\"Info\");\n File fp = new File(fname);\n \n if(fp.exists() && is_safe(fname)) { // fp validated but before calling getCanonicalPath,\n // hacker can bypass the validateion\n String uniqPath = fp.getCanonicalPath();\n FileOutputStream writer = new FileOutputStream(uniqPath);\n writer.write(info.getBytes());\n writer.close(); // info may be written to unkown location\n }\n }\n \n private Boolean is_safe(String path)\n {\n // do path validation\n if(path.startsWith(\"/share/user\")) {\n return true;\n } else {\n return false;\n }\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 64,
        "category": "VUL",
        "language": "Java",
        "code": "IDS00-J",
        "name": "String input to any SQL query must be sanitized before the query",
        "desc": "String input to any SQL query must be sanitized before the query.",
        "msg_templ": "In file ${si.filename}, function ${si.func} the string ${si.var} is not sanitized before the SQL query at line ${si.line}.",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nString input to any SQL query must be sanitized before the query.\n\n#### Explanation\nStrings that originated from an untrusted source must go through a sanitization and validation process to avoid being used as malicious input to a SQL database. Failure to do so may cause data leakage and privacy violations.\n",
        "examples": {
            "good": {
                "java": [
                    "import java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class j_ids00_2 {\n\n public Connection getConnection() throws SQLException {\n String dbConnection = System.getProperty(\\\"db.connection\\\");\n return DriverManager.getConnection(dbConnection);\n }\n\n String hashPwd(char[] pwd) {\n // Create hash of password\n return new String(pwd);\n }\n\n public void doPrivilegedAction(\n String username, char[] password // username is unsanitized \n ) throws SQLException, SecurityException {\n Connection connection = getConnection();\n if (connection == null) {\n // Handle error\n }\n try {\n String pwd = hashPwd(password);\n // the string query is composed with sanitized string (username) input\n PreparedStatement stmt = connection.prepareStatement(\\\"SELECT * FROM db_user WHERE username = ? AND passwd = ?\\\");\n \n // use set*() to enforce strong type checking\n stmt.setString(1, username); // to be sure, username may still be considered \\\"tainted\\\"\n stmt.setString(2, pwd); // to be sure, pwd ma still be considered \\\"tainted\\\" \n\n ResultSet result = stmt.executeQuery();\n if (!result.next()) {\n throw new SecurityException(\\\"User name/password incorrect\\\");\n }\n\n // Authenticated\n } finally {\n try {\n connection.close();\n } catch (SQLException x) {\n // Forward to handler\n }\n }\n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "import java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class j_ids00_2 {\n\n public Connection getConnection() throws SQLException {\n String dbConnection = System.getProperty(\\\"db.connection\\\");\n return DriverManager.getConnection(dbConnection);\n }\n\n String hashPwd(char[] pwd) {\n // Create hash of password\n return new String(pwd);\n }\n\n public void doPrivilegedAction(\n String username, char[] password // username is unsanitized \n ) throws SQLException, SecurityException {\n Connection connection = getConnection();\n if (connection == null) {\n // Handle error\n }\n try {\n String pwd = hashPwd(password);\n // the string query is composed with unsanitized string (username) input\n String query = \\\"SELECT * from where product username =\\\" +\n username + \\\" and password =\\\" + pwd;\n \n PreparedStatement stmt = connection.prepareStatement(query);\n\n ResultSet result = stmt.executeQuery();\n if (!result.next()) {\n throw new SecurityException(\\\"User name/password incorrect\\\");\n }\n\n // Authenticated\n } finally {\n try {\n connection.close();\n } catch (SQLException x) {\n // Forward to handler\n }\n }\n }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 65,
        "category": "VUL",
        "language": "Java",
        "code": "IDS01-J",
        "name": "Do not validate strings that have not been normalized",
        "desc": "The program is validating strings that have not been normalized.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, the string is validated in function ${si.var} before being normalized。",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is validating strings that have not been normalized.\n\n#### Explanation\nStrings have many representations such as \\\"char\\\", \\\"unicode\\\", etc. Many filtering or validation mechanisms are based on the strings' character data. Failure to filter out or normalize the string before validation could end up bypassing the validation mechanism, resulting in execution of arbitrary code.\n",
        "examples": {
            "good": {
                "java": [
                    "import java.text.Normalizer;\nimport java.text.Normalizer.Form;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n \npublic class j_ids01_0 { // inspired by CERT-J example\n public static String filterString(String str) {\n \n // Normalization form for validate String is NFKC\n String s = Normalizer.normalize(str, Form.NFKC); \n // compliant - Validate after the string is normalized\n Pattern pattern = Pattern.compile(\\\"<script>\\\");\n Matcher matcher = pattern.matcher(str);\n if (matcher.find()) {\n throw new IllegalArgumentException(\\\"Invalid input\\\");\n }\n return s;\n }\n \n public static void main(String[] args) {\n // \\\"\\\\ \\\" is a noncharacter code point\n String maliciousInput = \\\"<scr\\\" + \\\"\\\\ \\\" + \\\"ipt>\\\";\n String sb = filterString(maliciousInput);\n // sb = \\\"<script>\\\"\n }\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "import java.text.Normalizer;\nimport java.text.Normalizer.Form;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n \npublic class j_ids01_0 { // inspired by CERT-J example\n public static String filterString(String str) {\n \n // Non-compliant - Validate before the string is normalized\n Pattern pattern = Pattern.compile(\\\"<script>\\\");\n Matcher matcher = pattern.matcher(str);\n if (matcher.find()) {\n throw new IllegalArgumentException(\\\"Invalid input\\\");\n }\n // Normalization form for validate String is NFKC\n String s = Normalizer.normalize(str, Form.NFKC); \n return s;\n }\n \n public static void main(String[] args) {\n // \\\"\\\\ \\\" is a noncharacter code point\n String maliciousInput = \\\"<scr\\\" + \\\"\\\\ \\\" + \\\"ipt>\\\";\n String sb = filterString(maliciousInput);\n // sb = \\\"<script>\\\"\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 66,
        "category": "VUL",
        "language": "Java",
        "code": "IDS11-J",
        "name": "Do not modify a string that has gone through validation",
        "desc": "The program has changed a string that has gone through validation.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, the program modified the string ${si.var} that had been validated but now made untrusted again.",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has changed a string that has gone through validation.\n\n#### Explanation\nA string is modified after going through validation for processing.  The string may in turn become untrusted again which nullifies the previous validation effort. \n",
        "examples": {
            "good": {
                "java": [
                    "import java.text.Normalizer;\nimport java.text.Normalizer.Form;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n \npublic class j_ids11_0 {\n public static String filterString(String s) {\n // Normalize input string\n String str = Normalizer.normalize(s, Form.NFKC);\n \n // Delete noncharacter code\n // input string may have noncharacter code\n // however, the new string formed should go through normalize and validation again\n str = str.replaceAll(\\\"[\\\\\\\\p{Cn}]\\\", \\\"\\\");\n \n // Validate input after normalization\n Pattern pattern = Pattern.compile(\\\"<script>\\\");\n Matcher matcher = pattern.matcher(str);\n if (matcher.find()) {\n throw new IllegalArgumentException(\\\"Invalid input\\\");\n }\n \n return str;\n }\n // ... more code \n}"
                ]
            },
            "bad": {
                "java": [
                    "import java.text.Normalizer;\nimport java.text.Normalizer.Form;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n \npublic class j_ids11_0 {\n public static String filterString(String s) {\n // Normalize input string\n String str = Normalizer.normalize(s, Form.NFKC);\n \n // Validate input after normalization\n Pattern pattern = Pattern.compile(\\\"<script>\\\");\n Matcher matcher = pattern.matcher(str);\n if (matcher.find()) {\n throw new IllegalArgumentException(\\\"Invalid input\\\");\n }\n \n // Delete noncharacter code\n // input string may have noncharacter code\n // however, the new string formed should go through normalize and validation again\n str = str.replaceAll(\\\"[\\\\\\\\p{Cn}]\\\", \\\"\\\");\n return str;\n }\n // ... more code \n}"
                ]
            }
        }
    },
    {
        "master_id": 67,
        "category": "VUL",
        "language": "Java",
        "code": "IDS17-J",
        "name": "Improperly configured XML parser could cause XML external entity attack",
        "desc": "An external declaration that defines an external entity (typically specified by an URI) should be properly filtered.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, an external declaration is not properly filtered.",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nAn external declaration that defines an external entity (typically specified by an URI) should be properly filtered. \n\n#### Explanation\nThe external entities should be filtered, either through a whitelist or pre-registration so that XML attacks can be contained. Failure to do so could result in denial of service or data leakage.\n",
        "examples": {
            "good": {
                "java": [
                    "import java.io.IOException;\nimport org.xml.sax.EntityResolver;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\n\nclass ids17_CustomResolver implements EntityResolver {\n public InputSource resolveEntity(String publicId, String systemId)\n throws SAXException, IOException {\n // Check by whitelist good entity\n ....\n }\n}\n \npublic class ids17_example{\n private static void bad_receiveXMLStream(InputStream inStream,\n DefaultHandler defaultHandler)\n throws ParserConfigurationException, SAXException, IOException {\n SAXParserFactory factory = SAXParserFactory.newInstance();\n SAXParser saxParser = factory.newSAXParser();\n saxParser.parse(inStream, defaultHandler); // IDS17-J\n }\n\n private static void bad_receiveXMLStream2(InputStream inStream,\n DefaultHandler defaultHandler,\n Boolean do_sanitize) \n throws ParserConfigurationException, SAXException, IOException {\n try {\n SAXParserFactory factory = SAXParserFactory.newInstance();\n SAXParser saxParser = factory.newSAXParser();\n\n XMLReader reader = saxParser.getXMLReader();\n reader.setContentHandler(defaultHandler);\n // always sanitize\n reader.setEntityResolver(new ids17_CustomResolver()); // sanitized\n \n InputSource is = new InputSource(inStream);\n reader.parse(is); // no IDS17 complaince issue \n } catch (java.net.MalformedURLException mue) {\n System.err.println(\\\"Malformed URL Exception: \\\" + mue);\n }\n }\n\n \n public static void main(String[] args) throws ParserConfigurationException,\n SAXException, IOException {\n // invokes bad_receiveXMLStream and bad_receiveXMLStream2\n // ...\n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "import java.io.IOException;\nimport org.xml.sax.EntityResolver;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\n\nclass ids17_CustomResolver implements EntityResolver {\n public InputSource resolveEntity(String publicId, String systemId)\n throws SAXException, IOException {\n // Check by whitelist good entity\n ....\n }\n}\n \npublic class ids17_example{\n private static void bad_receiveXMLStream(InputStream inStream,\n DefaultHandler defaultHandler)\n throws ParserConfigurationException, SAXException, IOException {\n SAXParserFactory factory = SAXParserFactory.newInstance();\n SAXParser saxParser = factory.newSAXParser();\n saxParser.parse(inStream, defaultHandler); // IDS17-J\n }\n\n private static void bad_receiveXMLStream2(InputStream inStream,\n DefaultHandler defaultHandler,\n Boolean do_sanitize) \n throws ParserConfigurationException, SAXException, IOException {\n try {\n SAXParserFactory factory = SAXParserFactory.newInstance();\n SAXParser saxParser = factory.newSAXParser();\n\n XMLReader reader = saxParser.getXMLReader();\n reader.setContentHandler(defaultHandler);\n if(do_sanitize) {\n reader.setEntityResolver(new ids17_CustomResolver()); // sanitized\n }\n InputSource is = new InputSource(inStream);\n reader.parse(is); // IDS17-J, not setEntityResolver if !do_sanitize\n } catch (java.net.MalformedURLException mue) {\n System.err.println(\\\"Malformed URL Exception: \\\" + mue);\n }\n }\n\n \n public static void main(String[] args) throws ParserConfigurationException,\n SAXException, IOException {\n // invokes bad_receiveXMLStream and bad_receiveXMLStream2\n // ...\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 68,
        "category": "VUL",
        "language": "Java",
        "code": "MET06-J",
        "name": "Do not call overridable methods in clone()",
        "desc": "The program has called overridable methods in clone().",
        "msg_templ": "In file ${si.filename}, line ${si.line}, the overridable method ${si.var}, has been overridden by clone().",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "LOW",
        "details": "#### Abstract\nThe program has called overridable methods in clone().\n\n#### Explanation\nA malicious subclass could override the methods in clone() causing insecure or unpredictable behavior. Also, trusted subclasses could modify cloned objects which are in the construction process such that the object being cloned will be in an inconsistent state.\n",
        "examples": {
            "good": {
                "java": [
                    "import java.net.HttpCookie;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass j_met06 implements Cloneable {\n HttpCookie[] cookies;\n\n j_met06(HttpCookie[] c) {\n cookies = c;\n }\n\n public Object clone() throws CloneNotSupportedException {\n // get shallow copy of object\n final j_met06 clone = (j_met06) super.clone();\n clone.doSomething(); // Can invoke overridable method\n\n // the class has mutable object, need to deep copy those field\n clone.cookies = clone.deepCopy();\n return clone;\n }\n\n final void doSomething() { // not overridable method\n for (int i = 0; i < cookies.length; i++) {\n cookies[i].setValue(\\\"\\\" + i);\n }\n }\n\n final HttpCookie[] deepCopy() { // not overridable method\n if (cookies == null) {\n throw new NullPointerException();\n }\n\n // implements deep copy\n List<HttpCookie> cloned_cookie = new ArrayList<>();\n // ...\n return (HttpCookie[]) cloned_cookie;\n }\n}\n\nclass j_met06_ext extends j_met06 {\n j_met06_ext(HttpCookie[] c) {\n super(c);\n }\n\n public Object clone() throws CloneNotSupportedException {\n final j_met06_ext clone = (j_met06_ext) super.clone();\n clone.doSomething();\n return clone;\n }\n\n void doSomething() { // will not be called\n for (int i = 0;i < cookies.length; i++) {\n cookies[i].setDomain(i + \\\".xxx.com\\\");\n }\n }\n\n public static void main(String[] args)\n throws CloneNotSupportedException {\n HttpCookie[] hc = new HttpCookie[20];\n for (int i = 0 ; i < hc.length; i++){\n hc[i] = new HttpCookie(\\\"cookie\\\" + i,\\\"\\\" + i);\n }\n // deep copy was invoked, the original object cannot be modified\n j_met06 badcookie = new j_met06_ext(hc);\n badcookie.clone();\n }\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "// this example is extended from CERT site\nimport java.net.HttpCookie;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass j_met06 implements Cloneable {\n HttpCookie[] cookies;\n\n j_met06(HttpCookie[] c) {\n cookies = c;\n }\n\n public Object clone() throws CloneNotSupportedException {\n // get shallow copy of object\n final j_met06 clone = (j_met06) super.clone();\n clone.doSomething(); // Can invoke overridable method\n\n // the class has mutable object, need to deep copy those field\n clone.cookies = clone.deepCopy();\n return clone;\n }\n\n void doSomething() { // Overridable method\n for (int i = 0; i < cookies.length; i++) {\n cookies[i].setValue(\\\"\\\" + i);\n }\n }\n\n HttpCookie[] deepCopy() {\n if (cookies == null) {\n throw new NullPointerException();\n }\n\n // implements deep copy\n List<HttpCookie> cloned_cookie = new ArrayList<>();\n // ...\n return (HttpCookie[]) cloned_cookie;\n }\n}\n\nclass j_met06_ext extends j_met06 {\n j_met06_ext(HttpCookie[] c) {\n super(c);\n }\n\n public Object clone() throws CloneNotSupportedException {\n final j_met06_ext clone = (j_met06_ext) super.clone();\n clone.doSomething();\n return clone;\n }\n\n void doSomething() { // Erroneously executed\n for (int i = 0;i < cookies.length; i++) {\n cookies[i].setDomain(i + \\\".xxx.com\\\");\n }\n }\n\n public static void main(String[] args)\n throws CloneNotSupportedException {\n HttpCookie[] hc = new HttpCookie[20];\n for (int i = 0 ; i < hc.length; i++){\n hc[i] = new HttpCookie(\\\"cookie\\\" + i,\\\"\\\" + i);\n }\n // shallow copy was invoked, the original object can be modified\n j_met06 badcookie = new j_met06_ext(hc);\n badcookie.clone();\n }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 69,
        "category": "VUL",
        "language": "Java",
        "code": "MSC61-J",
        "name": "Security critical code must avoid using insecure or weak crypto algorithms",
        "desc": "The program is using weak cryptographic algorithms for security sensitive code.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, the encryption method ${si.var} in function ${si.func} used is generally weak and insecure.",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "#### Abstract\nThe program is using weak cryptographic algorithms for security sensitive code.\n\n#### Explanation\nSecurity and privacy sensitive information should be using strong encryption algorithms. Strong algorithms may include AES with Galois/Counter Mode (GCM) and AES with Cipher Block Chaining mode.\n",
        "examples": {
            "good": {
                "java": [
                    "import javax.crypto.*;\nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\n\npublic class j_msc61_0 {\n \n public static SecretKey genKey() {\n // DES is a weak encryption algorithm\n // AES is also weak, however, if AES is to be used\n // GCM (Galois/Counter Mode) will do the encryption\n try {\n KeyGenerator keygen = KeyGenerator.getInstance(\\\"AES\\\");\n keygen.init(128);\n return keygen.generateKey();\n } catch (NoSuchAlgorithmException e) {\n // handle exception\n ...\n }\n }\n \n public static byteArray[] encryption(String strToBeEncrypted, SecretKey seckey) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, UnsupportedEncodingException, BadPaddingException, IllegalBlockSizeException {\n Cipher cipher = Cipher.getInstance(\\\"AES/GCM/NoPadding\\\");\n // please consult example in CERT-J site for MSC61-J\n ...\n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "import javax.crypto.*;\nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\n\npublic class j_msc61_0 {\n public static byteArray[] encryption(String strToBeEncrypted) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, UnsupportedEncodingException, BadPaddingException, IllegalBlockSizeException {\n \n // DES is a weak encryption algorithm\n // AES is also weak, however, if AES is to be used\n // GCM (Galois/Counter Mode) will do the encryption\n SecretKey key = KeyGenerator.getInstance(\\\"DES\\\").generateKey();\n Cipher cipher = Cipher.getInstance(\\\"DES\\\");\n cipher.init(Cipher.ENCRYPT_MODE, key);\n\n // Encode bytes as UTF8; strToBeEncrypted contains\n // the input string that is to be encrypted\n byteArray[] encoded = strToBeEncrypted.getBytes(\\\"UTF8\\\");\n\n // Perform encryption\n byteArray[] encrypted = cipher.doFinal(encoded);\n return encrypted;\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 70,
        "category": "VUL",
        "language": "Java",
        "code": "OBJ09-J",
        "name": "Comparing class names may cause mix and match attacks",
        "desc": "Comparing class names may cause mix and match attacks.",
        "msg_templ": "In file ${si.filename} function ${si.func}, line ${si.line}, name is used to compare classes.",
        "severity": "HIGH",
        "likelihood": "UNLIKELY",
        "cost": "LOW",
        "details": "#### Abstract\nComparing class names may cause mix and match attacks.\n\n#### Explanation\nTwo classes are the same class only if they have the same qualified names. Classes with the same name may have different package names. Also distinct class loaders (or different instances of the class loader) will result in different classes with the same fully qualified names. \n",
        "examples": {
            "good": {},
            "bad": {
                "java": [
                    "import java.lang.String;\npublic class j_obj09_1 {\n void callComp(Boolean v) {\n Class cls1 = getClass();\n Class cls2 = String.class;\n if(v) {\n badComp1(cls1.getName()); \n } else {\n badComp2(cls1.getName(), cls2.getName());\n }\n }\n Boolean badComp1(String clsName) {\n if(clsName.equals(\\\"j_obj09_0\\\")) {\n return true;\n }\n else {\n return false;\n }\n } \n\n Boolean badComp2(String name1, String name2)\n {\n if(name1.equals(name2)) {\n return true;\n }\n else {\n return false;\n }\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 71,
        "category": "VUL",
        "language": "Java",
        "code": "OBJ11-J",
        "name": "Constructors should not throw exceptions",
        "desc": "Constructors throwing exceptions could leave the object in a partially initialized state.",
        "msg_templ": "Constructor ${si.func}, is throwing exception ${si.var} in ${si.filename}, line ${si.line}.",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nConstructors throwing exceptions could leave the object in a partially initialized state.\n\n#### Explanation\nDuring objection construction, the object is in a partially initialized state. Throwing exceptions during construction could leave the object in an unstable state.\n",
        "examples": {
            "good": {},
            "bad": {
                "java": [
                    "import java.io.IOException;\n\npublic class obj11_0 {\n public obj11_0()\n {\n // by throwing an exception in constructor\n // attacker can capture a reference to the partially initialized object of the obj11_0 class since\n // the object reference remains in the garbge collector\n if (!performVerification()) {\n throw new SecurityException(\\\"Access Denied!\\\");\n }\n }\n\n private boolean performVerification() {\n return false; // Returns true if data entered is valid, else false\n // Assume that the attacker always enters an invalid value\n }\n\n public void greeting() {\n System.out.println(\\\"Welcome user!\\\");\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 72,
        "category": "VUL",
        "language": "Java",
        "code": "SEC02-J",
        "name": "Security check code should not be based on untrusted sources",
        "desc": "The program has security checks whose sources are possibly from an untrusted origin.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, the method ${si.func} is returning untrusted sources to ${si.var} under assumed checked security.",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has security checks whose sources are possibly from an untrusted origin.\n\n#### Explanation\nUntrusted code may have been from many different sources. The check method could be bypassed through overriding. The checked object may be overridden also after the check. Even if the object is saved after passing the security check, the copy method itself may not be sufficient if the method is not thorough enough (such as shallow copy).\n",
        "examples": {
            "good": {
                "java": [
                    "import java.io.FileNotFoundException;\nimport java.io.RandomAccessFile;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.io.IOException;\n\npublic class sec02_0 {\n public static RandomAccessFile openFile(final java.io.File f) {\n // get a copy through getPath(), but not a clone\n final java.io.File copy = new java.io.File(f.getPath());\n // use copy of path later on\n if (copy.getPath().contains(\\\"passwd\\\")){\n return null;\n };\n // ...\n return (RandomAccessFile) AccessController.doPrivileged(new PrivilegedAction<Object>() {\n public Object run() {\n try {\n return new RandomAccessFile(copy.getPath(), \\\"r\\\");\n } catch (FileNotFoundException e) {\n e.printStackTrace();\n }\n return null;\n }\n });\n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "import java.io.FileNotFoundException;\nimport java.io.RandomAccessFile;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.io.IOException;\n\npublic class sec02_0 {\n public static RandomAccessFile openFile(final java.io.File f) {\n // getPath() can be extended, thus security check can pass the first time, \n // but getPath() changed the second time, bypass the good check\n if (f.getPath().contains(\\\"passwd\\\")){\n return null;\n };\n // ...\n return (RandomAccessFile) AccessController.doPrivileged(new PrivilegedAction<Object>() {\n public Object run() {\n try {\n return new RandomAccessFile(f, \\\"r\\\");\n } catch (FileNotFoundException e) {\n e.printStackTrace();\n }\n return null;\n }\n });\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 73,
        "category": "VUL",
        "language": "Java",
        "code": "SEC06-J",
        "name": "The default automatic signature verifier provided by URLClassLoader and java.util.jar should not be used",
        "desc": "The program is using the default automatic signature verifier provided by the URLClassLoader and java.util.jar.",
        "msg_templ": "In file ${si.filename}, function ${si.func}, line ${si.line}, method ${si.var} uses the default automatic signature verification by URLClassLoader. ",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is using the default automatic signature verifier provided by the URLClassLoader and java.util.jar.\n\n#### Explanation\nUsing these packages as default automatic signature verification is not sufficient when the signature is used for privilege elevation purposes. It only performs an integrity check. Also it only uses a public key which may have been maliciously modified for authentication of loaded classes.\n",
        "examples": {
            "good": {
                "java": [
                    "package io.xc5.cert;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.JarURLConnection;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.jar.Attributes;\nimport java.security.GeneralSecurityException;\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.io.FileInputStream;\n\npublic class j_sec06_fp_1 extends URLClassLoader {\n private URL url;\n public j_sec06_fp_1(URL url) {\n super(new URL[] { url });\n this.url = url;\n }\n\n Boolean verifyClass(Class c) throws ClassNotFoundException, NoSuchMethodException,\n InvocationTargetException, GeneralSecurityException,\n IOException {\n Certificate[] certs = c.getProtectionDomain().getCodeSource().getCertificates();\n if (certs == null) {\n return false;\n }\n else { \n KeyStore ks = KeyStore.getInstance(\\\"JKS\\\");\n ks.load(new FileInputStream(\\\"sec06.jks\\\"), \\\"loadkeystorepassword\\\".toCharArray());\n Certificate pubCert = ks.getCertificate(\\\"sec06\\\");\n // Check with the trusted public key, else throws exception\n certs[0].verify(pubCert.getPublicKey());\n return true;\n }\n }\n\n public void invokeClass(String name, String[] args)\n throws ClassNotFoundException, NoSuchMethodException,\n InvocationTargetException , GeneralSecurityException, IOException {\n Class c = loadClass(name);\n Method m = c.getMethod(\\\"getValue\\\", new Class[] { args.getClass() });\n m.setAccessible(true);\n \n // use customized, non-default verification method declared above\n if(verifyClass(c)) {\n try {\n m.invoke(null, new Object[] { args });\n } catch (IllegalAccessException e) {\n System.out.println(\\\"Access denied\\\");\n }\n }\n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "package io.xc5.cert;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.net.JarURLConnection;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.jar.Attributes;\nimport java.security.GeneralSecurityException;\nimport java.security.KeyStore;\nimport java.security.cert.Certificate;\nimport java.io.FileInputStream;\n\npublic class j_sec06_1 extends URLClassLoader {\n private URL url;\n public j_sec06_1(URL url) {\n super(new URL[] { url });\n this.url = url;\n }\n\n public void invokeClass(String name, String[] args)\n throws ClassNotFoundException, NoSuchMethodException,\n InvocationTargetException , GeneralSecurityException, IOException {\n Class c = loadClass(name);\n Method m = c.getMethod(\\\"getValue\\\", new Class[] { args.getClass() });\n m.setAccessible(true);\n try {\n m.invoke(null, new Object[] { args });\n } catch (IllegalAccessException e) {\n System.out.println(\\\"Access denied\\\");\n }\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 74,
        "category": "VUL",
        "language": "c,c++",
        "code": "FIO02-C",
        "name": "Canonicalize path names originating from tainted sources",
        "desc": "Names may constain characters that affect accuracy of validation. Furthermore, they may consist of comppnents that are symbolic links. Canonicalizing names is needed to ensure validity of name.",
        "msg_templ": "In ${si.filename}, line ${si.line}, the function ${si.func} is opening a file without canonicalizing its name which may come from tainted source.",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nPath and directory names from untrusted source should be canonicalized and validated.\n\n#### Explanation\nPath names, directory names and file names may contain characters that make validation difficult and inaccurate. Furthermore, any path name component can be a symbolic link, which further obscures the actual location or identity of a file. To simplify file name validation, it is recommended that names be translated into their canonical form. Canonicalizing file names makes it much easier to verify a path, directory, or file name by making it easier to compare names. Because the canonical form can vary between operating systems and file systems, it is best to use operating-system-specific mechanisms for canonicalization.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n#include <stdlib.h>\n\nFILE* f_open(char* fname, FILE *fptr)\n{\n    fptr = fopen(fname, \"r\");\n    return fptr;\n}\n\nchar *sanitize(char *fname);\n\n\nint main(int argc, char **argv[])\n{\n  FILE *fptr;\n  \n  if (!verify_file(sanitize(*argv[1]))) {  // sanitize file name first\n    printf(\"error\n\");\n    exit(1);\n  }\n  else {\n    fptr = f_open(*argv[1], fptr);\n  }\n  printf(\"File opened %x\n\", fptr);\n  // ...\n  exit(0);\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n#include <stdlib.h>\n\nFILE* f_open(char* fname, FILE *fptr)\n{\n    fptr = fopen(fname, \"r\");\n    return fptr;\n}\n\nint main(int argc, char **argv[])\n{\n  FILE *fptr;\n  \n  if (!verify_file(*argv[1])) {\n    printf(\"error\n\");\n    exit(1);\n  }\n  else {\n    fptr = f_open(*argv[1], fptr);\n  }\n  printf(\"File opened %x\n\", fptr);\n  // ...\n  exit(0);\n}"
                ]
            }
        }
    },
    {
        "master_id": 75,
        "category": "VUL",
        "language": "c,c++",
        "code": "STR07-C",
        "name": "Use the bounds-checking interfaces for string manipulation",
        "desc": "",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 76,
        "category": "BAD_PRACTICE",
        "language": "c,c++",
        "code": "POS02-C",
        "name": "Follow the principle of least privilege",
        "desc": "",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "HIGH",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 77,
        "category": "VUL",
        "language": "c,c++",
        "code": "POS36-C",
        "name": "Observe correct revocation order while relinquishing privileges",
        "desc": "",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nCorrect order of privilege revocation is not maintained in the program.\n\n#### Explanation\nsetgid() must be run with superuser privileges, whereas setuid() will leave the effective user ID as nonzero. It is possible to regain group privileges with incorrect relinquishment order. Vulnerability might occur as attacker is able to regain the original group privileges. Hence, the order of setgid() and setuid() must be properly maintained, i.e. setgid() first.",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n#include <unistd.h>\n\nvoid func() {\n    int gid_stat = setgid(getgid());\n    int uid_stat = setuid(getuid());\n    \n    // Correct order of privilege relinquishment\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n#include <unistd.h>\n\nvoid func(){\n    int uid_stat = setuid(getuid());\n    int gid_stat = setgid(getfid());\n\n    // Possible to regain group privileges because of incorrect order\n    // Vulnerability allowing execution of arbitrary code\n}"
                ]
            }
        }
    },
    {
        "master_id": 80,
        "category": "VUL",
        "language": "java",
        "code": "MSC62-J",
        "name": "Passwords should be stored using a secure hash to prevent being exposed to malicious users.",
        "desc": "Storing passwords as cleartext risk these passwords exposed in a lots of ways. Using hash functions that are computationally feasible whose decoding are not computationally feasible is an acceptable. Users can test equality of passwords using their hash values.",
        "msg_templ": "In ${si.filename}, line ${si.line}, the function ${si.func} is using an unsecure hash to store passwords.",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "LOW",
        "details": "#### Abstract\nStoring passwords in plain text may cause these passwords to be exposed in various ways. It is recommended to use a hash function that is computationally feasible but its decoding is not computationally feasible. Users can use the hash value to test whether the passwords are equivalent.\n\n#### Explanation\nPasswords should not be stored in clear text. To avoid exposure of them, they are typically stored in hash functions so that direct comparison is possible without requiring expensive encryption algorithms.\n",
        "examples": {
            "good": {
                "java": [
                    "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\npublic class j_msc62_ex {\n  private void regUser1(String userName, byte[] passwd, String regType) {\n    try {\n      String salt = genSalt();\n      String combPasswd = salt + passwd;\n      byte[] secureHash = secureHash(combPasswd.getBytes());\n      byte[] noSaltPasswd = secureHash(passwd);\n      byte[] unsecureHash = unSecureHash(combPasswd.getBytes());\n      if(regType.equals(\"NO_SALT_HASH\")) {\n        handleError(\"NO_SALT_HASH\");;             // MSC62-J, no salt, no hash\n      } else if(regType.equals(\"NO_SALT\")) {\n        handleError(\"NO_SALT_HASH\");        // MSC62-J no salt\n      } else if(regType.equals(\"UNSECURE_HASH\")){\n        handleError(\"UNSECURE_HASH\");       // MSC62-J unsecure hash\n      } else {\n        saveUser(userName, secureHash);         \n      }\n    } catch (NoSuchAlgorithmException e) {\n      e.printStackTrace();\n    }\n  } \n  private byte[] unSecureHash(byte [] passwd) throws NoSuchAlgorithmException{\n    MessageDigest msgDigest = MessageDigest.getInstance(\"MD5\");  // not secure hash algorithm\n    return msgDigest.digest(passwd);\n  }\n  \n  private byte[] secureHash(byte [] passwd) throws NoSuchAlgorithmException{\n    MessageDigest msgDigest = MessageDigest.getInstance(\"SHA256\");  // secure hash algorithm\n    return msgDigest.digest(passwd);\n  }\n\n  private void testRegUser(String userName, String passwd, String regType) {\n    regUser1(userName, passwd.getBytes(), regType);\n    regUser2(userName, passwd);  // MSC62-J passwd is String type\n  }\n\n} "
                ]
            },
            "bad": {
                "java": [
                    "import java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\npublic class j_msc62_ex {\n  private void regUser1(String userName, byte[] passwd, String regType) {\n    try {\n      String salt = genSalt();\n      String combPasswd = salt + passwd;\n      byte[] secureHash = secureHash(combPasswd.getBytes());\n      byte[] noSaltPasswd = secureHash(passwd);\n      byte[] unsecureHash = unSecureHash(combPasswd.getBytes());\n      if(regType.equals(\"NO_SALT_HASH\")) {\n        saveUser(userName, passwd);             // MSC62-J, no salt, no hash\n      } else if(regType.equals(\"NO_SALT\")) {\n        saveUser(userName, noSaltPasswd);       // MSC62-J no salt\n      } else if(regType.equals(\"UNSECURE_HASH\")){\n        saveUser(userName, unsecureHash);       // MSC62-J unsecure hash\n      } else {\n        saveUser(userName, secureHash);         // \n      }\n    } catch (NoSuchAlgorithmException e) {\n      e.printStackTrace();\n    }\n  } \n  private byte[] unSecureHash(byte [] passwd) throws NoSuchAlgorithmException{\n    MessageDigest msgDigest = MessageDigest.getInstance(\"MD5\");  // not secure hash algorithm\n    return msgDigest.digest(passwd);\n  }\n  // .. other code\n  private byte[] secureHash(byte [] passwd) throws NoSuchAlgorithmException{\n    MessageDigest msgDigest = MessageDigest.getInstance(\"SHA256\");  // secure hash algorithm\n    return msgDigest.digest(passwd);\n  }\n\n  private void testRegUser(String userName, String passwd, String regType) {\n    regUser1(userName, passwd.getBytes(), regType);\n    regUser2(userName, passwd);  // MSC62-J passwd is String type\n  }\n\n} "
                ]
            }
        }
    },
    {
        "master_id": 81,
        "category": "VUL",
        "language": "java",
        "code": "IDS03-J",
        "name": "Unsanitized user input should not appear in log",
        "desc": "Log entry containing unsanitized user input can lead to log injection attack and compromise data across a trust boundary.",
        "msg_templ": "",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nSensitive data leakage arises When unsanitized user input are logged or put out in standard output (stdout) device.\n\n#### Explanation\nLogging unsanitized user input can result in sensitive data leakage across a trusted boundary. A log injection attack may arise leading to further information leakage. This vulnerability is not limited to Java programs. C/C++ programs can subject to the same attack as show in the C example.",
        "examples": {
            "good": {
                "c": [
                    "\nusing namespace mychain;\nusing namespace MyContract::Sample;\n\nclass demoBranch:public Contract {\npublic:\n    TransferPtr m_ptransfer;\n\n    demoBranch() {\n        m_ptransfer = GetTransferM();\n    }\n    INTERFACE void Init() {\n        InitRoot();\n    }\n    \n    INTERFACE void LeakToLog(const std::string& sAccountName ) {\n        if(!m_ptransfer) {\n            Revert(\"error\");\n        }\n\n\t// get account, balance etc\n        AccountMMapPtr pAccountMap = m_ptransfer->get_accounts();\n        if (!pAccountMap) {\n            Revert(\"AcountMMapPtr Error.\");\n        }\n\n        // obtain user account number and name\n\t// ...\n\n\t//\n        int32_t iBalanceRmb = pBalance->get_rmb();\n        std::string sBalanceTopic = std::to_string(iBalanceRmb);\n        std::vector<std::string> leak_msg;\n        leak_msg.push_back(sAccountName);\n        leak_msg.push_back(sBalanceTopic);\n\n        if (iBalanceRmb < 1) {\n\t  // Sanitize and clean up message before logging\n          Log(std::string(\"acc_bal\"), SanitizeUser(leak_msg));\n        }\n    }\n};\nINTERFACE_EXPORT(demoBranch, (Init) (LeakToLog))\n"
                ],
                "java": [
                    "locationClient = new LocationClient(this, this, this);\nlocationClient.connect();\ncurrentUser.setLocation(locationClient.getLastLocation());\n... \n\ncatch (Exception e) {\n    AlertDialog.Builder builder = new AlertDialog.Builder(this);\n    builder.setMessage(\"Application Error.\");\n    AlertDialog alert = builder.create();\n    alert.show();\n\n    // user location is \"sanitized\" being written to log\n    Log.e(\"Example\", \"Caught exception: \" + e + \" User:\" + sanitizeUser(User.toString()));\n}\n"
                ]
            },
            "bad": {
                "c": [
                    "\nusing namespace mychain;\nusing namespace MyContract::Sample;\n\nclass demoBranch:public Contract {\npublic:\n    TransferPtr m_ptransfer;\n\n    demoBranch() {\n        m_ptransfer = GetTransferM();\n    }\n    INTERFACE void Init() {\n        InitRoot();\n    }\n    \n    INTERFACE void LeakToLog(const std::string& sAccountName ) {\n        if(!m_ptransfer) {\n            Revert(\"error\");\n        }\n\n\t// get account, balance etc\n        AccountMMapPtr pAccountMap = m_ptransfer->get_accounts();\n        if (!pAccountMap) {\n            Revert(\"AcountMMapPtr Error.\");\n        }\n\n        // obtain user account number and name\n\t// ...\n\n\t//\n        int32_t iBalanceRmb = pBalance->get_rmb();\n        std::string sBalanceTopic = std::to_string(iBalanceRmb);\n        std::vector<std::string> leak_msg;\n        leak_msg.push_back(sAccountName);\n        leak_msg.push_back(sBalanceTopic);\n\t\n        if (iBalanceRmb < 1) {\n          Log(std::string(\"acc_bal\"), leak_msg);\n        }\n    }\n};\nINTERFACE_EXPORT(demoBranch, (Init) (LeakToLog))\n"
                ],
                "java": [
                    "locationClient = new LocationClient(this, this, this);\nlocationClient.connect();\ncurrentUser.setLocation(locationClient.getLastLocation());\n... \n\ncatch (Exception e) {\n    AlertDialog.Builder builder = new AlertDialog.Builder(this);\n    builder.setMessage(\"Application Error.\");\n    AlertDialog alert = builder.create();\n    alert.show();\n\n    // user location is written to log\n    Log.e(\"Example\", \"Caught exception: \" + e + \" User:\" + User.toString());\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 82,
        "category": "VUL",
        "language": "c,c++",
        "code": "ARR38-C",
        "name": "Array out of bounds with the use of library functions",
        "desc": "The program is calling a library function with a pointer and a size parameter. The two parameters, when combined, will be outside of the legal range of the object.",
        "msg_templ": "In ${si.filename}, line ${si.line}, the function ${si.func} is calling a library function with a pointer and a size parameter.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nMake sure library functions don't form invalid pointers\n\n#### Explanation\nCertain functions that make changes to arrays or objects take at least two arguments.\nTherefore, supplying invalid or wrong arguments to such functions might form an \nincorrect pointer resulting in undefined pointer.",
        "examples": {
            "good": {
                "c": [
                    "#include <stdlib.h>\n#include <string.h>\n\nvoid func(size_t SIZE_LIMIT)\n{\n    char *p = (char *)malloc(SIZE_LIMIT);\n    /* ...  */\n\n    // ensures that it will not go past last element\n    const size_t n = SIZE_LIMIT - 1;\n    /* ...  */\n    memset(p, 0, n);\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdlib.h>\n#include <string.h>\n\nvoid func(size_t SIZE_LIMIT)\n{\n    char *p = (char *)malloc(SIZE_LIMIT);\n    /* ...  */\n\n    // adding 100 is out of bounds\n    const size_t n = SIZE_LIMIT + 100;\n    /* ...  */\n    memset(p, 0, n);\n}"
                ]
            }
        }
    },
    {
        "master_id": 83,
        "category": "VUL",
        "language": "c,c++",
        "code": "EXP34-C",
        "name": "Do not perform a dereference using a null pointer",
        "desc": "The program is accessing illegal memory through a pointer with a value.",
        "msg_templ": "In ${si.filename}, line ${si.line}, the function ${si.func} is accessing illegal memory through a pointer with value.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is accessing illegal memory through a pointer with value. This vulnerability is the same as the Xcalibyte NPD rule.\n\n#### Explanation\nPlease refer to rule NPD in the Xcalibyte vulnerability list for detailed explanation.\n",
        "examples": {
            "good": {},
            "bad": {
                "c": [
                    "extern int bar(int);\n\nint assign(int* a)\n{\n int i = bar(*a) // dereference a\n return i;\n}\n\nint foo(void)\n{\n int *p = 0; // p as a pointer has been initialized to 0 (null)\n assign(p);\n}"
                ],
                "java": [
                    "class User {\n public String getName() {\n return null;\n }\n}\n\nclass Bar {\n private User findUser(String uid) {\n if (user.containsKey(uid)) {\n return user.get(uid);\n }\n else\n return null;\n }\n public void Npd(String uid) {\n // do something\n // ...\n User user = findUser(uid); // Throws NPE if \\\"user\\\" has not been properly initialized\n String getName() {\n return null;\n }\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 84,
        "category": "VUL",
        "language": "c,c++",
        "code": "FIO47-C",
        "name": "Avoid using conflicting types to a format string",
        "desc": "The program is calling a function with a number of parameter(s) that are used differently from the prototype declaration.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, the arguments in function ${si.func} do not match the function declaration in file ${si.filename}, line ${si.line}.",
        "severity": "HIGH",
        "likelihood": "UNLIKELY",
        "cost": "LOW",
        "details": "#### Abstract\nThe program is calling a function with number of parameter(s) that are used different from that of the prototype declaration.\n\n#### Explanation\nIn a call site, the number of actual parameters passed is different from that of the function declaration. If the actuals passed is less than that of the declaration, the missing actual will ended up being \\\"wild\\\" and could cause unpreditable behavior.\n",
        "examples": {
            "good": {
                "c": [
                    "int foo(int a, int guard)\n{\n    int x = 0;\n    int result = 0;\n    if (guard != 0)\n        result = a * x;\n    foo(result, guard); // no parameters missing\n    return 0;\n}"
                ]
            },
            "bad": {
                "c": [
                    "int foo(int a, int guard)\n{\n    int x = 0;\n    int result = 0;\n    if (guard != 0)\n        result = a * x;\n\n    // missing one parameter, and \\\"guard\\\" will have random value during execution at this point\n    foo(result); \n    return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 85,
        "category": "VUL",
        "language": "c,c++",
        "code": "MEM30-C",
        "name": "Freed memory should not be accessed or used again",
        "desc": "The program is accessing memory that has been freed.",
        "msg_templ": "In ${si.filename}, line ${si.line}, the function ${si.func} is accessing memory that has been freed.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is accessing memory that has been freed.\n\n#### Explanation\nUse after free is a variation of dangling pointer reference. It typically occurs when the pointer is not updated after the memory object it points to has been freed. This pointer will be pointing to inappropriate memory leading to unauthorized access when the pointer is used.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stddef.h>\n\nint g = 2;\n\nvoid my_free(void *p)\n{\n    if (p != NULL)\n        free(p); // free p\n}\n\nint main()\n{\n    int i, j, *p, *q;\n    p = malloc(10 * sizeof(int));\n    if (p == NULL)\n        return 1;\n    for (i = 0; i < 10; ++i)\n        p[i] = i;\n\n    // do not free p\n\n    j = 0;\n    for (i = 0; i < 10; ++i)\n        j += q[i]; \n    return j;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stddef.h>\n\nint g = 2;\n\nvoid my_free(void *p)\n{\n    if (p != NULL)\n        free(p); // free p\n}\n\nint main()\n{\n    int i, j, *p, *q;\n    p = malloc(10 * sizeof(int));\n    if (p == NULL)\n        return 1;\n    for (i = 0; i < 10; ++i)\n        p[i] = i;\n    q = p;\n    my_free(p); // p is freed\n    j = 0;\n    for (i = 0; i < 10; ++i)\n        j += q[i]; // Use after free here (note the statement q = p), read of q[i] is illegal\n    return j;\n}"
                ]
            }
        }
    },
    {
        "master_id": 86,
        "category": "VUL",
        "language": "c++",
        "code": "MEM50-CPP",
        "name": "Access to freed memory should be prohibited",
        "desc": "The program reads a pointer variable that is already freed which may lead to an undefined behaviour that is unnoticeable.",
        "msg_templ": "In file ${so.filename}, line ${so.line}, variable ${so.var} in function ${so.func} was used. However, it has been freed at line ${so.line} in file ${so.filename}.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has referenced memory after it has been freed. It can cause the program to crash or an unexpected program behavior.\n\n#### Explanation\nUse after free is a variation of dangling pointer reference. It typically occurs when the pointer is not updated after the memory object it points to has been freed. This pointer will be pointing to inappropriate memory leading to unauthorized access when the pointer is used.\n",
        "examples": {
            "good": {},
            "bad": {
                "cpp": [
                    "int g = 2;\n\nvoid my_free(void *p) {\n if (p != NULL)\n free(p); // free p\n}\n\nint main() {\n int i, j, *p, *q;\n p = malloc(10 * sizeof(int));\n if (p == NULL)\n return 1;\n for (i=0; i < 10; ++i)\n p[i] = i;\n q = p;\n my_free(p); // p is freed\n j = 0;\n for (i=0; i < 10; ++i)\n j += q[i]; // Use after free here (note the statement q = p), read of q[i] is illegal\n return j;\n}"
                ]
            }
        }
    },
    {
        "master_id": 87,
        "category": "VUL",
        "language": "c++",
        "code": "MEM51-CPP",
        "name": "Allocated resources require a proper deallocation",
        "desc": "The program failed to appropriately deallocate memories that were dynamically allocated.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, variable ${si.var} in function ${si.func} has not been freed. ",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has allocated heap memory but failed to free that piece of memory.\n\n#### Explanation\nHeap memory has been allocated and the allocated memory address is stored in a variable of reference (pointer) type. That heap memory has never been released after its lifetime has effectively ended and its corresponding reference still points to that memory space. This could result in sensitive data leakage or unexpected program behavior such as denial of service.\n",
        "examples": {
            "good": {},
            "bad": {
                "cpp": [
                    "struct S {\n int *p;\n};\n\nint main() {\n int *p;\n struct S *s;\n p = malloc(10 * sizeof(int)); // heap memory allocated and pointed to by p\n if (p == NULL)\n return 1;\n s = (struct S*)malloc(sizeof(struct S)); // heap memory allocated and pointed to by s\n if (s == NULL) {\n free(p);\n return 1;\n }\n s->p = p;\n free(s); // only s is freed\n // s->p, which is copied from p is not freed\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 88,
        "category": "VUL",
        "language": "c++",
        "code": "EXP53-CPP",
        "name": "Reading uninitialized memory is prohibited",
        "desc": "The program is trying to read a piece of memory that is already declared but not yet initialized.",
        "msg_templ": "In file ${so.filename}, line ${so.line}, variable ${so.var} in function ${so.func} has been used but never assigned a value. ",
        "severity": "MEDIUM",
        "likelihood": "UNLIKELY",
        "cost": "LOW",
        "details": "#### Abstract\nThe program is using a variable before it has been initialized.\n\n#### Explanation\nStack variables in C and C++ are not initialized by default. Non-static global variables are not guaranteed to be zeroed. Their initial values are determined by the values that happen to be in their location in memory at the time the function is invoked. Doing so will cause an unexpected program behavior.\n\n",
        "examples": {
            "good": {},
            "bad": {
                "cpp": [
                    "int assign(int* a)\n{\n return *a; // dereference a\n}\n\nint main() {\n int a, b;\n b = assign(&a); // call assign with a uninitialized\n printf(\"value of b = %d\\\\\", b);\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 89,
        "category": "VUL",
        "language": "c++",
        "code": "EXP54-CPP",
        "name": "Access object only during its lifetime",
        "desc": "The program tries to access the object outside of its lifetime, which will result to an undefined behaviour.",
        "msg_templ": "In file ${so.filename}, line ${so.line}, the memory reference variable ${so.var} in function ${so.func} is used. Such variable is first assigned as a memory reference that may not be valid in file ${so.filename}, line ${so.line}.",
        "severity": "HIGH",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nDangling pointer has been used to refer to an invalid memory resource.\n\n#### Explanation\nDangling pointers are pointers that refer to invalid or inappropriate memory resources. Referencing these memory resources may create memory corruption, resulting in unpredictable program behavior or system instablity.\n",
        "examples": {
            "good": {},
            "bad": {
                "cpp": [
                    "int *assign()\n{\n int *c;\n c = 1;\n return &c;\n}\n\nint foo()\n{\n int *a;\n a = assign(); // return a stack address and assign to a\n printf(\\\"assigned value: %d\\\", a); // use dangling pointer\n return 0;\n}"
                ]
            }
        }
    },
    {
        "master_id": 90,
        "category": "VUL",
        "language": "Java",
        "code": "ERR00-J",
        "name": "Exceptions must be handled appropriately",
        "desc": "The program has an exception construct with an empty catch block.",
        "msg_templ": "In file ${si.filename}, function ${si.func}, the catch block in line ${si.line} is empty.",
        "severity": "LOW",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nChecked exceptions must be handled appropriately.\n\n#### Explanation\nExceptions disrupt the expected control flow of the application. The catch block must either recover from the exceptional condition or throw an exception that is appropriate to the context of the catch block.\n",
        "examples": {
            "good": {
                "java": [
                    "import java.io.*;\n\npublic class j_err00_0 {\n\n public void foo0(String fileName) {\n try {\n BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));\n int b;\n while ((b = reader.read()) != -1) {\n System.out.println(\"byte: \" + b);\n }\n } catch (IOException ioe) {\n throw new IllegalIOException(ioe.toString()); // we assume there is such exception handler here\n }\n }\n\n public void foo1(String fileName) {\n // indentation preserved to better show the difference with \\\"avoid\\\" example\n BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));\n int b;\n while ((b = reader.read()) != -1) {\n System.out.println(\"byte: \" + b);\n }\n\n }\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "import java.io.*;\n\npublic class j_err00_0 {\n\n public void foo0(String fileName) {\n try {\n BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));\n int b;\n while ((b = reader.read()) != -1) {\n System.out.println(\"byte: \" + b);\n }\n } catch (IOException ioe) {\n ioe.printStackTrace(); // print will not recover nor throw exception \n }\n }\n\n public void foo1(String fileName) {\n try {\n BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));\n int b;\n while ((b = reader.read()) != -1) {\n System.out.println(\"byte: \" + b);\n }\n } catch (IOException ioe) {\n // do nothing - no recovery of any kind\n }\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 91,
        "category": "VUL",
        "language": "Java",
        "code": "FIO08-J",
        "name": "Characters or bytes read from a stream and a -1 are different",
        "desc": "The program doesn't distinguish between characters read and end of the stream indicator by the read() method.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} does not distinguish between characters read and end of the stream indicator by the read() method.",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program doesn't distinguish between characters read and end of the stream indicator by the read() method.\n\n#### Explanation\nWhen reading byte data from stream with InputStream.read() and Reader.read(), end of stream is indicated with a 32 bit value of -1. Proper checking of end of stream must be done before conversion to a byte/char.\n",
        "examples": {
            "good": {
                "java": [
                    "// read result is cast to byte after read and check for end of stream\npublic class j_fio08_0 {\n\n  // ...\n\n  static void readData(String fileName) throws FileNotFoundException, IOException {\n    FileInputStream t = new FileInputStream(fileName);\n    try {\n      int inputbuf;\n      byte data;\n      StringBuffer value = new StringBuffer();\n      while((inputbuf = t.read()) != -1) {\n\tdata = (byte) inputbuf;\n        value.append(data);\n      }\n      System.out.println(value.toString());\n    } finally {\n      t.close();\n    }\n  }\n\n  static void readData2(String fileName) throws IOException {\n    FileReader fr = new FileReader(fileName);\n    try {\n      int inputbuf;\n      char data;\n      StringBuffer sb = new StringBuffer();\n      while (inputbuf = fr.read()) != -1) {\n\tdata = (char)inputbuf;\n        sb.append(data);\n      }\n    } finally {\n      fr.close();\n    }\n  }\n\n  static void readData3(String fileName) throws IOException {\n    FileReader fr = new FileReader(fileName);\n    try {\n      byte data;\n      StringBuffer sb = new StringBuffer();\n      while (true) {\n        int i = fr.read();\n        int j = i;\n        data = (byte) j;\n        if (data == -1) {\n          break;\n        }\n        sb.append(data);\n      }\n    } finally {\n      fr.close();\n    }\n  }"
                ]
            },
            "bad": {
                "java": [
                    "// read result is cast to byte, loop will halt prematurely if 0xFF is reached\npublic class j_fio08_0 {\n  // ... \n  static void readData(String fileName) throws FileNotFoundException, IOException {\n    FileInputStream t = new FileInputStream(fileName);\n    try {\n      byte data;\n      StringBuffer value = new StringBuffer();\n      while((data = (byte) t.read()) != -1) {\n        value.append(data);\n      }\n      System.out.println(value.toString());\n    } finally {\n      t.close();\n    }\n  }\n\n  static void readData2(String fileName) throws IOException {\n    FileReader fr = new FileReader(fileName);\n    try {\n      char data;\n      StringBuffer sb = new StringBuffer();\n      while ((data = (char) fr.read()) != -1) {\n        sb.append(data);\n      }\n    } finally {\n      fr.close();\n    }\n  }\n\n  static void readData3(String fileName) throws IOException {\n    FileReader fr = new FileReader(fileName);\n    try {\n      byte data;\n      StringBuffer sb = new StringBuffer();\n      while (true) {\n        int i = fr.read();\n        int j = i;\n        data = (byte) j;\n        if (data == -1) {\n          break;\n        }\n        sb.append(data);\n      }\n    } finally {\n      fr.close();\n    }\n  }"
                ]
            }
        }
    },
    {
        "master_id": 92,
        "category": "VUL",
        "language": "c,c++",
        "code": "FIO30-C",
        "name": "String parameters in format specification came from an untrusted source",
        "desc": "The program has a format specification that contains a parameter of char type (string) with an untrusted source, and hence, is considered tainted.",
        "msg_templ": "In file ${si.filename}, ${si.func}, line ${si.line} the printf family of calls were invoked at ${si.var} with format string from user input without being sanitized.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has a format specification that contains a parameter of char * type (aka string) with an untrusted source and is considered tainted.\n\n#### Explanation\nFormatted I/O functions can be tricked into overriding or reading the value of any arbitrary memory location. When the input source is untrusted it is better not to use format strings and related functions to perform I/O operation.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n int var_to_hold_content; // the variable where printf will store content of an address\n if (argc > 2) {\n scanf(argv[1]); // get a string from stdin (user input)\n fputs(argv[1, stdout]); // do not use printf with format specification\n }\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n int var_to_hold_content; // the variable where printf will store content of an address\n if (argc > 2) {\n scanf(argv[1]); // get a string from stdin (user input)\n printf(argv[1]); // user can read any address to a variable using a format specification\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 93,
        "category": "VUL",
        "language": "c,c++",
        "code": "MSC41-C",
        "name": "Do not expose hard coded sensitive information in the program",
        "desc": "The program has hard coded sensitive information (such as password and keys) in a readable form.",
        "msg_templ": "In file ${si.filename}, line ${si.line}， function ${si.func} has hard coded sensitive information.",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has hard coded sensitive information (such as password and keys) in readable form.\n\n#### Explanation\nSensitive information in strings or other readable forms can be examined even inside executables.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n\nint check_passwd(const char *s);\n\nint func(void)\n{\n    // user inputs password so no sensitive\n    // data leaked\n    #define PASSWORD_LEN 10\n    char password[PASSWORD_LEN];\n    printf(\"Please enter your password:\\n\");\n    fgets(password, sizeof(password), stdin);\n\n    int check = check_passwd(password);\n    memset_s(password, 0, sizeof(password));\n    // program logic\n    // ...\n    if (check)\n    {\n        // ... continue\n    }\n    else\n    {\n        // handle error\n        // ...\n    }\n}\n\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n\n#define BUF_SZ 1024\n\nint check_passwd(const char *s);\n\nint func(void)\n{\n    // program logic\n    // ...\n\n    // sensitive data is revealed below \n    if (check_passwd(\"admin\"))\n    {\n        // ... continue\n    }\n    else\n    {\n        // handle error\n        // ...\n    }\n}"
                ]
            }
        }
    },
    {
        "master_id": 94,
        "category": "VUL",
        "language": "Java",
        "code": "FIO52-J",
        "name": "Sensitive information should be encrypted if it is stored on the client side",
        "desc": "The program has stored unencrypted sensitive information on the client side.",
        "msg_templ": "In file ${si.filename}, function ${si.func}, line ${si.line}, unencrypted sensitive data ${si.var} are saved on the client side.",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has stored unencrypted sensitive information on the client side.\n\n#### Explanation \nIf unencrypted sensitive information is provided and stored on the client side, an attacker could get hold of the information either directly or indirectly to attack the client machine.\n",
        "examples": {
            "good": {
                "java": [
                    "import javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.Cookie;\ninterface Login {\n public Boolean isUserValid(String userName, char[] passwd);\n}\n\nclass LoginImpl implements Login {\n public Boolean isUserValid(String userName, char[] passwd) {\n // do the checking\n return true;\n }\n}\n\npublic class fio52_0 {\n protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n \n String username = request.getParameter(\"username\");\n char[] password = request.getParameter(\"password\").toCharArray();\n String userInfo = request.getParameter(\"userInfo\");\n \n Login login = new LoginImpl();\n \n if (request.getCookies()[0] != null &&\n request.getCookies()[0].getValue() != null) {\n String[] value = request.getCookies()[0].getValue().split(\";\");\n \n if (!login.isUserValid(value[0], value[1].toCharArray())) {\n // Set error and return\n } else {\n // Forward to welcome page\n }\n } else {\n boolean validated = login.isUserValid(username, password);\n \n if (validated) {\n Cookie loginCookie = new Cookie(\"MyCookie\", username + \";\" + new String(password));\n Cookie infoCookie = new Cookie(\"userInfo\", username + \":\" + userInfo);\n loginCookie.setHttpOnly(true); // use http protocol only\n loginCookie.setSecure(true); // set loginCookie through secure protocol\n response.addCookie(loginCookie); // sensitive cookie is encrypted and sent through secure protocol \n infoCookie.setSecure(true); // set infoCookie sent by secure protocol\n response.addCookie(infoCookie);\n  \n // ... Forward to welcome page\n } else {\n // Set error and return\n }\n }\n } \n}"
                ]
            },
            "bad": {
                "java": [
                    "import javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.Cookie;\ninterface Login {\n public Boolean isUserValid(String userName, char[] passwd);\n}\n\nclass LoginImpl implements Login {\n public Boolean isUserValid(String userName, char[] passwd) {\n // do the checking\n return true;\n }\n}\n\npublic class fio52_0 {\n protected void doPost(HttpServletRequest request, HttpServletResponse response) {\n \n String username = request.getParameter(\"username\");\n char[] password = request.getParameter(\"password\").toCharArray();\n String userInfo = request.getParameter(\"userInfo\");\n \n Login login = new LoginImpl();\n \n if (request.getCookies()[0] != null &&\n request.getCookies()[0].getValue() != null) {\n String[] value = request.getCookies()[0].getValue().split(\";\");\n \n if (!login.isUserValid(value[0], value[1].toCharArray())) {\n // Set error and return\n } else {\n // Forward to welcome page\n }\n } else {\n boolean validated = login.isUserValid(username, password);\n \n if (validated) {\n Cookie loginCookie = new Cookie(\"MyCookie\", username + \";\" + new String(password));\n Cookie infoCookie = new Cookie(\"userInfo\", username + \":\" + userInfo);\n loginCookie.setSecure(false); // set loginCookie sent by any protocol\n response.addCookie(loginCookie); // [FIO52-J] sensitive cookie, should be encrypted or sent through secure protocol \n infoCookie.setSecure(true); // set infoCookie sent by secure protocol\n \\t response.addCookie(infoCookie);\n \\t \n // ... Forward to welcome page\n } else {\n // Set error and return\n }\n }\n } \n}"
                ]
            }
        }
    },
    {
        "master_id": 95,
        "category": "VUL",
        "language": "Java",
        "code": "IDS07-J",
        "name": "Do not pass untrusted data as input to Runtime.exec() method",
        "desc": "The program has passed untrusted data as an input to the Runtime.exec() method.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, the string ${si.var} is not sanitized before being passed to runtime exec().",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has passed untrusted data as input to Runtime.exec() method.\n\n#### Explanation\nUntrusted data passed to Runtime.exec() will expose the system to an argument injection attack. The string must be sanitized to get rid of characters such as spaces, double quotes, and '-'.\n",
        "examples": {
            "good": {
                "java": [
                    "import java.io.InputStream;\n\npublic class ids07_0 { // example from CERT-J\n public static void main(String[] args) throws Exception {\n \n // dir is input from environment in which the app is running\n String dir = System.getProperty(\\\"dir\\\");\n if (!Pattern.matches(\\\"[0-9A-Za-z@.]+\\\", dir) { // whitelist characters allowed\n // report error and exit\n ...\n }\n Runtime rt = Runtime.getRuntime();\n \n // input from environment is directly concatenated and fed to Runtime.exec\n // Subject to command line injection\n Process proc = rt.exec(\\\"bash -c ls \\\" + dir);\n \n int result = proc.waitFor();\n if (result != 0) {\n System.out.println(\\\"process error: \\\" + result);\n }\n // continue processing\n // ...\n }\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "import java.io.InputStream;\n\npublic class ids07_0 { // example from CERT-J\n public static void main(String[] args) throws Exception {\n \n // dir is input from environment in which the app is running\n String dir = System.getProperty(\\\"dir\\\");\n Runtime rt = Runtime.getRuntime();\n \n // input from environment is directly concatenated and fed to Runtime.exec\n // Subject to command line injection\n Process proc = rt.exec(\\\"bash -c ls \\\" + dir);\n \n int result = proc.waitFor();\n if (result != 0) {\n System.out.println(\\\"process error: \\\" + result);\n }\n // continue processing\n // ...\n }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 96,
        "category": "VUL",
        "language": "Java",
        "code": "IDS15-J",
        "name": "Sensitive data (both input and output) should be sanitized/normalized",
        "desc": "Sensitive data should be kept secure including input and output data.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, sensitive data ${si.var} in function ${si.func} is leaked outside a trust boundary.",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "HiGH",
        "details": "#### Abstract\nSensitive data should be kept secure, including input and output data.\n\n#### Explanation\nSensitive information should not be allowed to leak across trusted boundaries. This is to keep integrity and security of different subsystems within a complex system. \n",
        "examples": {
            "good": {},
            "bad": {
                "java": [
                    "import javax.servlet.http.HttpServletRequest;\n\npublic class j_ids15_0\n{\n public void setSession(HttpServletRequest request, String attrName, String attrValue) {\n request.getSession().setAttribute(attrName, attrValue);\n }\n\n public void configSession(HttpServletRequest request) {\n String value = request.getParameter(\\\"Config\\\");\n String data = System.getenv(\\\"APP_DATA\\\");\n if(value.startsWith(\\\"APP_DATA\\\")) {\n setSession(request, \\\"APP_DATA\\\", data); // sensitive data\n } else if(value.startsWith(\\\"SAFE_DATA\\\")) {\n String safeData = Encryption(data);\n setSession(request, \\\"SAFE_DATA\\\", safeData); // data sanitized\n } else {\n setSession(request, \\\"attr\\\", \\\"value\\\");\n }\n }\n\n public String Encryption(String data) {\n // encrypt the input data\n // ...\n String safeData = data.replace(\\\"a\\\", \\\"z\\\");\n return safeData;\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 97,
        "category": "VUL",
        "language": "Java",
        "code": "MSC03-J",
        "name": "Do not hard code sensitive information in program",
        "desc": "The program has hard coded sensitive information.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, ${si.var} in function ${si.func} has hard coded data and may contain sensitive information.",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has hard coded sensitive information.\n\n#### Explanation\nSecurity and privacy related sensitive information should be retrieved at execution time from a secured file. Java executables are in the form of byte code and could be easily reverted back to source code form with the information in plain text.\n",
        "examples": {
            "good": {
                "java": [
                    "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class msc03_0 {\n public final Connection getConnection() throws SQLException, UnknownHostException {\n \n // IP address class to fill in at runtime. The address should be cleared immediately after use\n class IPAddress {\n // IP address in string\n char[] ipAddress = new char[128];\n try {\n // read in from some secure channel or file\n ...\n }\n finally {\n // clear after use\n Arrys.fill(ipAddress, (byte)0);\n // close file or channel\n ...\n }\n \n }\n if (InetAddress.getByName(ipAddress).isAnyLocalAddress()){\n // hard coded username and password\n String username, password;\n // Username and password should be read from a secure config file/channel at rungime\n return DriverManager.getConnection(\\\"dbhost:mysql://localhost/mydb\\\", username, password);\n }\n return DriverManager.getConnection(\\\"dbhost:mysql://localhost/dbName\\\", \\\"username\\\", \\\"password\\\");\n }\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "import java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class msc03_0 {\n public final Connection getConnection() throws SQLException, UnknownHostException {\n \n // hard coded IP address in String\n String ipAddress = new String(\\\"184.15.254.1\\\");\n if (InetAddress.getByName(ipAddress).isAnyLocalAddress()){\n // hard coded username and password\n return DriverManager.getConnection(\\\"dbhost:mysql://localhost/mydb\\\", \\\"7f4j9vj\\\", \\\"xsi9j2nn8\\\");\n }\n return DriverManager.getConnection(\\\"dbhost:mysql://localhost/dbName\\\", \\\"username\\\", \\\"password\\\");\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 98,
        "category": "VUL",
        "language": "Java",
        "code": "OBJ07-J",
        "name": "Classes with sensitive data should be protected against being copied or cloned",
        "desc": "Classes with sensitive data should be protected against being copied or cloned.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, the method ${si.var} can be copied or cloned.",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nClasses with sensitive data should be protected against being copied or cloned. \n\n#### Explanation\nClasses with sensitive data, when cloned or copied maliciously, may be exposed to thread-safety issues that violates invariants of critical data. \n",
        "examples": {
            "good": {
                "java": [
                    "public class j_obj07_fp_1 \n{\n private String userName;\n private char[] passwd;\n\n public j_obj07_fp_1(String name, String pass) {\n userName = name;\n passwd = pass.toCharArray();\n }\n\n // [certj pages]\n // sensitive class define clone() and throws CloneNotSupportedException\n // and clone() method marked finalclone\n // Well behaved clone that prevents subclasses from being made cloneable by defining a final clone that always fails\n public final j_obj07_fp_1 clone() throws CloneNotSupportedException {\n throw new CloneNotSupportedException();\n }\n\n void resetPasswd() {\n for(int i = 0; i < passwd.length; i++) {\n passwd[i] = 'a';\n } \n }\n\n void display() {\n System.out.println(\\\"UserName addr:\\\" + System.identityHashCode(userName));\n System.out.println(\\\"Passwd addr:\\\" + System.identityHashCode(passwd));\n System.out.print(\\\"User:\\\" + userName + \\\" passwd:\\\");\n System.out.println(passwd);\n }\n\n public static void main(String[] args) {\n j_obj07_fp_1 obj1= new j_obj07_fp_1(\\\"user1\\\", \\\"abcdef\\\");\n try {\n j_obj07_fp_1 obj2 = (j_obj07_fp_1)obj1.clone();\n obj2.resetPasswd();\n obj1.display();\n obj2.display();\n } catch (CloneNotSupportedException e) {\n System.out.println(\\\"Error: clone is not allowed for sensitive class\\\");\n }\n }\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "public class j_obj07_sensitive\n{\n private String userName;\n private char[] passwd;\n\n public j_obj07_sensitive(String name, char[] pass) { // OBJ07-J: class not provide clone throw exception and mark final\n userName = name;\n passwd = pass;\n } \n\n public String getUserName() {\n return userName;\n }\n\n public char[] getPasswd() {\n return passwd;\n }\n\n protected void resetPasswd() {\n for(int i = 0; i < passwd.length; i++) {\n passwd[i] = 'a';\n }\n }\n\n void display() {\n System.out.println(\\\"UserName addr:\\\" + System.identityHashCode(userName));\n System.out.println(\\\"Passwd addr:\\\" + System.identityHashCode(passwd));\n System.out.print(\\\"User:\\\" + userName + \\\" passwd:\\\");\n System.out.println(passwd);\n }\n\n}"
                ]
            }
        }
    },
    {
        "master_id": 99,
        "category": "VUL",
        "language": "Java",
        "code": "SEC01-J",
        "name": "Untrusted data is not allowed in privileged blocks",
        "desc": "The program has untrusted data in the privileged blocks.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, sensitive information may be leaked through ${si.var} inside a trusted block ${si.func}.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "#### Abstract\nThe program has untrusted data in privileged blocks.\n\n#### Explanation\nUntrusted data may contain special characters that eventually form tainted paths or file names. Attackers can take advantage of tainted data that get into privileged blocks for malicious intent.\n",
        "examples": {
            "good": {
                "java": [
                    "import java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.security.AccessController;\nimport java.security.PrivilegedActionException;\nimport java.security.PrivilegedExceptionAction;\n\npublic class sec01_0 { // edited from CERT-J example\n // input file name gone through sanitization and normalization before \n // enter the doPrivileged() block\n }\n private void privilegedMethod(final String filename)\n throws FileNotFoundException {\n \n final String sanitizeFilename;\n try {\n sanitizeFilename = sanitizeFilename(filename);\n } catch {\n // call handler appropriately \n ...\n }\n \n try {\n FileInputStream fis =\n (FileInputStream) AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () -> {\n return new FileInputStream(filename);\n });\n // Do something with the file and then close it\n } catch (PrivilegedActionException e) {\n // Forward to handler\n }\n }\n}"
                ]
            },
            "bad": {
                "java": [
                    "import java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.security.AccessController;\nimport java.security.PrivilegedActionException;\nimport java.security.PrivilegedExceptionAction;\n\npublic class sec01_0 { // edited from CERT-J example\n // input file name may be tainted since origin is unknown\n // should have gone through sanitization and normalization before \n // enter the doPrivileged() block\n private void privilegedMethod(final String filename)\n throws FileNotFoundException {\n try {\n FileInputStream fis =\n (FileInputStream) AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () -> {\n return new FileInputStream(filename);\n });\n // Do something with the file and then close it\n } catch (PrivilegedActionException e) {\n // Forward to handler\n }\n }\n}"
                ]
            }
        }
    },
    {
        "master_id": 100,
        "category": "VUL",
        "language": "c++",
        "code": "DCL55-CPP",
        "name": "Information leakage when transferring class objects across trusted boundaries",
        "desc": "The program has classes that have padding bits in the object that may have sensitive data but failed to clear them after use.",
        "msg_templ": "",
        "severity": "LOW",
        "likelihood": "UNLIKELY",
        "cost": "LOW",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 101,
        "category": "VUL",
        "language": "Java",
        "code": "ENV01-J",
        "name": "Security sensitive code should be signed and sealed in a single JAR",
        "desc": "The program is code signed to authenticate the origin of the code. Such codes should contain some code that performs privileged operations.",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is code signed to authenticate the origin of the code. Such code should contain some code that performs privileged operations.\n\n#### Explanation\nCode signing is usually taken as trusted and safe to execute code. Many systems are configured to be \\\"Always trust\\\". The implied permission can easily be exploited.\n\n",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 102,
        "category": "VUL",
        "language": "c,c++",
        "code": "FIO21-C",
        "name": "Temporary files should not be stored in shared directories",
        "desc": "The program has created temporary files in shared directories but has no removal or access procedure to prevent user attacks into the shared directory.",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has created temporary files in shared directories but has no removal or access procedures to prevent user attacks into the shared directory.\n\n#### Explanation\nProcess of creating temporary files is often used as a practice to transmit data from one process to another when it cannot reside in memory. If there is no clean up procedure for these files, or if the file name of these files is predictable, then it allows attackers to easily hijack this file. It can be fatal if the file holds sensitive information.\n",
        "examples": {
            "good": {},
            "bad": {
                "c": [
                    "void func(const char * file_name) {\nFILE *fp=fopen(file_name),\"wb+\";\nif(fp == NULL){\nreturn\n}\n// write to file ...\nfclose(fp)\n}"
                ]
            }
        }
    },
    {
        "master_id": 103,
        "category": "VUL",
        "language": "c++",
        "code": "DCL56-CPP",
        "name": "Initialization of static objects should not have a circular dependency",
        "desc": "The program makes a recursion call when initializing a static object. Program also might have an unordered initialization such that recursion may cause unexpected behaviors.",
        "msg_templ": "",
        "severity": "LOW",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 104,
        "category": "VUL",
        "language": "c++",
        "code": "FIO51-CPP",
        "name": "Always close files before a program terminates",
        "desc": "The program fails to close a file that was previously opened before program termination.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} fails to close an open file before program termination.",
        "severity": "MEDIUM",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 105,
        "category": "VUL",
        "language": "c++",
        "code": "MEM52-CPP",
        "name": "Failures in memory allocation should be properly handled",
        "desc": "Default allocators do not check results of allocation if it produces an exception. Any error has to be caught and handled.",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nDefault allocators do not check results of allocation if it produces an exception. Any error has to be caught and handled.\n\n#### Explanation\nOne of the most common memory alocation operators used in C++ is ::operator new(std::size_t) which may throw a std::bad_alloc when allocation fails. New operator is also overloaded with the non-throwing version which is ::operator new(std::size_t, const std::nothrow_t&) which instead of throwing exceptions will give a nullptr instead. Whichever new operator is used, there should be a check for either the corresponding error. Exceptions must be handled with catch, while nullptr should be checked accordingly, to avoid the abrupt termination of a program.\n",
        "examples": {
            "good": {},
            "bad": {
                "cpp": [
                    "#include <cstring>\n#include <new>\n\n void f(std::size_t size) noexcept {\nint *var = new int[size];\nvar[0]=5;\ndelete[] var;\n}"
                ]
            }
        }
    },
    {
        "master_id": 106,
        "category": "VUL",
        "language": "c++",
        "code": "MSC50-CPP",
        "name": "Use a stronger pseudorandom generator than std::rand()",
        "desc": "The program has used std::rand(), which is not a good candidate for random number sequences.",
        "msg_templ": "",
        "severity": "MEDIUM",
        "likelihood": "UNLIKELY",
        "cost": "LOW",
        "details": "#### Abstract\nThe program has used std::rand(), which is not a good candidate for random number sequences.\n\n#### Explanation\nPseudorandom number generator like rand() uses mathematical algorithms which makes numbers not completely random. Numbers generated by std::rand() doesn't give a good enough quality for random number sequences due to its comparatively short cycle. Hence, using rand() is not advised.\n",
        "examples": {
            "good": {},
            "bad": {
                "cpp": [
                    "#include <iostream>\n#include<string>\n\nvoid func(void){\nstd::string id{\\\"id\\\"};\nid += std::to_string(std::rand()%1000);\n}"
                ]
            }
        }
    },
    {
        "master_id": 107,
        "category": "VUL",
        "language": "c++",
        "code": "MSC52-CPP",
        "name": "Any value returning function must ensure all exit paths return a value",
        "desc": "The program has a function with non-void return, but that function has an execution path that will reach the exit without encountering a \"return\" statement.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} has non-void return but it will reach the exit without a return statement.",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has a function with non-void return, but that function has an execution path that will reach the exit without encountering a \\\"return\\\" statement.\n\n#### Explanation\nA value is expected to be returned upon calling this function, however, not all code paths return a value and may result in an undefined behavior.\n",
        "examples": {
            "good": {},
            "bad": {
                "cpp": [
                    "int get_number(int x){\nif(x>=1 && x<=10) return x;\n}"
                ]
            }
        }
    },
    {
        "master_id": 108,
        "category": "VUL",
        "language": "Java",
        "code": "OBJ05-J",
        "name": "References to mutable class members that are private should not be returned and exposed",
        "desc": "The program is returning references to mutable class members that are declared as private.",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program is returning references to mutable class members that are declared private.\n\n#### Explanation\nReturning reference to a private mutable class member is breaking the encapsulation and also makes a private object available that can be manipulated by an untrusted calling method.\n",
        "examples": {
            "good": {
                "java": [
                    "import java.util.Date;\n\npublic class obj05_0 {\n private Data private_d;\n\n // this class is mutable\n public obj05_0() {\n private_d = new Data();\n }\n\n // a copy is returned, hence, no leakage using this method\n public Data getDataSafe() {\n return (Data)d.clone();\n }\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "import java.util.Date;\n\npublic class obj05_0 {\n    private Data private_d;\n\n    // this class is mutable\n    public obj05_0() {\n        // private_d is declared private, and is being returned \n        // thus exposes the internal mutable component to untrustable caller\n        private_d = new Data();\n}\n\npublic Data getData() {\n    return private_d;\n}\n\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 109,
        "category": "VUL",
        "language": "Java",
        "code": "ENV02-J",
        "name": "Environment variables are to be treated as untrusted",
        "desc": "The program's use of environment variables may be a loophole for attackers.",
        "msg_templ": "",
        "severity": "LOW",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 110,
        "category": "VUL",
        "language": "Java",
        "code": "ENV04-J",
        "name": "Bytecode verification should not be disabled",
        "desc": "Java class files with no verification may come from untrusted sources.",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 111,
        "category": "VUL",
        "language": "Java",
        "code": "ENV05-J",
        "name": "Remotely monitored applications should not be deployed in the product",
        "desc": "Program fails to disable remote monitoring.",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "LOW",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 112,
        "category": "VUL",
        "language": "Java",
        "code": "JNI01-J",
        "name": "Invoke standard APIs safely",
        "desc": "The program has invoked a standard API on behalf of untrusted code through loadLibrary methods.",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 113,
        "category": "VUL",
        "language": "Java",
        "code": "OBJ01-J",
        "name": "Field accessibility of an object must be managed properly",
        "desc": "The program might expose sensitive fields through using a public modifier.",
        "msg_templ": "",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program might expose sensitive fields through using a public modifier.\n",
        "examples": {
            "good": {
                "java": [
                    "import java.util.List;\n\npublic class j_obj01_0 {\n\n  private static final String[] items = {\"abc\", \"def\", \"ghj\"/* ... */};\n\n  public static final List<String> itemsList =\n    Collections.unmodifiableList(Arrays.asList(items));\n\n  public static final String[] getItems() {\n    return items.clone();\n  }\n  public static final String getItem(int index) {\n    return items[index];\n  }\n\n  public static final int getItemCount() {\n    return items.length;\n  }\n\n  private static final HashMap<Integer, String> hm = new HashMap<Integer, String>();\n\n  public static String getElement(int key) {\n    return hm.get(key);\n  }\n\n  private int total; // Declared private\n\n  public int getTotal () {\n    return total;\n  }\n\n}"
                ]
            },
            "bad": {
                "java": [
                    "import java.util.List;\n\npublic class j_obj01_0 {\n\n  private static final String[] items = {\"abc\", \"def\", \"ghj\"/* ... */};\n\n  public static final List<String> itemsList =\n    Collections.unmodifiableList(Arrays.asList(items));\n\n  public static final String[] getItems() {\n    return items.clone();\n  }\n  public static final String getItem(int index) {\n    return items[index];\n  }\n\n  public static final int getItemCount() {\n    return items.length;\n  }\n\n  private static final HashMap<Integer, String> hm = new HashMap<Integer, String>();\n\n  public static String getElement(int key) {\n    return hm.get(key);\n  }\n\n  public int total; // Unprotected\n\n  public int getTotal () {\n    return total;\n  }\n\n}"
                ]
            }
        }
    },
    {
        "master_id": 114,
        "category": "VUL",
        "language": "Java",
        "code": "OBJ13-J",
        "name": "References to mutable objects should not be shown to client",
        "desc": "The program is exposing reference mutable objects to the user side where they may be modified freely.",
        "msg_templ": "",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 115,
        "category": "VUL",
        "language": "Java",
        "code": "SEC03-J",
        "name": "Trusted class must be loaded by the trusted class loader",
        "desc": "The program may allow a class loader from an untrusted source to load trusted classes.",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 116,
        "category": "VUL",
        "language": "Java",
        "code": "SEC04-J",
        "name": "Sensitive operations should be protected with a proper security manager check",
        "desc": "The program is allowing sensitive method calls that bypass security manager checks.",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 117,
        "category": "VUL",
        "language": "Java",
        "code": "SEC05-J",
        "name": "Do not use reflection to modify accessibility of classes, methods or fields",
        "desc": "The program is using Java reflection APIs that alters accessibility of certain fields.",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 118,
        "category": "VUL",
        "language": "Java",
        "code": "SER01-J",
        "name": "Follow the proper signatures when making custom serialization methods",
        "desc": "The program is not using signatures of serialization methods properly.",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "LOW",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 119,
        "category": "VUL",
        "language": "Java",
        "code": "SER04-J",
        "name": "Serialization and deserialization should always pass the security manager",
        "desc": "The program is doing a serialization without security checks that may allow untrusted code to modify internal state of class.",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 120,
        "category": "VUL",
        "language": "Java",
        "code": "SER05-J",
        "name": "Avoid serialization of inner classes",
        "desc": "The program contains inner class(es) that implement a serializable interface.",
        "msg_templ": "",
        "severity": "MEDIUM",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 121,
        "category": "VUL",
        "language": "Java",
        "code": "SER08-J",
        "name": "If deserializing requires privileges, strip permissions to the minimum of intended usage",
        "desc": "The program is doing deserialization within a privileged context.",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "MEDIUM",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 122,
        "category": "VUL",
        "language": "Java",
        "code": "IDS53-J",
        "name": "Prevent XPath Injection",
        "desc": "String input to retrieve data from XML document must be properly sanitized before the query.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, ${si.func}, ${si.var} is not properly sanitized before being used to retrieve data from XML document .",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "LOW",
        "details": "#### Abstract\nThe program is using String input to retrieve data from an XML document. It must be properly sanitized before the query.\n\n#### Explanation\nThe program is using String input to retrieve data from an XML document without adequate input sanitization and validation. This could result in malicious users formulating an SQL or XML query that results in a tautology and allow attackers access to restricted information.",
        "examples": {
            "good": {
                "java": [
                    "import javax.xml.xpath.*;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\nimport java.io.FileInputStream;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NodeList;\npublic class j_ids53_0 {\n  private final String accountFile = \"account.xml\";\n  private DocumentBuilder docBuilder;\n  private XPath xpath;\n\n  // the code below trying to query account Info with given id\n  public String queryAccountInfo(String id) throws XPathExpressionException, SAXException, IOException {\n    Document accountDoc = docBuilder.parse(accountFile);\n    Map queryVars = new HashMap();\n\n    // validate input \"id\" using StringEscapeUtils\n    String filteredId = StringEscaptUtils.escapeXml(id);\n    String compileStr = \"/Accounts/account[@id='\" + filteredId + \"']\";\n    String res = xpath.evaluate(compileStr, accountDoc); \n    return res;\n  }\n}\n\n"
                ]
            },
            "bad": {
                "java": [
                    "package io.xc5.cert;\n\nimport javax.xml.xpath.*;\nimport org.xml.sax.SAXException;\nimport java.io.IOException;\nimport java.io.FileInputStream;\nimport javax.xml.parsers.DocumentBuilder;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NodeList;\n\npublic class example_bad {\n  private final String accountFile = \"account.xml\";\n  private DocumentBuilder docBuilder;\n  private XPath xpath;\n\n  // the code below trying to query account Info with given id\n  public String queryAccountInfo(String id) throws XPathExpressionException, SAXException, IOException {\n    Document accountDoc = docBuilder.parse(accountFile);\n\n    // attacker can inject by provide id with '1'='1 causing evaluate to return \"true\"\n    String compileStr = \"/Accounts/account[@id='\" + id + \"']\"; \n    String res = xpath.evaluate(compileStr, accountDoc); // IDS53-J\n    return res;\n  }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 123,
        "category": "VUL",
        "language": "Java",
        "code": "IDS54-J",
        "name": "Prevent LDAP injection",
        "desc": "String input to perform remote directory access must be properly sanitized and validated.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, ${si.func}, ${si.var} is not properly sanitized and validated before being used to perform remote directory access.",
        "severity": "HIGH",
        "likelihood": "PROBABLE",
        "cost": "LOW",
        "details": "#### Abstract\nThe program is using LDAP for remote operations with inadequate input sanitization and validation.\n\n#### Explanation\nThe program is using Lightweight Directory Access Protocol to perform remote operations without adequate input sanitization and validation. This could result in giving malicious users access to restricted information.",
        "examples": {
            "good": {
                "java": [
                    "import javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.InitialDirContext;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\n\npublic class example_good\n{\n  public NamingEnumeration<SearchResult> queryUserInfo(InitialDirContext ctx, String id) throws NamingException {\n    SearchControls sc = new SearchControls();\n    sc.setReturningAttributes(new String[]{\"balance\", \"phone\"});\n    sc.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n    String searchBase = \"dc=Users,dc=com\";\n\n    // check against special characters \n    if (!id.matches(\"[\\\\w\\\\s]*\") || !id.matches(\"[\\\\w]*\")) {\n      throw new IllegalArgumentException(\"Invalid input\");\n    }\n    \n    String filter = \"(id=\" + id + \")\"; // attacker can inject by provide id with \"*\"\n    return ctx.search(searchBase, filter, sc); // IDS54-J, query user info with id \n  }\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "import javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.InitialDirContext;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\n\npublic class example_bad\n{\n  public NamingEnumeration<SearchResult> queryUserInfo(InitialDirContext ctx, String id) throws NamingException {\n    SearchControls sc = new SearchControls();\n    sc.setReturningAttributes(new String[]{\"balance\", \"phone\"});\n    sc.setSearchScope(SearchControls.SUBTREE_SCOPE);\n\n    String searchBase = \"dc=Users,dc=com\";\n    String filter = \"(id=\" + id + \")\"; // attacker can inject by provide id with \"*\"\n    return ctx.search(searchBase, filter, sc); // IDS54-J, query user info with id \n  }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 124,
        "category": "VUL",
        "language": "Java",
        "code": "IDS06-J",
        "name": "Exclude unsanitized user input from format strings",
        "desc": "Format string should not contain input that is not properly sanitized and validated.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, ${si.func}, ${si.var} contains input that is not properly santizied and validated.",
        "severity": "MEDIUM",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nThe program has format strings that includes unsanitized user input.\n\n#### Explanation\nUnsanitized input from an untrusted source should not be incorporated into format strings. This could result in information leakage or allow denial of service attacks.",
        "examples": {
            "good": {
                "java": [
                    "\nimport java.util.Calendar;\nimport java.util.GregorianCalendar;\n\n// this example is taken from CERT-J site Dashboard\n// \npublic class example_bad {\n  static Calendar c = new GregorianCalendar(1995, GregorianCalendar.MAY, 23);\n  public static void main(String[] args) {\n    // simply compare input with c\n    System.out.format(\n      \"%s did not match! HINT: It was issued on %terd of some month\", args[0], c\n    );\n  }\n}\n"
                ]
            },
            "bad": {
                "java": [
                    "\nimport java.util.Calendar;\nimport java.util.GregorianCalendar;\n\n// this example is taken from CERT-J site Dashboard\n// \npublic class example_bad {\n  static Calendar c = new GregorianCalendar(1995, GregorianCalendar.MAY, 23);\n  public static void main(String[] args) {\n    // Untrusted data is incorporated into the format string below.\n    // Attacker can expose the date against which input is compared against\n    // with some special input string, resulting in infomation leakage.\n    System.out.format(\n      args[0] + \"did not match! HINT: It was issued on %1$terd of some month\", c\n    );\n  }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 125,
        "category": "BAD_PRACTICE",
        "language": "c/c++",
        "code": "MSC30-C",
        "name": "Do not use the rand() function for generating pseudorandom numbers",
        "desc": "The program is using a pseudorandom number generator  that can produce a predictable sequence of numbers.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} is using a pseudorandom number generator that might produce a predictable sequence of numbers.",
        "severity": "MEDIUM",
        "likelihood": "UNLIKELY",
        "cost": "LOW",
        "details": "#### Abstract\nThe program is using a pseudorandom number generator that can produce a predictable sequence of numbers.\n\n#### Explanation\nThe rand() function produces numbers that are not truly random and may have a short cycle. An attacker can guess the next value that will be generated. Programmers should use a better random function that is properly seeded.",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nvoid use_rand(void) {\n  int r;\n  int i;\n  time_t t;\n\n  // seeds the rand()\n  srand((unsigned) time(&t));\n  \n  // random is a better pseudorandom number generator\n  for (i = 0; i < 10; i++) {\n    r = random();\n    printf(\"Random %d is %d\\n\", i, r);\n  }\n  \n}\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n#include <stdlib.h>\n\nvoid use_rand(void) {\n  int r;\n  int i;\n\n  // the same sequence will be printed every time this function is called\n  for (i = 0; i < 10; i++) {\n    r = rand();\n    printf(\"Random %d is %d\\n\", i, r);\n  }\n  \n}\n"
                ]
            }
        }
    },
    {
        "master_id": 126,
        "category": "VUL",
        "language": "c/c++",
        "code": "INT32-C",
        "name": "Make sure that operations on signed integers do not wraparound or overflow",
        "desc": "The program has operations in expressions with signed integers that may cause integer overflow or wraparound",
        "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} has operations in expressions with signed integers.",
        "severity": "HIGH",
        "likelihood": "LIKELY",
        "cost": "HIGH",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 127,
        "category": "VUL",
        "language": "Java",
        "code": "IDS04-J",
        "name": "Safely extract files from ZipInputStream",
        "desc": "The program is extracting file entries from a zip file using java.util.zip.ZipInputStream without any sanitization or resource guard measures.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} is extracting file entries from a zip file without any sanitization or resource guard measures.",
        "severity": "LOW",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "#### Abstract\nThe program is extracting file entries from a zip file using java.util.zip.ZipInputStream without sanitization or resource guard measures.\n\n#### Explanation\nWhen using the java.util.zip package to extract file entries from a zip file then file names may contain path information. These file names must be canonicalized and validated to prevent path injection attacks. Resource usage must also be tracked to ensure resources will not be exhausted that could result in a denial of service.\n\n",
        "examples": {
            "good": {
                "java": [
                    "import java.util.zip.*;\nimport java.io.*;\n\n\npublic class IDS04J_good {\n    public static void main(String[] args) throws IOException, IllegalStateException {\n        String zipPath = args[0];\n        String destPath = args[1];\n        \n        // Fix vulnerability by canonicalizing path\n        File checkZip = new File(zipPath);\n        File checkDest = new File(destPath);\n        String canonicalZip =  checkZip.getCanonicalPath();\n        String canonicalDest =  checkDest.getCanonicalPath();\n\n        // Check result of canonicalization\n        if (!canonicalZip.startsWith(canonicalDest)) {\n            throw new IllegalStateException(\"Accesing Out of Bounds Area, set a correct path\");\n        }\n    \n        byte[] buffer = new byte[1024];\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(zipPath));\n        ZipEntry zipEntry = zis.getNextEntry();\n        File destDirectory = new File(destPath);\n\n        long sizeLimit = 0x6400000; \n        int fileLimit = 2000; \n        long currentSize =  0; \n        int entry = 0; \n\n        try {\n            // Limit size to avoid DoS attack through resource exhaustion      \n            while (zipEntry != null) {\n                // Limit number of files\n                if (entry > fileLimit){\n                    throw new IllegalStateException(\"Unzipped file exceed the allowed limit\");\n                } \n                // Limit size of file\n                if (currentSize > sizeLimit) {\n                    throw new IllegalStateException(\"Unzipped file exceed the allowed size\");\n                }\n\n                System.out.println(\"File being extracted: \" + zipEntry);\n                FileOutputStream fos = new FileOutputStream(destDirectory + \"/\" + zipEntry.getName());\n                \n                int len;\n                while ((len = zis.read(buffer)) > 0) {\n                    fos.write(buffer, 0, len);\n                    currentSize += len;\n                }\n                fos.close();\n                zipEntry = zis.getNextEntry();\n                entry++;\n            }\n        } \n        finally {\n        \tzis.close(); \t\n        }\n    }\n}\n\n\n"
                ]
            },
            "bad": {
                "java": [
                    "import java.util.zip.*;\nimport java.io.*;\n\n\npublic class IDS04J_bad {\n    public static void main(String[] args) throws IOException {\n        // Path may be manipulated to access areas outside of intended directory\n        String zipPath = args[0];\n        String destPath = args[1];\n\n        byte[] buffer = new byte[1024];\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(zipPath));\n        ZipEntry zipEntry = zis.getNextEntry();\n        File destDirectory = new File(destPath);\n\n        try {          \n            // Exhaustion of resource without limit to the size of zip files in while loop\n            while (zipEntry != null) {\n                System.out.println(\"File being extracted: \" + zipEntry);\n                FileOutputStream fos = new FileOutputStream(destDirectory + \"/\" + zipEntry.getName());\n\n                int len;\n                while ((len = zis.read(buffer)) > 0) {\n                    fos.write(buffer, 0, len);\n                }\n\n                fos.close();\n                zipEntry = zis.getNextEntry();\n            }\n        } \n        finally {\n        \tzis.close(); \t\n        }\n    }\n}\n\n\n"
                ]
            }
        }
    },
    {
        "master_id": 128,
        "category": "VUL",
        "language": "c,c++,java",
        "code": "IDS03-J",
        "name": "Unsanitized user information should not be exposed",
        "desc": "Sensitive data leakage arises When unsanitized user input are logged or put out in standard output (stdout) device.",
        "msg_templ": "",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nSensitive data leakage arises When unsanitized user input are logged or put out in standard output (stdout) device.\n\n#### Explanation\nLogging unsanitized user input can result in sensitive data leakage across a trusted boundary. A log injection attack may arise leading to further information leakage. This vulnerability is not limited to Java programs. C/C++ programs can subject to the same attack as show in the C example.",
        "examples": {
            "good": {
                "c": [
                    "\nusing namespace mychain;\nusing namespace MyContract::Sample;\n\nclass demoBranch:public Contract {\npublic:\n    TransferPtr m_ptransfer;\n\n    demoBranch() {\n        m_ptransfer = GetTransferM();\n    }\n    INTERFACE void Init() {\n        InitRoot();\n    }\n    \n    INTERFACE void LeakToLog(const std::string& sAccountName ) {\n        if(!m_ptransfer) {\n            Revert(\"error\");\n        }\n\n\t// get account, balance etc\n        AccountMMapPtr pAccountMap = m_ptransfer->get_accounts();\n        if (!pAccountMap) {\n            Revert(\"AcountMMapPtr Error.\");\n        }\n\n        // obtain user account number and name\n\t// ...\n\n\t//\n        int32_t iBalanceRmb = pBalance->get_rmb();\n        std::string sBalanceTopic = std::to_string(iBalanceRmb);\n        std::vector<std::string> leak_msg;\n        leak_msg.push_back(sAccountName);\n        leak_msg.push_back(sBalanceTopic);\n\n        if (iBalanceRmb < 1) {\n\t  // Sanitize and clean up message before logging\n          Log(std::string(\"acc_bal\"), SanitizeUser(leak_msg));\n        }\n    }\n};\nINTERFACE_EXPORT(demoBranch, (Init) (LeakToLog))\n"
                ],
                "java": [
                    "locationClient = new LocationClient(this, this, this);\nlocationClient.connect();\ncurrentUser.setLocation(locationClient.getLastLocation());\n... \n\ncatch (Exception e) {\n    AlertDialog.Builder builder = new AlertDialog.Builder(this);\n    builder.setMessage(\"Application Error.\");\n    AlertDialog alert = builder.create();\n    alert.show();\n\n    // user location is \"sanitized\" being written to log\n    Log.e(\"Example\", \"Caught exception: \" + e + \" User:\" + sanitizeUser(User.toString()));\n}\n"
                ]
            },
            "bad": {
                "c": [
                    "\nusing namespace mychain;\nusing namespace MyContract::Sample;\n\nclass demoBranch:public Contract {\npublic:\n    TransferPtr m_ptransfer;\n\n    demoBranch() {\n        m_ptransfer = GetTransferM();\n    }\n    INTERFACE void Init() {\n        InitRoot();\n    }\n    \n    INTERFACE void LeakToLog(const std::string& sAccountName ) {\n        if(!m_ptransfer) {\n            Revert(\"error\");\n        }\n\n\t// get account, balance etc\n        AccountMMapPtr pAccountMap = m_ptransfer->get_accounts();\n        if (!pAccountMap) {\n            Revert(\"AcountMMapPtr Error.\");\n        }\n\n        // obtain user account number and name\n\t// ...\n\n\t//\n        int32_t iBalanceRmb = pBalance->get_rmb();\n        std::string sBalanceTopic = std::to_string(iBalanceRmb);\n        std::vector<std::string> leak_msg;\n        leak_msg.push_back(sAccountName);\n        leak_msg.push_back(sBalanceTopic);\n\t\n        if (iBalanceRmb < 1) {\n          Log(std::string(\"acc_bal\"), leak_msg);\n        }\n    }\n};\nINTERFACE_EXPORT(demoBranch, (Init) (LeakToLog))\n"
                ],
                "java": [
                    "locationClient = new LocationClient(this, this, this);\nlocationClient.connect();\ncurrentUser.setLocation(locationClient.getLastLocation());\n... \n\ncatch (Exception e) {\n    AlertDialog.Builder builder = new AlertDialog.Builder(this);\n    builder.setMessage(\"Application Error.\");\n    AlertDialog alert = builder.create();\n    alert.show();\n\n    // user location is written to log\n    Log.e(\"Example\", \"Caught exception: \" + e + \" User:\" + User.toString());\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 129,
        "category": "",
        "language": "c/c++",
        "code": "FIO39-C",
        "name": "Do not alternately input and output from a stream without an intervening flush or positioning call",
        "details": "",
        "msg_templ": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 130,
        "category": "",
        "language": "c/c++",
        "code": "POS39-C",
        "name": "Remark: Only work for self-created example because ntolh() ... is replaced by a custom user written function. See TG-137",
        "details": "",
        "msg_templ": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 132,
        "category": "VUL",
        "language": "c/c++",
        "code": "MLU",
        "name": "Missing lock or unlock",
        "desc": "The paired lock and unlock mutex program idiom is broken, missing one or the other counterpart",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "LOW",
        "cost": "HIGH",
        "details": "#### Abstract\nThe paired lock and unlock mutex program idiom is broken, missing one or the other counterpart\n\n#### Explanation\nA thread must enter or leave a mutex region through proper invokation of the corresponding lock or unlock functions. Failure to doing so will cause starvation for other threads.",
        "examples": {
            "good": {
                "c": [
                    "void hc1_good (int ret) {\n  int i;\n  for (i = 0; i < 100; i++){\n    pthread_mutex_lock(&g_struct[i].mutex);\n    if (ret > 0) {\n      if (ret < 100) {\n        printf(\"ret < 100\\n\");\n        pthread_mutex_unlock(&g_struct[i].mutex);\n        break;\n      }\n      else {\n\t// unlock before break \n        if (ret > 1000) {\n          printf(\"ret > 1000\\n\");\n          pthread_mutex_unlock(&g_struct[i].mutex);\n          break;\n        }\n      }\n    }\n    pthread_mutex_unlock(&g_struct[i].mutex);\n  }\n}\n \n"
                ]
            },
            "bad": {
                "c": [
                    "#include <pthread.h>\n#include <stdio.h>\n \ntypedef struct sMutex_Lock {\n  int index;\n  pthread_mutex_t mutex;\n} Mutex_Lock_Type;\n \nMutex_Lock_Type g_struct[100];\n \nvoid hc1_bad (int ret) {\n  int i;\n  for (i = 0; i < 100; i++){\n    pthread_mutex_lock(&g_struct[i].mutex);\n    if (ret > 0) {\n      if (ret < 100) {\n        printf(\"ret < 100\\n\");\n        pthread_mutex_unlock(&g_struct[i].mutex);\n        break;\n      }\n      else {\n\t// break statement exits the loop prematurely without calling unlock \n        if (ret > 1000) {\n          printf(\"ret > 1000\\n\");\n          break;\n        }\n      }\n    }\n    pthread_mutex_unlock(&g_struct[i].mutex);\n  }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 133,
        "category": "VUL",
        "language": "c/c++",
        "code": "DBLI",
        "name": "Do not spin-lock initialization more than once",
        "desc": "Thread spin_lock has been initialized more than once before deinitialized.",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "LOW",
        "cost": "HIGH",
        "details": "#### Abstract\nThread spin_lock has been initialized more than once before deinitialized.\n\n#### Explanation\nAfter initializing a thread, it should be de-initialized before initialization is called again. Failure to doing so will cause starvation for other threads.",
        "examples": {
            "good": {
                "c": [
                    " \n#include <linux/spinlock.h>\n \nstruct sbuf_mgr {\n  int         sbuf_inited;\n  spinlock_t  sbuf_lock;\n  char       *sbuf;\n};\n \nint is_sbuf_inited(struct sbuf_mgr *p_sbuf_mgr);\nvoid sbuf_mgr_reset(struct sbuf_mgr *p_sbuf_mgr);\nvoid write_data(struct sbuf_mgr *p_sbuf_mgr);\n \n// thread 1\nint *worker1(void *args)\n{\n  struct sbuf_mgr * p_sbuf_mgr = args;\n  if (is_sbuf_inited(p_sbuf_mgr)) {\n     write_data(p_sbuf_mgr);\n  }\n  return 0;\n}\n \nint is_sbuf_inited( struct sbuf_mgr *p_sbuf_mgr )\n{\n    int tmp_inited;\n    unsigned long irq_flags;\n    spin_lock_irqsave( &p_sbuf_mgr->sbuf_lock, irq_flags );\n    tmp_inited = p_sbuf_mgr->sbuf_inited;\n    spin_unlock_irqrestore( &p_sbuf_mgr->sbuf_lock, irq_flags );\n    return tmp_inited;\n}\n \n// thread 2\nint *worker2(void *args)\n{\n  struct sbuf_mgr * p_sbuf_mgr = args;\n\n  // spin_lock_init called in thread2 with this call\n  sbuf_mgr_reset(p_sbuf_mgr);\n  return 0;\n}\n \nvoid sbuf_mgr_reset( struct sbuf_mgr *p_sbuf_mgr )\n{\n    int i;\n    unsigned long irq_flags;\n    \n    spin_lock_init(&(p_sbuf_mgr->sbuf_lock));  \n    spin_lock_irqsave(&p_sbuf_mgr->sbuf_lock, irq_flags);\n    // .. do the work \n}\n \nint test_init_in_thread(void)\n{\n  struct sbuf_mgr buf_mgr;\n  struct task_struct *worker1_task, *worker2_task;\n \n  worker1_task = kthread_create(worker1, (void*)&buf_mgr, \"thread1\");\n \n  worker2_task = kthread_create(worker2, (void*)&buf_mgr, \"thread2\");\n  // ,,, \n  \n  // start tasks\n  wake_up_process(worker1_task);\n  wake_up_process(worker2_task);\n  return 0;\n}\n \nvoid init(struct sbuf_mgr *buf_mgr)\n{\n  spin_lock_init(&(buf_mgr->sbuf_lock));\n}\n  \nint test_double_init(bool is_double_init)\n{\n  struct sbuf_mgr buf_mgr;\n\n  // initialization only if boolean is false\n  if (!is_double_init)\n    init(&buf_mgr);\n  \n  return;  \n}\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <linux/spinlock.h>\n \nstruct sbuf_mgr {\n  int         sbuf_inited;\n  spinlock_t  sbuf_lock;\n  char       *sbuf;\n};\n \nint is_sbuf_inited(struct sbuf_mgr *p_sbuf_mgr);\nvoid sbuf_mgr_reset(struct sbuf_mgr *p_sbuf_mgr);\nvoid write_data(struct sbuf_mgr *p_sbuf_mgr);\n \n// thread 1\nint *worker1(void *args)\n{\n  struct sbuf_mgr * p_sbuf_mgr = args;\n  if (is_sbuf_inited(p_sbuf_mgr)) {\n     write_data(p_sbuf_mgr);\n  }\n  return 0;\n}\n \nint is_sbuf_inited( struct sbuf_mgr *p_sbuf_mgr )\n{\n    int tmp_inited;\n    unsigned long irq_flags;\n    spin_lock_irqsave( &p_sbuf_mgr->sbuf_lock, irq_flags );\n    tmp_inited = p_sbuf_mgr->sbuf_inited;\n    spin_unlock_irqrestore( &p_sbuf_mgr->sbuf_lock, irq_flags );\n    return tmp_inited;\n}\n \n// thread 2\nint *worker2(void *args)\n{\n  struct sbuf_mgr * p_sbuf_mgr = args;\n\n  // spin_lock_init called in thread2 with this call\n  sbuf_mgr_reset(p_sbuf_mgr);\n  return 0;\n}\n \nvoid sbuf_mgr_reset( struct sbuf_mgr *p_sbuf_mgr )\n{\n    int i;\n    unsigned long irq_flags;\n    \n    spin_lock_init(&(p_sbuf_mgr->sbuf_lock));  \n    spin_lock_irqsave(&p_sbuf_mgr->sbuf_lock, irq_flags);\n    // .. do the work \n}\n \nint test_init_in_thread(void)\n{\n  struct sbuf_mgr buf_mgr;\n  struct task_struct *worker1_task, *worker2_task;\n \n  worker1_task = kthread_create(worker1, (void*)&buf_mgr, \"thread1\");\n \n  worker2_task = kthread_create(worker2, (void*)&buf_mgr, \"thread2\");\n  // ,,, \n  \n  // start tasks\n  wake_up_process(worker1_task);\n  wake_up_process(worker2_task);\n  return 0;\n}\n \nvoid init(struct sbuf_mgr *buf_mgr)\n{\n  spin_lock_init(&(buf_mgr->sbuf_lock));\n}\n  \nint test_double_init(bool is_double_init)\n{\n  struct sbuf_mgr buf_mgr;\n\n  // first initialization \n  init(&buf_mgr);\n  \n  if (is_double_init) {\n    // if true, call init, causing double init\n    init(&buf_mgr);\n  }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 134,
        "category": "VUL",
        "language": "c/c++",
        "code": "LIIT",
        "name": "Do no call spinlock initialization in a thread",
        "desc": "Calling spinlock initialization in a thread may result the thread being initialized multiple times.",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "LOW",
        "cost": "HIGH",
        "details": "#### Abstract\nCalling spinlock initialization in a thread may result the thread being initialized multiple times.\n\n#### Explanation\nA thread should not be initialized multiple times, directly or indirectly. Doing so will cause starvation for other threads.",
        "examples": {
            "good": {},
            "bad": {
                "c": [
                    "#include <linux/spinlock.h>\n \nstruct sbuf_mgr {\n  int         sbuf_inited;\n  spinlock_t  sbuf_lock;\n  char       *sbuf;\n};\n \nint is_sbuf_inited(struct sbuf_mgr *p_sbuf_mgr);\nvoid sbuf_mgr_reset(struct sbuf_mgr *p_sbuf_mgr);\nvoid write_data(struct sbuf_mgr *p_sbuf_mgr);\n \n// thread 1\nint *worker1(void *args)\n{\n  struct sbuf_mgr * p_sbuf_mgr = args;\n  if (is_sbuf_inited(p_sbuf_mgr)) {\n     write_data(p_sbuf_mgr);\n  }\n  return 0;\n}\n \nint is_sbuf_inited( struct sbuf_mgr *p_sbuf_mgr )\n{\n    int tmp_inited;\n    unsigned long irq_flags;\n    spin_lock_irqsave( &p_sbuf_mgr->sbuf_lock, irq_flags );\n    tmp_inited = p_sbuf_mgr->sbuf_inited;\n    spin_unlock_irqrestore( &p_sbuf_mgr->sbuf_lock, irq_flags );\n    return tmp_inited;\n}\n \n// thread 2\nint *worker2(void *args)\n{\n  struct sbuf_mgr * p_sbuf_mgr = args;\n\n  // spin_lock_init called with this call, can result in double init\n  sbuf_mgr_reset(p_sbuf_mgr);\n  return 0;\n}\n \nvoid sbuf_mgr_reset( struct sbuf_mgr *p_sbuf_mgr )\n{\n    int i;\n    unsigned long irq_flags;\n    \n    spin_lock_init(&(p_sbuf_mgr->sbuf_lock));  \n    spin_lock_irqsave(&p_sbuf_mgr->sbuf_lock, irq_flags);\n    // .. do the work \n}\n \nint test_init_in_thread(void)\n{\n  struct sbuf_mgr buf_mgr;\n  struct task_struct *worker1_task, *worker2_task;\n \n  worker1_task = kthread_create(worker1, (void*)&buf_mgr, \"thread1\");\n \n  worker2_task = kthread_create(worker2, (void*)&buf_mgr, \"thread2\");\n  // ,,, \n  \n  // start tasks\n  wake_up_process(worker1_task);\n  wake_up_process(worker2_task);\n  return 0;\n}\n \nvoid init(struct sbuf_mgr *buf_mgr)\n{\n  spin_lock_init(&(buf_mgr->sbuf_lock));\n}\n  \nint test_double_init(bool is_double_init)\n{\n  struct sbuf_mgr buf_mgr;\n\n  // first initialization \n  init(&buf_mgr);\n  \n  if (is_double_init) {\n    // if true, call init, causing double init\n    init(&buf_mgr);\n  }\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 135,
        "category": "VUL",
        "language": "c/c++",
        "code": "SLAE",
        "name": "SpinLock variable address escaped",
        "desc": "Address of a spinlock variable has escaped and may cause deadlock situation",
        "msg_templ": "",
        "severity": "LOW",
        "likelihood": "UNLIKELY",
        "cost": "MEDIUM",
        "details": "#### Abstract\nAddress of a spinlock variable has escaped and may cause deadlock situation\n\n#### Explanation\nWhen the address of a spinlock variable is exposed to outside of a thread, the thread may not be properly unlock resulting in possible deadlock situation.",
        "examples": {
            "good": {},
            "bad": {
                "c": [
                    "#include <linux/spinlock.h>\nvoid bad(int irq, spinlock_t lock)\n{\n  // \n  spin_lock(&lock);\n}\n \nvoid bad2(int irq, spinlock_t lock, spinlock_t lock2)\n{\n  spin_lock(&lock);\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 136,
        "category": "VUL",
        "language": "c/c++",
        "code": "LNR",
        "name": "",
        "desc": "",
        "msg_templ": "",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "",
        "examples": {
            "good": {},
            "bad": {}
        }
    },
    {
        "master_id": 137,
        "category": "VUL",
        "language": "c/c++",
        "code": "SAC",
        "name": "Sleep in atomic-context or locked region",
        "desc": "The program has entered an atomic region/context, within that region, there is operation that may cause the program to pause, delay due to interrupt or sleep.",
        "msg_templ": "",
        "severity": "LOW",
        "likelihood": "LOW",
        "cost": "HIGH",
        "details": "#### Abstract\nThe program has entered an atomic region/context, within that region, there is operation that may cause the program to pause, delay due to interrupt or sleep. \n\n\n#### Explanation\nWhen a program is inside an atomic context or locked region, any operation that may pause due to sleep, interrupt or wait etc may cause dead lock.",
        "examples": {
            "good": {
                "c": [
                    "#include <linux/spinlock.h>\nvoid test_isr1(int irq, spinlock_t *lock)\n{\n  // this guarantees interrupt state is saved and that\n  // the critical section will not be preempted by the kernel\n  spin_lock_irqsave(lock);  \n}\n \n \n// cross function check\nnoinline\nvoid call_spin(spinlock_t *lock)\n{\n  spin_lock(lock);\n}\n",
                    "#include <stdio.h>\n#include <pthread.h>\n\nint num = 8; // global variable\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; // initialise a mutex\n\nint main() {\n    pthread_mutex_lock(&lock); // enter mutex locked region\n    switch (num) {\n    case 0:\n            num = 0;\n            break;\n    case 1:\n            num++;\n            break;\n    case 2:\n            num--;\n            break;\n    default:\n            pthread_mutex_unlock(&lock); // exit mutex lock region\n            return 0;\n    }\n    pthread_mutex_unlock(&lock); // exit mutex lock region\n    return 0;\n}\n",
                    "#include <stdio.h>\n#include <pthread.h>\n#include <unistd.h>\n\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; // initialise a mutex\nint num; // global variable\n\nint main () {\n    pthread_mutex_lock(&lock); // enter mutex lock region\n    num++;\n    pthread_mutex_unlock(&lock); // exit mutex lock region\n    return 0;\n}\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <linux/spinlock.h>\nvoid test_isr1(int irq, spinlock_t *lock)\n{\n  spin_lock(lock);  // VUL: should use spin_lock_irqsave\n}\n \n// cross function check\nnoinline\nvoid call_spin(spinlock_t *lock)\n{\n  spin_lock(lock);\n}\n\n\n",
                    "#include <stdio.h>\n#include <pthread.h>\n\nint num = 8; // global variable\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; // initialise a mutex\n\nint main() {\n    pthread_mutex_lock(&lock); // enter mutex locked region\n    switch (num) {\n    case 0:\n            num = 0;\n            break;\n    case 1:\n            num++;\n            break;\n    case 2:\n            num--;\n            break;\n    default:\n            // does not exit mutex lock region before return\n            // can cause a deadlock because lock is never released\n            return 0;\n    }\n    pthread_mutex_unlock(&lock); // exit mutex lock region\n    return 0;\n}\n",
                    "\n#include <stdio.h>\n#include <pthread.h>\n#include <unistd.h>\n\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; // initialise a mutex\nint num; // global variable\n\nint main () {\n    pthread_mutex_lock(&lock); // enter mutex lock region\n    num++;\n    sleep(1); // thread goes to sleep within lock region, never want to do this\n    pthread_mutex_unlock(&lock); // exit mutex lock region\n    return 0;\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 138,
        "category": "VUL",
        "language": "c/c++",
        "code": "LLAT",
        "name": "Thread local live after thread is terminated",
        "desc": "When a thread local's address has been saved, it can be called by its holder even after the thread has been terminated.",
        "msg_templ": "",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "#### Abstract\nWhen a thread local's address has been saved, it can be called by its holder even after the thread has been terminated.\n\n#### Explanation\nExposing address of a thread local variable can lead to unintended calls to illegal locks, or functions that are no longer valid. This results in non-deterministic behavior.",
        "examples": {
            "good": {},
            "bad": {
                "c": [
                    " \nstruct completion {\n  int done;\n};\n \nstruct usb_request {\n  struct completion *context;\n  void (*complete)(struct usb_request *req);\n};\n \nvoid complete(struct completion *x)\n{\n  printf(\"%d\\n\", x->done);\n}\n \nvoid ffs_epfile_io_complete(struct usb_request *req)\n{\n  complete(req->context);\n}\n \nvoid usb_ep_queue(struct usb_request *req)\n{\n  req->complete(req);\n}\n \nvoid ffs_epfile_io(struct usb_request *req)\n{\n  struct completion done;\n  req->context = &done;\n  req->complete = ffs_epfile_io_complete;\n  usb_ep_queue(req);\n}\n \n"
                ]
            }
        }
    },
    {
        "master_id": 139,
        "category": "VUL",
        "language": "c/c++",
        "code": "UIL",
        "name": "Uninitialized lock",
        "desc": "The lock has not been initialized when spin_lock was called.",
        "msg_templ": "",
        "severity": "HIGH",
        "likelihood": "LOW",
        "cost": "HIGH",
        "details": "#### Abstract\nThe lock has not been initialized when spin_lock was called.\n\n#### Explanation\nResource alloation is required to use a spin lock, it also needed to be initialized to an unlock state. Failure to do so will lead to non-determinstic system behavior",
        "examples": {
            "good": {},
            "bad": {
                "c": [
                    "#include <stddef.h>\n#include <pthread.h>\n \nvoid mutex_initialise(pthread_mutex_t *lock) {\n  pthread_mutex_init(lock, NULL);\n}\n \nvoid mutex_lock(pthread_mutex_t *lock) {\n  pthread_mutex_lock(lock);\n}\n \nvoid mutex_unlock(pthread_mutex_t *lock) {\n  pthread_mutex_unlock(lock);\n}\n \nint main(void) {\n    pthread_mutex_t mlock;\n    \n    // mutex_initialize, nor pthread_mutex_init has been invoked\n    mutex_lock(&mlock);\n    mutex_unlock(&mlock);\n    return 0;\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 140,
        "category": "VUL",
        "language": "c/c++",
        "code": "TASR",
        "name": "Race condition from test-and-set",
        "desc": "Test-and-set without proper locking may cause race condition",
        "msg_templ": "",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "HIGH",
        "details": "#### Abstract\nTest-and-set without proper locking may cause race condition\n\n#### Explanation\nModifying the variables that are decided in the test-and-set operation in a thread may cause a race condition if such an operation is not protected by the lock.",
        "examples": {
            "good": {},
            "bad": {
                "c": [
                    "extern int printf(const char*, ...);\nextern int get_int();\n \nvoid cmp_set_race_bad() {\n  int flag = get_int();\n  if (flag == 0) {\n    flag = 1;\n  }\n  else {\n    printf(\"\\n\");\n  }\n  printf(\"1st: get %d\\n\", flag);\n  flag = get_int();\n  if (flag != 0) {\n    printf(\"2nd: get %d\\n\", flag);\n  }\n  else {\n    flag = 1;\n  }\n  printf(\"final: %d\\n\", flag);\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 141,
        "category": "VUL",
        "language": "c/c++",
        "code": "PNC",
        "name": "Pair not called",
        "desc": "Specific functions should be paired. Using the first must also use the second in the pair.",
        "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the first one of the pair of specific functions is used while the second one is not.",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nSpecific functions should be paired. Using the first must also use the second in the pair.\n\n#### Explanation\nIf function “irq_of_parse_and_map”  has been called, the corresponding “irq_dispose_mapping” must be called during the program execution.",
        "examples": {
            "good": {
                "c": [
                    "#include <stdio.h>\n#include \"case.h\"\n\nstatic int sunxi_keyboard_startup(struct sunxi_key_data *key_data,\n                                struct platform_device *pdev)\n{\n        struct device_node *np = NULL;\n        int ret = 0;\n\n        key_data->reg_base = of_iomap(np, 0);\n        if (key_data->reg_base == 0) {\n                pr_err(\"%s:Failed to ioremap() io memory region.\", __func__);\n                ret = -1;\n                goto out_iounmap;\n        }\n\n        key_data->irq_num = irq_of_parse_and_map(np, 0);\n        if (key_data->irq_num == 0) {\n                pr_err(\"%s:Failed to map irq.\", __func__);\n                ret = -1;\n                goto out_dispose_mapping;\n        }\n\n        key_data->mclk = of_clk_get(np, 0);\n        if (IS_ERR_OR_NULL(key_data->mclk)) {\n                pr_debug(\"%s: keyboard has no clk.\", __func__);\n                goto out_clk;\n        } else{\n                if (clk_prepare_enable(key_data->mclk)) {\n                        pr_err(\"%s enable apb1_keyadc clock failed!\", __func__);\n                        ret = -1;\n                }\n        }\n\nout_clk:\n        clk_put(key_data->mclk);\nout_dispose_mapping:\n        irq_dispose_mapping(key_data->irq_num);\nout_iounmap:\n        iounmap(key_data->reg_base);\n\n        return ret;\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <stdio.h>\n#include \\\"case.h\\\"\n\nstatic int sunxi_keyboard_startup(struct sunxi_key_data *key_data,\n                                struct platform_device *pdev)\n{\n        struct device_node *np = NULL;\n        int ret = 0;\n\n        key_data->reg_base = of_iomap(np, 0);\n        if (key_data->reg_base == 0) {\n                pr_err(\"%s:Failed to ioremap() io memory region.\", __func__);\n                ret = -1;\n        }\n\n        key_data->irq_num = irq_of_parse_and_map(np, 0);\n        if (key_data->irq_num == 0) {\n                pr_err(\"%s:Failed to map irq.\", __func__);\n                ret = -1;\n        }\n\n        key_data->mclk = of_clk_get(np, 0);\n        if (IS_ERR_OR_NULL(key_data->mclk)) {\n                pr_debug(\"%s: keyboard has no clk.\", __func__);\n        } else{\n                if (clk_prepare_enable(key_data->mclk)) {\n                        pr_err(\"%s enable apb1_keyadc clock failed!\", __func__);\n                        return -1;\n                }\n        }\n        \n        return ret;\n}"
                ]
            }
        }
    },
    {
        "master_id": 142,
        "category": "VUL",
        "language": "c/c++",
        "code": "LSO",
        "name": "Wrong Phase of Lifetime Operation",
        "desc": "Operation on resource should not be performed in wrong phase of lifetime.",
        "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} is performed in wrong phase of lifetime.",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nOperation on resource should not be performed in wrong phase of lifetime.\n\n#### Explanation\nIf developers initialize, use or release resource in wrong phase of lifetime, it can lead to unexpected behaviors.",
        "examples": {
            "good": {
                "c": [
                    "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#define BUF_SZ 256\n\nint foo(void)\n{\n    int n;\n    char buffer[BUF_SZ];\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n\n    if (sockfd < 0)\n    {\n        perror(\"ERROR opening socket\");\n        exit(1);\n    }\n\n    struct sockaddr_in addr;\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    addr.sin_port = htons(3128);\n    if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0)\n    {\n        perror(\"ERROR binding socket\");\n        exit(1);\n    }\n\n    if (listen(sockfd, 0) < 0)\n    {\n        perror(\"ERROR listening socket\");\n        exit(1);\n    }\n\n    close(sockfd);\n    return n;\n}\n"
                ]
            },
            "bad": {
                "c": [
                    "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n#define BUF_SZ 256\n\nint foo(void)\n{\n    int n;\n    char buffer[BUF_SZ];\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\n\n    if (sockfd < 0)\n    {\n        perror(\"ERROR opening socket\");\n        exit(1);\n    }\n\n    struct sockaddr_in addr;\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    addr.sin_port = htons(3128);\n    if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0)\n    {\n        perror(\"ERROR binding socket\");\n        exit(1);\n    }\n\n    if (listen(sockfd, 0) < 0)\n    {\n        perror(\"ERROR listening socket\");\n        exit(1);\n    }\n\n    n = recv(sockfd, buffer, 255, 0);\n\n    // use buffer\n    // if buffer is used as argument to system() or to setenv()\n    // the buffer may contain untrusted commands or characters leading to unpredictable program behavior\n    // ...\n    close(sockfd);\n    return n;\n}\n"
                ]
            }
        }
    },
    {
        "master_id": 143,
        "category": "VUL",
        "language": "c/c++",
        "code": "MBSP",
        "name": "Multiple Sockets Bind to Same Port",
        "desc": "Multiple sockets should not bind to the same port",
        "msg_templ": "In file ${si.filename}, multiple sockets bind to the same port.",
        "severity": "MEDIUM",
        "likelihood": "PROBABLE",
        "cost": "MEDIUM",
        "details": "#### Abstract\nMultiple sockets should not bind to the same port\n\n#### Explanation\nIf multiple sockets bind to the same port, other services of that port may be stolen.\n",
        "examples": {
            "good": {
                "c": [
                    "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nvoid func( void )\n{\n    // create socket one and bind to port\n    int sockfd_one;\n    int server_len;\n    struct sockaddr_in addr;\n    sockfd_one = socket(AF_INET, SOCK_STREAM, 0);\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    addr.sin_port = htons(6789);\n    server_len = sizeof(struct sockaddr_in);\n    bind(sockfd_one, (struct sockaddr *) &addr, server_len);\n}"
                ]
            },
            "bad": {
                "c": [
                    "#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nvoid func( void )\n{\n    // create socket one\n    int sockfd_one;\n    int server_len;\n    struct sockaddr_in addr;\n    sockfd_one = socket(AF_INET, SOCK_STREAM, 0);\n    memset(&addr, 0, sizeof(addr));\n    addr.sin_family = AF_INET;\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    addr.sin_port = htons(6789);\n    server_len = sizeof(struct sockaddr_in);\n\n    // set SO_REUSEADDR and bind socket one to port\n    int opt = 1;\n    setsockopt( sockfd_one, SOL_SOCKET,SO_REUSEADDR, (const void *)&opt, sizeof(opt) );\n    bind(sockfd_one, (struct sockaddr *) &addr, server_len);\n\n    // create socket two\n    int sockfd_two;\n    sockfd_two = socket(AF_INET, SOCK_DGRAM, 0);\n\n    // set SO_REUSEADDR and bind socket two to port\n    opt = 1;\n    setsockopt( sockfd_two, SOL_SOCKET,SO_REUSEADDR, (const void *)&opt, sizeof(opt) );\n    bind(sockfd_two, (struct sockaddr *) &addr, server_len);\n}"
                ]
            }
        }
    }
]