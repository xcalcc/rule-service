- alias: {}
  category: BAD_PRACTICE
  code: CSL
  cost: M
  csv_string:
    - CSL0
  desc: >-
    The program has a call sequence that causes the runtime stack to exceed the
    call depth limit set by the user.
  details: >
    #### Abstract

    The program has a call sequence that causes the runtime stack to exceed the
    call depth limit set by the user.


    #### Explanation

    Function A calls another function B. Function B may in turn call another
    function C. This call chain can go on infinitely. In embedded systems, when
    the call stack is too deep, it may cause unintended side effects like
    running out of memory, inefficient execution time, etc.
  examples:
    bad:
      c:
        - |
          int __attribute__((__noinline__)) f1() {
            return 1;
          }
          int __attribute__((__noinline__)) f2() {
            return 2 + f1();
          }
          int __attribute__((__noinline__)) f3() {
            return 3 + f2();
          }
          int __attribute__((__noinline__)) f4() {
            return 4 + f3();
          }
          int __attribute__((__noinline__)) f5() {
            return 5 + f4();
          }
          int __attribute__((__noinline__)) f6() {
            return 6 + f5();
          }
          int __attribute__((__noinline__)) f7() {
            return 7 + f6();
          }
          int __attribute__((__noinline__)) f8() {
            return 8 + f7();
          }
          int __attribute__((__noinline__)) f9() {
            return 9 + f8();
          }
          int __attribute__((__noinline__)) f10() {
            return 10 + f9();
          }
          int __attribute__((__noinline__)) f11() {
            return 11 + f10();
          }
          int __attribute__((__noinline__)) f12() {
            return 12 + f11();
          }
          int __attribute__((__noinline__)) f13() {
            return 13 + f12();
          }
          int __attribute__((__noinline__)) f14() {
            return 14 + f13();
          }
          int __attribute__((__noinline__)) f15() {
            return 15 + f14();
          }
          int __attribute__((__noinline__)) f16() {
            return 16 + f15();
          }
          int __attribute__((__noinline__)) f17() {
            return 17 + f16();
          }
          int __attribute__((__noinline__)) f18() {
            return 18 + f17();
          }
          int __attribute__((__noinline__)) f19() {
            return 19 + f18();
          }
          int __attribute__((__noinline__)) f20() {
            return 20 + f19();
          }
          int __attribute__((__noinline__)) f21() {
            return 21 + f20();
          }
          int __attribute__((__noinline__)) f22() {
            return 22 + f21();
          }
          int __attribute__((__noinline__)) f23() {
            return 23 + f22();
          }
          int __attribute__((__noinline__)) f24() {
            return 24 + f23();
          }
          int __attribute__((__noinline__)) f25() {
            return 25 + f24();
          }
          int __attribute__((__noinline__)) f26() {
            return 26 + f25();
          }
          int __attribute__((__noinline__)) f27() {
            return 27 + f26();
          }
          int __attribute__((__noinline__)) f28() {
            return 28 + f27();
          }
          int __attribute__((__noinline__)) f29() {
            return 29 + f28();
          }
          int __attribute__((__noinline__)) f30() {
            return 30 + f29();
          }
          int __attribute__((__noinline__)) f31() {
            return 31 + f30();
          }
          int __attribute__((__noinline__)) f32() {
            return 32 + f31();
          }
          int __attribute__((__noinline__)) f33() {
            return 33 + f32();
          }
          int __attribute__((__noinline__)) f34() {
            return 34 + f33();
          }
          int __attribute__((__noinline__)) f35() {
            return 35 + f34();
          }
          int __attribute__((__noinline__)) f36() {
            return 36 + f35();
          }
          int __attribute__((__noinline__)) f37() {
            return 37 + f36();
          }
          int __attribute__((__noinline__)) f38() {
            return 38 + f37();
          }
          int __attribute__((__noinline__)) f39() {
            return 39 + f38();
          }
          int __attribute__((__noinline__)) f40() {
            return 40 + f39();
          }
          int __attribute__((__noinline__)) f41() {
            return 41 + f40();
          }
          int __attribute__((__noinline__)) f42() {
            return 42 + f41();
          }
          int __attribute__((__noinline__)) f43() {
            return 43 + f42();
          }
          int __attribute__((__noinline__)) f44() {
            return 44 + f43();
          }
          int __attribute__((__noinline__)) f45() {
            return 45 + f44();
          }
          int __attribute__((__noinline__)) f46() {
            return 46 + f45();
          }
          int __attribute__((__noinline__)) f47() {
            return 47 + f46();
          }
          int __attribute__((__noinline__)) f48() {
            return 48 + f47();
          }
          int __attribute__((__noinline__)) f49() {
            return 49 + f48();
          }
          int __attribute__((__noinline__)) f50() {
            return 50 + f49();
          }
      general:
        - >-
          // This case does not need an example.

          // The complete call level from function A to Z, i.e. A() ==> B() ==>
          .... ==> Z(), is too deep.
    good: {}
  language: c,c++
  likelihood: L
  master_id: 1
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, function ${si.func} has a call
    sequence that exceeds call level limit set from scan configuration.
  name: Call stack level exceeds limit
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: M
  standards:
    cwe:
      - '121'
- alias: {}
  category: BAD_PRACTICE
  code: CSS
  cost: M
  csv_string:
    - CSS0
  desc: >-
    The program has a call sequence that causes the runtime stack size to exceed
    the set limit.
  details: >
    #### Abstract

    The program has a call sequence that causes the runtime stack size to exceed
    the set limit.


    #### Explanation

    When function A calls another function B, the parameters passed to the
    called function, and the return value from the called function to the caller
    function will be placed on the execution stack. Local variables will also be
    placed on the execution stack.
  examples:
    bad:
      c:
        - |+
          extern void init_buf(char *buf, int sz);
          int f1() {
            char buf[8192];
            init_buf(buf, sizeof(buf));
            return buf[1];
          }

          int f2() {
            char buf[8192];
            init_buf(buf, sizeof(buf));
            return buf[2] + f1();
          }

          int f3() {
            char buf[8192];
            init_buf(buf, sizeof(buf));
            return buf[3] + f2();
          }

          int f4() {
            char buf[8192];
            init_buf(buf, sizeof(buf));
            return buf[4] + f3();
          }

      general:
        - >-
          // Assuming that stack size is 8 bytes for parameter, 4 bytes for
          return value (assume) 32 bit ABI

          int func_callee(int* a, int i)

          {
           return a[i];
          }


          // stack size is 0 byte (no parameter), 12 byte for local variable, 4
          bytes for return value

          int func_caller() {
           int a[3] = {0, 1}, b;
           b = assign(a, 1); /* callee stack size if 12 bytes
           return 0;
          }


          // total stack size for the call sequence func_caller -> func_callee
          is 28 bytes

          // (assume ABI specifies all parameters uses stack and not register)
    good:
      c:
        - >-
          // Assume that stack size is 8 bytes for parameter, 4 bytes for return
          value (assume) 32 bit ABI

          // Assume we limit the size of stack to that of 32 bytes


          int func_callee(int *a, int i)

          {
              return a[i];
          }


          // stack size is 0 byte (no parameter), 12 byte for local variable, 4
          bytes for return value

          int func_caller()

          {
              int a[3] = {0, 1}, b;
              b = func_callee(a, 1);
              // callee stack size if 12 bytes
              return 0;
          }


          // total stack size for the call sequence func_caller -> func_callee
          is 28 bytes

          // (assume ABI specifies all parameters uses stack and not register)
  language: c,c++
  likelihood: L
  master_id: 2
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, function ${si.func} has a call
    sequence that exceeds stack size limit set at scan configuration time.
  name: Call stack size exceeds limit
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: M
  standards:
    cwe:
      - '787'
- alias:
    cert:
      - MEM51-CPP
  category: VUL
  code: DBF
  cost: M
  csv_string:
    - DBF0
  desc: >-
    The program has freed some resources (e.g. heap memory, I/O stream object,
    etc.) on multiple occasions.
  details: >+
    #### Abstract

    The program has freed some resources (e.g. heap memory, I/O stream object,
    etc.) multiple times.


    #### Explanation

    The program has called functions such as free(), close() multiple times to
    release the same resource object. This could cause system inconsistencies
    such as corruption of the system's heap management data strutures or I/O
    stream subclasses. This in turn may allow malicious users to access
    arbitrary memory or cause an IOException.

  examples:
    bad:
      general:
        - |-
          int func_1(void *p) {
           if (p != NULL) {
           free(p); // free p
           }
          }

          int func_2(void *p) {
           if (p != NULL) {
           free(p); // free p
           }
          }

          int main() {
           int i, *p, *q;
           p = malloc(10 * sizeof(int));
           if (p == NULL)
           return 1;
           for (i=0; i < 10; ++i)
           p[i] = i;
           q = p;
           func_1(p); // free p the first time
           func_2(q); // free p the second time due to value of p copied into q
           return 0;
          }
    good:
      general:
        - |-
          int func_1(void *p) {
           if (p != NULL) {
           free(p); // free p
           }
          }

          int func_2(void *p) {
           if (p != NULL) {
           free(p); // free p
           }
          }

          int main() {
           int i, *p, *q;
           p = malloc(10 * sizeof(int));
           if (p == NULL)
           return 1;
           for (i=0; i < 10; ++i)
           p[i] = i;
           q = p;
           func_1(p); // free p the first time and only time
           return 0;
          }
  language: c,c++
  likelihood: L
  master_id: 3
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, resource variable ${si.var} at
    function ${si.func} has been released multiple times. Such variable is first
    released at file  ${so.filename}, line ${so.line}.
  name: Resource was freed multiple times
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    cwe:
      - '415'
- alias: {}
  category: VUL
  code: FMT
  cost: L
  csv_string:
    - FMT2
    - FMT1
    - FMT0
  desc: >-
    The program is calling one of the printf families with a number (or type) of
    parameter(s) that are used differently from the format string declaration.
  details: >
    #### Abstract

    The program is calling one of the printf families with a number (or type) of
    parameter(s) used differently from format string declaration.


    #### Explanation

    In a printf (or family with this type of system call), the format string
    specifier is inconsistent with the actual parameters or, that specifier has
    unsupported characters in the format string. When the actual parameters
    being passed are different, what is printed out will be unpredictable.
  examples:
    bad:
      c:
        - |+
          foo(int a, int guard)
          {
            int x = 0;
            int int_result = 0;
            if (guard != 0) int_result = a * x;
            
            // The format string specified two values to be printed,
            // only one actual parameter is passed. The second output is unpredictable
            printf("result %d is %x truncated", int_result); 
            return 0;
          }

    good:
      c:
        - |+

          foo(int a, int guard)
          {  int x = 0;
            int int_result = 0;
            if (guard != 0) int_result = a * x;

            // number of actuals match that with format statement
            printf("result %d is %x truncated", int_result, int_result); 
            return 0;
          }

  language: c,c++
  likelihood: U
  master_id: 4
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, the format specification in
    function ${si.func}, argument ${si.var} has unknown format characters in the
    format string declaration.
  name: Format string overflow
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    cwe:
      - '787'
      - '88'
      - '119'
    owasp:
      - A3
      - A1
      - A6
- alias: {}
  category: ROBUSTNESS
  code: MSF
  cost: M
  csv_string:
    - MSF2
    - MSF1
    - MSF0
  desc: >-
    The program has allocated heap memory but failed to free that piece of
    memory.
  details: >
    #### Abstract

    The program has allocated heap memory but failed to free that piece of
    memory.


    #### Explanation

    Heap memory has been allocated and the allocated memory address is stored in
    a variable of reference (pointer) type. That heap memory has never been
    released after its lifetime has effectively ended, and its corresponding
    reference still points to that memory space. This could result in sensitive
    data leakage or unexpected program behavior such as denial of service.
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>

          struct S
          {
              int *p;
          };

          int main()
          {
              int *p;
              struct S *s;
              p = malloc(10 * sizeof(int)); // heap memory allocated and pointed to by p
              if (p == NULL)
              {
                  return 1;
              }
              s = (struct S *)malloc(sizeof(struct S)); // heap memory allocated and pointed to by s
              if (s == NULL)
              {
                  free(p);
                  return 1;
              }
              s->p = p;
              free(s); // only s is freed
              // s->p, which is copied from p is not freed
              return 0;
          }
      general:
        - |-
          struct S {
           int *p;
          };

          int main() {
           int *p;
           struct S *s;
           p = malloc(10 * sizeof(int)); // heap memory allocated and pointed to by p
           if (p == NULL)
           return 1;
           s = (struct S*)malloc(sizeof(struct S)); // heap memory allocated and pointed to by s
           if (s == NULL) {
           free(p);
           return 1;
           }
           s->p = p;
           free(s); // only s is freed
           // s->p, which is copied from p is not freed
           return 0;
          }
    good:
      c:
        - |-
          #include <stdio.h>

          struct S
          {
              int *p;
          };

          int main()
          {
              int *p;
              struct S *s;
              p = malloc(10 * sizeof(int)); // heap memory allocated and pointed to by p
              if (p == NULL)
              {
                  return 1;
              }
              s = (struct S *)malloc(sizeof(struct S)); // heap memory allocated and pointed to by s
              if (s == NULL)
              {
                  free(p);
                  return 1;
              }
              s->p = p;
              // both s and p are freed
              free(s); 
              free(p); 
              return 0;
          }
  language: c,c++
  likelihood: L
  master_id: 5
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, variable ${si.var} in function
    ${si.func} has not been freed. Such variable is first assigned heap memory
    acquired in file ${so.filename} at line ${so.line}.
  name: Missing free
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    owasp:
      - A3
- alias:
    cert:
      - EXP54-CPP
      - DCL30-C
  category: VUL
  code: RAL
  cost: L
  csv_string:
    - RAL1
    - RAL0
  desc: >-
    The function returns the address of a stack variable and will cause
    unintended program behavior.
  details: >
    #### Abstract

    The function returns the address of a stack variable and will cause
    unintended program behavior.


    #### Explanation

    Because local variables are allocated to the stack, when a function returns
    to the caller, the callee's stack address is no longer valid. A subsequent
    function call is likely to re-use this same stack address, thereby
    overwriting the previous value.
  examples:
    bad:
      c:
        - |
          extern void bar(int);

          int *foo()
          {
              int c = 0;
              bar(c);
              return &c; //return a local address to caller
          }
      general:
        - |-
          int foo()
          {
           int *c;
           return &c; //return a local address to caller
          }
    good:
      c:
        - |-
          int foo()
          {
              int *c;
              return *c; // item *c is pointing to returned
          }
  language: c,c++
  likelihood: L
  master_id: 6
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, address of the local variable
    ${si.var} has been returned to the caller.
  name: Return address of local
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    autosar:
      - M7-5-1
- alias: {}
  category: VUL
  code: RXS
  cost: L
  csv_string:
    - RXS0
  desc: The program has read from external sockets which may include untrusted data.
  details: >
    #### Abstract

    The program has read from external sockets which may include untrusted data.


    #### Explanation

    The external interface allows the program to interact with the external
    world, so it is very important to ensure that the external interface does
    not receive security sensitive or untrusted input.
  examples:
    bad:
      c:
        - |-
          #include <sys/socket.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <unistd.h>

          #define BUF_SZ 256

          int foo(void)
          {
              int n;
              char buffer[BUF_SZ];
              int sockfd = socket(AF_INET, SOCK_STREAM, 0);

              if (sockfd < 0)
              {
                  perror("ERROR opening socket");
                  exit(1);
              }

              n = read(sockfd, buffer, 255);

              // use buffer
              // if buffer is used as argument to system() or to setenv()
              // the buffer may contain untrusted commands or characters leading to unpredictable program behavior
              // ...
          }
      general:
        - |
          #include <sys/socket.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <unistd.h>

          #define BUF_SZ 256

          int foo(void)
          {
           int n;
           char buffer[BUF_SZ];
           sockfd = socket(AF_INET, SOCK_STREAM, 0);

           if (sockfd < 0) {
           perror(\"ERROR opening socket\");
           exit(1);
           }

           n = read(sockfd,buffer,255);

           // use buffer
           // if buffer is used as argument to system() or to setenv()
           // the buffer may contain untrusted commands or characters leading to unpredictable program behavior
           // ...
          }
    good:
      c:
        - |-
          #include <sys/socket.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <unistd.h>

          #define BUF_SZ 256

          int foo(void)
          {
              int n;
              char buffer[BUF_SZ];
              char *cp = buffer; 
              int sockfd = socket(AF_INET, SOCK_STREAM, 0);

              if (sockfd < 0)
              {
                  perror("ERROR opening socket");
                  exit(1);
              }

              // filter out untrusted data and characters
              static char approved[] = "abcdefghijklmnopqrstuvwxyz"
                                       "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                                       "1234567890_-.@";
              const char *end = buffer + strlen(buffer);
              for (cp += strspn(cp, approved); cp != end; cp += strspn(cp, approved))
              {
                  *cp = '_';
              }

              n = read(sockfd, buffer, 255);

              // use buffer
              // if buffer is used as argument to system() or to setenv()
              // the buffer may contain untrusted commands or characters leading to unpredictable program behavior
              // ...
          }
  language: c,c++
  likelihood: L
  master_id: 7
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, function ${si.func} is receiving
    untrusted data from external socket. The socket has been created in file
    ${si.filename} at line ${si.line}.
  name: Read from external socket
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: M
  standards:
    cwe:
      - '577'
- alias:
    cert:
      - MEM50-CPP
      - MEM01-C
      - MEM30-C
      - MEM00-C
  category: VUL
  code: UAF
  cost: M
  csv_string:
    - UAF3
    - UAF2
    - UAF1
    - UAF0
  desc: >-
    The program has referenced memory after it has been freed. It can cause the
    program to crash or lead to an unexpected program behavior.
  details: >
    #### Abstract

    The program has referenced memory after it has been freed. It can cause the
    program to crash or an unexpected program behavior.


    #### Explanation

    Use after free is a variation of dangling pointer reference. It typically
    occurs when the pointer is not updated after the memory object it points to
    has been freed. This pointer will be pointing to inappropriate memory
    leading to unauthorized access when the pointer is used.
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>

          int g = 2;

          void my_free(void *p)
          {
              if (p != NULL) 
              {
                  free(p); // free p
              }
          }

          int main()
          {
              int i, j, *p, *q;
              p = malloc(10 * sizeof(int));
              if (p == NULL)
              {
                  return 1;
              }
              for (i = 0; i < 10; ++i) 
              {
                  p[i] = i;
              }
              q = p;
              my_free(p); // p is freed
              j = 0;
              for (i = 0; i < 10; ++i)
              {
                  j += q[i]; // Use after free here (note the statement q = p), read of q[i] is illegal
              }
              return j;
          }
      general:
        - |-
          #include <stdio.h>

          int g = 2;

          void my_free(void *p) {
           if (p != NULL)
           free(p); // free p
          }

          int main() {
           int i, j, *p, *q;
           p = malloc(10 * sizeof(int));
           if (p == NULL)
           return 1;
           for (i=0; i < 10; ++i)
           p[i] = i;
           q = p;
           my_free(p); // p is freed
           j = 0;
           for (i=0; i < 10; ++i)
           j += q[i]; // Use after free here (note the statement q = p), read of q[i] is illegal
           return j;
          }
    good:
      c:
        - |-
          #include <stdio.h>

          int g = 2;

          void my_free(void *p)
          {
              if (p != NULL) 
              {
                  free(p); // free p
              }
                  
          }

          int main()
          {
              int i, j, *p, *q;
              p = malloc(10 * sizeof(int));
              if (p == NULL)
              {
                  return 1;
              }
              for (i = 0; i < 10; ++i) 
              {
                  p[i] = i;
              }    
              q = p;
              my_free(p); // p is freed
              j = 0;

              // checks if q is illegal before running the for loop
              if (q == 0 || q == NULL)
              {
                  exit(1);
              }
              
              for (i = 0; i < 10; ++i)
              {
                  // Use after free here (note the statement q = p), read of q[i] is illegal
                  j += q[i]; 
              }
                  
              return j;
          }
  language: c,c++
  likelihood: L
  master_id: 8
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, variable ${so.var} in function
    ${so.func} was used. However, it has been freed at line ${so.line} in file
    ${so.filename}.
  name: Use after free
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    cwe:
      - '416'
      - '672'
    owasp:
      - A1
      - A3
- alias: {}
  category: VUL
  code: UDR
  cost: H
  csv_string:
    - UDR5
    - UDR4
    - UDR3
    - UDR2
    - UDR1
    - UDR0
  desc: Dangling pointer has been used to refer to an invalid memory resource.
  details: >
    #### Abstract

    Dangling pointer has been used to refer to an invalid memory resource.


    #### Explanation

    Dangling pointers are pointers that refer to invalid or inappropriate memory
    resources. Referencing these memory resources may create memory corruption,
    resulting in unpredictable program behavior or system instablity.
  examples:
    bad:
      c:
        - |-
          int *assign()
          {
              int *c;
              c = 1;
              return &c;
          }

          int foo()
          {
              int *a;
              a = assign(); // return a stack address and assign to a
              printf("assigned value: %d", a); // use dangling pointer
              return 0;
          }
        - |-
          #include <alloca.h>
          #include <stdlib.h>

          void extern fill(char *data, int num);
          void dangling_ptr_func(int sz, char *data_buf)
          {
            data_buf = alloca(sz);
            fill(data_buf, sz);  // fill data buffer
            // more manipulation of data buffer ...


            // free does not really free data_buf
            // data_buf points to memory that is out of scope after
            free(data_buf);
            return;
          }
      general:
        - |-
          int *assign()
          {
           int *c;
           c = 1;
           return &c;
          }

          int foo()
          {
           int *a;
           a = assign(); // return a stack address and assign to a
           printf(\"assigned value: %d\", a); // use dangling pointer
           return 0;
          }
    good:
      c:
        - |+
          void assign(int *c)
          {
              *c = 1;
              return;
          }

          int foo()
          {
              int a;
              assign(&a); 
              printf("assigned value: %d", a); // pointer is not dangling
              return 0;
          }

  language: c,c++
  likelihood: L
  master_id: 9
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, the memory reference variable
    ${so.var} in function ${so.func} is used. Such variable is first assigned as
    a memory reference that may not be valid in file ${so.filename}, line
    ${so.line}.
  name: Use dangling reference
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    cwe:
      - '590'
    owasp:
      - A1
      - A2
      - A3
- alias: {}
  category: VUL
  code: WRF
  cost: M
  csv_string:
    - WRF0
  desc: >-
    The program is performing write operations to a file that is available for
    read only.
  details: >
    #### Abstract

    The program is performing a write operation to a file that is available for
    read only


    #### Explanation

    When the file that is opened for read and later then written upon, the
    fwrite will report an error. If the result of fwrite is not checked, the
    program will continue and the file may not be updated as expected.
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>
          #include <unistd.h>
          #include <sys/stat.h>
          #include <fcntl.h>

          int file_operation()
          {
              struct stat statBefore, statAfter;

              lstat("/tmp/x", &statBefore);

              // file open for read
              FILE *fp_open_readonly = fopen("/tmp/x", "r");
              lstat("/tmp/x", &statAfter);

              if (statAfter.st_ino == statBefore.st_ino)
              {
                  if (fp_open_readonly != NULL)
                  {
                      // writing to the file
                      fwrite("HELLO!", 1, 5, fp_open_readonly);
                  }
              }

              fclose(fp_open_readonly);
              return 0;
          }
      general:
        - |-
          int file_operation(two_level *p, two_level *q)
          {
           struct stat statBefore, statAfter;

           lstat(\"/tmp/x\", &statBefore);

           // file open for read
           FILE *fp_open_readonly = fopen(\"/tmp/x\", \"r\");
           lstat(\"/tmp/x\", &statAfter);

           if (statAfter.st_ino == statBefore.st_ino) {
           if (fp_open_readonly != NULL) {
           // writing to the file
           fwrite(\"HELLO!\", 1, 5, fp_open_readonly);
           }
           }

           fclose(fp_open_readonly);
           return 0;
          }
    good:
      c:
        - |-
          #include <stdio.h>
          #include <unistd.h>
          #include <sys/stat.h>
          #include <fcntl.h>

          int file_operation()
          {
              struct stat statBefore, statAfter;

              lstat("/tmp/x", &statBefore);

              // file open for read
              FILE *fp_open_readonly = fopen("/tmp/x", "w");
              lstat("/tmp/x", &statAfter);

              if (statAfter.st_ino == statBefore.st_ino)
              {
                  if (fp_open_readonly != NULL)
                  {
                      // writing to the file
                      fwrite("HELLO!", 1, 5, fp_open_readonly);
                  }
              }

              fclose(fp_open_readonly);
              return 0;
          }
  language: c,c++
  likelihood: L
  master_id: 10
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, function ${si.func} is performing
    write operations to a read-only file .
  name: Write to file for read only
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    cwe:
      - '275'
    owasp:
      - A5
- alias:
    cert:
      - ARR38-C
      - ARR30-C
  category: VUL
  code: AOB
  cost: H
  csv_string:
    - AOB4
    - AOB3
    - AOB2
    - AOB1
    - AOB0
  desc: >-
    The program is accessing data outside the declared boundary (before or
    after) of the intended buffer.
  details: >
    #### Abstract

    The program is accessing data outside (i.e. before or after) the declared
    boundary of the intended buffer.


    #### Explanation

    Typically, this can allow attackers to cause a crash during program
    execution. A crash can occur when the code reads sensitive information from
    other memory locations or causable amount of data and assumes that a
    sentinel exists to stop the read operation, such as a NUL in a string. The
    expected sentinel might not be located in the out-of-bounds memory, causing
    excessive data to be read, leading to a segmentation fault or a buffer
    overflow. The software may modify an index or perform pointer arithmetic
    that references a memory location that is outside of the boundaries of the
    buffer. A subsequent read operation then produces undefined or unexpected
    results.
  examples:
    bad:
      c:
        - |-
          int assign(int* a, int i)
          {
           return a[i]; /* called by main
           a only has 2 elements but i is 2 */
          }

          int main() {
           int a[2] = {0, 1}, b;
           b = assign(a, 2); // call assign with a and i
           // a has two elements and i is 2
           // a[2] is out-of-bound and also uninitialized
           printf("value of b = %d\\", b);
           return 0;
          }
      general:
        - |-
          int assign(int* a, int i)
          {
           return a[i]; /* called by main
           a only has 2 elements but i is 2 */
          }

          int main() {
           int a[2] = {0, 1}, b;
           b = assign(a, 2); // call assign with a and i
           // a has two elements and i is 2
           // a[2] is out-of-bound and also uninitialized
           printf("value of b = %d\\", b);
           return 0;
          }
    good:
      c:
        - |-
          int assign(int* a, int i)
          {
              return a[i];    /* called by main
              a only has 2 elements but i is 2 */
          }

          #define ARR_SZ 2
          int main()
          {
              int a[ARR_SZ] = {0, 1}, b;
              b = assign(a, (ARR_SZ-1)); // call assign with a and i
              // a has two elements and i is 2
              // a[2] is out-of-bound and also uninitialized
              printf("value of b = %d\\", b);
              return 0;
          }
      general:
        - |-
          int assign(int* a, int i)
          {
           return a[i]; /* called by main
           a only has 2 elements but i is 2 */
          }

          #define ARR_SZ 2
          int main() {
           int a[ARR_SZ] = {0, 1}, b;
           if ()
           b = assign(a, (ARR_SZ-1)); // call assign with a and i
           // a has two elements and i is 2
           // a[2] is out-of-bound and also uninitialized
           printf("value of b = %d\\", b);
           return 0;
          }
  language: c,c++,java
  likelihood: L
  master_id: 11
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, an array out of bound has been
    detected for variable ${si.var} in function ${si.func}. 
  name: Array out of bounds
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    cwe:
      - '787'
      - '125'
      - '121'
      - '122'
      - '126'
    owasp:
      - A1
      - A2
      - A3
      - A5
- alias: {}
  category: BAD_PRACTICE
  code: CRF
  cost: M
  csv_string:
    - CRF0
  desc: The program has a call sequence that results in recursion at runtime.
  details: >
    #### Abstract

    The program has a call sequence that results in recursion at runtime


    #### Explanation

    Recursion happens when a function (e.g. A) calls another function in such a
    way that the call sequence eventually calls A again. In its most simple
    form, a function simply calls itself during the execution. If not programmed
    correctly, this could lead to an infinite loop. It can also cause an
    excessive use of stack space and may lead to running out of memory or stack
    space problems.
  examples:
    bad:
      c:
        - |-
          // Most simple forms of recursion.
          // if first call to func_recurse is: func_recurse(p_glbl, 6)
          // this code segment will recurse and get into an infinite loop

          int global = 5;
          static *p_glbl = &global;
          int func_recurse(int *p, int i)
          {
              if ((p != 0) && (*p != i))
              {
                  return func_recurse(p, 2); // calls itself directly
              }
              return 0;
          }
      general:
        - |-
          // Most simple forms of recursion.
          // if first call to func_recurse is: func_recurse(p_glbl, 6)
          // this code segment will recurse and get into an infinite loop

          int global = 5;
          static *p_glbl = &global;
          int func_recurse(int* p, int i)
          {
           if ((p != 0) && (*p != i))
           return func_recurse(p, 2); // calls itself directly
           return 0;
          }
        - |-
          // Indirect recursion.
          // if first call to func_recurse is: func_recurse(p_glbl, 6)
          // this code segment will call func_recurse inside func_b

          int global = 5;
          static *p_glbl = &global;

          int func_b(int *q, int j)
          {
           if (q != 0) {
           return func_recurse(q, 5);
           }
           else
           return 5;
          }

          int func_recurse(int *p, int i)
          {
           if ((p != 0) && (*p != i))
           return func_b(p, i); // calls func_recurse indirectly
           return 0;
          }
    good:
      c:
        - "// suppose first call to func_recurse is (p_glbl, 6)\n\nconst int MAXIMUM_LIMIT = 100;\nint global = 5;\nstatic *p_glbl = &global;\nint func_recurse(int *p, int i)\n{\n    if (i > MAXIMUM_LIMIT) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (i != 0) {\n        // recursion bottoms out when second argument tends to 0\n        return func_recurse(p_glbl, i - 1);                                           \n    }\n    return 0;\n}"
  language: c,c++,java
  likelihood: L
  master_id: 12
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, function ${si.func} is calling
    itself. 
  name: Use recursive function
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: M
  standards:
    cwe:
      - '674'
- alias:
    cert:
      - FLP03-C
      - INT33-C
      - NUM02-J
  category: CORRECTNESS
  code: DBZ
  cost: H
  csv_string:
    - DBZ2
    - DBZ1
    - DBZ0
  desc: The program is trying to divide a value by zero.
  details: >+
    #### Abstract

    The program is trying to divide a value by zero.


    #### Explanation

    This can occur when an unexpected constant zero is assigned to the divisor,
    or if an error occurs that is not properly detected (for example, return
    value of a function call).

  examples:
    bad:
      c:
        - |-
          int divide(int num, int denom)
          {
              // denom could be of value 0, and dividing 
              // by 0 results in undefined behavior
              return num / denom;
          }

          int func(void)
          {
              return divide(3, 0); // non-compliant
          }
      general:
        - |-
          int foo(int a, int guard)
          {
           int x = 0;
           int result = 0;
           if (guard != 0)
           result = a / x; // did not check for zero
           printf(\"result is %d\", result);
           return 0;
          }
    good:
      c:
        - |-
          int divide(int num, int denom) {

              // checks if denom is 0, and always throws an
              // error when trying to divide by 0
              if (denom == 0) 
              {
                  printf("Cannot divide a number by 0");
                  exit(133);
              }

              return num/denom;
          }
  language: c,c++,java
  likelihood: P
  master_id: 13
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, variable ${so.var} in function
    ${so.func}, a division by zero has been detected. Such variable has a value
    of zero.
  name: Division by zero
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: L
  standards:
    cwe:
      - '369'
- alias:
    cert:
      - MSC07-C
      - MSC12-C
  category: BAD_PRACTICE
  code: DDC
  cost: M
  csv_string:
    - DDC1
    - DDC0
  desc: Unreachable code after a jump statement.
  details: >
    #### Abstract

    Unreachable code after a jump statement.


    #### Explanation

    Execution will never reach statements that come immediately after a jump
    statement or function calls that do not return. This could be due to
    unintended edits and is a code quality issue.
  examples:
    bad:
      c:
        - |
          void abort();
          void exit();
          int foo();

          int f1()
          {
              abort();
              foo(); // unreachable
          }
          int f2()
          {
              exit();
              foo(); // unreachable
          }

          int f3()
          {
              foo();
              goto L;
              foo(); // unreachable
          L:
              foo();
          }

          int f4(int x)
          {
              foo();
              goto L;
              if (x > 5)
              { // unreachable
              L:
                  foo();
              }
          }
      general:
        - |
          void abort();
          void exit();
          int foo();

          int f1() {
           abort();
           foo(); // unreachable
          }
          int f2() {
           exit();
           foo(); // unreachable
          }

          int f3() {
           foo();
           goto L;
           foo(); // unreachable
          L:
           foo();
          }

          int f4(int x) {
           foo();
           goto L;
           if (x>5) { // unreachable
          L:
           foo();
           }
          }
    good:
      c:
        - |
          void abort();
          void exit();
          int foo();

          int f1()
          {
              foo(); // reachable
          }
          int f2()
          {
              foo(); // reachable
          }

          int f3()
          {
              foo();
              goto L;
              L:
                  foo();  // reachable
          }
  language: c,c++,java
  likelihood: U
  master_id: 14
  msg_templ: >-
    In file ${si.filename}, function ${si.func} at line ${si.line} has
    unreachable code during execution.
  name: Unreachable code after jump
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: L
  standards: {}
- alias:
    cert:
      - MSC12-C
  category: PFM
  code: DDV
  cost: M
  csv_string:
    - DDV0
  desc: >-
    Execution of this statement will be nullified by another statement following
    it, or the result of this statement is never used.
  details: >
    #### Abstract

    Execution of this statement will be nullified by another statement following
    it, or the result of this statement is never used.


    #### Explanation

    Such error usually indicates either a typo or that some type of statement
    has been removed through time.
  examples:
    bad:
      c:
        - |-
          void assign(int input)
          {
              int a = 0; // dead code
              a = input; // result of \"a = 0\" will be nullified by this statement
              printf("a value: %d", a);
          }
      general:
        - |-
          void assign(int input)
          {
           int a = 0; // dead code
           a = input; // result of \"a = 0\" will be nullified by this statement
           printf(\"a value: %d\", a);
          }
    good:
      c:
        - |-
          void assign(int input)
          {
              int a = input; // a is only used once and does not get nullified
              printf("a value: %d", a);
          }
  language: c,c++,java
  likelihood: U
  master_id: 15
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, variable ${si.var} in function
    ${si.func}, a dead assignment has been detected.
  name: Dead variable
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: L
  standards: {}
- alias: {}
  category: VUL
  code: FAM
  cost: H
  csv_string:
    - FAM2
    - FAM1
    - FAM0
  desc: >-
    The program is calling a function with a number of parameter(s) that are
    used differently from the prototype declaration.
  details: >
    #### Abstract

    The program is calling a function with number of parameter(s) that are used
    different from that of the prototype declaration.


    #### Explanation

    In a call site, the number of actual parameters passed is different from
    that of the function declaration. If the actuals passed is less than that of
    the declaration, the missing actual will ended up being \"wild\" and could
    cause unpreditable behavior.
  examples:
    bad:
      c:
        - |-
          int foo(int a, int guard)
          {
              a++;
              guard++;
              return 0;
          }

          int func(void)
          {
              int t = 1;
              /* 
              missing one parameter, and \"guard\" will have 
              random value during execution at this point;
              compilation error would be raised here
              */
              foo(t);
              return 1;
          }
      general:
        - |-
          int foo(int a, int guard)
          {
           int x = 0;
           int result = 0;
           if (guard != 0)
           result = a * x;
           foo(result); // missing one parameter, and \"guard\" will have random value during execution at this point
           return 0;
          }
    good:
      c:
        - |-
          int foo(int a, int guard)
          {
              int x = 0;
              int result = 0;
              if (guard != 0)
              {
                  result = a * x;
              }
              foo(result, guard); // no parameters missing
              return 0;
          }
  language: c,c++,java
  likelihood: P
  master_id: 16
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, the arguments in function
    ${si.func} do not match the function declaration in file ${si.filename},
    line ${si.line}.
  name: Formal and actual parameter mismatch
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    owasp:
      - A3
      - A6
- alias:
    cert:
      - EXP34-C
  category: ROBUSTNESS
  code: NPD
  cost: M
  csv_string:
    - NPD0
  desc: >-
    The program is accessing memory through a pointer with NULL value. This
    could cause a segmentation fault or unpredictable program behavior.
  details: >
    #### Abstract

    The program is accessing memory through a pointer with a NULL value. This
    will cause a segmentation fault or unpredictable program behavior. This
    vulnerability is equivalent to EXP34-C


    #### Explanation

    On a system with memory protection, such as Linux, dereferencing a null
    pointer will cause a segmentation fault. For embedded systems, it will cause
    unpredicted program behavior. In Java, a null pointer dereference will
    trigger a null pointer exception.
  examples:
    bad:
      c:
        - |-
          extern int bar(int);

          int assign(int* a)
          {
           int i = bar(*a) // dereference a
           return i;
          }

          int foo(void)
          {
           int *p = 0; // p as a pointer has been initialized to 0 (null)
           assign(p);
          }
      java:
        - |-
          class User {
           public String getName() {
           return null;
           }
          }

          class Bar {
           private User findUser(String uid) {
           if (user.containsKey(uid)) {
           return user.get(uid);
           }
           else
           return null;
           }
           public void Npd(String uid) {
           // program continues
           // ...
           User user = findUser(uid); // Throws NPE if \"user\" has not been properly initialized
           String getName() {
           return null;
           }
           }
          }
    good:
      c:
        - |-
          extern int bar(int);

          int assign(int* a)
          {
           int i;
           if (a != 0)
           i = bar(*a); // dereference a
           else {
           // handle error and exit gracefully (such exit program)
           exit(1);
           }
           return i;
          }

          int foo(void)
          {
           int *p = 0; // p as a pointer has been initialized to 0 (null)
           assign(p);
          }
      java:
        - |-
          class User {
           public String getName() {
           return null;
           }
          }

          class Bar {
           private User findUser(String uid) {
           if (user.containsKey(uid)) {
           return user.get(uid);
           }
           else
           return null;
           }
           public void Npd(String uid) {
           // program continues
           // ...
           User user = findUser(uid); 
           if (user == null) {
           throw new RuntimeException(\"Null String\");
           }
           String getName() {
           return null;
           }
           }
          }
  language: c,c++,java
  likelihood: L
  master_id: 17
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, an NPD defect has been detected in
    function ${so.func} for variable ${so.var}. Such variable has a value of
    zero.
  name: Null pointer dereference
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    cwe:
      - '476'
- alias:
    cert:
      - MSC12-C
  category: BAD_PRACTICE
  code: RCD
  cost: M
  csv_string:
    - RCD0
  desc: Redundant statements that are control dependent.
  details: >
    #### Abstract

    Redundant statements that are control dependent.


    #### Explanation

    When there are two conditional statements that are dependent in execution
    flow, then one conditional can logically subsume the other conditional
    statement. In that case, the other conditional is redundant and unnecessary.
    This could be due to an editing error and is a code quality issue.
  examples:
    bad:
      c:
        - |-
          int foo();
          int bar();

          int f1(int x)
          {
              if (x > 15 && x > 16) // x>16 will subsume x>15
                  foo();
          }

          int f2(int x)
          {
              if (x > 16 && x > 15) // x>16 implies x>15, hence x>15 is redundant
                  foo();
          }

          int f3(int x)
          {
              if (x > 16)
              {
                  foo();
                  if (x > 15) // x>16 implies x>15, hence this check is unnecessary
                      bar();
              }
          }

          int f4(int x)
          {
              if (x > 15)
              {
                  foo();
                  if (x > 16) // x>15 does not imply x>16, this check is not redundant
                      bar();
              }
          }
      general:
        - |-
          int foo();
          int bar();

          int f1(int x) {
           if (x>15 && x>16) // x>16 will subsume x>15
           foo();
          }

          int f2(int x) {
           if (x>16 && x>15) // x>16 implies x>15, hence x>15 is redundant
           foo();
          }

          int f3(int x) {
           if (x>16) {
           foo();
           if (x>15) // x>16 implies x>15, hence this check is unnecessary
           bar();
           }
          }

          int f4(int x) {
           if (x>15) {
           foo();
           if (x>16) // x>15 does not imply x>16, this check is not redundant
           bar();
           }
          }
    good:
      c:
        - |-
          int foo();
          int bar();

          int f1(int x)
          {
              if (x > 16) // removed x>15 since unnecessary
                  foo();
          }

          int f2(int x)
          {
              if (x > 16) // removed x>15 since unnecessary
                  foo();
          }

          int f3(int x)
          {
              if (x > 16)
              {
                  foo();
                  bar(); // bar will always run anyways so no need an if statement
              }
          }

          int f4(int x)
          {
              if (x > 15)
              {
                  foo();
                  if (x > 16) 
                  {
                      bar();
                  }
              }
          }
  language: c,c++,java
  likelihood: U
  master_id: 18
  msg_templ: >-
    In file ${si.filename}, function ${si.func}, the statement at line
    ${si.line} is redundant.
  name: Redundant control dependency
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: L
  standards: {}
- alias:
    cert:
      - MSC12-C
  category: BAD_PRACTICE
  code: SCB
  cost: M
  csv_string:
    - SCB0
  desc: Same code blocks inside a conditional statement.
  details: >
    #### Abstract

    Same code block inside conditional statements.


    #### Explanation

    Two code blocks are the same inside a conditional statement. This is likely
    due to an editing error. It is a code quality issue.
  examples:
    bad:
      c:
        - |
          int foo();
          int a, b;

          int f1(int x)
          {
              if (a) 
              {
                  foo();
              } 
              else 
              {
                  foo();
              }
          }

          int f2(int x)
          {
              return x ? foo() : foo();  // equivalent to above
          }

          int f3(int x)
          {
              if (x);  // both then and else blocks are empty
          }
      general:
        - |
          int foo();
          int a, b;

          int f1(int x) {
           if (x) // in this condition (if-then-else, block 1 and block 2 are the same. Effectively making the conditional statement useless)
           foo(); // block 1
           else
           foo(); // block 2
          }

          int f2(int x) {
           return x ? foo() : foo(); // similar code written differently
          }

          int f3(int x) {
            if (x);  // both then and else blocks are empty
          }
    good:
      c:
        - |
          int foo();
          int a, b;

          int f1(int x)
          {
              foo(); // no dead code
          }

          int f2(int x)
          {
              return foo();
          }
  language: c,c++,java
  likelihood: U
  master_id: 19
  msg_templ: >-
    In file ${si.filename}, function ${si.func}, the blocks of code are the same
    on either side of the conditional statement at line ${si.line}.
  name: Same code block
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: L
  standards:
    cwe:
      - '223'
- alias:
    cert:
      - MSC07-C
  category: BAD_PRACTICE
  code: SSE
  cost: M
  csv_string:
    - SSE0
  desc: The program has the same sub-expressions.
  details: >
    #### Abstract

    The program has the same sub-expressions. 


    #### Explanation

    The same expressions are found in a statement, where the value of variables
    in the expression has not changed in value. It could be due to a typo in the
    program. This is a code quality issue.
  examples:
    bad:
      c:
        - |-
          int foo();
          int a, b;

          int f3(int x, int *p)
          {
              if (*p && x) // both expressions are not the same 
              {
                  foo();
              }  
          }

          int f4(int x, int y)
          {
              if ((x + y++) && (y + x)) 
              {
                  foo();
              }
                  
          }
      general:
        - |-
          int foo();
          int a, b;


          int f3(int x, int *p) {
           if (*p && *p) // same sub-expression
           foo();
          }

          int f4(int x, int y) {
           if ((x+y++) && (y+x)) // not same sub-expression due to y++
           foo();
          }
    good:
      c:
        - |-
          int foo();
          int a, b;

          int f3(int x, int *p)
          {
              if (*p && *p) // same sub-expression
                  foo();
          }

          int f4(int x, int y)
          {
              if ((x + y++) && (y + x)) // not same sub-expression due to y++
                  foo();
          }
  language: c,c++,java
  likelihood: U
  master_id: 20
  msg_templ: >-
    In file ${si.filename}, function ${si.func}, line ${si.line} has
    sub-expressions that are conditionally the same.
  name: Same sub-expression
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: L
  standards: {}
- alias: {}
  category: BAD_PRACTICE
  code: UIC
  cost: L
  csv_string:
    - UIC0
  desc: A field of a class is not initialized in its constructor.
  details: >
    #### Abstract

    A field of a class is not initialized in its constructor.


    #### Explanation

    Constructor of a class typically includes initialization of fields inside
    the class. When a field is not initialized, it is likely due to an editing
    error and is a code quality issue.
  examples:
    bad:
      cpp:
        - |
          #include <stdio.h>

          class Construct_Init
          {
          private:
              int a;
              int b;

          public:
              // all variables in all constructors are
              // initialized
              Construct_Init();
              Construct_Init(int i);
              Construct_Init(int i, int j);

              void CI_Run() { printf("%d:%d", a, b); }
          };

          Construct_Init::Construct_Init()
          {
          }

          Construct_Init::Construct_Init(int i)
          {
              a = i;
          }

          Construct_Init::Construct_Init(int i, int j)
          {
              a = i;
              b = j;
          }

          int main(int argc, char **argv)
          {
              Construct_Init ci;
              ci.CI_Run();
              Construct_Init ci1(1);
              ci1.CI_Run();
              Construct_Init ci2(1, 2);
              ci2.CI_Run();
          }
      general:
        - |
          #include <stdio.h>

          class Construct_Init{
          private:
           int a;
           int b;
          public:
           Construct_Init();
           Construct_Init(int i): a(i) {}; // did not initialize b
           Construct_Init(int i, int j) { a = i; b = j; }

           void CI_Run() { printf(\"%d:%d\
          \", a, b); }
          };

          int main(int argc, char**argv)
          {
           Construct_Init ci;
           ci.CI_Run();
           Construct_Init ci1(1);
           ci1.CI_Run();
           Construct_Init ci2(1,2);
           ci2.CI_Run();
          }
    good:
      cpp:
        - |-
          #include <stdio.h>

          class Construct_Init
          {
          private:
              int a;
              int b;

          public:
              // all variables in all constructors are
              // initialized
              Construct_Init()
              {
                  a = 0;
                  b = 0;
              };
              Construct_Init(int i)
              {
                  a = i;
                  b = 0;
              }
              Construct_Init(int i, int j)
              {
                  a = i;
                  b = j;
              }

              void CI_Run() { printf("%d:%d", a, b); }
          };

          int main(int argc, char **argv)
          {
              Construct_Init ci;
              ci.CI_Run();
              Construct_Init ci1(1);
              ci1.CI_Run();
              Construct_Init ci2(1, 2);
              ci2.CI_Run();
          }
  language: c,c++,java
  likelihood: L
  master_id: 21
  msg_templ: >-
    In file ${si.filename}, constructor ${si.func} at line ${si.line} has a
    field ${si.var} that is not initialized.
  name: Uninitialized field in constructor
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: L
  standards:
    cwe:
      - '909'
- alias:
    cert:
      - EXP33-C
      - EXP53-CPP
  category: CORRECTNESS
  code: UIV
  cost: M
  csv_string:
    - UIV1
    - UIV0
  desc: The program is using a variable before it has been initialized.
  details: >
    #### Abstract

    The program is using a variable before it has been initialized.


    #### Explanation

    Stack variables in C and C++ are not initialized by default. Non-static
    global variables are not guaranteed to be zeroed. Their initial values are
    determined by the values that happen to be in their location in memory at
    the time the function is invoked. Doing so will cause an unexpected program
    behavior.
  examples:
    bad:
      c:
        - |-
          int assign(int *a)
          {
              return *a; // dereference a
          }

          int main()
          {
              int a, b;
              b = assign(&a); // call assign with a uninitialized variable
              printf("value of b = %d", b);
              return 0;
          }
      general:
        - |-
          int assign(int* a)
          {
           return *a; // dereference a
          }

          int main() {
           int a, b;
           b = assign(&a); // call assign with a uninitialized
           printf(\"value of b = %d\
          \", b);
           return 0;
          }
    good:
      c:
        - |-
          int assign(int *a)
          {
              return *a; // dereference a
          }

          int main()
          {
              int a = 100; // a is assigned as 100
              int b;
              b = assign(&a); 
              printf("value of b = %d", b);
              return 0;
          }
  language: c,c++,java
  likelihood: P
  master_id: 22
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, variable ${so.var} in function
    ${so.func} has been used but never assigned a value. 
  name: Uninitialized variable
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards: {}
- alias:
    cert:
      - ERR00-J
  category: BAD_PRACTICE
  code: ECB
  cost: M
  csv_string:
    - ECB1
    - ECB0
  desc: The program has an exception construct with an empty catch block.
  details: >
    #### Abstract

    The program has an exception construct with an empty catch block.


    #### Explanation

    Empty catch block effectively suppressed an exception from being correctly
    handled by another try block. The \"uncaught\" exception may cause
    unintended program behavior.
  examples:
    bad:
      cpp:
        - |-
          #include <iostream>

          int integer_divide(int a, int b) 
          {
              if (b == 0) 
              {
                  throw "division by zero error";
              }
              else return (a/b);
          }

          int foo(int x, int y) {
              try {
                  int z = integer_divide(x, y);
                  std::cout << z << std::endl;
              }
              catch (const char* msg) {
              // empty catch body, zero as divisor notice suppressed
              }
              return 0;
          }
      general:
        - |-
          #include <iostream>

          int integer_divide(int a, int b) {
           if (b == 0) {
           throw \"division by zero error\";
           }
           else return (a/b);
          }

          int foo(int x, int y) {
           try {
           int z = integer_divide(x, y);
           std::cout << z << std::endl;
           }
           catch (const char* msg) {
           // empty catch body, zero as divisor notice suppressed
           }
           return 0;
          }
    good:
      cpp:
        - |-
          #include <iostream>

          int integer_divide(int a, int b) {
              if (b == 0) {
                  throw "division by zero error";
              }
              else return (a/b);
          }

          int foo(int x, int y) {
              try {
                  int z = integer_divide(x, y);
                  std::cout << z << std::endl;
              }
              catch (const char* msg) {
              // non-empty catch body and return error
                  std::cout << "division exception" << std::endl;
                  return 1;
              }
              return 0;
          }
      general:
        - |-
          #include <iostream>

          int integer_divide(int a, int b) {
           if (b == 0) {
           throw \"division by zero error\";
           }
           else return (a/b);
          }

          int foo(int x, int y) {
           try {
           int z = integer_divide(x, y);
           std::cout << z << std::endl;
           }
           catch (const char* msg) {
           // non-empty catch body and return error
           std::cout << \"division exception\" << std::endl;
           return 1;
           }
           return 0;
          }
  language: c++,java
  likelihood: P
  master_id: 23
  msg_templ: >-
    In file ${si.filename}, function ${si.func}, the catch block in line
    ${si.line} is empty.
  name: Empty catch block
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: L
  standards:
    cwe:
      - '223'
    owasp:
      - A3
      - A5
- alias: {}
  category: VUL
  code: FIO37-C
  cost: M
  csv_string:
    - F37C1
    - F37C0
  desc: >-
    The program is calling fgets() or fgetws(), assuming the string returned is
    a non-empty string.
  details: >
    #### Abstract

    The program is calling fgets() or fgetws() and assuming the string returned
    is a non-empty string.


    #### Explanation

    The two functions may return a null string (e.g. the file may be a binary
    file).
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>

          #define BUF_SZ 1024

          void read_string(void)
          {
           char buf[BUF_SZ];
           FILE *fp = fopen("/myfile", "+r");
           // check fp valid
           // ...

           if (fgets(buf, BUF_SZ, fp) != 0) {
           // if the first character of buf is '\\0', a random meaningless large number will be printed
           printf("Size of string read = %d", strlen(buf)-1);
           }

          }
    good:
      c:
        - |-
          #include <stdio.h>

          #define BUF_SZ 1024

          void read_string(void)
          {
           char buf[BUF_SZ];
           FILE *fp = fopen("/myfile", "+r");
           // check fp valid
           // ...

           if (fgets(buf, BUF_SZ, fp) != 0) {
           // replace newline character if it is there
           char *pchar = strchr(buf, '');
           if (pchar) *pchar = '\\0';

           printf("Size of string read = %d", strlen(buf)-1);
           }

          }
  language: c,c++
  likelihood: P
  master_id: 24
  msg_templ: >-
    In file ${si.filename}, line ${si.line},  ${si.func} may return a null
    string.
  name: fgets() and fgetws() may return an empty string
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '119'
      - '241'
- alias: {}
  category: VUL
  code: MSC32-C
  cost: L
  csv_string:
    - M32C1
    - M32C0
  desc: >-
    The program is using a pseudo random number generator with seeding (initial
    state) that will produce a deterministic sequence of numbers.
  details: >
    #### Abstract

    The program is using a pseudo random number generator with seeding (initial
    state) that will produce a deterministic sequence of numbers.


    #### Explanation

    A properly seeded PRNG will generate a different number sequence each time
    it runs (e.g. call srandom() before invoking the random function). This
    prevents potential attackers to predict the number sequence generated.
    Alternatively, use random number generators that cannot be seeded.
  examples:
    bad:
      c:
        - |+
          #include <stdio.h>
          #include <stdlib.h>

          // this function calls random() without proper seeding it
          // output of this function will be the same each time it is called
          void print_rand(void)
          {
              for (int i = 0; i < 20; i++)
              {
                  printf("%lx \n", random());
              }
          }



    good:
      c:
        - |
          #include <stdio.h>
          #include <stdlib.h>

          // function calls random() with proper seeding
          void print_rand(void)
          {
              srandom(time(NULL));
              for (int i = 0; i < 20; i++)
              {
                  printf("%lx \n", random());
              }
          }
  language: c,c++
  likelihood: L
  master_id: 25
  msg_templ: >-
    In file ${si.filename}, ${si.func}, line ${si.line} is calling variable
    ${si.var}. This generator will produce a deterministic sequence.
  name: Pseudo-random number generators should be properly seeded before use
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '522'
      - '327'
    owasp:
      - A2
      - A3
- alias: {}
  category: VUL
  code: ENV32-C
  cost: M
  csv_string:
    - N32C0
  desc: The program is using an exit handler that does not return normally.
  details: >
    #### Abstract

    The program is using some exit handler that does not return normally.


    #### Explanation

    The following three functions _Exit(), exit(), quick_exit() are C standard
    exit functions. exit() and quick_exit() will call exit handlers atexit() and
    at_quick_exit() respectively for cleanup purposes, while _Exit() will not.
    User can define their own handlers and register with the system provided
    handlers. These exit handlers must return normally so that all exit handlers
    (thus all cleanup tasks) are properly performed. Furthermore, all exit
    handlers should not call exit().
  examples:
    bad:
      c:
        - |-
          #include <stdlib.h>
          #include <stdio.h>

          extern int file_opened;

          int my_exit1(void)
          {
           // some clean up code for opened file
           fprintf(stderr, "abnormal exit from my_exit1() with file closed\\");
           exit(0); // this exit handler does not return normally. exit() is called the second time when value of file_opened is 1.
          }

          int my_exit2(void)
          {
           if (file_opened == 1) {
           my_exit1();
           }
           fprintf(stderr, "abnormal exit with errno %d", errno());
           // other cleanup code
           // if file_opened is 1, the clean up code here will not be executed
           // ...
           return 1;

          }

          int main() {
           // ...
           if (atexit(my_exit2) != 0) {
           // handle error
           }
          }
           return 0;
          }
    good:
      c:
        - |-
          #include <stdlib.h>
          #include <stdio.h>

          static int file_opened;

          void my_exit1(void)
          {
           // some clean up code for opened file
           fprintf(stderr, "abnormal exit from my_exit1() with file closed\\");
           exit(0); // this exit handler does not return normally. exit() is called the second time when value of file_opened is 1.
          }

          void my_exit2(void)
          {
           if (file_opened == 1) {
           my_exit1();
           }
           fprintf(stderr, "abnormal exit with errno %d", errno());
           // other cleanup code
           // if file_opened is 1, the clean up code here will not be executed
           // ...
           return;

          }

          int main() {
           // ...
           file_opened = 1;
           if (atexit(my_exit2) != 0) {
           // handle error
           }
          }
           return 0;
          }
  language: c,c++
  likelihood: L
  master_id: 26
  msg_templ: >-
    In file ${si.filename}, function ${si.func} is registered at line ${si.line}
    as exit handler. The program will exit and not return normally.
  name: Exit handlers must return normally
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards: {}
- alias: {}
  category: VUL
  code: ENV33-C
  cost: M
  csv_string:
    - N33C3
    - N33C2
    - N33C1
    - N33C0
  desc: >-
    The program is calling the C standard system() function. When not properly
    protected, it could lead to various types of exploitation.
  details: >+
    #### Abstract

    The program is calling the C standard system() function. When not properly
    protected, it could lead to various exploitations.


    #### Explanation

    The program is calling the system() function where the parameter is a
    character string. Such a string must be properly protected (examples:
    sanitized string, normalized path). Failure to do so will cause arbitrary
    program execution, privilege elevation or other unpredictable behavior.

  examples:
    bad:
      c:
        - |-
          void func_call_sys(const char *in)
          {
           // system() is called with a string \"in\" passed from outside of this function
           // There is no evidence that \"in\" has been sanitized
           // for example, if \"in\" is the string \"rm *\"
           // executing the system() call could be devastating
           system(in);
          }
    good:
      c:
        - |-
          void func_call_sys(const char *in)
          {
           // system() is called with a string \"in\" passed from outside of this function
           // There is no evidence that \"in\" has been sanitized
           // Sanitize input to system()
           // use full path name for directory for example
           sanitise(in); // e.g. for file or directory name, do not include \"../\" substring
           system(in);
          }
  language: c,c++
  likelihood: P
  master_id: 27
  msg_templ: >-
    In file ${si.filename}, function ${si.func}, system() at line ${si.line}
    carries input parameters that have not been sanitized.
  name: Please pay attention to the direct call to system()
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '88'
      - '77'
      - '78'
      - '917'
- alias: {}
  category: VUL
  code: ERR33-C
  cost: M
  csv_string:
    - E33C0
  desc: >-
    The program is calling the standard library function but failed to check and
    handle the function error returns.
  details: >
    #### Abstract

    The program is calling the standard library function but failed to check and
    handle the function error returns.


    #### Explanation

    The program is calling a standard library function(s). These functions
    typically return a valid value, or some form of value that indicates an
    error. Failure to check if the call is successful leads to an unexpected or
    undefined behavior. Please refer to the language or system specification for
    a full description of the standard interface. Please note that there are
    system functions for which return values do not need to be checked. The list
    of these functions can also be found in the system or language
    specification. Notably the most popular ones are printf, vprintf, memcpy,
    memmove, strcpy, strcat, memset (and their wide char versions).
  examples:
    bad:
      c:
        - |-
          #include <stdlib.h>
          #include <string.h>

          typedef struct {
           int len;
           int *data;
          } vec_rec, *vec_rec_ptr;

          enum { VEC_SZ = 32 };

          vec_rec vr[VEC_SZ] = { 0 }; // initialize table content
          vec_rec_ptr func_call_stdlib(int len, vec_rec_ptr in_vec)
          {
           vec_rec_ptr vrp = (vec_rec_ptr)(malloc(sizeof(vec_rec) * len));
           // vrp may be NULL if malloc failed
           // this code did not check that vrp may be invalid

           // this memcpy may enable an attacker to access memory causing remote code execution
           memcpy(vrp, in_vec, len);

          }
    good:
      c:
        - |
          #include <stdlib.h>
          #include <string.h>

          typedef struct {
           int len;
           int *data;
          } vec_rec, *vec_rec_ptr;

          enum { VEC_SZ = 32 };

          vec_rec vr[VEC_SZ] = { 0 }; // initialize table content
          vec_rec_ptr func_call_stdlib(int len, vec_rec_ptr in_vec)
          {
           vec_rec_ptr vrp = (vec_rec_ptr)(malloc(sizeof(vec_rec) * len));

           // Checks if vrp is NULL, such as when malloc failed
           if (vrp == NULL) 
           {
            printf("Malloc has failed, the program will terminate.");
            return NULL;
           }

           // this memcpy may enable an attacker to access memory causing remote code execution
           memcpy(vrp, in_vec, len);

          }
  language: c,c++
  likelihood: L
  master_id: 28
  msg_templ: >-
    In file ${si.filename}, function ${si.func} at line ${si.line}, the system
    library call ${si.var} is used without checking for error return.
  name: Please check and handle standard library return errors
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- alias: {}
  category: VUL
  code: FIO34-C
  cost: M
  csv_string:
    - F34C0
  desc: >-
    The program is using a return value of file read (such as getchar(), getc(),
    getwc()...) to check for EOF/WEOF as an end of file read operation.
  details: >
    #### Abstract

    The program is using a return value of file read (such as getchar(), getc(),
    getwc(),..) to check for EOF/WEOF as an end of file read operation.


    #### Explanation

    The function that read characters from a file returned an int type. Directly
    comparing the character read with EOF/WEOF may cause an unexpected result
    because EOF and WEOF are implementation defined.
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>

          void read_char(void)
          {
           FILE *fp = fopen("/tmp/myfile", "+r");
           // check fp valid
           // ...

           int c = getc(fp);
           while (c != EOF) // this check does not guarantee read has reached end of file
           {
           putchar(c); // echo what is read in
           c = getc(fp);
           }
          }
    good:
      c:
        - "#include <stdio.h>\n\nvoid read_char(void)\n{\n\tFILE *fp = fopen(\"/tmp/myfile\", \"+r\");\n\t// check fp valid\n\t// ...\n\t\n\tint c = getc(fp);\n\t\n\t// make sure it is really an EOF character and that the EOF is due to end-of-file\n\t\n\twhile (c != EOF || (feof(stdin) && !ferror(stdin)) \n\t{\n\tputchar(c); // echo what is read in\n\tc = getc(fp);\n\t}\n}"
  language: c,c++
  likelihood: P
  master_id: 29
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, function ${si.func} is using a
    return value of file read to check for EOF.
  name: EOF or WEOF as "char" size objects are different from chars read from a file
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '197'
    owasp:
      - A1
- alias: {}
  category: VUL
  code: FIO42-C
  cost: M
  csv_string:
    - F42C2
    - F42C1
    - F42C0
  desc: >-
    The program has opened a file but then failed to close it when done or
    before the program terminated.
  details: >
    #### Abstract

    The program has opened a file but then failed to close the file when
    finished or before the program has terminated.


    #### Explanation

    It is important to close a file when it is no longer needed. Failure to do
    so may expose resource (such as non-flushed data) associated with the file
    to attackers.
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>

          int open_file(const char *fname)
          {
           FILE *fp = fopen(fname, "+r");
           if (fp == NULL) return -1;

           // program continues
           return 0; // file is not properly closed on return

          }
    good:
      c:
        - |-
          #include <stdio.h>

          int open_file(const char *fname)
          {
           FILE *fp = fopen(fname, "+r");
           if (fp == NULL) return -1;

           // program continues

           if (fclose(fp) == EOF) {
           // handle error
           ...
           }
           return 0; // file is properly closed on return

          }
  language: c,c++
  likelihood: U
  master_id: 30
  msg_templ: >-
    In file ${si.filename}, function ${si.func}, line ${si.line}, file ${si.var}
    was opened and not closed.
  name: Close files when done with them
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '459'
      - '772'
      - '404'
    owasp:
      - A3
- alias: {}
  category: VUL
  code: FIO45-C
  cost: H
  csv_string:
    - F45C0
  desc: >-
    Race conditions while accessing files (time of check, time of use) may
    happen and should be avoided.
  details: >
    #### Abstract

    Race conditions while accessing files (time of check, time of use) may
    happen and should be avoided.


    #### Explanation

    In a shared file system, two or more processes may access the same file,
    causing a race condition. Attackers can change the file between two accesses
    or replace the file (symbolic or hard linked) with a different file.
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>
          #include <unistd.h>
          #include <sys/stat.h>
          #include <fcntl.h>

          // This example is modified from example in 
          // CERT-C FIO45 site
          int file_s1(char *p, char *q)
          {
              struct stat statBefore, statAfter;

              lstat("/tmp/x", &statBefore);
              // previous contents of file gets destroyed 
              // with "w" mode
              FILE *f = fopen("/tmp/x", "w");
              lstat("/tmp/x", &statAfter);
              if (statAfter.st_ino == statBefore.st_ino)
              {
                  if (f != NULL)
                      fwrite("HELLO!", 1, 5, f);
              }

              fclose(f);
              return 0;
          }
    good:
      c:
        - |-
          #include <stdio.h>
          #include <unistd.h>
          #include <sys/stat.h>
          #include <fcntl.h>

          int file_s1(char *p, char *q)
          {
              struct stat statBefore, statAfter;

              lstat("/tmp/x", &statBefore);
              
              // "x" mode will cause fopen() to fail
              // if the file exists.  
              // NOTE: Only works for C11 and above or
              // systems that support this feature
              FILE *f = fopen("/tmp/x", "wx");
              if (statAfter.st_ino == statBefore.st_ino)
              {
                  if (f != NULL)
                      fwrite("HELLO!", 1, 5, f);
              }

              fclose(f);
              return 0;
          }
  language: c,c++
  likelihood: P
  master_id: 31
  msg_templ: >-
    In file ${si.filename} function ${si.func}, line ${si.line}, the file
    ${si.var} has TOCTOU problem.
  name: File access may have race conditions and should be avoided
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    owasp:
      - A3
- alias: {}
  category: VUL
  code: MEM35-C
  cost: H
  csv_string:
    - m35C1
    - m35C0
  desc: >-
    The program has used the malloc family of functions to allocate memory that
    is smaller than the memory required by the program.
  details: >
    #### Abstract

    The program has used malloc family of functions to allocate memory that is
    smaller than the memory required by the program.


    #### Explanation

    The parameter corresponding to size arguments to the malloc functions should
    have sufficient range to represent the size of objects to be stored. Failure
    to do so will cause a buffer overflow leading to an unexpected program
    behavior.
  examples:
    bad:
      c:
        - |-
          #include <stdlib.h>

          typedef struct
          {
              size_t len;
              int *data;
          } vect_record, *vect_ptr;

          vect_record *vector_new(size_t len)
          {
              vect_record *vect;
              // size of pointer used to determine size of pointed-to object
              vect_ptr result = (vect_ptr)malloc(sizeof(vect));
              if (result == NULL)
              {
                  // handle error and return
                  return NULL;
              }

              // initialize vector
              result[0].len = 1;
              result[1].len = 2;
              // ...
              return result;
          }
    good:
      c:
        - |-
          #include <stdlib.h>

          typedef struct
          {
              size_t len;
              int *data;
          } vect_record, *vect_ptr;

          vect_record *vector_new(size_t len)
          {
              vect_record *vect;
              // dereferenced pointer type means correct amount 
              // of memory is allocated for the struct tm object
              vect_ptr result = (vect_ptr)malloc(sizeof(*vect));
              if (result == NULL)
              {
                  // handle error and return
                  return NULL;
              }

              // initialize vector
              result[0].len = 1;
              result[1].len = 2;
              // ...
              return result;
          }
  language: c,c++
  likelihood: P
  master_id: 32
  msg_templ: >-
    In file ${si.filename}, function ${si.func}, line ${si.line}, out of range
    memory access occurs. 
  name: Make sure sufficient memory has been allocated for an object
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    owasp:
      - A3
      - A1
- category: VUL
  code: MEM36-C
  cost: HIGH
  desc: >-
    The program has used realloc() that causes a pointer with alignment which is
    less restrictive than before the memory reallocation.
  details: >
    #### Abstract

    The program has used realloc() that causes a pointer with alignment which is
    then less restrictive than before the memory reallocation.


    #### Explanation

    realloc() will allocate new memory and set the previously allocated memory
    pointer to the newly allocated area. If the previously allocated memory has
    more restricted alignment (e.g. 16B), the memory that is newly pointed to it
    will not satisfy this restriction resulting in an unexpected program
    behavior.
  examples:
    bad:
      c:
        - |-
          #include <stdlib.h>

          int *vector_calc(size_t vec_sz, int elements)
          {
           size_t align_vec = 1 << vec_sz;
           int *ptr_align;

           if ((ptr_align = (int *)aligned_alloc(align_vec, sizeof(int)*elements)) == NULL) {
           // handle error and return;
           // ...
           }

           // program continues
           // ...
           if ((ptr1 = (int *) realloc(ptr_align, sizeof(int)*elements * 2)) == NULL) {
           // handle error and return
           //...
           }

           // program continues
           // but ptr1 is not guaranteed to properly aligned with the vector objects previous allocated

           return ptr1;

          }
    good: {}
  language: c,c++
  likelihood: PROBABLE
  master_id: 33
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, function ${si.func} has used
    realloc().
  name: Calling realloc() may cause misalignment for previously aligned objects
  severity: LOW
- alias: {}
  category: VUL
  code: MSC33-C
  cost: L
  csv_string:
    - M33C0
  desc: >-
    The program is calling an asctime() function. However, the input parameter
    for that function is from an untrusted source.
  details: >
    #### Abstract

    The program is calling asctime() function, however the input parameter for
    that function is from an untrusted source.


    #### Explanation

    The function asctime() does not validate the value or range of its input
    parameter. The subsequent use of the result from this function may cause a
    buffer overflow and other security violations when trying to print to a
    string.
  examples:
    bad:
      c:
        - |-
          #include <time.h>
          #include <stdio.h>

          void read_time(struct tm *time_info)
          {
              // does not check for invalid or potentially
              // unsanitised data
              char *time = asctime(time_info);
              printf("time is %s", time);
          }
    good:
      c:
        - |+
          #define __STDC_WANT_LIB_EXT1__ 1
          #include <time.h>
          #include <stdio.h>

          enum
          {
              max = 50
          };

          void read_time(struct tm *time_info)
          {   
              // checks for invalid data below and handles 
              // error if exists
              char buffer[max];
              if (asctime_s(buffer, max, &time_info))
              {
                  /* Handle error */
              }

              char *time = asctime(time_info);
              printf("time is %s", time);
          }
              


  language: c,c++
  likelihood: L
  master_id: 34
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, function asctime is called with
    ${si.var} as parameter, which may not have been sanitized.
  name: Use of asctime() function must pass the parameter needed with valid ranges
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- alias: {}
  category: VUL
  code: MSC37-C
  cost: L
  csv_string:
    - M37C0
  desc: >-
    The program has an execution path that might reach the exit point of a
    non-void function without going through a "return" statement.
  details: >
    #### Abstract

    The program has an execution path that might reach the exit point of a
    non-void function without going through a \"return\" statement.


    #### Explanation

    When the program exits that function on an execution path without a return
    statement, then the return value will be non-deterministic causing an
    unexpected program behavior. If the function happens to be \"main\", or if
    the function is marked with \"no-return\" attribute, then there is no
    problem.
  examples:
    bad:
      c:
        - |-
          #include <string.h>

          #define BUF_SZ 1024

          int has_char(const char *s)
          {
              if (s != NULL)
              {
                  int l = strlen(s);
                  int i;
                  for (i = 0; i < l; i++)
                  {
                      if (s[i] == 'c')
                          return i;
                  }
              }
              // missing return here, return value will be undefined
          }
    good:
      c:
        - |
          #include <string.h>
          #define BUF_SZ 1024
          int has_char(const char *s)
          {
              if (s != NULL)
              {
                  int l = strlen(s);
                  int i;
                  for (i = 0; i < l; i++)
                  {
                      if (s[i] == 'c')
                          return i;
                  }
              }
              // return statement ensures control never reaches end of
              // the function, returns -1 if no letter 'c'
              return -1;
          }
  language: c,c++
  likelihood: U
  master_id: 35
  msg_templ: >-
    In file ${si.filename} at line ${si.line}, function ${si.func} is declared
    to return non-void but has reached end of function without a return
    statement.
  name: >-
    Non-void functions should always exit this function through a return
    statement
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- alias: {}
  category: VUL
  code: POS30-C
  cost: M
  csv_string:
    - P30C1
    - P30C0
  desc: >-
    The program has called function readlink() and the number of characters
    written on the buffer (second argument) is not enough to hold a valid
    string.
  details: >
    #### Abstract

    The program has called function readlink() and the number of characters
    written on the buffer (second argument) is not enough to hold a valid
    string.


    #### Explanation

    The number of characters written by readlink() may overflow the buffer
    specified in the second parameter. Also one needs to ensure that the end of
    the string is null terminated.
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>

          #define BUF_SZ 1024

          int func(char *env_str)
          {
              char buf[BUF_SZ];

              // if len is >= sizeof(buf), up till the last byte of buf is non-null
              ssize_t len = readlink("/usr/somedir/symlinkfile", buf, sizeof(buf));

              // len is outside of buf size range (i may be -1 or i >= sizeof(buf))
              buf[len] = '\0'; 
              return;
          }
    good:
      c:
        - |-
          #include <stdio.h>

          #define BUF_SZ 1024

          int func(char *env_str)
          {
              char buf[BUF_SZ];

              // if len is >= sizeof(buf), up till the last byte of buf is non-null
              ssize_t len = readlink("/usr/somedir/symlinkfile", buf, sizeof(buf)); 

              // case handled when len is an invalid value
              if (len >= sizeof(buf) || len == -1) {
                  // Handle Exception 
                  return;
              }

              buf[len] = '\0'; // len is always within buf size range
              return;
          }
  language: c,c++
  likelihood: P
  master_id: 36
  msg_templ: >-
    In file ${si.filename} at line ${si.line}, the function readlink() is called
    and assigned to ${si.var}. The string read is not null terminated.
  name: >-
    The readlink() function will only fill the buffer in the second argument not
    including the null terminator
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '170'
    owasp:
      - A1
      - A7
- alias: {}
  category: VUL
  code: POS34-C
  cost: M
  csv_string:
    - P34C2
    - P34C1
    - P34C0
  desc: >-
    The program has called putenv() with an argument that points to a local
    object.
  details: >
    #### Abstract

    The program has called putenv() with an argument that points to a local
    object.


    #### Explanation

    The system that calls putenv() will save the argument (which is a pointer to
    the intended string) into the environment array. When the function returns
    to the caller, the local object with the environment string may be
    overwritten. This will cause an unpredictable program behavior.
  examples:
    bad:
      c:
        - |-
          #include <string.h>

          #define BUF_SZ 1024

          // TEST environment variable may take on unintended value

          int func(char *env_str)
          {
              char buf[BUF_SZ];
              // ...
              if (strlen(env_str) < BUF_SZ)
              {
                  strcpy(buf, env_str);
                  return putenv(buf);
              }
              else
              {
                  // handle error
                  // ...
              }
              return 0;
          }
    good:
      c:
        - |-
          #include <string.h>

          #define BUF_SZ 1024

          int func(char *env_str)
          {
              // use a static array so that call to putenv() is 
              // only necessary the first time func() is called
              static char buf[BUF_SZ];
              // ...
              if (strlen(env_str) < BUF_SZ)
              {
                  strcpy(buf, env_str);
                  return putenv(buf);
              }
              else
              {
                  // handle error
                  // ...
              }
              return 0;
          }
  language: c,c++
  likelihood: U
  master_id: 37
  msg_templ: >-
    In file ${si.filename} at line ${si.line}, the system function putenv() is
    called with variable ${si.var} as a parameter.
  name: The pointer argument in the putenv() call should not point to local objects
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '252'
      - '253'
      - '391'
    owasp:
      - A2
      - A3
      - A5
- alias: {}
  category: VUL
  code: POS35-C
  cost: M
  csv_string:
    - P35C0
  desc: >-
    The program has called function lstat() to check the named file for symbolic
    linkage. Results of this check may not be valid when the file is later
    accessed.
  details: >
    #### Abstract

    The program has called function lstat() to check the named file for symbolic
    linkage. Result of this check may not be valid when the file is later
    accessed.


    #### Explanation

    Checking that a file is a symbolic link suffers from time of call, time of
    use (TOCTOU) problem. In other words, when the file is finally opened for
    access, that the file is of symbolic link status may not be valid anymore.
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>
          #include <stdlib.h>
          #include <sys/stat.h>

          #define BUF_SZ 1024

          struct stat link_info;
          int val;

          int func(char *fname)
          {
              FILE *fp;
              if (lstat(fname, &link_info) == -1)
              {
                  // handle error
                  // ...
                  printf("lstat return error");
                  return 0;
              }
              else if (S_ISLNK(link_info.st_mode))
              {

                  // both fopen and lstat operate on a file name
                  // the name can be manipulated asynchronously such that
                  // lstat and fopen referred to different files in reality
                  fp = fopen(fname, "O_RDWR"); 
                  if (fp == 0)
                  {
                      // handle error
                      return 0;
                  }

                  size_t i = fread(&val, sizeof(int), 1, fp);
                  // ...
              }
              return 1;
          }
    good:
      c:
        - |-
          #include <stdio.h>
          #include <stdlib.h>
          #include <sys/stat.h>

          #define BUF_SZ 1024

          struct stat link_info;
          int val;

          int func(char *fname)
          {
              FILE *fp;
              // Race condition eliminated by using O_NOFOLLOW 
              // to cause open() to fail if passed a symbolic link
              int fd = open(fp, "O_RDWR"|"O_NOFOLLOW");
              if (fd == -1)
              {
                  /* Handle error */
                  return 0;
              }

              return 1;
          }
  language: c,c++
  likelihood: L
  master_id: 38
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, function ${si.func} has called
    lstat() to check the named file for symbolic linkage.
  name: >-
    When checking for validity of a symbolic link, there could be a race
    condition that may nullify the checked result
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '363'
    owasp:
      - A3
- alias: {}
  category: VUL
  code: POS37-C
  cost: M
  csv_string:
    - P37C2
    - P37C1
    - P37C0
  desc: >-
    The program has one of the get/set uid/euid set of functions which
    manipulates user ID privileges. The result of calling such functions is not
    checked which can cause the program's privilege to be in an unexpected
    state.
  details: >
    #### Abstract

    The program has one of the get/set uid/euid set of functions which
    manipulates user id privileges. The result of calling such functions is not
    checked which will cause the program's privilege to be in an unexpected
    state.


    #### Explanation

    Privilege capabilities are implementation defined. To ensure that the
    privileges are set and relinquished as expected, it is important to check
    the error conditions on return. Failure to do this may result in the program
    being run with root permission.
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>
          #include <unistd.h>

          void func()
          {
              // Permanently drop privileges
              if (setuid(getuid()) != 0) {
                  // Handle error
              }
              
              // Check for failure of privilege relinquishmnet has to be done here
              // Else, attacker can regain elevated privileges    
          }
    good:
      c:
        - |2-
           // ...

           // the following check alone is not sufficient. need to make sure privilege can be restored
           if (setuid(getuid()) != 0) {
           // Handle error
           }

           // check for failure to set uid when the caller is UID 0
           // failure to do this will result in a serious security risk
           if (setuid(0) != -1) {
           // privilege can be restored. Handle error
           }
  language: c,c++
  likelihood: L
  master_id: 39
  msg_templ: >-
    In file ${si.filename}, function ${si.func} at line ${si.line}, privilege
    has not been properly restored.
  name: >-
    When manipulating system privilege through the set/set uid/euid functions,
    please make sure that privileges are relinquished successfully
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '273'
      - '299'
      - '200'
    owasp:
      - A2
- alias: {}
  category: VUL
  code: POS54-C
  cost: L
  csv_string:
    - P54C0
  desc: >-
    The program has called some POSIX library functions but failed to check and
    handle the return error condition.
  details: >
    #### Abstract

    The program has called some POSIX library function but failed to check and
    handle the return error condition.


    #### Explanation

    Each POSIX library has a well defined error return. Failure to check the
    return value for an indication of an error condition and handle the error
    appropriately will lead to an unexpected program behavior.
  examples:
    bad:
      c:
        - |-
          #include <sys/types.h>
          #include <sys/mman.h>
          #include <err.h>
          #include <fcntl.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <unistd.h>

          int main(void)
          {
              const char str1[] = "string 1";
              int fd = -1;
              void *rwrite;

              if ((fd = open("/usr/somefile", O_RDWR, 0)) == -1)
              {
                  err(1, "open");
              }

              rwrite = (char *)mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

              // rwrite may not be valid pointer since mmap may have failed
              strcpy(rwrite, str1);

              // ... continue
          }
    good:
      c:
        - |-
          #include <sys/types.h>
          #include <sys/mman.h>
          #include <err.h>
          #include <fcntl.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <unistd.h>

          int main(void)
          {
              const char str1[] = "string 1";
              int fd = -1;
              void *rwrite;

              if ((fd = open("/usr/somefile", O_RDWR, 0)) == -1)
              {
                  err(1, "open");
              }

              rwrite = (char *)mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

              // checks if rwrite fails and handles error so that
              // strcpy() works properly below
              if (rwrite == NULL) 
              {
                  // Handle error
              }

              strcpy(rwrite, str1);

              // ... continue
          }
  language: c,c++
  likelihood: L
  master_id: 40
  msg_templ: >-
    In file ${si.filename}, function ${si.func} at line ${si.line} a POSIX
    function is called, and the call result was used without being validated.
  name: >-
    When using POSIX library, please make sure to detect and appropriately
    handle errors on function returns
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- alias: {}
  category: VUL
  code: SIG30-C
  cost: M
  csv_string:
    - G30C0
  desc: >-
    The program is calling non-asynchronous safe functions inside signal
    handlers.
  details: >
    #### Abstract

    The program is calling non-asynchronous safe functions inside signal
    handlers.


    #### Explanation

    The table of asynchronous safe functions are functions that can be called
    safely without side effects by a signal handler. Non-reentrant functions are
    typically not safe. Users can check the system user manual for a full list
    of all safe functions to use.
  examples:
    bad:
      c:
        - |
          #include <signal.h>
          #include <stdio.h>
          #include <stdlib.h>

          char *messg = NULL;
          int errflag;

          #define BUF_SZ 1024

          void put_messg(void)
          {
              fputs(messg, stderr);
          }

          void handler(int signum)
          {
              put_messg(); // this is not asynchronous safe
              free(messg); // this is not asynchronous safe
              errflag = 1;
          }

          int main(void)
          {
              if (signal(SIGINT, handler) == SIG_ERR)
              {
                  // handle error
              }
              messg = (char *)malloc(BUF_SZ);
              if (messg == 0)
              {
                  // handle error
              }

              if (!errflag)
              {
                  put_messg();
                  // ...
              }
              return 0;
          }
    good:
      c:
        - |
          #include <signal.h>
          #include <stdio.h>
          #include <stdlib.h>

          char *messg = NULL;
          // sets flag of type volatile
          volatile sig_atomic_t eflag = 0;
          int errflag;

          #define BUF_SZ 1024

          void put_messg(void)
          {
              fputs(messg, stderr);
          }

          void handler(int signum)
          {
              errflag = 1;
          }

          int main(void)
          {
              if (signal(SIGINT, handler) == SIG_ERR)
              {
                  // handle error
              }
              messg = (char *)malloc(BUF_SZ);
              if (messg == 0)
              {
                  // handle error
              }

              while (!errflag)
              {
                  put_messg();
                  // ...
              }

              // put_messg() and free() are directly called from main()
              put_messg();
              free(messg);
              messg = NULL;

              return 0;
          }
  language: c,c++
  likelihood: L
  master_id: 41
  msg_templ: >-
    In file ${si.filename}, function ${si.func} at line ${si.line}, a call to
    signal with handler ${si.var} occurs. Such handler will call functions that
    are not asynchronous-safe.
  name: Signal handlers can only invoke asynchronous safe functions
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '479'
    owasp:
      - A1
- alias: {}
  category: VUL
  code: SIG31-C
  cost: H
  csv_string:
    - G31C1
    - G31C0
  desc: >-
    The program is accessing a shared variable or an object inside a signal
    handler.
  details: >
    #### Abstract

    The program is accessing a shared variable or object inside a signal
    handler.


    #### Explanation

    Other than variables of type \"volatile sig_atomic_t\", accessing any other
    type of objects from a signal handler may cause a race condition resulting
    in an undefined behavior.
  examples:
    bad:
      c:
        - >-
          #include <signal.h>

          #include <stdlib.h>

          #include <sys/socket.h>


          char *messg = NULL;

          #define BUF_SZ 1024

          int sockfd; // as a simple example, we assume sockfd has been properly
          initialized and connected


          volatile sig_atomic_t errflag = 0;


          ssize_t put_messg(void)

          {
              ssize_t err = send(sockfd, (const void *)messg, BUF_SZ, MSG_DONTWAIT);
              return err;
          }


          void handler(int signum)

          {
              errflag = 1; // access shared variable inside handler
          }


          int main(void)

          {
              messg = (char *)malloc(1024);
              if (messg == 0)
              {
                  // handle error
              }

              if (signal(SIGINT, handler) == SIG_ERR)
              {
                  // handle error
              }

              if (!errflag)
              {
                  if (put_messg() >= 0)
                  {
                      // messg sent
                      // ...
                  }
                  else
                  {
                      // ...
                  }
              }
              return 0;
          }
    good:
      c:
        - >-
          #include <signal.h>

          #include <stdlib.h>

          #include <sys/socket.h>


          char *messg = NULL;

          #define BUF_SZ 1024

          int sockfd; // as a simple example, we assume sockfd has been properly
          initialized and connected


          int errflag; // this is a shared variable


          ssize_t put_messg(void)

          {
              ssize_t err = send(sockfd, (const void *)messg, BUF_SZ, MSG_DONTWAIT);
              return err;
          }


          void handler(int signum)

          {
              errflag = 1; // access shared variable inside handler
          }


          int main(void)

          {
              messg = (char *)malloc(1024);
              if (messg == 0)
              {
                  // handle error
              }

              if (signal(SIGINT, handler) == SIG_ERR)
              {
                  // handle error
              }

              if (!errflag)
              {
                  if (put_messg() >= 0)
                  {
                      // messg sent
                      // ...
                  }
                  else
                  {
                      // ...
                  }
              }
              return 0;
          }
  language: c,c++
  likelihood: L
  master_id: 42
  msg_templ: >-
    In file ${si.filename}, function ${si.func} at line ${si.line}, a call to
    signal with handler ${si.var} is made. Such handler eventually will access a
    sharable memory object.
  name: >-
    Signal handlers accessing shared variables or objects may result in race
    conditions
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '662'
      - '828'
- alias: {}
  category: VUL
  code: STR02-C
  cost: M
  csv_string:
    - S02C2
    - S02C1
    - S0200
  desc: >-
    The program is passing string data to external packages or subsystems. These
    data as strings need to be sanitized.
  details: >
    #### Abstract

    The program is passing string data to external packages or subsystems, these
    data strings need to be sanitized.


    #### Explanation

    When data containing sensitive information is passed to system calls,
    databases or other external third party components, it is important to
    ensure that only data that is acceptable to both producer and consumer will
    be passed.
  examples:
    bad:
      c:
        - |-
          #include <stdlib.h>
          #include <stdio.h>

          char *messg = NULL;
          #define BUF_SZ 1024

          void foo(char *argv)
          {
              int len;
              char buf[BUF_SZ];

              if (*argv != 0)
                  len = snprintf(buf, BUF_SZ, "%s", *argv); // buf will be fed into system call later. \"argv\" needs to be sanitized
              if (len < 0)
              {
                  // report error
                  return;
              }
              else
              {
                  if (system(buf) == -1)
                  {
                      // report error
                      return;
                  }
              }
          }
    good:
      c:
        - |
          #include <stdlib.h>
          #include <stdio.h>

          char *messg = NULL;
          #define BUF_SZ 1024

          void foo(char *argv)
          {
              int len;
              char buf[BUF_SZ];


              // filter out invalid data and characters
              static char approved[] = "abcdefghijklmnopqrstuvwxyz"
                                       "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                                       "1234567890_-.@";
              const char *end = *argv + strlen(*argv);
              for (argv += strspn(argv, approved); argv != end; argv += strspn(argv, approved))
              {
                  *argv = '_';
              }

              if (*argv != 0)
                  len = snprintf(buf, BUF_SZ, "%s", *argv); 
              if (len < 0)
              {
                  // report error
                  return;
              }
              else
              {
                  if (system(buf) == -1)
                  {
                      // report error
                      return;
                  }
              }
          }
  language: c,c++
  likelihood: L
  master_id: 43
  msg_templ: >-
    In file ${si.filename}, function ${si.func} at line ${si.line}, {si.var} is
    passed to a system call. This variable is declared and considered
    unsanitized through the program flow.
  name: Data passed to external packages or subsystems should be sanitized
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '88'
      - '78'
      - '917'
    owasp:
      - A3
      - A1
- alias: {}
  category: VUL
  code: STR31-C
  cost: M
  csv_string:
    - S31C4
    - S31C3
    - S31C2
    - S31C1
    - S31C0
  desc: >-
    Ensure that the destination storage of a string is sufficiently large that
    it includes the terminating null.
  details: >
    #### Abstract

    Ensure that the destination storage of a string is sufficiently large that
    it includes the terminating null.


    #### Explanation

    A string is terminated by the null character and should be part of the
    string size/length. If the storage for the string is not sufficiently large
    enough, it will cause a buffer overflow or other spurious errors.
  examples:
    bad:
      c:
        - |-
          #include <stdlib.h>
          #include <string.h>
          #include <stdio.h>

          void get_passwd(void)
          {
              char buf[256];
              char *passwd = getenv("PASSWORD");
              if (passwd == NULL)
              {
                  printf("Error getting password");
                  exit(1);
              }
              //
              // copy environmental string to a fixed-length can cause buffer overflow
              //
              strcpy(buf, passwd);
          }
    good:
      c:
        - |+
          #include <stdlib.h>
          #include <string.h>
          #include <stdio.h>

          void get_passwd(void)
          {
              // length is not fixed, so no buffer overflow
              
              char *buf;
              char *passwd = getenv("PASSWORD");
              if (passwd == NULL)
              {
                  printf("Error getting password");
                  exit(1);
              }

              size_t length = strlen(passwd) + 1;
              buf = (char *)malloc(length);
              if (buf == NULL)
              {
                  // handle error
              }

              memcpy(buf, passwd, length);
              free(buf);
          }

  language: c,c++
  likelihood: L
  master_id: 44
  msg_templ: >-
    In file ${si.filename}, function ${si.func} at line ${si.line}, a pointer to
    character ${si.var} was used to fill another character array/pointer.
    ${si.var} is not large enough to hold all data including null terminator and
    may cause memory access error.
  name: >-
    Strings should have sufficient storage for all characters including the null
    terminator
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '122'
      - '767'
      - '787'
      - '125'
      - '119'
    owasp:
      - A3
      - A1
- alias: {}
  category: VUL
  code: STR32-C
  cost: M
  csv_string:
    - S32C4
    - S32C3
    - S32C2
    - S32C1
    - S32C0
  desc: >-
    The program is calling a library function with a string parameter. That
    string may not be properly terminated.
  details: >
    #### Abstract

    The program is calling a library function with a string parameter. That
    string may not be properly terminated.


    #### Explanation

    Library functions that operate on a string that is not null terminated can
    result in accessing memory outside of the string object. This in turn will
    cause an unexpected program behavior.
  examples:
    bad:
      c:
        - |-
          #include <stdlib.h>
          #include <stdio.h>

          char *messg = NULL;
          #define BUF_SZ 3

          void foo(void)
          {
              char buf[BUF_SZ] = "123";

              printf("string is %s", buf); // buf may not be null terminated since the array is a local array

              // ...
          }
    good:
      c:
        - |-
          #include <stdlib.h>
          #include <stdio.h>

          char *messg = NULL;
          #define BUF_SZ 3

          void foo(void)
          {
              char buf[] = "123";

              printf("string is %s", buf); 

              // ...
          }
  language: c,c++
  likelihood: P
  master_id: 45
  msg_templ: >-
    In file ${si.filename}, function ${si.func} at line ${si.line}, ${si.var} is
    passed to a library function. This variable is not null terminated.
  name: String parameters to library functions should be properly null-terminated
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '119'
      - '125'
      - '123'
      - '170'
      - '787'
    owasp:
      - A3
      - A1
- alias: {}
  category: VUL
  code: STR38-C
  cost: L
  csv_string:
    - S38C0
  desc: >-
    The program is using functions and parameters with mismatching character
    size or type for the size of characters in the string.
  details: >
    #### Abstract

    The program is using functions and parameter with mismatching character size
    or type for the size of characters in the string.


    #### Explanation

    The program is passing a pointer to an object and a size parameter to the
    library function. The two parameters, when combined, will cause the library
    function to access this object but outside its valid range, resulting in an
    undefined behavior.
  examples:
    bad:
      c:
        - |-
          #include <stddef.h>
          #include <stdlib.h>
          #include <wchar.h>

          #define ARRAY_SZ 2
          int mismatch_char_type()
          {
              char char_array[] = "0123456789";
              wchar_t wchar_array[] = "0123456789";

              // size of char_array is smaller than wchar_array due to different char type
              memcpy(&char_array[0], &wchar_array[0], sizeof(wchar_array));
              return 0;
          }
    good:
      c:
        - |-
          #include <stddef.h>
          #include <stdlib.h>
          #include <wchar.h>

          #define ARRAY_SZ 2
          int mismatch_char_type()
          {
              char char_array[] = "0123456789";
              char char_array_2[] = "0123456789";

              // char type is the same, so comparing is acceptable
              strncpy(&char_array[0], &char_array[2], sizeof(char_array));
              return 0;
          }
  language: c,c++
  likelihood: L
  master_id: 46
  msg_templ: >-
    In file ${si.filename}, at line ${si.line}, ${si.var} is erroneously used
    for function ${si.func}.
  name: Do not confuse narrow and wide character strings and functions
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- alias: {}
  category: VUL
  code: STR50-CPP
  cost: M
  csv_string:
    - S50P0
  desc: >-
    The program is using inappropriate string methods to process characters
    which may lead to validation checks that are bypassed or a memory leakage.
  details: >
    #### Abstract

    The program is using inappropriate string methods to process characters
    which may lead to validation checks that are bypassed or a memory leakage.


    #### Explanation

    When trying to construct a string of char type in C or C++ , we must declare
    the maximum length if it is not initialized. When trying to input more
    characters into the variable (i.e. from console) than the variable can
    handle, a buffer overflow will occur. A buffer overflow will expose programs
    to attacks.
  examples:
    bad:
      cpp:
        - |-
          #include <string>
          #include <iostream>
          void f(){
          char x[5];
          std::cin>>x;
          }
    good:
      cpp:
        - |-
          void f(){
          std:;string x;
          std::cin >> x;
          }
  language: c++
  likelihood: L
  master_id: 47
  msg_templ: >-
    In file ${si.filename} at line ${si.line}, copying data into the buffer may
    result to buffer overflow.
  name: Ensure string storage is adequate for the content
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- category: VUL
  code: ERR54-CPP
  cost: LOW
  desc: >-
    Program fails to manage the catch handlers for exceptions in the correct
    order after a try statement. The current order is from the least derived
    (more general) to the most derived (more specific). Hence, catch handlers
    for the most derived will never be executed.
  details: >
    #### Abstract

    Program fails to manage the catch handlers for exceptions in the correct
    order after a try statement. The current order is from least derived(more
    general) to most derived(more specific).
     
    #### Explanation

    Catch handlers go in order of declaration after a try statement. The correct
    order should be from the most derived to the least derived, from the most
    specific to the least specific.

    If the catch starts from the least derived which may possibly be a problem
    caught from the most derived. This way, the catch handler for the most
    derived will never be executed, and that behaviour is not desirable.
  examples:
    bad:
      cpp:
        - |-
          // Classes used for exception handling
          #include <iostream>
           
          class Base {};
           
          class Derived1 : public Base {};
          class Derived2 : public Derived1 {};
           
          void foo();
          void bar();
           
          void foo()
          {
           std::cout << "foo" << std::endl;
          }
          void bar()
          {
           std::cout << "bar" << std::endl;
          }
           
          void f()
          {
           try {
           foo();
           bar();
           // ...
           }
           catch (Base &) {
           // ...
           }
           catch (Derived1 &) { // violation here in Line 19
           // ...
           }
           try {
           foo();
           bar();
           // ...
           }
           catch (Base &) {
           // ...
           }
           catch (Derived2 &) // violation here in Line 31
           {
           // ...
           }
           
           try {
           foo();
           bar();
           // ...
           }
           catch (Base *) {
           // ...
           }
           catch (Derived1 *) { // violation here in Line 44
           // ...
           }
          }
           
          int main() {
           f();
          }
    good:
      cpp:
        - |-
          // Classes used for exception handling
          #include <iostream>
           
          class Base {};
           
          class Derived1 : public Base {};
          class Derived2 : public Derived1 {};
           
          void foo();
          void bar();
           
          void foo()
          {
           std::cout << "foo" << std::endl;
          }
          void bar() {
           std::cout << "bar" << std::endl;
          }
           
          void f()
          {
           try {
           foo();
           bar();
           // ...
           }
           catch (Derived1 &) {
           // ...
           }
           catch (Base &)
           {
           // ...
           }
           try {
           foo();
           bar();
           // ...
           }
           catch (Derived2 &) {
           // ...
           }
           catch (Base &) //
           {
           // ...
           }
           
           try {
           foo();
           bar();
           // ...
           }
           catch (Derived1 *) {
           // ...
           }
           catch (Base *) { //
           // ...
           }
          }
           
          int main() {
           f();
          }
  language: c++
  likelihood: LIKELY
  master_id: 48
  msg_templ: >-
    In file ${si.filename}, function ${si.func} at line ${si.line}, the order of
    catch handler is not properly arranged. 
  name: Order the catch handlers from most specific to the least specific
  severity: MEDIUM
- alias: {}
  category: VUL
  code: MEM55-CPP
  cost: M
  csv_string:
    - m55P0
  desc: >-
    The program has replaced the function for dynamic memory allocation or
    deallocation that does not meet the semantic requirements specified by the
    C++ standard.
  details: >
    #### Abstract

    The program has replaced the function for a dynamic memory allocation or a
    deallocation that does not meet the semantic requirements specified by the
    C++ standard.


    #### Explanation

    The replacement function for allocation contains an external declaration
    that may return nullptr. The function \"new\" will instead return a nullptr
    instead of the supposed \"std::bad_alloc\". 
  examples:
    bad:
      cpp:
        - |-
          #include <cstdio>
          #include <cstdlib>
          #include <new>
          #include <iostream>

          extern void* cust_allocator(std::size_t);

          class Person {
           int age; 
           std::string name;
           
          public:
           Person(){}
           void* operator new(size_t s)
           {
           return cust_allocator(s);
           }
          };
    good:
      cpp:
        - |-
          #include <cstdio>
          #include <cstdlib>
          #include <new>
          #include <iostream>

          extern void* cust_allocator(std::size_t);

          class Person {
           int age; 
           std::string name;
           
          public:
           Person(){}
           void* operator new(size_t s)
           {
           if (((void*) ret = cust_allocator) == 0)
           return ret;
           return cust_allocator(s);
           }
          };
  language: c++
  likelihood: L
  master_id: 49
  msg_templ: >-
    In file ${si.filename}, function${si.func}, line ${si.line}, the replacement
    function for allocation/deallocation violates the required semantics
    specified by the C++ standard.
  name: >-
    User-defined dynamic storage management should follow the language
    requirements
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- alias: {}
  category: VUL
  code: MSC51-CPP
  cost: L
  csv_string:
    - M51P0
  desc: >-
    The program doesn't properly seed the pseudorandom number generator. It has
    used a constant seed OR a non-constant seed that is predictable (i.e. time).
  details: >
    #### Abstract

    The program doesn't properly seed the pseudorandom number generator. It has
    used a constant seed OR it has used a seed that is predictable creating the
    same sequence over and over.


    #### Explanation

    When calling a pseudorandom number generator (PRNG) with the same initial
    state, like using the same seed, it will always generate the exact same
    sequence of numbers. An attacker will be able to easily predict the sequence
    of numbers and cause security issues.
  examples:
    bad:
      cpp:
        - |-
          #include <stdlib.h>
          #include <iostream>
          #include <vector>

          #define MAX_VALUE 100
          #define VECTOR_SIZE 10
          int main()
          { 
           std::vector<int> vec;
           
           for(int i = 0 ; i < VECTOR_SIZE; ++i) {
           vec.push_back(rand()%MAX_VALUE); // using the same initial seed 
           }

           // printing
           for(int j=0 ; j < vec.size() ; ++j ) {
           std::cout << vec[j] << \" \";
           }
           std::cout << '\
          ';
          }
    good:
      cpp:
        - |-
          #include <stdlib.h>
          #include <iostream>
          #include <vector>

          #define MAX_VALUE 100
          #define VECTOR_SIZE 10

          int main() 
          {
           std::vector<int> vec;
           std::random_device rd;

           srand(rd()); // seed is randomized again for every execution
           for(int i = 0 ; i < VECTOR_SIZE; ++i) {
           vec.push_back(rand()%MAX_VALUE); // no repeated sequence 
           }

           for(int j=0 ; j < vec.size() ; ++j ) {
           std::cout << vec[j] << \" \";
           }
           std::cout << '\
          ';
          }
  language: c++
  likelihood: L
  master_id: 50
  msg_templ: >-
    In file ${si.filename}, function ${si.func}, line ${si.line} uses a
    pseudorandom number generator that is not properly seeded. Seed is either
    constant or predictable.
  name: A proper seeding of pseudorandom generator is required
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards: {}
- alias: {}
  category: VUL
  code: MSC54-CPP
  cost: H
  csv_string:
    - M54P0
  desc: >-
    The signal handler function in the program is not a plain old function. The
    particular signal handler function uses pure C++ linkage with no linkage
    with C.
  details: >
    #### Abstract

    The signal handler function in the program is not a plain old function. The
    particular signal handler function uses pure C++ linkage and no linkage with
    C. 


    #### Explanation

    POF or 'Plain Old Function' is a function that uses a feature on the common
    subset between C and C++ language. All signal handlers declared in a C++
    source code must have a C linkage, otherwise it may cause an undefined
    behaviour.
  examples:
    bad:
      cpp:
        - |-
          #include <iostream>
          #include <csignal>
          using namespace std;



          void handle_signal(int signum) 
          {
           cout << \"Signal to interrupt \" << signum << endl;
           exit(signum);
          }

          int main() 
          {
           signal(SIGINT, handle_signal);
           // ....

          }
    good:
      cpp:
        - |-
          #include <iostream>
          #include <csignal>
          using namespace std;

          // use C signature
          extern \"C\" void handle_signal(int signum)
          {
           cout << \"Signal to interrupt \" << signum << endl;
           exit(signum);
          }

          int main() 
          {
           signal(SIGINT, handle_signal);
           // ....

          }
  language: c++
  likelihood: P
  master_id: 51
  msg_templ: >-
    In file ${si.filename}, function ${si.func}, it is not a POF (plain old
    function) even though it exhibits a signal handler behaviour.
  name: Ensure signal handlers are a plain old function
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- alias: {}
  category: VUL
  code: IDS16-J
  cost: M
  csv_string:
    - I16J1
    - I16J0
  desc: >-
    The program is manipulating XMLStrings intended for XML processing without
    validating the string.
  details: >
    #### Abstract

    The program is manipulating XMLString objects intended for XML processing
    without validating the string.


    #### Explanation

    When XMLString objects are not sanitized, the XML string could be
    maliciously injected and mistaken for valid XML, resulting in an XML
    injection attack.
  examples:
    bad:
      java:
        - |
          import java.io.BufferedOutputStream;
          import java.io.ByteArrayOutputStream;
          import java.io.IOException;
           
          public class j_ids16_1 {
           public static void createXMLStreamBad(final BufferedOutputStream outStream,
           final String number) throws IOException {
           String xmlString = \"<item>\
          <description>Widget</description>\
          \"
           + \"<level>500</>\
          \";

           if (number != null) {
           // the string xmlString should be validated
           // to prevent XML injection
          \t xmlString = xmlString + \"<number>\" + number
           + \"</number></item>\";
           }
           outStream.write(xmlString.getBytes());
           outStream.flush();
           }
          }
    good:
      java:
        - |-
          import java.io.BufferedOutputStream;
          import java.io.ByteArrayOutputStream;
          import java.io.IOException;
           
          public class j_ids16_1 {
           public static void createXMLStreamBad(final BufferedOutputStream outStream,
           final String number) throws IOException {
           String xmlString = \"<item>\
          <description>Widget</description>\
          \"
           + \"<level>500</>\
          \";

           if (number != null) {
           int sanitizedNumber = Integer.parseUnsignedInt(number);
           // the string xmlString should be validated
           // to prevent XML injection
          \t xmlString = xmlString + \"<number>\" + sanitizedNumber
           + \"</number></item>\";
           }
           outStream.write(xmlString.getBytes());
           outStream.flush();
           }
          }
  language: Java
  likelihood: P
  master_id: 52
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, the string ${si.var} in function
    ${si.func} is not sanitized before being passed to XML query.
  name: XMLStrings intended for XML processing must be validated before processing
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '79'
      - '776'
    owasp:
      - A4
      - A1
    p3c-sec:
      - '4'
- alias: {}
  category: VUL
  code: MSC02-J
  cost: M
  csv_string:
    - M02J1
    - M02J0
  desc: >-
    The program has used random number generators (PRNG) that are not strong
    enough.
  details: >
    #### Abstract

    The program has used random number generators (PRNG) that are not strong.


    #### Explanation

    Java API provides a PRNG in java.util.Random class which generates the same
    sequence when the same seed is used. For security sensitive programs, a more
    secure PRNG such as java.security.SecureRandom class should be used.
  examples:
    bad:
      java:
        - |-
          // The Random() generates identical sequences in all three cases
          import java.util.Random;
          import java.lang.Math;

          public class msc02_0 {

           public void foo0() {
           Random number = new Random(123L);
           for (int i = 0; i < 20; i++) {
           int n = number.nextInt();
           System.out.println(n);
           }
           }

           public void foo1() {
           Random number = new Random();
           System.out.println(number.nextLong());
           }

          }
    good:
      java:
        - |-
          // The Random() generates identical sequences in the following cases
          import java.util.Random;
          import java.lang.Math;

          public class msc02_0 {

           public void foo0() {
           Random number = new SecureRandom(); // use SecureRandom class 
           for (int i = 0; i < 20; i++) {
           int n = number.nextInt();
           System.out.println(n);
           }
           }

           public void foo1() {
           Random number = new SecureRandom.getInstanceStrong(); // use strong algorithm 
           System.out.println(number.nextLong());
           }

          }
  language: Java
  likelihood: P
  master_id: 53
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, the method ${si.var} in function
    ${si.func} does not generate strong random numbers.
  name: Use strong random number generators
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '327'
    owasp:
      - A3
      - A5
- alias: {}
  category: VUL
  code: SEC07-J
  cost: L
  csv_string:
    - C07J0
  desc: >-
    The program has a custom class loader and failed to call the
    super.getPermission() method.
  details: >
    #### Abstract

    The program has a custom class loader and failed to call
    super.getPermission() method. 


    #### Explanation

    The program has a custom class loader to override the getPermission()
    method. The implementation should invoke the superclass's getPermission() to
    get the default system policy before assigning custom permission to the
    program. This way, both system wide security policies are also applied.
  examples:
    bad:
      java:
        - |-
          import java.net.URL;
          import java.net.URLClassLoader;
          import java.security.CodeSource;
          import java.security.PermissionCollection;
          import java.security.Permissions;

          public class j_sec07_0 extends URLClassLoader { 

           public j_sec07_0(URL[] urls) {
           super(urls);
           }

           protected PermissionCollection getPermissions(CodeSource cs) {
           PermissionCollection pc = new Permissions();
           // Allow exit from the VM anytime
           pc.add(new RuntimePermission(\"exitVM\"));
           return pc;
           }

           public static boolean checkRtPermission(URL[] urls, String tag) {
           j_sec07_0 loader = new j_sec07_0(urls);
           PermissionCollection pc = loader.getPermissions(null);
           RuntimePermission rp = new RuntimePermission(tag);
           if(pc.implies(rp)) {
           System.out.println(\"Able to exit vm\");
           return true;
           } else {
           System.out.println(\"Not Able to exit VM\");
           return false;
           }
           }

           public static void main(String[] args) {
           URL[] urls = new URL[0];
           checkRtPermission(urls, \"exitVM\");
           checkRtPermission(urls, \"stopVM\");
           }

          }
    good:
      java:
        - |
          import java.net.URL;
          import java.net.URLClassLoader;
          import java.security.CodeSource;
          import java.security.PermissionCollection;
          import java.security.Permissions;

          public class j_sec07_0 extends URLClassLoader { 

           public j_sec07_0(URL[] urls) {
           super(urls);
           }

           protected PermissionCollection getPermissions(CodeSource cs) {
           // apply default system wide security policy
           PermissionCollection pc = superPermissions(cs);
           // Allow exit from the VM anytime
           pc.add(new RuntimePermission(\"exitVM\"));
           return pc;
           }

           public static boolean checkRtPermission(URL[] urls, String tag) {
           j_sec07_0 loader = new j_sec07_0(urls);
           PermissionCollection pc = loader.getPermissions(null);
           RuntimePermission rp = new RuntimePermission(tag);
           if(pc.implies(rp)) {
           System.out.println(\"Able to exit vm\");
           return true;
           } else {
           System.out.println(\"Not Able to exit VM\");
           return false;
           }
           }

           public static void main(String[] args) {
           URL[] urls = new URL[0];
           checkRtPermission(urls, \"exitVM\");
           checkRtPermission(urls, \"stopVM\");
           }

          }
  language: Java
  likelihood: P
  master_id: 54
  msg_templ: >-
    In file ${si.filename} at line ${si.line}, function ${si.func}, ${si.var}
    overrides getPermission() without invoking superclass' permission.
  name: >-
    Call the superclass' getPermissions() method to implement a custom class
    loader
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    owasp:
      - A9
- alias: {}
  category: VUL
  code: DCL00-J
  cost: M
  csv_string:
    - D00J0
  desc: The program has a class initialization that forms a cycle.
  details: >
    #### Abstract

    The program has class initialization that forms a cycle.


    #### Explanation

    Static field triggers the initialization of a class. When the static field
    is dependent on the initialization of another class, a cycle will be
    created.
  examples:
    bad:
      java:
        - |-
          import java.util.Calendar;
          public class j_dcl00_0 {
           private int elapse;
           private static final j_dcl00_0 obj = new j_dcl00_0(); // self cycle (call constructor)
           private static final int curr_year = Calendar.getInstance().get(Calendar.YEAR);
           
           public j_dcl00_0() {
           if(200 > Calendar.getInstance().get(Calendar.YEAR))
           elapse = curr_year - 2000; // curr_year not initialized yet, due to constructor is called before curr_year assignment in line 73. 
           // ( Remediate suggestion: swap lines 72 and line 73 will ensure initialized)
           }

           public static void main(String[] args) {
           System.out.println(\"It was \" + obj.elapse + \" years since 2000\");
           }
           
          }
    good:
      java:
        - |-
          import java.util.Calendar;
          public class j_dcl00_0 {
           private int elapse;
           private static final int curr_year = Calendar.getInstance().get(Calendar.YEAR);
           private static final j_dcl00_0 obj = new j_dcl00_0(); // curr_year is initialized before used in constructor
           
           public j_dcl00_0() {
           if(200 > Calendar.getInstance().get(Calendar.YEAR))
           elapse = curr_year - 2000; 
           }

           public static void main(String[] args) {
           System.out.println(\"It was \" + obj.elapse + \" years since 2000\");
           }
           
          }
  language: Java
  likelihood: U
  master_id: 55
  msg_templ: >-
    In file ${si.filename}, function ${si.func} at line ${si.line}, the class
    ${si.var} forms an initialization cycle.
  name: Program should not have a class initialization cycle
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: L
  standards: {}
- alias: {}
  category: VUL
  code: ENV03-J
  cost: L
  csv_string:
    - N03J2
    - N03J1
    - N03J0
  desc: >-
    The program has called methods to grant permissions or a combination of
    permissions to the code.
  details: >
    #### Abstract

    The program has called methods to grant permissions or a combination of
    permissions to code, and this could be dangerous.


    #### Explanation

    A combination of permissions granting code could be dangerous. For example,
    when RuntimePermission is applied to createClassLoader it can create a
    custom class loader and assign arbitrary permissions. ReflectPermission and
    suppressAccessChecks together will suppress all standard checks. 
  examples:
    bad:
      java:
        - |-
          import java.net.URL;
          import java.net.URLClassLoader;
          import java.net.MalformedURLException;
          import java.security.cert.Certificate;
          import java.security.CodeSource;
          import java.security.PermissionCollection;
          import java.security.Permissions;
          import java.lang.reflect.*;

          public class env03_0 extends URLClassLoader {

           public env03_0(URL[] urls) {
           super(urls);
           }

           protected PermissionCollection getPermissions(CodeSource cs) {
           PermissionCollection pc = super.getPermissions(cs); 
           pc.add(new ReflectPermission("suppressAccessChecks")); // add permission to create a class loader
           // includes granting "suppressAccessChecks"
           // ...
           // other permissions
           return pc;
           }

           public static boolean checkRtPermission(URL[] urls, String tag) throws MalformedURLException{
           env03_0 loader = new env03_0(urls);
           Certificate[] cert = null;
           CodeSource cs = new CodeSource(new URL("http://abc"), cert);
           PermissionCollection pc = loader.getPermissions(cs);
           ReflectPermission rp = new ReflectPermission(tag);
           if(pc.implies(rp)) {
           System.out.println("Able to get suppressAccessChecks");
           return true;
           } else {
           System.out.println("Not Able to get suppressAccessChecks");
           return false;
           }
           }

           public static void main(String[] args) throws MalformedURLException{
           URL[] urls = new URL[0];
           checkRtPermission(urls, "suppressAccessChecks");
           }

          }
    good:
      java:
        - |
          import java.net.URL;
          import java.net.URLClassLoader;
          import java.net.MalformedURLException;
          import java.security.cert.Certificate;
          import java.security.CodeSource;
          import java.security.PermissionCollection;
          import java.security.Permissions;
          import java.lang.reflect.*;

          public class env03_0 extends URLClassLoader {

           public env03_0(URL[] urls) {
           super(urls);
           }

           protected PermissionCollection getPermissions(CodeSource cs) {
           PermissionCollection pc = super.getPermissions(cs);
           // ...
           // other permissions
           return pc;
           }

           public static boolean checkRtPermission(URL[] urls, String tag) throws MalformedURLException{
           env03_0 loader = new env03_0(urls);
           Certificate[] cert = null;
           CodeSource cs = new CodeSource(new URL("http://abc"), cert);
           PermissionCollection pc = loader.getPermissions(cs);
           ReflectPermission rp = new ReflectPermission(tag);
           if(pc.implies(rp)) {
           System.out.println("Able to get suppressAccessChecks");
           return true;
           } else {
           System.out.println("Not Able to get suppressAccessChecks");
           return false;
           }
           }

           public static void main(String[] args) throws MalformedURLException{
           URL[] urls = new URL[0];
           checkRtPermission(urls, "suppressAccessChecks");
           }

          }
  language: Java
  likelihood: L
  master_id: 56
  msg_templ: >-
    In file ${si.filename}, function ${si.func} at line ${si.line} with method
    ${si.var}, we detected a dangerous combination of permissions granted to an
    object.
  name: Permissions should be granted explicitly and judiciously
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '287'
      - '732'
      - '862'
    owasp:
      - A2
      - A5
      - A6
- alias: {}
  category: VUL
  code: ENV06-J
  cost: L
  csv_string:
    - N06J2
    - N06J1
    - N06J0
  desc: >-
    The program should strip all code used for debugging and is not intended to
    be shipped or deployed with the application.
  details: >
    #### Abstract

    The program should strip all code used for debugging that is not intended to
    be shipped or deployed with the application. 


    #### Explanation

    Although it is an acceptable practice to include \"main\" development,
    leaving that in production code could leave a backdoor entry point for an
    attacker. Methods that include \"main\" should be removed from production
    applications.
  examples:
    bad:
      java:
        - |-
          public class my_code {
           // DEBUG is set to false, but \"main\" is left behind
           private static final boolean DEBUG = false;
           public static void main(String[] args) {
           my_code f = new my_code();
           }
          }
    good:
      java:
        - |-
          public class my_code {
           // DEBUG is set to false, but \"main\" is left behind
           private static final boolean DEBUG = false;
           // remove the following statement if DEBUG is set to FALSE
           // public static void main(String[] args) {
           // my_code f = new my_code();
           // }
          }
  language: Java
  likelihood: P
  master_id: 57
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, \"main\" is found, possibly left
    over for debugging purposes.
  name: Debugged entry points should not remain in product code
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '200'
    owasp:
      - A2
      - A9
      - A3
- alias: {}
  category: VUL
  code: ERR08-J
  cost: M
  csv_string:
    - E08J0
  desc: The program is catching a NullPointerException.
  details: >
    #### Abstract

    The program is catching a NullPointerException. 


    #### Explanation

    A NullPointerException thrown at runtime indicates an underlying defect that
    must be fixed in the application code. Catching this exception (or others
    like RuntimeException, Exception or Throwable) adds more runtime performance
    overhead. Furthermore, when this happens, the program is likely to be in an
    unknown state and any continued execution will cause unexpected results.
  examples:
    bad:
      java:
        - |-
          public class err08_0 {
           boolean isName(String s) {
           try {
           String names = s.concat("abc");
           if (names.length() != 5) {
           return false;
           }
           return true;
           } catch (NullPointerException e) {
           // catch Null pointer exception 
           return false;
           }
           
           }

           boolean foo1() {
           try {
           throw new RuntimeException("xyz");
           } catch (RuntimeException e) {
           // this catch RuntimeException is ancestor of the NullPointerException
           return false;
           }
           }
          }
    good:
      java:
        - |-
          public class err08_0 {
           boolean isName(String s) {
           try {
           String names = s.concat("abc");
           if (names.length() != 5) {
           return false;
           }
           return true;
           } 
           }

           boolean foo1() {
           try {
           throw new RuntimeException("xyz");
           } catch (RuntimeException e) {
           // this catch RuntimeException is ancestor of the NullPointerException
           return false;
           }
           }
          }
  language: Java
  likelihood: L
  master_id: 58
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, a NullPointerException is caught at
    the try block in function ${si.func}.
  name: NullPointerException or any of its ancestors should not be caught
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '476'
    owasp:
      - A10
- alias: {}
  category: VUL
  code: EXP02-J
  cost: L
  csv_string:
    - X02J0
  desc: The program is comparing two arrays using an Object.equals() method.
  details: >
    #### Abstract

    The program is comparing two arrays using the Object.equals() method.


    #### Explanation

    Two arrays are equal if they contain equivalent elements and in the same
    order. Using Object.equals() on arrays only compares array references, not
    their content.
  examples:
    bad:
      java:
        - |-
          // this example is modified from CERT-J site
          import java.util.Arrays;

          public class exp02_example {

           public static void println(int[] ar1, int[] ar2) {
           System.out.println(ar1.equals(ar2)); // prints false
           }
           
           public static void main(String[] args) {
           int[] arr1 = new int[20]; // Initialized to 0
           int[] arr2 = new int[20]; // Initialized to 0
           println(arr1, arr2); 
           }
          }
    good:
      java:
        - |-
          // this example is modified from CERT-J site
          import java.util.Arrays;

          public class exp02_example {

           public static void println(int[] ar1, int[] ar2) {
           System.out.println(Arrays.equals(arr1, arr2)); // prints true
           }
           
           public static void main(String[] args) {
           int[] arr1 = new int[20]; // Initialized to 0
           int[] arr2 = new int[20]; // Initialized to 0
           println(arr1, arr2); 
           }
          }
  language: Java
  likelihood: L
  master_id: 59
  msg_templ: >-
    In file ${si.filename}, function ${si.func} at line ${si.line},
    Object.equals() has been used to compare ${si.var}. 
  name: The Object.equals() should not be used to compare two arrays
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: L
  standards: {}
- alias: {}
  category: VUL
  code: FIO02-J
  cost: M
  csv_string:
    - F02J0
  desc: >-
    The program is attempting to manipulate a file but failed to check the
    validity of the return values from the method.
  details: >
    #### Abstract

    The program is attempting to manipulate a file but failed to check validity
    of the return values from the method.


    #### Explanation

    File I/O operations in Java must check the return values of methods that
    perform the file I/O. For example, if not checked, File.delete() will
    silently fail.
  examples:
    bad:
      java:
        - |-
          import java.io.File;
          import java.io.IOException;

          public class j_fio02_0 {
           void foo(boolean b) {
           try {
           File f = new File("file");
           if (b) {
           if (f.delete()) {
           System.out.println("Deletion error");
           }
           }
           else {
           f.delete(); // failed to check return value of delete()
           }
           }
           catch(Exception e) {
           System.out.println("Exception");
           }
           }
          }
    good:
      java:
        - |
          import java.io.File;
          import java.io.IOException;

          public class j_fio02_0 {
           void foo(boolean b) {
           try {
           File f = new File("file");
           if (b) {
           if (f.delete()) {
           System.out.println("Deletion error");
           }
           }
           else {
           if (f.delete()) {
           System.out.println("Deletion error");
           }
           
           }
           }
           catch(Exception e) {
           System.out.println("Exception");
           }
           }
          }
  language: Java
  likelihood: P
  master_id: 60
  msg_templ: >-
    In file ${si.filename}, function ${si.func} at line ${si.line}, a new file
    object ${si.var} is requested. Subsequent call to such object at line
    ${si.line} fails to check if file manipulation is successful.
  name: File related errors should be checked and handled
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '252'
- alias: {}
  category: VUL
  code: FIO05-J
  cost: L
  csv_string:
    - F05J1
    - F05J0
  desc: >-
    The program is using wrap() or duplicate() methods in buffer class in the
    java.nio package. These buffers are exposed to untrusted code in the
    program.
  details: >
    #### Abstract

    The program is using wrap() or duplicate() methods in buffer class in the
    java.nio package. These buffers are exposed to untrusted code in the
    program.


    #### Explanation

    The methods will create a new Buffer object, backed by the given input
    array. Hence, the new Buffer object can be maliciously modified. It is
    important to use a read only Buffer or make sure the original buffer will
    not be modified. 
  examples:
    bad:
      java:
        - |-
          // this example is modified from CERT-J example
          import java.nio.CharBuffer;

          public class j_fio05_0 {
           private char[] dataArray;
           private CharBuffer cb;

           public j_fio05_0() {
           dataArray = new char[10];
           }

           public CharBuffer getBufferCopy() {
           return CharBuffer.wrap(dataArray); // dataArray (private) is exposed through this wrap
           }
          }
        - |-
          import java.nio.CharBuffer;

          public class j_fio05_0 {
           private char[] dataArray;
           private CharBuffer cb;

           public j_fio05_0() {
           dataArray = new char[10];
           }

           public CharBuffer getBufferCopy() {
           return CharBuffer.wrap(dataArray); // dataArray (private) is exposed through this wrap
           }

           private void storeBuffer() {
           cb = CharBuffer.wrap(dataArray); // dataArray (private) is exposed, see comment in return statement below
           }

           public CharBuffer getBufferCopy2() {
           storeBuffer();
           return cb; // dataArray is exposed through cb which is assigned in storeBuffer()
           }
          }
    good:
      java:
        - |-
          // this example is modified from CERT-J example
          import java.nio.CharBuffer;

          public class j_fio05_0 {
           private char[] dataArray;
           private CharBuffer cb;

           public j_fio05_0() {
           dataArray = new char[10];
           }

           public CharBuffer getBufferCopy() {
           return CharBuffer.wrap(dataArray).asReadOnlyBuffer(); // attemp to modify will result in exception
           }
          }
        - |-
          import java.nio.CharBuffer;

          public class j_fio05_0 {
           private char[] dataArray;
           private CharBuffer cb;

           public j_fio05_0() {
           dataArray = new char[10];
           }

           public CharBuffer getBufferCopy() {
           return CharBuffer.wrap(dataArray).asReadOnlyBuffer();; // attempt to modify will result in exception
           }

           private void storeBuffer() {
           cb = CharBuffer.wrap(dataArray).asReadOnlyBuffer();; // attempt to modify will result in exception
           }

           public CharBuffer getBufferCopy2() {
           storeBuffer();
           return cb; 
           }
          }
  language: Java
  likelihood: L
  master_id: 61
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, the backing array of the buffer
    class ${si.var} can be exposed to untrusted code through function
    ${si.func}.
  name: >-
    Buffers created with wrap() or duplicate() should not be exposed to
    untrusted code
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '522'
    owasp:
      - A3
      - A2
- alias: {}
  category: VUL
  code: FIO14-J
  cost: M
  csv_string:
    - F14J0
  desc: The program did not perform a proper cleanup when the program terminated.
  details: >
    #### Abstract

    The program did not perform a proper cleanup when the program terminated.


    #### Explanation

    When irrecoverable errors are detected, it is common to quickly shut down
    the system and allow the operator to start over in a determinate state. This
    should include cleanup of the external resources. Failure to do so may leave
    important and sensitive data behind in the system.
  examples:
    bad:
      java:
        - |
          import java.io.*;

          public class fio14_example {
           public static void reg_hook(PrintStream out) {
           // shut down hook will be called when Runtime.exit(),
           // make sure in call hierarchy,
           // there is an path from Runtime.exit() to Runtime.addShutdownHook
           Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
           public void run() {
           System.out.println("exit without closing file, need out.close()");
           out.close(); // report double close
           }
           }
           ));
           }

           public static void close2() throws FileNotFoundException {
           final PrintStream out =
           new PrintStream(new BufferedOutputStream(
           new FileOutputStream("foo.txt")));
           reg_hook(out);
           out.println("register hook");
           Runtime.getRuntime().exit(1);
           }
           public static void main(String[] args) throws FileNotFoundException{
           close2();
           }
          }
    good:
      java:
        - |-
          import java.io.*;

          public class fio14_example {
           public static void reg_hook(PrintStream out) {
           // shut down hook will be called when Runtime.exit(),
           // make sure in call hierarchy,
           // there is an edge from Runtime.exit() to Runtime.addShutdownHook
           Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
           public void run() {
           System.out.println("exit without closing file, need out.close()");
           out.close(); // report double close
           }
           }
           ));
           }

           public static void close2() throws FileNotFoundException {
           final PrintStream out =
           new PrintStream(new BufferedOutputStream(
           new FileOutputStream("foo.txt")));
           reg_hook(out);
           out.println("hello");
           Runtime.getRuntime().exit(1);
           }
           public static void main(String[] args) throws FileNotFoundException{
           close2();
           }
          }
  language: Java
  likelihood: L
  master_id: 62
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, resource associated with ${si.var}
    will not be properly cleaned up when the program is terminated.
  name: >-
    At program termination, proper cleanup should be performed through
    Runtime.exit()
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '705'
    owasp:
      - A3
- alias: {}
  category: VUL
  code: FIO16-J
  cost: M
  csv_string:
    - F16J2
    - F16J1
  desc: The program is validating pathnames without first canonicalizing them.
  details: >
    #### Abstract

    The program is validating pathnames without first canonicalizing them.


    #### Explanation

    Pathnames may contain special characters that make validation difficult.
    Also, a pathname may be symbolic links or shadows which attackers could use
    to bypass security check. It is important to fully resolve/canonicalize a
    pathname before validation. 
  examples:
    bad:
      java:
        - |-
          import javax.servlet.http.HttpServletRequest;
          import javax.servlet.http.HttpServletResponse;
          import java.io.*;

          public class fio16_example
          {

           public void bad_1(HttpServletRequest request, HttpServletResponse response) throws IOException
           {
           String fname = request.getParameter("FileName");
           String info = request.getParameter("Info");
           File fp = new File(fname);
           
           if(fp.exists() && is_safe(fname)) { // fp validated but before calling getCanonicalPath,
           // hacker can bypass the validateion
           String uniqPath = fp.getCanonicalPath();
           FileOutputStream writer = new FileOutputStream(uniqPath);
           writer.write(info.getBytes());
           writer.close(); // info may be written to unkown location
           }
           }
           
           private Boolean is_safe(String path)
           {
           // do path validation
           if(path.startsWith("/share/user")) {
           return true;
           } else {
           return false;
           }
           }
          }
    good:
      java:
        - |-
          import javax.servlet.http.HttpServletRequest;
          import javax.servlet.http.HttpServletResponse;
          import java.io.*;

          public class fio16_example
          {

           public void bad_1(HttpServletRequest request, HttpServletResponse response) throws IOException
           {
           String fname = request.getParameter("FileName");
           String info = request.getParameter("Info");
           File fp = new File(fname);
           
           { 
           String uniqPath = fp.getCanonicalPath();
           // va;odate after calling getCanonicalPath
           if (fp.exists() && is_safe(uniqPath) { 
           FileOutputStream writer = new FileOutputStream(uniqPath);
           writer.write(info.getBytes());
           writer.close(); // info is written to validated location
           }
           }
           }
           
           private Boolean is_safe(String path)
           {
           // do path validation
           if(path.startsWith("/share/user")) {
           return true;
           } else {
           return false;
           }
           }
          }
  language: Java
  likelihood: U
  master_id: 63
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, the file name string ${si.var} in
    function ${si.func} is not canonicalized before the file is opened.
  name: Please canonicalize path names before validating them
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '22'
      - '647'
    owasp:
      - A2
      - A5
- alias: {}
  category: VUL
  code: IDS00-J
  cost: M
  csv_string:
    - I00J3
    - I00J2
    - I00J1
    - I00J0
  desc: String input to any SQL query must be sanitized before the query.
  details: >
    #### Abstract

    String input to any SQL query must be sanitized before the query.


    #### Explanation

    Strings that originated from an untrusted source must go through a
    sanitization and validation process to avoid being used as malicious input
    to a SQL database. Failure to do so may cause data leakage and privacy
    violations.
  examples:
    bad:
      java:
        - |
          import java.sql.DriverManager;
          import java.sql.PreparedStatement;
          import java.sql.ResultSet;
          import java.sql.SQLException;
          import java.sql.Statement;

          public class j_ids00_2 {

           public Connection getConnection() throws SQLException {
           String dbConnection = System.getProperty(\"db.connection\");
           return DriverManager.getConnection(dbConnection);
           }

           String hashPwd(char[] pwd) {
           // Create hash of password
           return new String(pwd);
           }

           public void doPrivilegedAction(
           String username, char[] password // username is unsanitized 
           ) throws SQLException, SecurityException {
           Connection connection = getConnection();
           if (connection == null) {
           // Handle error
           }
           try {
           String pwd = hashPwd(password);
           // the string query is composed with unsanitized string (username) input
           String query = \"SELECT * from where product username =\" +
           username + \" and password =\" + pwd;
           
           PreparedStatement stmt = connection.prepareStatement(query);

           ResultSet result = stmt.executeQuery();
           if (!result.next()) {
           throw new SecurityException(\"User name/password incorrect\");
           }

           // Authenticated
           } finally {
           try {
           connection.close();
           } catch (SQLException x) {
           // Forward to handler
           }
           }
           }
          }
    good:
      java:
        - |-
          import java.sql.DriverManager;
          import java.sql.PreparedStatement;
          import java.sql.ResultSet;
          import java.sql.SQLException;
          import java.sql.Statement;

          public class j_ids00_2 {

           public Connection getConnection() throws SQLException {
           String dbConnection = System.getProperty(\"db.connection\");
           return DriverManager.getConnection(dbConnection);
           }

           String hashPwd(char[] pwd) {
           // Create hash of password
           return new String(pwd);
           }

           public void doPrivilegedAction(
           String username, char[] password // username is unsanitized 
           ) throws SQLException, SecurityException {
           Connection connection = getConnection();
           if (connection == null) {
           // Handle error
           }
           try {
           String pwd = hashPwd(password);
           // the string query is composed with sanitized string (username) input
           PreparedStatement stmt = connection.prepareStatement(\"SELECT * FROM db_user WHERE username = ? AND passwd = ?\");
           
           // use set*() to enforce strong type checking
           stmt.setString(1, username); // to be sure, username may still be considered \"tainted\"
           stmt.setString(2, pwd); // to be sure, pwd ma still be considered \"tainted\" 

           ResultSet result = stmt.executeQuery();
           if (!result.next()) {
           throw new SecurityException(\"User name/password incorrect\");
           }

           // Authenticated
           } finally {
           try {
           connection.close();
           } catch (SQLException x) {
           // Forward to handler
           }
           }
           }
          }
  language: Java
  likelihood: P
  master_id: 64
  msg_templ: >-
    In file ${si.filename}, function ${si.func} the string ${si.var} is not
    sanitized before the SQL query at line ${si.line}.
  name: String input to any SQL query must be sanitized before the query
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '116'
      - '943'
      - '564'
      - '89'
    owasp:
      - A1
      - A5
      - A2
    p3c-sec:
      - '3'
      - '5'
      - '4'
- alias: {}
  category: VUL
  code: IDS01-J
  cost: M
  csv_string:
    - I01J2
    - I01J1
    - I01J0
  desc: The program is validating strings that have not been normalized.
  details: >
    #### Abstract

    The program is validating strings that have not been normalized.


    #### Explanation

    Strings have many representations such as \"char\", \"unicode\", etc. Many
    filtering or validation mechanisms are based on the strings' character data.
    Failure to filter out or normalize the string before validation could end up
    bypassing the validation mechanism, resulting in execution of arbitrary
    code.
  examples:
    bad:
      java:
        - |-
          import java.text.Normalizer;
          import java.text.Normalizer.Form;
          import java.util.regex.Matcher;
          import java.util.regex.Pattern;
           
          public class j_ids01_0 { // inspired by CERT-J example
           public static String filterString(String str) {
           
           // Non-compliant - Validate before the string is normalized
           Pattern pattern = Pattern.compile(\"<script>\");
           Matcher matcher = pattern.matcher(str);
           if (matcher.find()) {
           throw new IllegalArgumentException(\"Invalid input\");
           }
           // Normalization form for validate String is NFKC
           String s = Normalizer.normalize(str, Form.NFKC); 
           return s;
           }
           
           public static void main(String[] args) {
           // \"\\ \" is a noncharacter code point
           String maliciousInput = \"<scr\" + \"\\ \" + \"ipt>\";
           String sb = filterString(maliciousInput);
           // sb = \"<script>\"
           }
          }
    good:
      java:
        - |
          import java.text.Normalizer;
          import java.text.Normalizer.Form;
          import java.util.regex.Matcher;
          import java.util.regex.Pattern;
           
          public class j_ids01_0 { // inspired by CERT-J example
           public static String filterString(String str) {
           
           // Normalization form for validate String is NFKC
           String s = Normalizer.normalize(str, Form.NFKC); 
           // compliant - Validate after the string is normalized
           Pattern pattern = Pattern.compile(\"<script>\");
           Matcher matcher = pattern.matcher(str);
           if (matcher.find()) {
           throw new IllegalArgumentException(\"Invalid input\");
           }
           return s;
           }
           
           public static void main(String[] args) {
           // \"\\ \" is a noncharacter code point
           String maliciousInput = \"<scr\" + \"\\ \" + \"ipt>\";
           String sb = filterString(maliciousInput);
           // sb = \"<script>\"
           }
          }
  language: Java
  likelihood: P
  master_id: 65
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, the string is validated in function
    ${si.var} before being normalized。
  name: Do not validate strings that have not been normalized
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '180'
      - '289'
      - '79'
    owasp:
      - A7
      - A5
      - A2
    p3c-sec:
      - '4'
- alias: {}
  category: VUL
  code: IDS11-J
  cost: M
  csv_string:
    - I11J2
    - I11J1
    - I11J0
  desc: The program has changed a string that has gone through validation.
  details: >
    #### Abstract

    The program has changed a string that has gone through validation.


    #### Explanation

    A string is modified after going through validation for processing.  The
    string may in turn become untrusted again which nullifies the previous
    validation effort. 
  examples:
    bad:
      java:
        - |-
          import java.text.Normalizer;
          import java.text.Normalizer.Form;
          import java.util.regex.Matcher;
          import java.util.regex.Pattern;
           
          public class j_ids11_0 {
           public static String filterString(String s) {
           // Normalize input string
           String str = Normalizer.normalize(s, Form.NFKC);
           
           // Validate input after normalization
           Pattern pattern = Pattern.compile(\"<script>\");
           Matcher matcher = pattern.matcher(str);
           if (matcher.find()) {
           throw new IllegalArgumentException(\"Invalid input\");
           }
           
           // Delete noncharacter code
           // input string may have noncharacter code
           // however, the new string formed should go through normalize and validation again
           str = str.replaceAll(\"[\\\\p{Cn}]\", \"\");
           return str;
           }
           // ... more code 
          }
    good:
      java:
        - |-
          import java.text.Normalizer;
          import java.text.Normalizer.Form;
          import java.util.regex.Matcher;
          import java.util.regex.Pattern;
           
          public class j_ids11_0 {
           public static String filterString(String s) {
           // Normalize input string
           String str = Normalizer.normalize(s, Form.NFKC);
           
           // Delete noncharacter code
           // input string may have noncharacter code
           // however, the new string formed should go through normalize and validation again
           str = str.replaceAll(\"[\\\\p{Cn}]\", \"\");
           
           // Validate input after normalization
           Pattern pattern = Pattern.compile(\"<script>\");
           Matcher matcher = pattern.matcher(str);
           if (matcher.find()) {
           throw new IllegalArgumentException(\"Invalid input\");
           }
           
           return str;
           }
           // ... more code 
          }
  language: Java
  likelihood: P
  master_id: 66
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, the program modified the string
    ${si.var} that had been validated but now made untrusted again.
  name: Do not modify a string that has gone through validation
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '182'
    owasp:
      - A7
      - A2
      - A3
    p3c-sec:
      - '4'
- alias: {}
  category: VUL
  code: IDS17-J
  cost: M
  csv_string:
    - I17J2
    - I17J1
    - I17J0
  desc: >-
    An external declaration that defines an external entity (typically specified
    by an URI) should be properly filtered.
  details: >
    #### Abstract

    An external declaration that defines an external entity (typically specified
    by an URI) should be properly filtered. 


    #### Explanation

    The external entities should be filtered, either through a whitelist or
    pre-registration so that XML attacks can be contained. Failure to do so
    could result in denial of service or data leakage.
  examples:
    bad:
      java:
        - |-
          import java.io.IOException;
          import org.xml.sax.EntityResolver;
          import org.xml.sax.InputSource;
          import org.xml.sax.SAXException;
          import java.io.FileInputStream;
          import java.io.InputStream;

          import javax.xml.parsers.ParserConfigurationException;
          import javax.xml.parsers.SAXParser;
          import javax.xml.parsers.SAXParserFactory;
          import org.xml.sax.XMLReader;
          import org.xml.sax.helpers.DefaultHandler;

          class ids17_CustomResolver implements EntityResolver {
           public InputSource resolveEntity(String publicId, String systemId)
           throws SAXException, IOException {
           // Check by whitelist good entity
           ....
           }
          }
           
          public class ids17_example{
           private static void bad_receiveXMLStream(InputStream inStream,
           DefaultHandler defaultHandler)
           throws ParserConfigurationException, SAXException, IOException {
           SAXParserFactory factory = SAXParserFactory.newInstance();
           SAXParser saxParser = factory.newSAXParser();
           saxParser.parse(inStream, defaultHandler); // IDS17-J
           }

           private static void bad_receiveXMLStream2(InputStream inStream,
           DefaultHandler defaultHandler,
           Boolean do_sanitize) 
           throws ParserConfigurationException, SAXException, IOException {
           try {
           SAXParserFactory factory = SAXParserFactory.newInstance();
           SAXParser saxParser = factory.newSAXParser();

           XMLReader reader = saxParser.getXMLReader();
           reader.setContentHandler(defaultHandler);
           if(do_sanitize) {
           reader.setEntityResolver(new ids17_CustomResolver()); // sanitized
           }
           InputSource is = new InputSource(inStream);
           reader.parse(is); // IDS17-J, not setEntityResolver if !do_sanitize
           } catch (java.net.MalformedURLException mue) {
           System.err.println(\"Malformed URL Exception: \" + mue);
           }
           }

           
           public static void main(String[] args) throws ParserConfigurationException,
           SAXException, IOException {
           // invokes bad_receiveXMLStream and bad_receiveXMLStream2
           // ...
           }
          }
    good:
      java:
        - |-
          import java.io.IOException;
          import org.xml.sax.EntityResolver;
          import org.xml.sax.InputSource;
          import org.xml.sax.SAXException;
          import java.io.FileInputStream;
          import java.io.InputStream;

          import javax.xml.parsers.ParserConfigurationException;
          import javax.xml.parsers.SAXParser;
          import javax.xml.parsers.SAXParserFactory;
          import org.xml.sax.XMLReader;
          import org.xml.sax.helpers.DefaultHandler;

          class ids17_CustomResolver implements EntityResolver {
           public InputSource resolveEntity(String publicId, String systemId)
           throws SAXException, IOException {
           // Check by whitelist good entity
           ....
           }
          }
           
          public class ids17_example{
           private static void bad_receiveXMLStream(InputStream inStream,
           DefaultHandler defaultHandler)
           throws ParserConfigurationException, SAXException, IOException {
           SAXParserFactory factory = SAXParserFactory.newInstance();
           SAXParser saxParser = factory.newSAXParser();
           saxParser.parse(inStream, defaultHandler); // IDS17-J
           }

           private static void bad_receiveXMLStream2(InputStream inStream,
           DefaultHandler defaultHandler,
           Boolean do_sanitize) 
           throws ParserConfigurationException, SAXException, IOException {
           try {
           SAXParserFactory factory = SAXParserFactory.newInstance();
           SAXParser saxParser = factory.newSAXParser();

           XMLReader reader = saxParser.getXMLReader();
           reader.setContentHandler(defaultHandler);
           // always sanitize
           reader.setEntityResolver(new ids17_CustomResolver()); // sanitized
           
           InputSource is = new InputSource(inStream);
           reader.parse(is); // no IDS17 complaince issue 
           } catch (java.net.MalformedURLException mue) {
           System.err.println(\"Malformed URL Exception: \" + mue);
           }
           }

           
           public static void main(String[] args) throws ParserConfigurationException,
           SAXException, IOException {
           // invokes bad_receiveXMLStream and bad_receiveXMLStream2
           // ...
           }
          }
  language: Java
  likelihood: P
  master_id: 67
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, an external declaration is not
    properly filtered.
  name: Improperly configured XML parser could cause XML external entity attack
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '611'
      - '116'
      - '776'
    owasp:
      - A4
      - A1
- alias: {}
  category: VUL
  code: MET06-J
  cost: L
  csv_string:
    - T06J1
    - T06J0
  desc: The program has called overridable methods in clone().
  details: >
    #### Abstract

    The program has called overridable methods in clone().


    #### Explanation

    A malicious subclass could override the methods in clone() causing insecure
    or unpredictable behavior. Also, trusted subclasses could modify cloned
    objects which are in the construction process such that the object being
    cloned will be in an inconsistent state.
  examples:
    bad:
      java:
        - |
          // this example is extended from CERT site
          import java.net.HttpCookie;
          import java.util.ArrayList;
          import java.util.List;

          class j_met06 implements Cloneable {
           HttpCookie[] cookies;

           j_met06(HttpCookie[] c) {
           cookies = c;
           }

           public Object clone() throws CloneNotSupportedException {
           // get shallow copy of object
           final j_met06 clone = (j_met06) super.clone();
           clone.doSomething(); // Can invoke overridable method

           // the class has mutable object, need to deep copy those field
           clone.cookies = clone.deepCopy();
           return clone;
           }

           void doSomething() { // Overridable method
           for (int i = 0; i < cookies.length; i++) {
           cookies[i].setValue(\"\" + i);
           }
           }

           HttpCookie[] deepCopy() {
           if (cookies == null) {
           throw new NullPointerException();
           }

           // implements deep copy
           List<HttpCookie> cloned_cookie = new ArrayList<>();
           // ...
           return (HttpCookie[]) cloned_cookie;
           }
          }

          class j_met06_ext extends j_met06 {
           j_met06_ext(HttpCookie[] c) {
           super(c);
           }

           public Object clone() throws CloneNotSupportedException {
           final j_met06_ext clone = (j_met06_ext) super.clone();
           clone.doSomething();
           return clone;
           }

           void doSomething() { // Erroneously executed
           for (int i = 0;i < cookies.length; i++) {
           cookies[i].setDomain(i + \".xxx.com\");
           }
           }

           public static void main(String[] args)
           throws CloneNotSupportedException {
           HttpCookie[] hc = new HttpCookie[20];
           for (int i = 0 ; i < hc.length; i++){
           hc[i] = new HttpCookie(\"cookie\" + i,\"\" + i);
           }
           // shallow copy was invoked, the original object can be modified
           j_met06 badcookie = new j_met06_ext(hc);
           badcookie.clone();
           }
          }
    good:
      java:
        - |
          import java.net.HttpCookie;
          import java.util.ArrayList;
          import java.util.List;

          class j_met06 implements Cloneable {
           HttpCookie[] cookies;

           j_met06(HttpCookie[] c) {
           cookies = c;
           }

           public Object clone() throws CloneNotSupportedException {
           // get shallow copy of object
           final j_met06 clone = (j_met06) super.clone();
           clone.doSomething(); // Can invoke overridable method

           // the class has mutable object, need to deep copy those field
           clone.cookies = clone.deepCopy();
           return clone;
           }

           final void doSomething() { // not overridable method
           for (int i = 0; i < cookies.length; i++) {
           cookies[i].setValue(\"\" + i);
           }
           }

           final HttpCookie[] deepCopy() { // not overridable method
           if (cookies == null) {
           throw new NullPointerException();
           }

           // implements deep copy
           List<HttpCookie> cloned_cookie = new ArrayList<>();
           // ...
           return (HttpCookie[]) cloned_cookie;
           }
          }

          class j_met06_ext extends j_met06 {
           j_met06_ext(HttpCookie[] c) {
           super(c);
           }

           public Object clone() throws CloneNotSupportedException {
           final j_met06_ext clone = (j_met06_ext) super.clone();
           clone.doSomething();
           return clone;
           }

           void doSomething() { // will not be called
           for (int i = 0;i < cookies.length; i++) {
           cookies[i].setDomain(i + \".xxx.com\");
           }
           }

           public static void main(String[] args)
           throws CloneNotSupportedException {
           HttpCookie[] hc = new HttpCookie[20];
           for (int i = 0 ; i < hc.length; i++){
           hc[i] = new HttpCookie(\"cookie\" + i,\"\" + i);
           }
           // deep copy was invoked, the original object cannot be modified
           j_met06 badcookie = new j_met06_ext(hc);
           badcookie.clone();
           }
          }
  language: Java
  likelihood: P
  master_id: 68
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, the overridable method ${si.var},
    has been overridden by clone().
  name: Do not call overridable methods in clone()
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    owasp:
      - A5
      - A2
- alias: {}
  category: VUL
  code: MSC61-J
  cost: H
  csv_string:
    - M61J1
    - M61J0
  desc: >-
    The program is using weak cryptographic algorithms for security sensitive
    code.
  details: >
    #### Abstract

    The program is using weak cryptographic algorithms for security sensitive
    code.


    #### Explanation

    Security and privacy sensitive information should be using strong encryption
    algorithms. Strong algorithms may include AES with Galois/Counter Mode (GCM)
    and AES with Cipher Block Chaining mode.
  examples:
    bad:
      java:
        - |-
          import javax.crypto.*;
          import java.io.UnsupportedEncodingException;
          import java.security.InvalidKeyException;
          import java.security.NoSuchAlgorithmException;

          public class j_msc61_0 {
           public static byteArray[] encryption(String strToBeEncrypted) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, UnsupportedEncodingException, BadPaddingException, IllegalBlockSizeException {
           
           // DES is a weak encryption algorithm
           // AES is also weak, however, if AES is to be used
           // GCM (Galois/Counter Mode) will do the encryption
           SecretKey key = KeyGenerator.getInstance(\"DES\").generateKey();
           Cipher cipher = Cipher.getInstance(\"DES\");
           cipher.init(Cipher.ENCRYPT_MODE, key);

           // Encode bytes as UTF8; strToBeEncrypted contains
           // the input string that is to be encrypted
           byteArray[] encoded = strToBeEncrypted.getBytes(\"UTF8\");

           // Perform encryption
           byteArray[] encrypted = cipher.doFinal(encoded);
           return encrypted;
           }
          }
    good:
      java:
        - |-
          import javax.crypto.*;
          import java.io.UnsupportedEncodingException;
          import java.security.InvalidKeyException;
          import java.security.NoSuchAlgorithmException;

          public class j_msc61_0 {
           
           public static SecretKey genKey() {
           // DES is a weak encryption algorithm
           // AES is also weak, however, if AES is to be used
           // GCM (Galois/Counter Mode) will do the encryption
           try {
           KeyGenerator keygen = KeyGenerator.getInstance(\"AES\");
           keygen.init(128);
           return keygen.generateKey();
           } catch (NoSuchAlgorithmException e) {
           // handle exception
           ...
           }
           }
           
           public static byteArray[] encryption(String strToBeEncrypted, SecretKey seckey) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, UnsupportedEncodingException, BadPaddingException, IllegalBlockSizeException {
           Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\");
           // please consult example in CERT-J site for MSC61-J
           ...
           }
          }
  language: Java
  likelihood: P
  master_id: 69
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, the encryption method ${si.var} in
    function ${si.func} used is generally weak and insecure.
  name: Security critical code must avoid using insecure or weak crypto algorithms
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '325'
      - '326'
    owasp:
      - A3
- alias: {}
  category: VUL
  code: OBJ09-J
  cost: L
  csv_string:
    - O09J
  desc: Comparing class names may cause mix and match attacks.
  details: >
    #### Abstract

    Comparing class names may cause mix and match attacks.


    #### Explanation

    Two classes are the same class only if they have the same qualified names.
    Classes with the same name may have different package names. Also distinct
    class loaders (or different instances of the class loader) will result in
    different classes with the same fully qualified names. 
  examples:
    bad:
      java:
        - |-
          import java.lang.String;
          public class j_obj09_1 {
           void callComp(Boolean v) {
           Class cls1 = getClass();
           Class cls2 = String.class;
           if(v) {
           badComp1(cls1.getName()); 
           } else {
           badComp2(cls1.getName(), cls2.getName());
           }
           }
           Boolean badComp1(String clsName) {
           if(clsName.equals(\"j_obj09_0\")) {
           return true;
           }
           else {
           return false;
           }
           } 

           Boolean badComp2(String name1, String name2)
           {
           if(name1.equals(name2)) {
           return true;
           }
           else {
           return false;
           }
           }
          }
    good: {}
  language: Java
  likelihood: U
  master_id: 70
  msg_templ: >-
    In file ${si.filename} function ${si.func}, line ${si.line}, name is used to
    compare classes.
  name: Comparing class names may cause mix and match attacks
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- alias: {}
  category: VUL
  code: OBJ11-J
  cost: M
  csv_string:
    - O11J0
  desc: >-
    Constructors throwing exceptions could leave the object in a partially
    initialized state.
  details: >
    #### Abstract

    Constructors throwing exceptions could leave the object in a partially
    initialized state.


    #### Explanation

    During objection construction, the object is in a partially initialized
    state. Throwing exceptions during construction could leave the object in an
    unstable state.
  examples:
    bad:
      java:
        - |-
          import java.io.IOException;

          public class obj11_0 {
           public obj11_0()
           {
           // by throwing an exception in constructor
           // attacker can capture a reference to the partially initialized object of the obj11_0 class since
           // the object reference remains in the garbge collector
           if (!performVerification()) {
           throw new SecurityException(\"Access Denied!\");
           }
           }

           private boolean performVerification() {
           return false; // Returns true if data entered is valid, else false
           // Assume that the attacker always enters an invalid value
           }

           public void greeting() {
           System.out.println(\"Welcome user!\");
           }
          }
    good: {}
  language: Java
  likelihood: P
  master_id: 71
  msg_templ: >-
    Constructor ${si.func}, is throwing exception ${si.var} in ${si.filename},
    line ${si.line}.
  name: Constructors should not throw exceptions
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- alias: {}
  category: VUL
  code: SEC02-J
  cost: M
  csv_string:
    - C02J1
    - C02J0
  desc: >-
    The program has security checks whose sources are possibly from an untrusted
    origin.
  details: >
    #### Abstract

    The program has security checks whose sources are possibly from an untrusted
    origin.


    #### Explanation

    Untrusted code may have been from many different sources. The check method
    could be bypassed through overriding. The checked object may be overridden
    also after the check. Even if the object is saved after passing the security
    check, the copy method itself may not be sufficient if the method is not
    thorough enough (such as shallow copy).
  examples:
    bad:
      java:
        - |-
          import java.io.FileNotFoundException;
          import java.io.RandomAccessFile;
          import java.security.AccessController;
          import java.security.PrivilegedAction;
          import java.io.IOException;

          public class sec02_0 {
           public static RandomAccessFile openFile(final java.io.File f) {
           // getPath() can be extended, thus security check can pass the first time, 
           // but getPath() changed the second time, bypass the good check
           if (f.getPath().contains(\"passwd\")){
           return null;
           };
           // ...
           return (RandomAccessFile) AccessController.doPrivileged(new PrivilegedAction<Object>() {
           public Object run() {
           try {
           return new RandomAccessFile(f, \"r\");
           } catch (FileNotFoundException e) {
           e.printStackTrace();
           }
           return null;
           }
           });
           }
          }
    good:
      java:
        - |-
          import java.io.FileNotFoundException;
          import java.io.RandomAccessFile;
          import java.security.AccessController;
          import java.security.PrivilegedAction;
          import java.io.IOException;

          public class sec02_0 {
           public static RandomAccessFile openFile(final java.io.File f) {
           // get a copy through getPath(), but not a clone
           final java.io.File copy = new java.io.File(f.getPath());
           // use copy of path later on
           if (copy.getPath().contains(\"passwd\")){
           return null;
           };
           // ...
           return (RandomAccessFile) AccessController.doPrivileged(new PrivilegedAction<Object>() {
           public Object run() {
           try {
           return new RandomAccessFile(copy.getPath(), \"r\");
           } catch (FileNotFoundException e) {
           e.printStackTrace();
           }
           return null;
           }
           });
           }
          }
  language: Java
  likelihood: P
  master_id: 72
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, the method ${si.func} is returning
    untrusted sources to ${si.var} under assumed checked security.
  name: Security check code should not be based on untrusted sources
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '269'
      - '862'
    owasp:
      - A2
      - A6
- alias: {}
  category: VUL
  code: SEC06-J
  cost: M
  csv_string:
    - C06J3
    - C06J2
    - C06J1
    - C06J0
  desc: >-
    The program is using the default automatic signature verifier provided by
    the URLClassLoader and java.util.jar.
  details: >
    #### Abstract

    The program is using the default automatic signature verifier provided by
    the URLClassLoader and java.util.jar.


    #### Explanation

    Using these packages as default automatic signature verification is not
    sufficient when the signature is used for privilege elevation purposes. It
    only performs an integrity check. Also it only uses a public key which may
    have been maliciously modified for authentication of loaded classes.
  examples:
    bad:
      java:
        - |-
          package io.xc5.cert;
          import java.io.IOException;
          import java.lang.reflect.InvocationTargetException;
          import java.lang.reflect.Method;
          import java.lang.reflect.Modifier;
          import java.net.JarURLConnection;
          import java.net.URL;
          import java.net.URLClassLoader;
          import java.util.jar.Attributes;
          import java.security.GeneralSecurityException;
          import java.security.KeyStore;
          import java.security.cert.Certificate;
          import java.io.FileInputStream;

          public class j_sec06_1 extends URLClassLoader {
           private URL url;
           public j_sec06_1(URL url) {
           super(new URL[] { url });
           this.url = url;
           }

           public void invokeClass(String name, String[] args)
           throws ClassNotFoundException, NoSuchMethodException,
           InvocationTargetException , GeneralSecurityException, IOException {
           Class c = loadClass(name);
           Method m = c.getMethod(\"getValue\", new Class[] { args.getClass() });
           m.setAccessible(true);
           try {
           m.invoke(null, new Object[] { args });
           } catch (IllegalAccessException e) {
           System.out.println(\"Access denied\");
           }
           }
          }
    good:
      java:
        - |-
          package io.xc5.cert;
          import java.io.IOException;
          import java.lang.reflect.InvocationTargetException;
          import java.lang.reflect.Method;
          import java.lang.reflect.Modifier;
          import java.net.JarURLConnection;
          import java.net.URL;
          import java.net.URLClassLoader;
          import java.util.jar.Attributes;
          import java.security.GeneralSecurityException;
          import java.security.KeyStore;
          import java.security.cert.Certificate;
          import java.io.FileInputStream;

          public class j_sec06_fp_1 extends URLClassLoader {
           private URL url;
           public j_sec06_fp_1(URL url) {
           super(new URL[] { url });
           this.url = url;
           }

           Boolean verifyClass(Class c) throws ClassNotFoundException, NoSuchMethodException,
           InvocationTargetException, GeneralSecurityException,
           IOException {
           Certificate[] certs = c.getProtectionDomain().getCodeSource().getCertificates();
           if (certs == null) {
           return false;
           }
           else { 
           KeyStore ks = KeyStore.getInstance(\"JKS\");
           ks.load(new FileInputStream(\"sec06.jks\"), \"loadkeystorepassword\".toCharArray());
           Certificate pubCert = ks.getCertificate(\"sec06\");
           // Check with the trusted public key, else throws exception
           certs[0].verify(pubCert.getPublicKey());
           return true;
           }
           }

           public void invokeClass(String name, String[] args)
           throws ClassNotFoundException, NoSuchMethodException,
           InvocationTargetException , GeneralSecurityException, IOException {
           Class c = loadClass(name);
           Method m = c.getMethod(\"getValue\", new Class[] { args.getClass() });
           m.setAccessible(true);
           
           // use customized, non-default verification method declared above
           if(verifyClass(c)) {
           try {
           m.invoke(null, new Object[] { args });
           } catch (IllegalAccessException e) {
           System.out.println(\"Access denied\");
           }
           }
           }
          }
  language: Java
  likelihood: P
  master_id: 73
  msg_templ: >-
    In file ${si.filename}, function ${si.func}, line ${si.line}, method
    ${si.var} uses the default automatic signature verification by
    URLClassLoader. 
  name: >-
    The default automatic signature verifier provided by URLClassLoader and
    java.util.jar should not be used
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '256'
      - '295'
      - '285'
      - '862'
    owasp:
      - A2
      - A3
- alias: {}
  category: VUL
  code: FIO02-C
  cost: M
  csv_string:
    - F02C6
    - F02C5
    - F02C4
    - F02C3
    - F02C2
    - F02C1
    - F02C0
  desc: >-
    Names may constain characters that affect accuracy of validation.
    Furthermore, they may consist of comppnents that are symbolic links.
    Canonicalizing names is needed to ensure validity of name.
  details: >
    #### Abstract

    Path and directory names from untrusted source should be canonicalized and
    validated.


    #### Explanation

    Path names, directory names and file names may contain characters that make
    validation difficult and inaccurate. Furthermore, any path name component
    can be a symbolic link, which further obscures the actual location or
    identity of a file. To simplify file name validation, it is recommended that
    names be translated into their canonical form. Canonicalizing file names
    makes it much easier to verify a path, directory, or file name by making it
    easier to compare names. Because the canonical form can vary between
    operating systems and file systems, it is best to use
    operating-system-specific mechanisms for canonicalization.
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>
          #include <stdlib.h>

          FILE* f_open(char* fname, FILE *fptr)
          {
              fptr = fopen(fname, "r");
              return fptr;
          }

          int main(int argc, char **argv[])
          {
            FILE *fptr;
            
            if (!verify_file(*argv[1])) {
              printf("error
          ");
              exit(1);
            }
            else {
              fptr = f_open(*argv[1], fptr);
            }
            printf("File opened %x
          ", fptr);
            // ...
            exit(0);
          }
    good:
      c:
        - |-
          #include <stdio.h>
          #include <stdlib.h>

          FILE* f_open(char* fname, FILE *fptr)
          {
              fptr = fopen(fname, "r");
              return fptr;
          }

          char *sanitize(char *fname);


          int main(int argc, char **argv[])
          {
            FILE *fptr;
            
            if (!verify_file(sanitize(*argv[1]))) {  // sanitize file name first
              printf("error
          ");
              exit(1);
            }
            else {
              fptr = f_open(*argv[1], fptr);
            }
            printf("File opened %x
          ", fptr);
            // ...
            exit(0);
          }
  language: c,c++
  likelihood: P
  master_id: 74
  msg_templ: >-
    In ${si.filename}, line ${si.line}, the function ${si.func} is opening a
    file without canonicalizing its name which may come from tainted source.
  name: Canonicalize path names originating from tainted sources
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '22'
      - '23'
      - '28'
      - '40'
      - '41'
      - '59'
      - '73'
- category: VUL
  code: STR07-C
  cost: MEDIUM
  desc: ''
  details: ''
  examples:
    bad: {}
    good: {}
  language: c,c++
  likelihood: PROBABLE
  master_id: 75
  msg_templ: ''
  name: Use the bounds-checking interfaces for string manipulation
  severity: HIGH
- category: BAD_PRACTICE
  code: POS02-C
  cost: HIGH
  desc: ''
  details: ''
  examples:
    bad: {}
    good: {}
  language: c,c++
  likelihood: LIKELY
  master_id: 76
  msg_templ: ''
  name: Follow the principle of least privilege
  severity: HIGH
- category: VUL
  code: POS36-C
  cost: MEDIUM
  desc: ''
  details: >-
    #### Abstract

    Correct order of privilege revocation is not maintained in the program.


    #### Explanation

    setgid() must be run with superuser privileges, whereas setuid() will leave
    the effective user ID as nonzero. It is possible to regain group privileges
    with incorrect relinquishment order. Vulnerability might occur as attacker
    is able to regain the original group privileges. Hence, the order of
    setgid() and setuid() must be properly maintained, i.e. setgid() first.
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>
          #include <unistd.h>

          void func(){
              int uid_stat = setuid(getuid());
              int gid_stat = setgid(getfid());

              // Possible to regain group privileges because of incorrect order
              // Vulnerability allowing execution of arbitrary code
          }
    good:
      c:
        - |-
          #include <stdio.h>
          #include <unistd.h>

          void func() {
              int gid_stat = setgid(getgid());
              int uid_stat = setuid(getuid());
              
              // Correct order of privilege relinquishment
          }
  language: c,c++
  likelihood: PROBABLE
  master_id: 77
  msg_templ: ''
  name: Observe correct revocation order while relinquishing privileges
  severity: HIGH
- alias: {}
  category: VUL
  code: MSC62-J
  cost: L
  csv_string:
    - M62J1
    - M62J0
  desc: >-
    Storing passwords as cleartext risk these passwords exposed in a lots of
    ways. Using hash functions that are computationally feasible whose decoding
    are not computationally feasible is an acceptable. Users can test equality
    of passwords using their hash values.
  details: >
    #### Abstract

    Storing passwords in plain text may cause these passwords to be exposed in
    various ways. It is recommended to use a hash function that is
    computationally feasible but its decoding is not computationally feasible.
    Users can use the hash value to test whether the passwords are equivalent.


    #### Explanation

    Passwords should not be stored in clear text. To avoid exposure of them,
    they are typically stored in hash functions so that direct comparison is
    possible without requiring expensive encryption algorithms.
  examples:
    bad:
      java:
        - |-
          import java.security.MessageDigest;
          import java.security.NoSuchAlgorithmException;
          import java.security.SecureRandom;

          public class j_msc62_ex {
            private void regUser1(String userName, byte[] passwd, String regType) {
              try {
                String salt = genSalt();
                String combPasswd = salt + passwd;
                byte[] secureHash = secureHash(combPasswd.getBytes());
                byte[] noSaltPasswd = secureHash(passwd);
                byte[] unsecureHash = unSecureHash(combPasswd.getBytes());
                if(regType.equals("NO_SALT_HASH")) {
                  saveUser(userName, passwd);             // MSC62-J, no salt, no hash
                } else if(regType.equals("NO_SALT")) {
                  saveUser(userName, noSaltPasswd);       // MSC62-J no salt
                } else if(regType.equals("UNSECURE_HASH")){
                  saveUser(userName, unsecureHash);       // MSC62-J unsecure hash
                } else {
                  saveUser(userName, secureHash);         // 
                }
              } catch (NoSuchAlgorithmException e) {
                e.printStackTrace();
              }
            } 
            private byte[] unSecureHash(byte [] passwd) throws NoSuchAlgorithmException{
              MessageDigest msgDigest = MessageDigest.getInstance("MD5");  // not secure hash algorithm
              return msgDigest.digest(passwd);
            }
            // .. other code
            private byte[] secureHash(byte [] passwd) throws NoSuchAlgorithmException{
              MessageDigest msgDigest = MessageDigest.getInstance("SHA256");  // secure hash algorithm
              return msgDigest.digest(passwd);
            }

            private void testRegUser(String userName, String passwd, String regType) {
              regUser1(userName, passwd.getBytes(), regType);
              regUser2(userName, passwd);  // MSC62-J passwd is String type
            }

          } 
    good:
      java:
        - |-
          import java.security.MessageDigest;
          import java.security.NoSuchAlgorithmException;
          import java.security.SecureRandom;

          public class j_msc62_ex {
            private void regUser1(String userName, byte[] passwd, String regType) {
              try {
                String salt = genSalt();
                String combPasswd = salt + passwd;
                byte[] secureHash = secureHash(combPasswd.getBytes());
                byte[] noSaltPasswd = secureHash(passwd);
                byte[] unsecureHash = unSecureHash(combPasswd.getBytes());
                if(regType.equals("NO_SALT_HASH")) {
                  handleError("NO_SALT_HASH");;             // MSC62-J, no salt, no hash
                } else if(regType.equals("NO_SALT")) {
                  handleError("NO_SALT_HASH");        // MSC62-J no salt
                } else if(regType.equals("UNSECURE_HASH")){
                  handleError("UNSECURE_HASH");       // MSC62-J unsecure hash
                } else {
                  saveUser(userName, secureHash);         
                }
              } catch (NoSuchAlgorithmException e) {
                e.printStackTrace();
              }
            } 
            private byte[] unSecureHash(byte [] passwd) throws NoSuchAlgorithmException{
              MessageDigest msgDigest = MessageDigest.getInstance("MD5");  // not secure hash algorithm
              return msgDigest.digest(passwd);
            }
            
            private byte[] secureHash(byte [] passwd) throws NoSuchAlgorithmException{
              MessageDigest msgDigest = MessageDigest.getInstance("SHA256");  // secure hash algorithm
              return msgDigest.digest(passwd);
            }

            private void testRegUser(String userName, String passwd, String regType) {
              regUser1(userName, passwd.getBytes(), regType);
              regUser2(userName, passwd);  // MSC62-J passwd is String type
            }

          } 
  language: java
  likelihood: P
  master_id: 80
  msg_templ: >-
    In ${si.filename}, line ${si.line}, the function ${si.func} is using an
    unsecure hash to store passwords.
  name: >-
    Passwords should be stored using a secure hash to prevent being exposed to
    malicious users.
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '522'
- alias: {}
  category: VUL
  code: IDS03-J
  cost: M
  csv_string:
    - I03J2
    - I03J1
    - I03J0
  desc: >-
    Log entry containing unsanitized user input can lead to log injection attack
    and compromise data across a trust boundary.
  details: >-
    #### Abstract

    Sensitive data leakage arises When unsanitized user input are logged or put
    out in standard output (stdout) device.


    #### Explanation

    Logging unsanitized user input can result in sensitive data leakage across a
    trusted boundary. A log injection attack may arise leading to further
    information leakage. This vulnerability is not limited to Java programs.
    C/C++ programs can subject to the same attack as show in the C example.
  examples:
    bad:
      c:
        - "\nusing namespace mychain;\nusing namespace MyContract::Sample;\n\nclass demoBranch:public Contract {\npublic:\n    TransferPtr m_ptransfer;\n\n    demoBranch() {\n        m_ptransfer = GetTransferM();\n    }\n    INTERFACE void Init() {\n        InitRoot();\n    }\n    \n    INTERFACE void LeakToLog(const std::string& sAccountName ) {\n        if(!m_ptransfer) {\n            Revert(\"error\");\n        }\n\n\t// get account, balance etc\n        AccountMMapPtr pAccountMap = m_ptransfer->get_accounts();\n        if (!pAccountMap) {\n            Revert(\"AcountMMapPtr Error.\");\n        }\n\n        // obtain user account number and name\n\t// ...\n\n\t//\n        int32_t iBalanceRmb = pBalance->get_rmb();\n        std::string sBalanceTopic = std::to_string(iBalanceRmb);\n        std::vector<std::string> leak_msg;\n        leak_msg.push_back(sAccountName);\n        leak_msg.push_back(sBalanceTopic);\n\t\n        if (iBalanceRmb < 1) {\n          Log(std::string(\"acc_bal\"), leak_msg);\n        }\n    }\n};\nINTERFACE_EXPORT(demoBranch, (Init) (LeakToLog))\n"
      java:
        - |
          locationClient = new LocationClient(this, this, this);
          locationClient.connect();
          currentUser.setLocation(locationClient.getLastLocation());
          ... 

          catch (Exception e) {
              AlertDialog.Builder builder = new AlertDialog.Builder(this);
              builder.setMessage("Application Error.");
              AlertDialog alert = builder.create();
              alert.show();

              // user location is written to log
              Log.e("Example", "Caught exception: " + e + " User:" + User.toString());
          }
    good:
      c:
        - "\nusing namespace mychain;\nusing namespace MyContract::Sample;\n\nclass demoBranch:public Contract {\npublic:\n    TransferPtr m_ptransfer;\n\n    demoBranch() {\n        m_ptransfer = GetTransferM();\n    }\n    INTERFACE void Init() {\n        InitRoot();\n    }\n    \n    INTERFACE void LeakToLog(const std::string& sAccountName ) {\n        if(!m_ptransfer) {\n            Revert(\"error\");\n        }\n\n\t// get account, balance etc\n        AccountMMapPtr pAccountMap = m_ptransfer->get_accounts();\n        if (!pAccountMap) {\n            Revert(\"AcountMMapPtr Error.\");\n        }\n\n        // obtain user account number and name\n\t// ...\n\n\t//\n        int32_t iBalanceRmb = pBalance->get_rmb();\n        std::string sBalanceTopic = std::to_string(iBalanceRmb);\n        std::vector<std::string> leak_msg;\n        leak_msg.push_back(sAccountName);\n        leak_msg.push_back(sBalanceTopic);\n\n        if (iBalanceRmb < 1) {\n\t  // Sanitize and clean up message before logging\n          Log(std::string(\"acc_bal\"), SanitizeUser(leak_msg));\n        }\n    }\n};\nINTERFACE_EXPORT(demoBranch, (Init) (LeakToLog))\n"
      java:
        - |
          locationClient = new LocationClient(this, this, this);
          locationClient.connect();
          currentUser.setLocation(locationClient.getLastLocation());
          ... 

          catch (Exception e) {
              AlertDialog.Builder builder = new AlertDialog.Builder(this);
              builder.setMessage("Application Error.");
              AlertDialog alert = builder.create();
              alert.show();

              // user location is "sanitized" being written to log
              Log.e("Example", "Caught exception: " + e + " User:" + sanitizeUser(User.toString()));
          }
  language: java
  likelihood: P
  master_id: 81
  msg_templ: ''
  name: Unsanitized user input should not appear in log
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '117'
      - '150'
      - '144'
    owasp:
      - A3
    p3c-sec:
      - '2'
- alias: {}
  category: VUL
  code: ARR38-C
  cost: M
  csv_string:
    - A38C2
    - A38C1
    - A38C0
  desc: >-
    The program is calling a library function with a pointer and a size
    parameter. The two parameters, when combined, will be outside of the legal
    range of the object.
  details: >-
    #### Abstract

    Make sure library functions don't form invalid pointers


    #### Explanation

    Certain functions that make changes to arrays or objects take at least two
    arguments.

    Therefore, supplying invalid or wrong arguments to such functions might form
    an 

    incorrect pointer resulting in undefined pointer.
  examples:
    bad:
      c:
        - |-
          #include <stdlib.h>
          #include <string.h>

          void func(size_t SIZE_LIMIT)
          {
              char *p = (char *)malloc(SIZE_LIMIT);
              /* ...  */

              // adding 100 is out of bounds
              const size_t n = SIZE_LIMIT + 100;
              /* ...  */
              memset(p, 0, n);
          }
    good:
      c:
        - |-
          #include <stdlib.h>
          #include <string.h>

          void func(size_t SIZE_LIMIT)
          {
              char *p = (char *)malloc(SIZE_LIMIT);
              /* ...  */

              // ensures that it will not go past last element
              const size_t n = SIZE_LIMIT - 1;
              /* ...  */
              memset(p, 0, n);
          }
  language: c,c++
  likelihood: L
  master_id: 82
  msg_templ: >-
    In ${si.filename}, line ${si.line}, the function ${si.func} is calling a
    library function with a pointer and a size parameter.
  name: Array out of bounds with the use of library functions
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '787'
      - '119'
      - '125'
- category: VUL
  code: EXP34-C
  cost: MEDIUM
  desc: The program is accessing illegal memory through a pointer with a value.
  details: >
    #### Abstract

    The program is accessing illegal memory through a pointer with value. This
    vulnerability is the same as the Xcalibyte NPD rule.


    #### Explanation

    Please refer to rule NPD in the Xcalibyte vulnerability list for detailed
    explanation.
  examples:
    bad:
      c:
        - |-
          extern int bar(int);

          int assign(int* a)
          {
           int i = bar(*a) // dereference a
           return i;
          }

          int foo(void)
          {
           int *p = 0; // p as a pointer has been initialized to 0 (null)
           assign(p);
          }
      java:
        - |-
          class User {
           public String getName() {
           return null;
           }
          }

          class Bar {
           private User findUser(String uid) {
           if (user.containsKey(uid)) {
           return user.get(uid);
           }
           else
           return null;
           }
           public void Npd(String uid) {
           // do something
           // ...
           User user = findUser(uid); // Throws NPE if \"user\" has not been properly initialized
           String getName() {
           return null;
           }
           }
          }
    good: {}
  language: c,c++
  likelihood: LIKELY
  master_id: 83
  msg_templ: >-
    In ${si.filename}, line ${si.line}, the function ${si.func} is accessing
    illegal memory through a pointer with value.
  name: Do not perform a dereference using a null pointer
  severity: HIGH
- category: VUL
  code: FIO47-C
  cost: LOW
  desc: >-
    The program is calling a function with a number of parameter(s) that are
    used differently from the prototype declaration.
  details: >
    #### Abstract

    The program is calling a function with number of parameter(s) that are used
    different from that of the prototype declaration.


    #### Explanation

    In a call site, the number of actual parameters passed is different from
    that of the function declaration. If the actuals passed is less than that of
    the declaration, the missing actual will ended up being \"wild\" and could
    cause unpreditable behavior.
  examples:
    bad:
      c:
        - |-
          int foo(int a, int guard)
          {
              int x = 0;
              int result = 0;
              if (guard != 0)
                  result = a * x;

              // missing one parameter, and \"guard\" will have random value during execution at this point
              foo(result); 
              return 0;
          }
    good:
      c:
        - |-
          int foo(int a, int guard)
          {
              int x = 0;
              int result = 0;
              if (guard != 0)
                  result = a * x;
              foo(result, guard); // no parameters missing
              return 0;
          }
  language: c,c++
  likelihood: UNLIKELY
  master_id: 84
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, the arguments in function
    ${si.func} do not match the function declaration in file ${si.filename},
    line ${si.line}.
  name: Avoid using conflicting types to a format string
  severity: HIGH
- category: VUL
  code: MEM30-C
  cost: MEDIUM
  desc: The program is accessing memory that has been freed.
  details: >
    #### Abstract

    The program is accessing memory that has been freed.


    #### Explanation

    Use after free is a variation of dangling pointer reference. It typically
    occurs when the pointer is not updated after the memory object it points to
    has been freed. This pointer will be pointing to inappropriate memory
    leading to unauthorized access when the pointer is used.
  examples:
    bad:
      c:
        - |-
          #include <stddef.h>

          int g = 2;

          void my_free(void *p)
          {
              if (p != NULL)
                  free(p); // free p
          }

          int main()
          {
              int i, j, *p, *q;
              p = malloc(10 * sizeof(int));
              if (p == NULL)
                  return 1;
              for (i = 0; i < 10; ++i)
                  p[i] = i;
              q = p;
              my_free(p); // p is freed
              j = 0;
              for (i = 0; i < 10; ++i)
                  j += q[i]; // Use after free here (note the statement q = p), read of q[i] is illegal
              return j;
          }
    good:
      c:
        - |-
          #include <stddef.h>

          int g = 2;

          void my_free(void *p)
          {
              if (p != NULL)
                  free(p); // free p
          }

          int main()
          {
              int i, j, *p, *q;
              p = malloc(10 * sizeof(int));
              if (p == NULL)
                  return 1;
              for (i = 0; i < 10; ++i)
                  p[i] = i;

              // do not free p

              j = 0;
              for (i = 0; i < 10; ++i)
                  j += q[i]; 
              return j;
          }
  language: c,c++
  likelihood: LIKELY
  master_id: 85
  msg_templ: >-
    In ${si.filename}, line ${si.line}, the function ${si.func} is accessing
    memory that has been freed.
  name: Freed memory should not be accessed or used again
  severity: HIGH
- category: VUL
  code: MEM50-CPP
  cost: MEDIUM
  desc: >-
    The program reads a pointer variable that is already freed which may lead to
    an undefined behaviour that is unnoticeable.
  details: >
    #### Abstract

    The program has referenced memory after it has been freed. It can cause the
    program to crash or an unexpected program behavior.


    #### Explanation

    Use after free is a variation of dangling pointer reference. It typically
    occurs when the pointer is not updated after the memory object it points to
    has been freed. This pointer will be pointing to inappropriate memory
    leading to unauthorized access when the pointer is used.
  examples:
    bad:
      cpp:
        - |-
          int g = 2;

          void my_free(void *p) {
           if (p != NULL)
           free(p); // free p
          }

          int main() {
           int i, j, *p, *q;
           p = malloc(10 * sizeof(int));
           if (p == NULL)
           return 1;
           for (i=0; i < 10; ++i)
           p[i] = i;
           q = p;
           my_free(p); // p is freed
           j = 0;
           for (i=0; i < 10; ++i)
           j += q[i]; // Use after free here (note the statement q = p), read of q[i] is illegal
           return j;
          }
    good: {}
  language: c++
  likelihood: LIKELY
  master_id: 86
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, variable ${so.var} in function
    ${so.func} was used. However, it has been freed at line ${so.line} in file
    ${so.filename}.
  name: Access to freed memory should be prohibited
  severity: HIGH
- alias: {}
  category: VUL
  code: MEM51-CPP
  cost: M
  csv_string:
    - m51P0
  desc: >-
    The program failed to appropriately deallocate memories that were
    dynamically allocated.
  details: >
    #### Abstract

    The program has allocated heap memory but failed to free that piece of
    memory.


    #### Explanation

    Heap memory has been allocated and the allocated memory address is stored in
    a variable of reference (pointer) type. That heap memory has never been
    released after its lifetime has effectively ended and its corresponding
    reference still points to that memory space. This could result in sensitive
    data leakage or unexpected program behavior such as denial of service.
  examples:
    bad:
      cpp:
        - |-
          struct S {
           int *p;
          };

          int main() {
           int *p;
           struct S *s;
           p = malloc(10 * sizeof(int)); // heap memory allocated and pointed to by p
           if (p == NULL)
           return 1;
           s = (struct S*)malloc(sizeof(struct S)); // heap memory allocated and pointed to by s
           if (s == NULL) {
           free(p);
           return 1;
           }
           s->p = p;
           free(s); // only s is freed
           // s->p, which is copied from p is not freed
           return 0;
          }
    good: {}
  language: c++
  likelihood: L
  master_id: 87
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, variable ${si.var} in function
    ${si.func} has not been freed. 
  name: Allocated resources require a proper deallocation
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '401'
- category: VUL
  code: EXP53-CPP
  cost: LOW
  desc: >-
    The program is trying to read a piece of memory that is already declared but
    not yet initialized.
  details: >+
    #### Abstract

    The program is using a variable before it has been initialized.


    #### Explanation

    Stack variables in C and C++ are not initialized by default. Non-static
    global variables are not guaranteed to be zeroed. Their initial values are
    determined by the values that happen to be in their location in memory at
    the time the function is invoked. Doing so will cause an unexpected program
    behavior.

  examples:
    bad:
      cpp:
        - |-
          int assign(int* a)
          {
           return *a; // dereference a
          }

          int main() {
           int a, b;
           b = assign(&a); // call assign with a uninitialized
           printf("value of b = %d\\", b);
           return 0;
          }
    good: {}
  language: c++
  likelihood: UNLIKELY
  master_id: 88
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, variable ${so.var} in function
    ${so.func} has been used but never assigned a value. 
  name: Reading uninitialized memory is prohibited
  severity: MEDIUM
- category: VUL
  code: EXP54-CPP
  cost: MEDIUM
  desc: >-
    The program tries to access the object outside of its lifetime, which will
    result to an undefined behaviour.
  details: >
    #### Abstract

    Dangling pointer has been used to refer to an invalid memory resource.


    #### Explanation

    Dangling pointers are pointers that refer to invalid or inappropriate memory
    resources. Referencing these memory resources may create memory corruption,
    resulting in unpredictable program behavior or system instablity.
  examples:
    bad:
      cpp:
        - |-
          int *assign()
          {
           int *c;
           c = 1;
           return &c;
          }

          int foo()
          {
           int *a;
           a = assign(); // return a stack address and assign to a
           printf(\"assigned value: %d\", a); // use dangling pointer
           return 0;
          }
    good: {}
  language: c++
  likelihood: UNLIKELY
  master_id: 89
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, the memory reference variable
    ${so.var} in function ${so.func} is used. Such variable is first assigned as
    a memory reference that may not be valid in file ${so.filename}, line
    ${so.line}.
  name: Access object only during its lifetime
  severity: HIGH
- alias: {}
  category: VUL
  code: ERR00-J
  cost: M
  csv_string:
    - E00J0
  desc: The program has an exception construct with an empty catch block.
  details: >
    #### Abstract

    Checked exceptions must be handled appropriately.


    #### Explanation

    Exceptions disrupt the expected control flow of the application. The catch
    block must either recover from the exceptional condition or throw an
    exception that is appropriate to the context of the catch block.
  examples:
    bad:
      java:
        - |-
          import java.io.*;

          public class j_err00_0 {

           public void foo0(String fileName) {
           try {
           BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));
           int b;
           while ((b = reader.read()) != -1) {
           System.out.println("byte: " + b);
           }
           } catch (IOException ioe) {
           ioe.printStackTrace(); // print will not recover nor throw exception 
           }
           }

           public void foo1(String fileName) {
           try {
           BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));
           int b;
           while ((b = reader.read()) != -1) {
           System.out.println("byte: " + b);
           }
           } catch (IOException ioe) {
           // do nothing - no recovery of any kind
           }
           }
          }
    good:
      java:
        - |
          import java.io.*;

          public class j_err00_0 {

           public void foo0(String fileName) {
           try {
           BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));
           int b;
           while ((b = reader.read()) != -1) {
           System.out.println("byte: " + b);
           }
           } catch (IOException ioe) {
           throw new IllegalIOException(ioe.toString()); // we assume there is such exception handler here
           }
           }

           public void foo1(String fileName) {
           // indentation preserved to better show the difference with \"avoid\" example
           BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));
           int b;
           while ((b = reader.read()) != -1) {
           System.out.println("byte: " + b);
           }

           }
          }
  language: Java
  likelihood: P
  master_id: 90
  msg_templ: >-
    In file ${si.filename}, function ${si.func}, the catch block in line
    ${si.line} is empty.
  name: Exceptions must be handled appropriately
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: L
  standards:
    cwe:
      - '223'
    owasp:
      - A10
- alias: {}
  category: VUL
  code: FIO08-J
  cost: M
  csv_string:
    - F08J0
  desc: >-
    The program doesn't distinguish between characters read and end of the
    stream indicator by the read() method.
  details: >
    #### Abstract

    The program doesn't distinguish between characters read and end of the
    stream indicator by the read() method.


    #### Explanation

    When reading byte data from stream with InputStream.read() and
    Reader.read(), end of stream is indicated with a 32 bit value of -1. Proper
    checking of end of stream must be done before conversion to a byte/char.
  examples:
    bad:
      java:
        - >-
          // read result is cast to byte, loop will halt prematurely if 0xFF is
          reached

          public class j_fio08_0 {
            // ... 
            static void readData(String fileName) throws FileNotFoundException, IOException {
              FileInputStream t = new FileInputStream(fileName);
              try {
                byte data;
                StringBuffer value = new StringBuffer();
                while((data = (byte) t.read()) != -1) {
                  value.append(data);
                }
                System.out.println(value.toString());
              } finally {
                t.close();
              }
            }

            static void readData2(String fileName) throws IOException {
              FileReader fr = new FileReader(fileName);
              try {
                char data;
                StringBuffer sb = new StringBuffer();
                while ((data = (char) fr.read()) != -1) {
                  sb.append(data);
                }
              } finally {
                fr.close();
              }
            }

            static void readData3(String fileName) throws IOException {
              FileReader fr = new FileReader(fileName);
              try {
                byte data;
                StringBuffer sb = new StringBuffer();
                while (true) {
                  int i = fr.read();
                  int j = i;
                  data = (byte) j;
                  if (data == -1) {
                    break;
                  }
                  sb.append(data);
                }
              } finally {
                fr.close();
              }
            }
    good:
      java:
        - "// read result is cast to byte after read and check for end of stream\npublic class j_fio08_0 {\n\n  // ...\n\n  static void readData(String fileName) throws FileNotFoundException, IOException {\n    FileInputStream t = new FileInputStream(fileName);\n    try {\n      int inputbuf;\n      byte data;\n      StringBuffer value = new StringBuffer();\n      while((inputbuf = t.read()) != -1) {\n\tdata = (byte) inputbuf;\n        value.append(data);\n      }\n      System.out.println(value.toString());\n    } finally {\n      t.close();\n    }\n  }\n\n  static void readData2(String fileName) throws IOException {\n    FileReader fr = new FileReader(fileName);\n    try {\n      int inputbuf;\n      char data;\n      StringBuffer sb = new StringBuffer();\n      while (inputbuf = fr.read()) != -1) {\n\tdata = (char)inputbuf;\n        sb.append(data);\n      }\n    } finally {\n      fr.close();\n    }\n  }\n\n  static void readData3(String fileName) throws IOException {\n    FileReader fr = new FileReader(fileName);\n    try {\n      byte data;\n      StringBuffer sb = new StringBuffer();\n      while (true) {\n        int i = fr.read();\n        int j = i;\n        data = (byte) j;\n        if (data == -1) {\n          break;\n        }\n        sb.append(data);\n      }\n    } finally {\n      fr.close();\n    }\n  }"
  language: Java
  likelihood: P
  master_id: 91
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, function ${si.func} does not
    distinguish between characters read and end of the stream indicator by the
    read() method.
  name: Characters or bytes read from a stream and a -1 are different
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- alias: {}
  category: VUL
  code: FIO30-C
  cost: M
  csv_string:
    - F30C1
    - F30C0
  desc: >-
    The program has a format specification that contains a parameter of char
    type (string) with an untrusted source, and hence, is considered tainted.
  details: >
    #### Abstract

    The program has a format specification that contains a parameter of char *
    type (aka string) with an untrusted source and is considered tainted.


    #### Explanation

    Formatted I/O functions can be tricked into overriding or reading the value
    of any arbitrary memory location. When the input source is untrusted it is
    better not to use format strings and related functions to perform I/O
    operation.
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>

          int main(int argc, char *argv[])
          {
           int var_to_hold_content; // the variable where printf will store content of an address
           if (argc > 2) {
           scanf(argv[1]); // get a string from stdin (user input)
           printf(argv[1]); // user can read any address to a variable using a format specification
           }
          }
    good:
      c:
        - |-
          #include <stdio.h>

          int main(int argc, char *argv[])
          {
           int var_to_hold_content; // the variable where printf will store content of an address
           if (argc > 2) {
           scanf(argv[1]); // get a string from stdin (user input)
           fputs(argv[1, stdout]); // do not use printf with format specification
           }
          }
  language: c,c++
  likelihood: L
  master_id: 92
  msg_templ: >-
    In file ${si.filename}, ${si.func}, line ${si.line} the printf family of
    calls were invoked at ${si.var} with format string from user input without
    being sanitized.
  name: String parameters in format specification came from an untrusted source
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '20'
      - '134'
    owasp:
      - A1
      - A5
- alias: {}
  category: VUL
  code: MSC41-C
  cost: M
  csv_string:
    - M41C2
    - M41C1
    - M41C0
  desc: >-
    The program has hard coded sensitive information (such as password and keys)
    in a readable form.
  details: >
    #### Abstract

    The program has hard coded sensitive information (such as password and keys)
    in readable form.


    #### Explanation

    Sensitive information in strings or other readable forms can be examined
    even inside executables.
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>

          #define BUF_SZ 1024

          int check_passwd(const char *s);

          int func(void)
          {
              // program logic
              // ...

              // sensitive data is revealed below 
              if (check_passwd("admin"))
              {
                  // ... continue
              }
              else
              {
                  // handle error
                  // ...
              }
          }
    good:
      c:
        - |+
          #include <stdio.h>

          int check_passwd(const char *s);

          int func(void)
          {
              // user inputs password so no sensitive
              // data leaked
              #define PASSWORD_LEN 10
              char password[PASSWORD_LEN];
              printf("Please enter your password:\n");
              fgets(password, sizeof(password), stdin);

              int check = check_passwd(password);
              memset_s(password, 0, sizeof(password));
              // program logic
              // ...
              if (check)
              {
                  // ... continue
              }
              else
              {
                  // handle error
                  // ...
              }
          }

  language: c,c++
  likelihood: P
  master_id: 93
  msg_templ: >-
    In file ${si.filename}, line ${si.line}， function ${si.func} has hard coded
    sensitive information.
  name: Do not expose hard coded sensitive information in the program
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '798'
      - '311'
      - '259'
    owasp:
      - A3
      - A1
      - A5
- alias: {}
  category: VUL
  code: FIO52-J
  cost: M
  csv_string:
    - F52J2
    - F52J1
    - F52J0
  desc: The program has stored unencrypted sensitive information on the client side.
  details: >
    #### Abstract

    The program has stored unencrypted sensitive information on the client side.


    #### Explanation 

    If unencrypted sensitive information is provided and stored on the client
    side, an attacker could get hold of the information either directly or
    indirectly to attack the client machine.
  examples:
    bad:
      java:
        - |-
          import javax.servlet.ServletException;
          import javax.servlet.annotation.WebServlet;
          import javax.servlet.http.HttpServlet;
          import javax.servlet.http.HttpServletRequest;
          import javax.servlet.http.HttpServletResponse;
          import javax.servlet.http.Cookie;
          interface Login {
           public Boolean isUserValid(String userName, char[] passwd);
          }

          class LoginImpl implements Login {
           public Boolean isUserValid(String userName, char[] passwd) {
           // do the checking
           return true;
           }
          }

          public class fio52_0 {
           protected void doPost(HttpServletRequest request, HttpServletResponse response) {
           
           String username = request.getParameter("username");
           char[] password = request.getParameter("password").toCharArray();
           String userInfo = request.getParameter("userInfo");
           
           Login login = new LoginImpl();
           
           if (request.getCookies()[0] != null &&
           request.getCookies()[0].getValue() != null) {
           String[] value = request.getCookies()[0].getValue().split(";");
           
           if (!login.isUserValid(value[0], value[1].toCharArray())) {
           // Set error and return
           } else {
           // Forward to welcome page
           }
           } else {
           boolean validated = login.isUserValid(username, password);
           
           if (validated) {
           Cookie loginCookie = new Cookie("MyCookie", username + ";" + new String(password));
           Cookie infoCookie = new Cookie("userInfo", username + ":" + userInfo);
           loginCookie.setSecure(false); // set loginCookie sent by any protocol
           response.addCookie(loginCookie); // [FIO52-J] sensitive cookie, should be encrypted or sent through secure protocol 
           infoCookie.setSecure(true); // set infoCookie sent by secure protocol
           \t response.addCookie(infoCookie);
           \t 
           // ... Forward to welcome page
           } else {
           // Set error and return
           }
           }
           } 
          }
    good:
      java:
        - |-
          import javax.servlet.ServletException;
          import javax.servlet.annotation.WebServlet;
          import javax.servlet.http.HttpServlet;
          import javax.servlet.http.HttpServletRequest;
          import javax.servlet.http.HttpServletResponse;
          import javax.servlet.http.Cookie;
          interface Login {
           public Boolean isUserValid(String userName, char[] passwd);
          }

          class LoginImpl implements Login {
           public Boolean isUserValid(String userName, char[] passwd) {
           // do the checking
           return true;
           }
          }

          public class fio52_0 {
           protected void doPost(HttpServletRequest request, HttpServletResponse response) {
           
           String username = request.getParameter("username");
           char[] password = request.getParameter("password").toCharArray();
           String userInfo = request.getParameter("userInfo");
           
           Login login = new LoginImpl();
           
           if (request.getCookies()[0] != null &&
           request.getCookies()[0].getValue() != null) {
           String[] value = request.getCookies()[0].getValue().split(";");
           
           if (!login.isUserValid(value[0], value[1].toCharArray())) {
           // Set error and return
           } else {
           // Forward to welcome page
           }
           } else {
           boolean validated = login.isUserValid(username, password);
           
           if (validated) {
           Cookie loginCookie = new Cookie("MyCookie", username + ";" + new String(password));
           Cookie infoCookie = new Cookie("userInfo", username + ":" + userInfo);
           loginCookie.setHttpOnly(true); // use http protocol only
           loginCookie.setSecure(true); // set loginCookie through secure protocol
           response.addCookie(loginCookie); // sensitive cookie is encrypted and sent through secure protocol 
           infoCookie.setSecure(true); // set infoCookie sent by secure protocol
           response.addCookie(infoCookie);
            
           // ... Forward to welcome page
           } else {
           // Set error and return
           }
           }
           } 
          }
  language: Java
  likelihood: L
  master_id: 94
  msg_templ: >-
    In file ${si.filename}, function ${si.func}, line ${si.line}, unencrypted
    sensitive data ${si.var} are saved on the client side.
  name: Sensitive information should be encrypted if it is stored on the client side
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '522'
      - '200'
      - '312'
    owasp:
      - A2
      - A3
- alias: {}
  category: VUL
  code: IDS07-J
  cost: M
  csv_string:
    - I07J1
    - I07J0
  desc: >-
    The program has passed untrusted data as an input to the Runtime.exec()
    method.
  details: >
    #### Abstract

    The program has passed untrusted data as input to Runtime.exec() method.


    #### Explanation

    Untrusted data passed to Runtime.exec() will expose the system to an
    argument injection attack. The string must be sanitized to get rid of
    characters such as spaces, double quotes, and '-'.
  examples:
    bad:
      java:
        - |
          import java.io.InputStream;

          public class ids07_0 { // example from CERT-J
           public static void main(String[] args) throws Exception {
           
           // dir is input from environment in which the app is running
           String dir = System.getProperty(\"dir\");
           Runtime rt = Runtime.getRuntime();
           
           // input from environment is directly concatenated and fed to Runtime.exec
           // Subject to command line injection
           Process proc = rt.exec(\"bash -c ls \" + dir);
           
           int result = proc.waitFor();
           if (result != 0) {
           System.out.println(\"process error: \" + result);
           }
           // continue processing
           // ...
           }
          }
    good:
      java:
        - |
          import java.io.InputStream;

          public class ids07_0 { // example from CERT-J
           public static void main(String[] args) throws Exception {
           
           // dir is input from environment in which the app is running
           String dir = System.getProperty(\"dir\");
           if (!Pattern.matches(\"[0-9A-Za-z@.]+\", dir) { // whitelist characters allowed
           // report error and exit
           ...
           }
           Runtime rt = Runtime.getRuntime();
           
           // input from environment is directly concatenated and fed to Runtime.exec
           // Subject to command line injection
           Process proc = rt.exec(\"bash -c ls \" + dir);
           
           int result = proc.waitFor();
           if (result != 0) {
           System.out.println(\"process error: \" + result);
           }
           // continue processing
           // ...
           }
          }
  language: Java
  likelihood: P
  master_id: 95
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, the string ${si.var} is not
    sanitized before being passed to runtime exec().
  name: Do not pass untrusted data as input to Runtime.exec() method
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '78'
      - '917'
    owasp:
      - A1
    p3c-sec:
      - '4'
- alias: {}
  category: VUL
  code: IDS15-J
  cost: H
  csv_string:
    - I15J2
    - I15J1
    - I15J0
  desc: Sensitive data should be kept secure including input and output data.
  details: >
    #### Abstract

    Sensitive data should be kept secure, including input and output data.


    #### Explanation

    Sensitive information should not be allowed to leak across trusted
    boundaries. This is to keep integrity and security of different subsystems
    within a complex system. 
  examples:
    bad:
      java:
        - |-
          import javax.servlet.http.HttpServletRequest;

          public class j_ids15_0
          {
           public void setSession(HttpServletRequest request, String attrName, String attrValue) {
           request.getSession().setAttribute(attrName, attrValue);
           }

           public void configSession(HttpServletRequest request) {
           String value = request.getParameter(\"Config\");
           String data = System.getenv(\"APP_DATA\");
           if(value.startsWith(\"APP_DATA\")) {
           setSession(request, \"APP_DATA\", data); // sensitive data
           } else if(value.startsWith(\"SAFE_DATA\")) {
           String safeData = Encryption(data);
           setSession(request, \"SAFE_DATA\", safeData); // data sanitized
           } else {
           setSession(request, \"attr\", \"value\");
           }
           }

           public String Encryption(String data) {
           // encrypt the input data
           // ...
           String safeData = data.replace(\"a\", \"z\");
           return safeData;
           }
          }
    good: {}
  language: Java
  likelihood: L
  master_id: 96
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, sensitive data ${si.var} in
    function ${si.func} is leaked outside a trust boundary.
  name: Sensitive data (both input and output) should be sanitized/normalized
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '523'
      - '200'
      - '284'
    owasp:
      - A2
      - A5
    p3c-sec:
      - '1'
      - '7'
- alias: {}
  category: VUL
  code: MSC03-J
  cost: M
  csv_string:
    - M03J0
  desc: The program has hard coded sensitive information.
  details: >
    #### Abstract

    The program has hard coded sensitive information.


    #### Explanation

    Security and privacy related sensitive information should be retrieved at
    execution time from a secured file. Java executables are in the form of byte
    code and could be easily reverted back to source code form with the
    information in plain text.
  examples:
    bad:
      java:
        - |-
          import java.net.InetAddress;
          import java.net.UnknownHostException;
          import java.sql.Connection;
          import java.sql.DriverManager;
          import java.sql.SQLException;

          public class msc03_0 {
           public final Connection getConnection() throws SQLException, UnknownHostException {
           
           // hard coded IP address in String
           String ipAddress = new String(\"184.15.254.1\");
           if (InetAddress.getByName(ipAddress).isAnyLocalAddress()){
           // hard coded username and password
           return DriverManager.getConnection(\"dbhost:mysql://localhost/mydb\", \"7f4j9vj\", \"xsi9j2nn8\");
           }
           return DriverManager.getConnection(\"dbhost:mysql://localhost/dbName\", \"username\", \"password\");
           }
          }
    good:
      java:
        - |
          import java.net.InetAddress;
          import java.net.UnknownHostException;
          import java.sql.Connection;
          import java.sql.DriverManager;
          import java.sql.SQLException;

          public class msc03_0 {
           public final Connection getConnection() throws SQLException, UnknownHostException {
           
           // IP address class to fill in at runtime. The address should be cleared immediately after use
           class IPAddress {
           // IP address in string
           char[] ipAddress = new char[128];
           try {
           // read in from some secure channel or file
           ...
           }
           finally {
           // clear after use
           Arrys.fill(ipAddress, (byte)0);
           // close file or channel
           ...
           }
           
           }
           if (InetAddress.getByName(ipAddress).isAnyLocalAddress()){
           // hard coded username and password
           String username, password;
           // Username and password should be read from a secure config file/channel at rungime
           return DriverManager.getConnection(\"dbhost:mysql://localhost/mydb\", username, password);
           }
           return DriverManager.getConnection(\"dbhost:mysql://localhost/dbName\", \"username\", \"password\");
           }
          }
  language: Java
  likelihood: P
  master_id: 97
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, ${si.var} in function ${si.func}
    has hard coded data and may contain sensitive information.
  name: Do not hard code sensitive information in program
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '798'
    owasp:
      - A3
- alias: {}
  category: VUL
  code: OBJ07-J
  cost: M
  csv_string:
    - O07J1
    - O07J0
  desc: >-
    Classes with sensitive data should be protected against being copied or
    cloned.
  details: >
    #### Abstract

    Classes with sensitive data should be protected against being copied or
    cloned. 


    #### Explanation

    Classes with sensitive data, when cloned or copied maliciously, may be
    exposed to thread-safety issues that violates invariants of critical data. 
  examples:
    bad:
      java:
        - |-
          public class j_obj07_sensitive
          {
           private String userName;
           private char[] passwd;

           public j_obj07_sensitive(String name, char[] pass) { // OBJ07-J: class not provide clone throw exception and mark final
           userName = name;
           passwd = pass;
           } 

           public String getUserName() {
           return userName;
           }

           public char[] getPasswd() {
           return passwd;
           }

           protected void resetPasswd() {
           for(int i = 0; i < passwd.length; i++) {
           passwd[i] = 'a';
           }
           }

           void display() {
           System.out.println(\"UserName addr:\" + System.identityHashCode(userName));
           System.out.println(\"Passwd addr:\" + System.identityHashCode(passwd));
           System.out.print(\"User:\" + userName + \" passwd:\");
           System.out.println(passwd);
           }

          }
    good:
      java:
        - |
          public class j_obj07_fp_1 
          {
           private String userName;
           private char[] passwd;

           public j_obj07_fp_1(String name, String pass) {
           userName = name;
           passwd = pass.toCharArray();
           }

           // [certj pages]
           // sensitive class define clone() and throws CloneNotSupportedException
           // and clone() method marked finalclone
           // Well behaved clone that prevents subclasses from being made cloneable by defining a final clone that always fails
           public final j_obj07_fp_1 clone() throws CloneNotSupportedException {
           throw new CloneNotSupportedException();
           }

           void resetPasswd() {
           for(int i = 0; i < passwd.length; i++) {
           passwd[i] = 'a';
           } 
           }

           void display() {
           System.out.println(\"UserName addr:\" + System.identityHashCode(userName));
           System.out.println(\"Passwd addr:\" + System.identityHashCode(passwd));
           System.out.print(\"User:\" + userName + \" passwd:\");
           System.out.println(passwd);
           }

           public static void main(String[] args) {
           j_obj07_fp_1 obj1= new j_obj07_fp_1(\"user1\", \"abcdef\");
           try {
           j_obj07_fp_1 obj2 = (j_obj07_fp_1)obj1.clone();
           obj2.resetPasswd();
           obj1.display();
           obj2.display();
           } catch (CloneNotSupportedException e) {
           System.out.println(\"Error: clone is not allowed for sensitive class\");
           }
           }
          }
  language: Java
  likelihood: P
  master_id: 98
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, the method ${si.var} can be copied
    or cloned.
  name: >-
    Classes with sensitive data should be protected against being copied or
    cloned
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '498'
    owasp:
      - A3
      - A5
- alias: {}
  category: VUL
  code: SEC01-J
  cost: L
  csv_string:
    - C01J2
    - C01J1
    - C01J0
  desc: The program has untrusted data in the privileged blocks.
  details: >
    #### Abstract

    The program has untrusted data in privileged blocks.


    #### Explanation

    Untrusted data may contain special characters that eventually form tainted
    paths or file names. Attackers can take advantage of tainted data that get
    into privileged blocks for malicious intent.
  examples:
    bad:
      java:
        - |-
          import java.io.FileInputStream;
          import java.io.FileNotFoundException;
          import java.security.AccessController;
          import java.security.PrivilegedActionException;
          import java.security.PrivilegedExceptionAction;

          public class sec01_0 { // edited from CERT-J example
           // input file name may be tainted since origin is unknown
           // should have gone through sanitization and normalization before 
           // enter the doPrivileged() block
           private void privilegedMethod(final String filename)
           throws FileNotFoundException {
           try {
           FileInputStream fis =
           (FileInputStream) AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () -> {
           return new FileInputStream(filename);
           });
           // Do something with the file and then close it
           } catch (PrivilegedActionException e) {
           // Forward to handler
           }
           }
          }
    good:
      java:
        - |-
          import java.io.FileInputStream;
          import java.io.FileNotFoundException;
          import java.security.AccessController;
          import java.security.PrivilegedActionException;
          import java.security.PrivilegedExceptionAction;

          public class sec01_0 { // edited from CERT-J example
           // input file name gone through sanitization and normalization before 
           // enter the doPrivileged() block
           }
           private void privilegedMethod(final String filename)
           throws FileNotFoundException {
           
           final String sanitizeFilename;
           try {
           sanitizeFilename = sanitizeFilename(filename);
           } catch {
           // call handler appropriately 
           ...
           }
           
           try {
           FileInputStream fis =
           (FileInputStream) AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () -> {
           return new FileInputStream(filename);
           });
           // Do something with the file and then close it
           } catch (PrivilegedActionException e) {
           // Forward to handler
           }
           }
          }
  language: Java
  likelihood: L
  master_id: 99
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, sensitive information may be leaked
    through ${si.var} inside a trusted block ${si.func}.
  name: Untrusted data is not allowed in privileged blocks
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '732'
      - '266'
      - '272'
    owasp:
      - A2
      - A5
      - A3
- category: VUL
  code: DCL55-CPP
  cost: LOW
  desc: >-
    The program has classes that have padding bits in the object that may have
    sensitive data but failed to clear them after use.
  details: ''
  examples:
    bad: {}
    good: {}
  language: c++
  likelihood: UNLIKELY
  master_id: 100
  msg_templ: ''
  name: >-
    Information leakage when transferring class objects across trusted
    boundaries
  severity: LOW
- alias: {}
  category: VUL
  code: ENV01-J
  cost: M
  csv_string:
    - N01J0
  desc: >-
    The program is code signed to authenticate the origin of the code. Such
    codes should contain some code that performs privileged operations.
  details: >+
    #### Abstract

    The program is code signed to authenticate the origin of the code. Such code
    should contain some code that performs privileged operations.


    #### Explanation

    Code signing is usually taken as trusted and safe to execute code. Many
    systems are configured to be \"Always trust\". The implied permission can
    easily be exploited.

  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: P
  master_id: 101
  msg_templ: ''
  name: Security sensitive code should be signed and sealed in a single JAR
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '349'
    owasp:
      - A2
- category: VUL
  code: FIO21-C
  cost: MEDIUM
  desc: >-
    The program has created temporary files in shared directories but has no
    removal or access procedure to prevent user attacks into the shared
    directory.
  details: >
    #### Abstract

    The program has created temporary files in shared directories but has no
    removal or access procedures to prevent user attacks into the shared
    directory.


    #### Explanation

    Process of creating temporary files is often used as a practice to transmit
    data from one process to another when it cannot reside in memory. If there
    is no clean up procedure for these files, or if the file name of these files
    is predictable, then it allows attackers to easily hijack this file. It can
    be fatal if the file holds sensitive information.
  examples:
    bad:
      c:
        - |-
          void func(const char * file_name) {
          FILE *fp=fopen(file_name),"wb+";
          if(fp == NULL){
          return
          }
          // write to file ...
          fclose(fp)
          }
    good: {}
  language: c,c++
  likelihood: LIKELY
  master_id: 102
  msg_templ: ''
  name: Temporary files should not be stored in shared directories
  severity: HIGH
- category: VUL
  code: DCL56-CPP
  cost: MEDIUM
  desc: >-
    The program makes a recursion call when initializing a static object.
    Program also might have an unordered initialization such that recursion may
    cause unexpected behaviors.
  details: ''
  examples:
    bad: {}
    good: {}
  language: c++
  likelihood: UNLIKELY
  master_id: 103
  msg_templ: ''
  name: Initialization of static objects should not have a circular dependency
  severity: LOW
- category: VUL
  code: FIO51-CPP
  cost: MEDIUM
  desc: >-
    The program fails to close a file that was previously opened before program
    termination.
  details: ''
  examples:
    bad: {}
    good: {}
  language: c++
  likelihood: UNLIKELY
  master_id: 104
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, function ${si.func} fails to close
    an open file before program termination.
  name: Always close files before a program terminates
  severity: MEDIUM
- category: VUL
  code: MEM52-CPP
  cost: MEDIUM
  desc: >-
    Default allocators do not check results of allocation if it produces an
    exception. Any error has to be caught and handled.
  details: >
    #### Abstract

    Default allocators do not check results of allocation if it produces an
    exception. Any error has to be caught and handled.


    #### Explanation

    One of the most common memory alocation operators used in C++ is ::operator
    new(std::size_t) which may throw a std::bad_alloc when allocation fails. New
    operator is also overloaded with the non-throwing version which is
    ::operator new(std::size_t, const std::nothrow_t&) which instead of throwing
    exceptions will give a nullptr instead. Whichever new operator is used,
    there should be a check for either the corresponding error. Exceptions must
    be handled with catch, while nullptr should be checked accordingly, to avoid
    the abrupt termination of a program.
  examples:
    bad:
      cpp:
        - |-
          #include <cstring>
          #include <new>

           void f(std::size_t size) noexcept {
          int *var = new int[size];
          var[0]=5;
          delete[] var;
          }
    good: {}
  language: c++
  likelihood: LIKELY
  master_id: 105
  msg_templ: ''
  name: Failures in memory allocation should be properly handled
  severity: HIGH
- category: VUL
  code: MSC50-CPP
  cost: LOW
  desc: >-
    The program has used std::rand(), which is not a good candidate for random
    number sequences.
  details: >
    #### Abstract

    The program has used std::rand(), which is not a good candidate for random
    number sequences.


    #### Explanation

    Pseudorandom number generator like rand() uses mathematical algorithms which
    makes numbers not completely random. Numbers generated by std::rand()
    doesn't give a good enough quality for random number sequences due to its
    comparatively short cycle. Hence, using rand() is not advised.
  examples:
    bad:
      cpp:
        - |-
          #include <iostream>
          #include<string>

          void func(void){
          std::string id{\"id\"};
          id += std::to_string(std::rand()%1000);
          }
    good: {}
  language: c++
  likelihood: UNLIKELY
  master_id: 106
  msg_templ: ''
  name: Use a stronger pseudorandom generator than std::rand()
  severity: MEDIUM
- category: VUL
  code: MSC52-CPP
  cost: MEDIUM
  desc: >-
    The program has a function with non-void return, but that function has an
    execution path that will reach the exit without encountering a "return"
    statement.
  details: >
    #### Abstract

    The program has a function with non-void return, but that function has an
    execution path that will reach the exit without encountering a \"return\"
    statement.


    #### Explanation

    A value is expected to be returned upon calling this function, however, not
    all code paths return a value and may result in an undefined behavior.
  examples:
    bad:
      cpp:
        - |-
          int get_number(int x){
          if(x>=1 && x<=10) return x;
          }
    good: {}
  language: c++
  likelihood: PROBABLE
  master_id: 107
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, function ${si.func} has non-void
    return but it will reach the exit without a return statement.
  name: Any value returning function must ensure all exit paths return a value
  severity: MEDIUM
- category: VUL
  code: OBJ05-J
  cost: MEDIUM
  desc: >-
    The program is returning references to mutable class members that are
    declared as private.
  details: >
    #### Abstract

    The program is returning references to mutable class members that are
    declared private.


    #### Explanation

    Returning reference to a private mutable class member is breaking the
    encapsulation and also makes a private object available that can be
    manipulated by an untrusted calling method.
  examples:
    bad:
      java:
        - |
          import java.util.Date;

          public class obj05_0 {
              private Data private_d;

              // this class is mutable
              public obj05_0() {
                  // private_d is declared private, and is being returned 
                  // thus exposes the internal mutable component to untrustable caller
                  private_d = new Data();
          }

          public Data getData() {
              return private_d;
          }

          }
    good:
      java:
        - |
          import java.util.Date;

          public class obj05_0 {
           private Data private_d;

           // this class is mutable
           public obj05_0() {
           private_d = new Data();
           }

           // a copy is returned, hence, no leakage using this method
           public Data getDataSafe() {
           return (Data)d.clone();
           }
          }
  language: Java
  likelihood: PROBABLE
  master_id: 108
  msg_templ: ''
  name: >-
    References to mutable class members that are private should not be returned
    and exposed
  severity: HIGH
- category: VUL
  code: ENV02-J
  cost: LOW
  desc: The program's use of environment variables may be a loophole for attackers.
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: LIKELY
  master_id: 109
  msg_templ: ''
  name: Environment variables are to be treated as untrusted
  severity: LOW
- category: VUL
  code: ENV04-J
  cost: LOW
  desc: Java class files with no verification may come from untrusted sources.
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: LIKELY
  master_id: 110
  msg_templ: ''
  name: Bytecode verification should not be disabled
  severity: HIGH
- category: VUL
  code: ENV05-J
  cost: LOW
  desc: Program fails to disable remote monitoring.
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: PROBABLE
  master_id: 111
  msg_templ: ''
  name: Remotely monitored applications should not be deployed in the product
  severity: HIGH
- alias: {}
  category: VUL
  code: JNI01-J
  cost: L
  csv_string:
    - J01J0
  desc: >-
    The program has invoked a standard API on behalf of untrusted code through
    loadLibrary methods.
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: L
  master_id: 112
  msg_templ: ''
  name: Invoke standard APIs safely
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- alias: {}
  category: VUL
  code: OBJ01-J
  cost: M
  csv_string:
    - O01J0
  desc: The program might expose sensitive fields through using a public modifier.
  details: |
    #### Abstract
    The program might expose sensitive fields through using a public modifier.
  examples:
    bad:
      java:
        - |-
          import java.util.List;

          public class j_obj01_0 {

            private static final String[] items = {"abc", "def", "ghj"/* ... */};

            public static final List<String> itemsList =
              Collections.unmodifiableList(Arrays.asList(items));

            public static final String[] getItems() {
              return items.clone();
            }
            public static final String getItem(int index) {
              return items[index];
            }

            public static final int getItemCount() {
              return items.length;
            }

            private static final HashMap<Integer, String> hm = new HashMap<Integer, String>();

            public static String getElement(int key) {
              return hm.get(key);
            }

            public int total; // Unprotected

            public int getTotal () {
              return total;
            }

          }
    good:
      java:
        - |-
          import java.util.List;

          public class j_obj01_0 {

            private static final String[] items = {"abc", "def", "ghj"/* ... */};

            public static final List<String> itemsList =
              Collections.unmodifiableList(Arrays.asList(items));

            public static final String[] getItems() {
              return items.clone();
            }
            public static final String getItem(int index) {
              return items[index];
            }

            public static final int getItemCount() {
              return items.length;
            }

            private static final HashMap<Integer, String> hm = new HashMap<Integer, String>();

            public static String getElement(int key) {
              return hm.get(key);
            }

            private int total; // Declared private

            public int getTotal () {
              return total;
            }

          }
  language: Java
  likelihood: L
  master_id: 113
  msg_templ: ''
  name: Field accessibility of an object must be managed properly
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '766'
    owasp:
      - A5
- alias: {}
  category: VUL
  code: OBJ13-J
  cost: L
  csv_string:
    - O13J1
    - O13J0
  desc: >-
    The program is exposing reference mutable objects to the user side where
    they may be modified freely.
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: L
  master_id: 114
  msg_templ: ''
  name: References to mutable objects should not be shown to client
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    owasp:
      - A2
      - A3
- alias: {}
  category: VUL
  code: SEC03-J
  cost: M
  csv_string:
    - C03J1
    - C03J0
  desc: >-
    The program may allow a class loader from an untrusted source to load
    trusted classes.
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: P
  master_id: 115
  msg_templ: ''
  name: Trusted class must be loaded by the trusted class loader
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '269'
      - '284'
    owasp:
      - A5
      - A2
- alias: {}
  category: VUL
  code: SEC04-J
  cost: M
  csv_string:
    - C04J2
    - C04J1
    - C04J0
  desc: >-
    The program is allowing sensitive method calls that bypass security manager
    checks.
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: P
  master_id: 116
  msg_templ: ''
  name: >-
    Sensitive operations should be protected with a proper security manager
    check
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '284'
      - '285'
    owasp:
      - A5
      - A3
      - A6
- alias: {}
  category: VUL
  code: SEC05-J
  cost: M
  csv_string:
    - C05J0
  desc: >-
    The program is using Java reflection APIs that alters accessibility of
    certain fields.
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: P
  master_id: 117
  msg_templ: ''
  name: Do not use reflection to modify accessibility of classes, methods or fields
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '269'
- alias: {}
  category: VUL
  code: SER01-J
  cost: L
  csv_string:
    - R01J0
  desc: The program is not using signatures of serialization methods properly.
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: L
  master_id: 118
  msg_templ: ''
  name: Follow the proper signatures when making custom serialization methods
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '502'
    owasp:
      - A8
- category: VUL
  code: SER04-J
  cost: HIGH
  desc: >-
    The program is doing a serialization without security checks that may allow
    untrusted code to modify internal state of class.
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: PROBABLE
  master_id: 119
  msg_templ: ''
  name: Serialization and deserialization should always pass the security manager
  severity: HIGH
- alias: {}
  category: VUL
  code: SER05-J
  cost: M
  csv_string:
    - R05J0
  desc: >-
    The program contains inner class(es) that implement a serializable
    interface.
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: L
  master_id: 120
  msg_templ: ''
  name: Avoid serialization of inner classes
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards: {}
- category: VUL
  code: SER08-J
  cost: MEDIUM
  desc: The program is doing deserialization within a privileged context.
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: LIKELY
  master_id: 121
  msg_templ: ''
  name: >-
    If deserializing requires privileges, strip permissions to the minimum of
    intended usage
  severity: HIGH
- alias: {}
  category: VUL
  code: IDS53-J
  cost: L
  csv_string:
    - I53J1
    - I53J0
  desc: >-
    String input to retrieve data from XML document must be properly sanitized
    before the query.
  details: >-
    #### Abstract

    The program is using String input to retrieve data from an XML document. It
    must be properly sanitized before the query.


    #### Explanation

    The program is using String input to retrieve data from an XML document
    without adequate input sanitization and validation. This could result in
    malicious users formulating an SQL or XML query that results in a tautology
    and allow attackers access to restricted information.
  examples:
    bad:
      java:
        - |
          package io.xc5.cert;

          import javax.xml.xpath.*;
          import org.xml.sax.SAXException;
          import java.io.IOException;
          import java.io.FileInputStream;
          import javax.xml.parsers.DocumentBuilder;
          import org.w3c.dom.Document;
          import org.w3c.dom.NodeList;

          public class example_bad {
            private final String accountFile = "account.xml";
            private DocumentBuilder docBuilder;
            private XPath xpath;

            // the code below trying to query account Info with given id
            public String queryAccountInfo(String id) throws XPathExpressionException, SAXException, IOException {
              Document accountDoc = docBuilder.parse(accountFile);

              // attacker can inject by provide id with '1'='1 causing evaluate to return "true"
              String compileStr = "/Accounts/account[@id='" + id + "']"; 
              String res = xpath.evaluate(compileStr, accountDoc); // IDS53-J
              return res;
            }
          }
    good:
      java:
        - |+
          import javax.xml.xpath.*;
          import org.xml.sax.SAXException;
          import java.io.IOException;
          import java.io.FileInputStream;
          import javax.xml.parsers.DocumentBuilder;
          import org.w3c.dom.Document;
          import org.w3c.dom.NodeList;
          public class j_ids53_0 {
            private final String accountFile = "account.xml";
            private DocumentBuilder docBuilder;
            private XPath xpath;

            // the code below trying to query account Info with given id
            public String queryAccountInfo(String id) throws XPathExpressionException, SAXException, IOException {
              Document accountDoc = docBuilder.parse(accountFile);
              Map queryVars = new HashMap();

              // validate input "id" using StringEscapeUtils
              String filteredId = StringEscaptUtils.escapeXml(id);
              String compileStr = "/Accounts/account[@id='" + filteredId + "']";
              String res = xpath.evaluate(compileStr, accountDoc); 
              return res;
            }
          }

  language: Java
  likelihood: P
  master_id: 122
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, ${si.func}, ${si.var} is not
    properly sanitized before being used to retrieve data from XML document .
  name: Prevent XPath Injection
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '91'
      - '943'
    owasp:
      - A1
- alias: {}
  category: VUL
  code: IDS54-J
  cost: L
  csv_string:
    - I54J1
    - I54J0
  desc: >-
    String input to perform remote directory access must be properly sanitized
    and validated.
  details: >-
    #### Abstract

    The program is using LDAP for remote operations with inadequate input
    sanitization and validation.


    #### Explanation

    The program is using Lightweight Directory Access Protocol to perform remote
    operations without adequate input sanitization and validation. This could
    result in giving malicious users access to restricted information.
  examples:
    bad:
      java:
        - |
          import javax.naming.NamingEnumeration;
          import javax.naming.NamingException;
          import javax.naming.directory.InitialDirContext;
          import javax.naming.directory.SearchControls;
          import javax.naming.directory.SearchResult;

          public class example_bad
          {
            public NamingEnumeration<SearchResult> queryUserInfo(InitialDirContext ctx, String id) throws NamingException {
              SearchControls sc = new SearchControls();
              sc.setReturningAttributes(new String[]{"balance", "phone"});
              sc.setSearchScope(SearchControls.SUBTREE_SCOPE);

              String searchBase = "dc=Users,dc=com";
              String filter = "(id=" + id + ")"; // attacker can inject by provide id with "*"
              return ctx.search(searchBase, filter, sc); // IDS54-J, query user info with id 
            }
          }
    good:
      java:
        - |
          import javax.naming.NamingEnumeration;
          import javax.naming.NamingException;
          import javax.naming.directory.InitialDirContext;
          import javax.naming.directory.SearchControls;
          import javax.naming.directory.SearchResult;

          public class example_good
          {
            public NamingEnumeration<SearchResult> queryUserInfo(InitialDirContext ctx, String id) throws NamingException {
              SearchControls sc = new SearchControls();
              sc.setReturningAttributes(new String[]{"balance", "phone"});
              sc.setSearchScope(SearchControls.SUBTREE_SCOPE);

              String searchBase = "dc=Users,dc=com";

              // check against special characters 
              if (!id.matches("[\\w\\s]*") || !id.matches("[\\w]*")) {
                throw new IllegalArgumentException("Invalid input");
              }
              
              String filter = "(id=" + id + ")"; // attacker can inject by provide id with "*"
              return ctx.search(searchBase, filter, sc); // IDS54-J, query user info with id 
            }
          }
  language: Java
  likelihood: P
  master_id: 123
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, ${si.func}, ${si.var} is not
    properly sanitized and validated before being used to perform remote
    directory access.
  name: Prevent LDAP injection
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '90'
      - '943'
    owasp:
      - A1
- alias: {}
  category: VUL
  code: IDS06-J
  cost: M
  csv_string:
    - I06J0
  desc: >-
    Format string should not contain input that is not properly sanitized and
    validated.
  details: >-
    #### Abstract

    The program has format strings that includes unsanitized user input.


    #### Explanation

    Unsanitized input from an untrusted source should not be incorporated into
    format strings. This could result in information leakage or allow denial of
    service attacks.
  examples:
    bad:
      java:
        - |

          import java.util.Calendar;
          import java.util.GregorianCalendar;

          // this example is taken from CERT-J site Dashboard
          // 
          public class example_bad {
            static Calendar c = new GregorianCalendar(1995, GregorianCalendar.MAY, 23);
            public static void main(String[] args) {
              // Untrusted data is incorporated into the format string below.
              // Attacker can expose the date against which input is compared against
              // with some special input string, resulting in infomation leakage.
              System.out.format(
                args[0] + "did not match! HINT: It was issued on %1$terd of some month", c
              );
            }
          }
    good:
      java:
        - |

          import java.util.Calendar;
          import java.util.GregorianCalendar;

          // this example is taken from CERT-J site Dashboard
          // 
          public class example_bad {
            static Calendar c = new GregorianCalendar(1995, GregorianCalendar.MAY, 23);
            public static void main(String[] args) {
              // simply compare input with c
              System.out.format(
                "%s did not match! HINT: It was issued on %terd of some month", args[0], c
              );
            }
          }
  language: Java
  likelihood: U
  master_id: 124
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, ${si.func}, ${si.var} contains
    input that is not properly santizied and validated.
  name: Exclude unsanitized user input from format strings
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '134'
- alias: {}
  category: BAD_PRACTICE
  code: MSC30-C
  cost: L
  csv_string:
    - M30C2
    - M30C1
    - M30C0
  desc: >-
    The program is using a pseudorandom number generator  that can produce a
    predictable sequence of numbers.
  details: >-
    #### Abstract

    The program is using a pseudorandom number generator that can produce a
    predictable sequence of numbers.


    #### Explanation

    The rand() function produces numbers that are not truly random and may have
    a short cycle. An attacker can guess the next value that will be generated.
    Programmers should use a better random function that is properly seeded.
  examples:
    bad:
      c:
        - |
          #include <stdio.h>
          #include <stdlib.h>

          void use_rand(void) {
            int r;
            int i;

            // the same sequence will be printed every time this function is called
            for (i = 0; i < 10; i++) {
              r = rand();
              printf("Random %d is %d\n", i, r);
            }
            
          }
    good:
      c:
        - |
          #include <stdio.h>
          #include <stdlib.h>
          #include <time.h>

          void use_rand(void) {
            int r;
            int i;
            time_t t;

            // seeds the rand()
            srand((unsigned) time(&t));
            
            // random is a better pseudorandom number generator
            for (i = 0; i < 10; i++) {
              r = random();
              printf("Random %d is %d\n", i, r);
            }
            
          }
  language: c/c++
  likelihood: U
  master_id: 125
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, function ${si.func} is using a
    pseudorandom number generator that might produce a predictable sequence of
    numbers.
  name: Do not use the rand() function for generating pseudorandom numbers
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '338'
      - '327'
      - '330'
    owasp:
      - A3
- alias: {}
  category: VUL
  code: INT32-C
  cost: H
  csv_string:
    - N322
    - N321
    - N320
  desc: >-
    The program has operations in expressions with signed integers that may
    cause integer overflow or wraparound
  details: ''
  examples:
    bad: {}
    good: {}
  language: c/c++
  likelihood: L
  master_id: 126
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, function ${si.func} has operations
    in expressions with signed integers.
  name: Make sure that operations on signed integers do not wraparound or overflow
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '190'
      - '191'
      - '680'
- alias: {}
  category: VUL
  code: IDS04-J
  cost: H
  csv_string:
    - I04J0
  desc: >-
    The program is extracting file entries from a zip file using
    java.util.zip.ZipInputStream without any sanitization or resource guard
    measures.
  details: >+
    #### Abstract

    The program is extracting file entries from a zip file using
    java.util.zip.ZipInputStream without sanitization or resource guard
    measures.


    #### Explanation

    When using the java.util.zip package to extract file entries from a zip file
    then file names may contain path information. These file names must be
    canonicalized and validated to prevent path injection attacks. Resource
    usage must also be tracked to ensure resources will not be exhausted that
    could result in a denial of service.

  examples:
    bad:
      java:
        - "import java.util.zip.*;\nimport java.io.*;\n\n\npublic class IDS04J_bad {\n    public static void main(String[] args) throws IOException {\n        // Path may be manipulated to access areas outside of intended directory\n        String zipPath = args[0];\n        String destPath = args[1];\n\n        byte[] buffer = new byte[1024];\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(zipPath));\n        ZipEntry zipEntry = zis.getNextEntry();\n        File destDirectory = new File(destPath);\n\n        try {          \n            // Exhaustion of resource without limit to the size of zip files in while loop\n            while (zipEntry != null) {\n                System.out.println(\"File being extracted: \" + zipEntry);\n                FileOutputStream fos = new FileOutputStream(destDirectory + \"/\" + zipEntry.getName());\n\n                int len;\n                while ((len = zis.read(buffer)) > 0) {\n                    fos.write(buffer, 0, len);\n                }\n\n                fos.close();\n                zipEntry = zis.getNextEntry();\n            }\n        } \n        finally {\n        \tzis.close(); \t\n        }\n    }\n}\n\n\n"
    good:
      java:
        - "import java.util.zip.*;\nimport java.io.*;\n\n\npublic class IDS04J_good {\n    public static void main(String[] args) throws IOException, IllegalStateException {\n        String zipPath = args[0];\n        String destPath = args[1];\n        \n        // Fix vulnerability by canonicalizing path\n        File checkZip = new File(zipPath);\n        File checkDest = new File(destPath);\n        String canonicalZip =  checkZip.getCanonicalPath();\n        String canonicalDest =  checkDest.getCanonicalPath();\n\n        // Check result of canonicalization\n        if (!canonicalZip.startsWith(canonicalDest)) {\n            throw new IllegalStateException(\"Accesing Out of Bounds Area, set a correct path\");\n        }\n    \n        byte[] buffer = new byte[1024];\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(zipPath));\n        ZipEntry zipEntry = zis.getNextEntry();\n        File destDirectory = new File(destPath);\n\n        long sizeLimit = 0x6400000; \n        int fileLimit = 2000; \n        long currentSize =  0; \n        int entry = 0; \n\n        try {\n            // Limit size to avoid DoS attack through resource exhaustion      \n            while (zipEntry != null) {\n                // Limit number of files\n                if (entry > fileLimit){\n                    throw new IllegalStateException(\"Unzipped file exceed the allowed limit\");\n                } \n                // Limit size of file\n                if (currentSize > sizeLimit) {\n                    throw new IllegalStateException(\"Unzipped file exceed the allowed size\");\n                }\n\n                System.out.println(\"File being extracted: \" + zipEntry);\n                FileOutputStream fos = new FileOutputStream(destDirectory + \"/\" + zipEntry.getName());\n                \n                int len;\n                while ((len = zis.read(buffer)) > 0) {\n                    fos.write(buffer, 0, len);\n                    currentSize += len;\n                }\n                fos.close();\n                zipEntry = zis.getNextEntry();\n                entry++;\n            }\n        } \n        finally {\n        \tzis.close(); \t\n        }\n    }\n}\n\n\n"
  language: Java
  likelihood: P
  master_id: 127
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, function ${si.func} is extracting
    file entries from a zip file without any sanitization or resource guard
    measures.
  name: Safely extract files from ZipInputStream
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: L
  standards:
    cwe:
      - '409'
- alias: {}
  category: VUL
  code: IDS03-J
  cost: L
  csv_string:
    - SIL0
  desc: >-
    Sensitive data leakage arises When unsanitized user input are logged or put
    out in standard output (stdout) device.
  details: >-
    #### Abstract

    Sensitive data leakage arises When unsanitized user input are logged or put
    out in standard output (stdout) device.


    #### Explanation

    Logging unsanitized user input can result in sensitive data leakage across a
    trusted boundary. A log injection attack may arise leading to further
    information leakage. This vulnerability is not limited to Java programs.
    C/C++ programs can subject to the same attack as show in the C example.
  examples:
    bad:
      c:
        - "\nusing namespace mychain;\nusing namespace MyContract::Sample;\n\nclass demoBranch:public Contract {\npublic:\n    TransferPtr m_ptransfer;\n\n    demoBranch() {\n        m_ptransfer = GetTransferM();\n    }\n    INTERFACE void Init() {\n        InitRoot();\n    }\n    \n    INTERFACE void LeakToLog(const std::string& sAccountName ) {\n        if(!m_ptransfer) {\n            Revert(\"error\");\n        }\n\n\t// get account, balance etc\n        AccountMMapPtr pAccountMap = m_ptransfer->get_accounts();\n        if (!pAccountMap) {\n            Revert(\"AcountMMapPtr Error.\");\n        }\n\n        // obtain user account number and name\n\t// ...\n\n\t//\n        int32_t iBalanceRmb = pBalance->get_rmb();\n        std::string sBalanceTopic = std::to_string(iBalanceRmb);\n        std::vector<std::string> leak_msg;\n        leak_msg.push_back(sAccountName);\n        leak_msg.push_back(sBalanceTopic);\n\t\n        if (iBalanceRmb < 1) {\n          Log(std::string(\"acc_bal\"), leak_msg);\n        }\n    }\n};\nINTERFACE_EXPORT(demoBranch, (Init) (LeakToLog))\n"
      java:
        - |
          locationClient = new LocationClient(this, this, this);
          locationClient.connect();
          currentUser.setLocation(locationClient.getLastLocation());
          ... 

          catch (Exception e) {
              AlertDialog.Builder builder = new AlertDialog.Builder(this);
              builder.setMessage("Application Error.");
              AlertDialog alert = builder.create();
              alert.show();

              // user location is written to log
              Log.e("Example", "Caught exception: " + e + " User:" + User.toString());
          }
    good:
      c:
        - "\nusing namespace mychain;\nusing namespace MyContract::Sample;\n\nclass demoBranch:public Contract {\npublic:\n    TransferPtr m_ptransfer;\n\n    demoBranch() {\n        m_ptransfer = GetTransferM();\n    }\n    INTERFACE void Init() {\n        InitRoot();\n    }\n    \n    INTERFACE void LeakToLog(const std::string& sAccountName ) {\n        if(!m_ptransfer) {\n            Revert(\"error\");\n        }\n\n\t// get account, balance etc\n        AccountMMapPtr pAccountMap = m_ptransfer->get_accounts();\n        if (!pAccountMap) {\n            Revert(\"AcountMMapPtr Error.\");\n        }\n\n        // obtain user account number and name\n\t// ...\n\n\t//\n        int32_t iBalanceRmb = pBalance->get_rmb();\n        std::string sBalanceTopic = std::to_string(iBalanceRmb);\n        std::vector<std::string> leak_msg;\n        leak_msg.push_back(sAccountName);\n        leak_msg.push_back(sBalanceTopic);\n\n        if (iBalanceRmb < 1) {\n\t  // Sanitize and clean up message before logging\n          Log(std::string(\"acc_bal\"), SanitizeUser(leak_msg));\n        }\n    }\n};\nINTERFACE_EXPORT(demoBranch, (Init) (LeakToLog))\n"
      java:
        - |
          locationClient = new LocationClient(this, this, this);
          locationClient.connect();
          currentUser.setLocation(locationClient.getLastLocation());
          ... 

          catch (Exception e) {
              AlertDialog.Builder builder = new AlertDialog.Builder(this);
              builder.setMessage("Application Error.");
              AlertDialog alert = builder.create();
              alert.show();

              // user location is "sanitized" being written to log
              Log.e("Example", "Caught exception: " + e + " User:" + sanitizeUser(User.toString()));
          }
  language: c,c++,java
  likelihood: P
  master_id: 128
  msg_templ: ''
  name: Unsanitized user information should not be exposed
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards: {}
- alias: {}
  category: ''
  code: FIO39-C
  cost: M
  csv_string:
    - F39C0
  details: ''
  examples:
    bad: {}
    good: {}
  language: c/c++
  likelihood: L
  master_id: 129
  msg_templ: ''
  name: >-
    Do not alternately input and output from a stream without an intervening
    flush or positioning call
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: L
  standards: {}
- alias: {}
  category: ''
  code: POS39-C
  cost: L
  csv_string:
    - P39C0
  details: ''
  examples:
    bad: {}
    good: {}
  language: c/c++
  likelihood: L
  master_id: 130
  msg_templ: ''
  name: >-
    Remark: Only work for self-created example because ntolh() ... is replaced
    by a custom user written function. See TG-137
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards: {}
- alias: {}
  category: VUL
  code: MLU
  cost: H
  csv_string:
    - MLU0
  desc: >-
    The paired lock and unlock mutex program idiom is broken, missing one or the
    other counterpart
  details: >-
    #### Abstract

    The paired lock and unlock mutex program idiom is broken, missing one or the
    other counterpart


    #### Explanation

    A thread must enter or leave a mutex region through proper invokation of the
    corresponding lock or unlock functions. Failure to doing so will cause
    starvation for other threads.
  examples:
    bad:
      c:
        - "#include <pthread.h>\n#include <stdio.h>\n \ntypedef struct sMutex_Lock {\n  int index;\n  pthread_mutex_t mutex;\n} Mutex_Lock_Type;\n \nMutex_Lock_Type g_struct[100];\n \nvoid hc1_bad (int ret) {\n  int i;\n  for (i = 0; i < 100; i++){\n    pthread_mutex_lock(&g_struct[i].mutex);\n    if (ret > 0) {\n      if (ret < 100) {\n        printf(\"ret < 100\\n\");\n        pthread_mutex_unlock(&g_struct[i].mutex);\n        break;\n      }\n      else {\n\t// break statement exits the loop prematurely without calling unlock \n        if (ret > 1000) {\n          printf(\"ret > 1000\\n\");\n          break;\n        }\n      }\n    }\n    pthread_mutex_unlock(&g_struct[i].mutex);\n  }\n}\n"
    good:
      c:
        - "void hc1_good (int ret) {\n  int i;\n  for (i = 0; i < 100; i++){\n    pthread_mutex_lock(&g_struct[i].mutex);\n    if (ret > 0) {\n      if (ret < 100) {\n        printf(\"ret < 100\\n\");\n        pthread_mutex_unlock(&g_struct[i].mutex);\n        break;\n      }\n      else {\n\t// unlock before break \n        if (ret > 1000) {\n          printf(\"ret > 1000\\n\");\n          pthread_mutex_unlock(&g_struct[i].mutex);\n          break;\n        }\n      }\n    }\n    pthread_mutex_unlock(&g_struct[i].mutex);\n  }\n}\n \n"
  language: c/c++
  likelihood: L
  master_id: 132
  msg_templ: ''
  name: Missing lock or unlock
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    cwe:
      - '832'
- alias:
    cert:
      - CON35-C
  category: VUL
  code: DBLI
  cost: H
  csv_string:
    - DBLI0
  desc: Thread spin_lock has been initialized more than once before deinitialized.
  details: >-
    #### Abstract

    Thread spin_lock has been initialized more than once before deinitialized.


    #### Explanation

    After initializing a thread, it should be de-initialized before
    initialization is called again. Failure to doing so will cause starvation
    for other threads.
  examples:
    bad:
      c:
        - |
          #include <linux/spinlock.h>
           
          struct sbuf_mgr {
            int         sbuf_inited;
            spinlock_t  sbuf_lock;
            char       *sbuf;
          };
           
          int is_sbuf_inited(struct sbuf_mgr *p_sbuf_mgr);
          void sbuf_mgr_reset(struct sbuf_mgr *p_sbuf_mgr);
          void write_data(struct sbuf_mgr *p_sbuf_mgr);
           
          // thread 1
          int *worker1(void *args)
          {
            struct sbuf_mgr * p_sbuf_mgr = args;
            if (is_sbuf_inited(p_sbuf_mgr)) {
               write_data(p_sbuf_mgr);
            }
            return 0;
          }
           
          int is_sbuf_inited( struct sbuf_mgr *p_sbuf_mgr )
          {
              int tmp_inited;
              unsigned long irq_flags;
              spin_lock_irqsave( &p_sbuf_mgr->sbuf_lock, irq_flags );
              tmp_inited = p_sbuf_mgr->sbuf_inited;
              spin_unlock_irqrestore( &p_sbuf_mgr->sbuf_lock, irq_flags );
              return tmp_inited;
          }
           
          // thread 2
          int *worker2(void *args)
          {
            struct sbuf_mgr * p_sbuf_mgr = args;

            // spin_lock_init called in thread2 with this call
            sbuf_mgr_reset(p_sbuf_mgr);
            return 0;
          }
           
          void sbuf_mgr_reset( struct sbuf_mgr *p_sbuf_mgr )
          {
              int i;
              unsigned long irq_flags;
              
              spin_lock_init(&(p_sbuf_mgr->sbuf_lock));  
              spin_lock_irqsave(&p_sbuf_mgr->sbuf_lock, irq_flags);
              // .. do the work 
          }
           
          int test_init_in_thread(void)
          {
            struct sbuf_mgr buf_mgr;
            struct task_struct *worker1_task, *worker2_task;
           
            worker1_task = kthread_create(worker1, (void*)&buf_mgr, "thread1");
           
            worker2_task = kthread_create(worker2, (void*)&buf_mgr, "thread2");
            // ,,, 
            
            // start tasks
            wake_up_process(worker1_task);
            wake_up_process(worker2_task);
            return 0;
          }
           
          void init(struct sbuf_mgr *buf_mgr)
          {
            spin_lock_init(&(buf_mgr->sbuf_lock));
          }
            
          int test_double_init(bool is_double_init)
          {
            struct sbuf_mgr buf_mgr;

            // first initialization 
            init(&buf_mgr);
            
            if (is_double_init) {
              // if true, call init, causing double init
              init(&buf_mgr);
            }
          }
    good:
      c:
        - |2
           
          #include <linux/spinlock.h>
           
          struct sbuf_mgr {
            int         sbuf_inited;
            spinlock_t  sbuf_lock;
            char       *sbuf;
          };
           
          int is_sbuf_inited(struct sbuf_mgr *p_sbuf_mgr);
          void sbuf_mgr_reset(struct sbuf_mgr *p_sbuf_mgr);
          void write_data(struct sbuf_mgr *p_sbuf_mgr);
           
          // thread 1
          int *worker1(void *args)
          {
            struct sbuf_mgr * p_sbuf_mgr = args;
            if (is_sbuf_inited(p_sbuf_mgr)) {
               write_data(p_sbuf_mgr);
            }
            return 0;
          }
           
          int is_sbuf_inited( struct sbuf_mgr *p_sbuf_mgr )
          {
              int tmp_inited;
              unsigned long irq_flags;
              spin_lock_irqsave( &p_sbuf_mgr->sbuf_lock, irq_flags );
              tmp_inited = p_sbuf_mgr->sbuf_inited;
              spin_unlock_irqrestore( &p_sbuf_mgr->sbuf_lock, irq_flags );
              return tmp_inited;
          }
           
          // thread 2
          int *worker2(void *args)
          {
            struct sbuf_mgr * p_sbuf_mgr = args;

            // spin_lock_init called in thread2 with this call
            sbuf_mgr_reset(p_sbuf_mgr);
            return 0;
          }
           
          void sbuf_mgr_reset( struct sbuf_mgr *p_sbuf_mgr )
          {
              int i;
              unsigned long irq_flags;
              
              spin_lock_init(&(p_sbuf_mgr->sbuf_lock));  
              spin_lock_irqsave(&p_sbuf_mgr->sbuf_lock, irq_flags);
              // .. do the work 
          }
           
          int test_init_in_thread(void)
          {
            struct sbuf_mgr buf_mgr;
            struct task_struct *worker1_task, *worker2_task;
           
            worker1_task = kthread_create(worker1, (void*)&buf_mgr, "thread1");
           
            worker2_task = kthread_create(worker2, (void*)&buf_mgr, "thread2");
            // ,,, 
            
            // start tasks
            wake_up_process(worker1_task);
            wake_up_process(worker2_task);
            return 0;
          }
           
          void init(struct sbuf_mgr *buf_mgr)
          {
            spin_lock_init(&(buf_mgr->sbuf_lock));
          }
            
          int test_double_init(bool is_double_init)
          {
            struct sbuf_mgr buf_mgr;

            // initialization only if boolean is false
            if (!is_double_init)
              init(&buf_mgr);
            
            return;  
          }
  language: c/c++
  likelihood: L
  master_id: 133
  msg_templ: ''
  name: Do not spin-lock initialization more than once
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    cwe:
      - '609'
- alias: {}
  category: VUL
  code: LIIT
  cost: H
  csv_string:
    - LIIT0
  desc: >-
    Calling spinlock initialization in a thread may result the thread being
    initialized multiple times.
  details: >-
    #### Abstract

    Calling spinlock initialization in a thread may result the thread being
    initialized multiple times.


    #### Explanation

    A thread should not be initialized multiple times, directly or indirectly.
    Doing so will cause starvation for other threads.
  examples:
    bad:
      c:
        - |
          #include <linux/spinlock.h>
           
          struct sbuf_mgr {
            int         sbuf_inited;
            spinlock_t  sbuf_lock;
            char       *sbuf;
          };
           
          int is_sbuf_inited(struct sbuf_mgr *p_sbuf_mgr);
          void sbuf_mgr_reset(struct sbuf_mgr *p_sbuf_mgr);
          void write_data(struct sbuf_mgr *p_sbuf_mgr);
           
          // thread 1
          int *worker1(void *args)
          {
            struct sbuf_mgr * p_sbuf_mgr = args;
            if (is_sbuf_inited(p_sbuf_mgr)) {
               write_data(p_sbuf_mgr);
            }
            return 0;
          }
           
          int is_sbuf_inited( struct sbuf_mgr *p_sbuf_mgr )
          {
              int tmp_inited;
              unsigned long irq_flags;
              spin_lock_irqsave( &p_sbuf_mgr->sbuf_lock, irq_flags );
              tmp_inited = p_sbuf_mgr->sbuf_inited;
              spin_unlock_irqrestore( &p_sbuf_mgr->sbuf_lock, irq_flags );
              return tmp_inited;
          }
           
          // thread 2
          int *worker2(void *args)
          {
            struct sbuf_mgr * p_sbuf_mgr = args;

            // spin_lock_init called with this call, can result in double init
            sbuf_mgr_reset(p_sbuf_mgr);
            return 0;
          }
           
          void sbuf_mgr_reset( struct sbuf_mgr *p_sbuf_mgr )
          {
              int i;
              unsigned long irq_flags;
              
              spin_lock_init(&(p_sbuf_mgr->sbuf_lock));  
              spin_lock_irqsave(&p_sbuf_mgr->sbuf_lock, irq_flags);
              // .. do the work 
          }
           
          int test_init_in_thread(void)
          {
            struct sbuf_mgr buf_mgr;
            struct task_struct *worker1_task, *worker2_task;
           
            worker1_task = kthread_create(worker1, (void*)&buf_mgr, "thread1");
           
            worker2_task = kthread_create(worker2, (void*)&buf_mgr, "thread2");
            // ,,, 
            
            // start tasks
            wake_up_process(worker1_task);
            wake_up_process(worker2_task);
            return 0;
          }
           
          void init(struct sbuf_mgr *buf_mgr)
          {
            spin_lock_init(&(buf_mgr->sbuf_lock));
          }
            
          int test_double_init(bool is_double_init)
          {
            struct sbuf_mgr buf_mgr;

            // first initialization 
            init(&buf_mgr);
            
            if (is_double_init) {
              // if true, call init, causing double init
              init(&buf_mgr);
            }
          }
    good: {}
  language: c/c++
  likelihood: L
  master_id: 134
  msg_templ: ''
  name: Do no call spinlock initialization in a thread
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards: {}
- alias:
    cert:
      - CON38-C
  category: VUL
  code: SLAE
  cost: M
  csv_string:
    - SLAE0
  desc: Address of a spinlock variable has escaped and may cause deadlock situation
  details: >-
    #### Abstract

    Address of a spinlock variable has escaped and may cause deadlock situation


    #### Explanation

    When the address of a spinlock variable is exposed to outside of a thread,
    the thread may not be properly unlock resulting in possible deadlock
    situation.
  examples:
    bad:
      c:
        - |
          #include <linux/spinlock.h>
          void bad(int irq, spinlock_t lock)
          {
            // 
            spin_lock(&lock);
          }
           
          void bad2(int irq, spinlock_t lock, spinlock_t lock2)
          {
            spin_lock(&lock);
          }
    good: {}
  language: c/c++
  likelihood: U
  master_id: 135
  msg_templ: ''
  name: SpinLock variable address escaped
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: L
  standards:
    cwe:
      - '412'
- alias:
    cert:
      - CON30-C
  category: VUL
  code: LNR
  cost: H
  csv_string:
    - LNR0
  desc: ''
  details: ''
  examples:
    bad: {}
    good: {}
  language: c/c++
  likelihood: P
  master_id: 136
  msg_templ: ''
  name: ''
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: M
  standards:
    cwe:
      - '833'
- alias: {}
  category: VUL
  code: SAC
  cost: H
  csv_string:
    - SAC0
  desc: >-
    The program has entered an atomic region/context, within that region, there
    is operation that may cause the program to pause, delay due to interrupt or
    sleep.
  details: >-
    #### Abstract

    The program has entered an atomic region/context, within that region, there
    is operation that may cause the program to pause, delay due to interrupt or
    sleep. 



    #### Explanation

    When a program is inside an atomic context or locked region, any operation
    that may pause due to sleep, interrupt or wait etc may cause dead lock.
  examples:
    bad:
      c:
        - |+
          #include <linux/spinlock.h>
          void test_isr1(int irq, spinlock_t *lock)
          {
            spin_lock(lock);  // VUL: should use spin_lock_irqsave
          }
           
          // cross function check
          noinline
          void call_spin(spinlock_t *lock)
          {
            spin_lock(lock);
          }


        - >
          #include <stdio.h>

          #include <pthread.h>


          int num = 8; // global variable

          pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; // initialise a
          mutex


          int main() {
              pthread_mutex_lock(&lock); // enter mutex locked region
              switch (num) {
              case 0:
                      num = 0;
                      break;
              case 1:
                      num++;
                      break;
              case 2:
                      num--;
                      break;
              default:
                      // does not exit mutex lock region before return
                      // can cause a deadlock because lock is never released
                      return 0;
              }
              pthread_mutex_unlock(&lock); // exit mutex lock region
              return 0;
          }
        - >

          #include <stdio.h>

          #include <pthread.h>

          #include <unistd.h>


          pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; // initialise a
          mutex

          int num; // global variable


          int main () {
              pthread_mutex_lock(&lock); // enter mutex lock region
              num++;
              sleep(1); // thread goes to sleep within lock region, never want to do this
              pthread_mutex_unlock(&lock); // exit mutex lock region
              return 0;
          }
    good:
      c:
        - |
          #include <linux/spinlock.h>
          void test_isr1(int irq, spinlock_t *lock)
          {
            // this guarantees interrupt state is saved and that
            // the critical section will not be preempted by the kernel
            spin_lock_irqsave(lock);  
          }
           
           
          // cross function check
          noinline
          void call_spin(spinlock_t *lock)
          {
            spin_lock(lock);
          }
        - >
          #include <stdio.h>

          #include <pthread.h>


          int num = 8; // global variable

          pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; // initialise a
          mutex


          int main() {
              pthread_mutex_lock(&lock); // enter mutex locked region
              switch (num) {
              case 0:
                      num = 0;
                      break;
              case 1:
                      num++;
                      break;
              case 2:
                      num--;
                      break;
              default:
                      pthread_mutex_unlock(&lock); // exit mutex lock region
                      return 0;
              }
              pthread_mutex_unlock(&lock); // exit mutex lock region
              return 0;
          }
        - >
          #include <stdio.h>

          #include <pthread.h>

          #include <unistd.h>


          pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; // initialise a
          mutex

          int num; // global variable


          int main () {
              pthread_mutex_lock(&lock); // enter mutex lock region
              num++;
              pthread_mutex_unlock(&lock); // exit mutex lock region
              return 0;
          }
  language: c/c++
  likelihood: L
  master_id: 137
  msg_templ: ''
  name: Sleep in atomic-context or locked region
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: L
  standards: {}
- alias:
    cert:
      - CON30-C
  category: VUL
  code: LLAT
  cost: H
  csv_string:
    - LLAT0
  desc: >-
    When a thread local's address has been saved, it can be called by its holder
    even after the thread has been terminated.
  details: >-
    #### Abstract

    When a thread local's address has been saved, it can be called by its holder
    even after the thread has been terminated.


    #### Explanation

    Exposing address of a thread local variable can lead to unintended calls to
    illegal locks, or functions that are no longer valid. This results in
    non-deterministic behavior.
  examples:
    bad:
      c:
        - |2
           
          struct completion {
            int done;
          };
           
          struct usb_request {
            struct completion *context;
            void (*complete)(struct usb_request *req);
          };
           
          void complete(struct completion *x)
          {
            printf("%d\n", x->done);
          }
           
          void ffs_epfile_io_complete(struct usb_request *req)
          {
            complete(req->context);
          }
           
          void usb_ep_queue(struct usb_request *req)
          {
            req->complete(req);
          }
           
          void ffs_epfile_io(struct usb_request *req)
          {
            struct completion done;
            req->context = &done;
            req->complete = ffs_epfile_io_complete;
            usb_ep_queue(req);
          }
           
    good: {}
  language: c/c++
  likelihood: P
  master_id: 138
  msg_templ: ''
  name: Thread local live after thread is terminated
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: M
  standards:
    cwe:
      - '412'
- alias:
    cert:
      - CON35-C
  category: VUL
  code: UIL
  cost: H
  csv_string:
    - UIL0
  desc: The lock has not been initialized when spin_lock was called.
  details: >-
    #### Abstract

    The lock has not been initialized when spin_lock was called.


    #### Explanation

    Resource alloation is required to use a spin lock, it also needed to be
    initialized to an unlock state. Failure to do so will lead to
    non-determinstic system behavior
  examples:
    bad:
      c:
        - |
          #include <stddef.h>
          #include <pthread.h>
           
          void mutex_initialise(pthread_mutex_t *lock) {
            pthread_mutex_init(lock, NULL);
          }
           
          void mutex_lock(pthread_mutex_t *lock) {
            pthread_mutex_lock(lock);
          }
           
          void mutex_unlock(pthread_mutex_t *lock) {
            pthread_mutex_unlock(lock);
          }
           
          int main(void) {
              pthread_mutex_t mlock;
              
              // mutex_initialize, nor pthread_mutex_init has been invoked
              mutex_lock(&mlock);
              mutex_unlock(&mlock);
              return 0;
          }
    good: {}
  language: c/c++
  likelihood: L
  master_id: 139
  msg_templ: ''
  name: Uninitialized lock
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    cwe:
      - '667'
- alias:
    cert:
      - CON43-C
  category: VUL
  code: TASR
  cost: H
  csv_string:
    - TASR0
  desc: Test-and-set without proper locking may cause race condition
  details: >-
    #### Abstract

    Test-and-set without proper locking may cause race condition


    #### Explanation

    Modifying the variables that are decided in the test-and-set operation in a
    thread may cause a race condition if such an operation is not protected by
    the lock.
  examples:
    bad:
      c:
        - |
          extern int printf(const char*, ...);
          extern int get_int();
           
          void cmp_set_race_bad() {
            int flag = get_int();
            if (flag == 0) {
              flag = 1;
            }
            else {
              printf("\n");
            }
            printf("1st: get %d\n", flag);
            flag = get_int();
            if (flag != 0) {
              printf("2nd: get %d\n", flag);
            }
            else {
              flag = 1;
            }
            printf("final: %d\n", flag);
          }
    good: {}
  language: c/c++
  likelihood: P
  master_id: 140
  msg_templ: ''
  name: Race condition from test-and-set
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: M
  standards: {}
- alias: {}
  category: VUL
  code: PNC
  cost: M
  csv_string:
    - PAIR-NOT-CALLED
  desc: >-
    Specific functions should be paired. Using the first must also use the
    second in the pair.
  details: >-
    #### Abstract

    Specific functions should be paired. Using the first must also use the
    second in the pair.


    #### Explanation

    If function “irq_of_parse_and_map”  has been called, the corresponding
    “irq_dispose_mapping” must be called during the program execution.
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>
          #include \"case.h\"

          static int sunxi_keyboard_startup(struct sunxi_key_data *key_data,
                                          struct platform_device *pdev)
          {
                  struct device_node *np = NULL;
                  int ret = 0;

                  key_data->reg_base = of_iomap(np, 0);
                  if (key_data->reg_base == 0) {
                          pr_err("%s:Failed to ioremap() io memory region.", __func__);
                          ret = -1;
                  }

                  key_data->irq_num = irq_of_parse_and_map(np, 0);
                  if (key_data->irq_num == 0) {
                          pr_err("%s:Failed to map irq.", __func__);
                          ret = -1;
                  }

                  key_data->mclk = of_clk_get(np, 0);
                  if (IS_ERR_OR_NULL(key_data->mclk)) {
                          pr_debug("%s: keyboard has no clk.", __func__);
                  } else{
                          if (clk_prepare_enable(key_data->mclk)) {
                                  pr_err("%s enable apb1_keyadc clock failed!", __func__);
                                  return -1;
                          }
                  }
                  
                  return ret;
          }
    good:
      c:
        - |-
          #include <stdio.h>
          #include "case.h"

          static int sunxi_keyboard_startup(struct sunxi_key_data *key_data,
                                          struct platform_device *pdev)
          {
                  struct device_node *np = NULL;
                  int ret = 0;

                  key_data->reg_base = of_iomap(np, 0);
                  if (key_data->reg_base == 0) {
                          pr_err("%s:Failed to ioremap() io memory region.", __func__);
                          ret = -1;
                          goto out_iounmap;
                  }

                  key_data->irq_num = irq_of_parse_and_map(np, 0);
                  if (key_data->irq_num == 0) {
                          pr_err("%s:Failed to map irq.", __func__);
                          ret = -1;
                          goto out_dispose_mapping;
                  }

                  key_data->mclk = of_clk_get(np, 0);
                  if (IS_ERR_OR_NULL(key_data->mclk)) {
                          pr_debug("%s: keyboard has no clk.", __func__);
                          goto out_clk;
                  } else{
                          if (clk_prepare_enable(key_data->mclk)) {
                                  pr_err("%s enable apb1_keyadc clock failed!", __func__);
                                  ret = -1;
                          }
                  }

          out_clk:
                  clk_put(key_data->mclk);
          out_dispose_mapping:
                  irq_dispose_mapping(key_data->irq_num);
          out_iounmap:
                  iounmap(key_data->reg_base);

                  return ret;
          }
  language: c/c++
  likelihood: P
  master_id: 141
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the first one of the
    pair of specific functions is used while the second one is not.
  name: Pair not called
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: M
  standards: {}
- alias: {}
  category: VUL
  code: LSO
  cost: M
  csv_string:
    - LSO0
  desc: Operation on resource should not be performed in wrong phase of lifetime.
  details: >-
    #### Abstract

    Operation on resource should not be performed in wrong phase of lifetime.


    #### Explanation

    If developers initialize, use or release resource in wrong phase of
    lifetime, it can lead to unexpected behaviors.
  examples:
    bad:
      c:
        - |
          #include <sys/socket.h>
          #include <arpa/inet.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <unistd.h>

          #define BUF_SZ 256

          int foo(void)
          {
              int n;
              char buffer[BUF_SZ];
              int sockfd = socket(AF_INET, SOCK_STREAM, 0);

              if (sockfd < 0)
              {
                  perror("ERROR opening socket");
                  exit(1);
              }

              struct sockaddr_in addr;
              memset(&addr, 0, sizeof(addr));
              addr.sin_family = AF_INET;
              addr.sin_addr.s_addr = htonl(INADDR_ANY);
              addr.sin_port = htons(3128);
              if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
              {
                  perror("ERROR binding socket");
                  exit(1);
              }

              if (listen(sockfd, 0) < 0)
              {
                  perror("ERROR listening socket");
                  exit(1);
              }

              n = recv(sockfd, buffer, 255, 0);

              // use buffer
              // if buffer is used as argument to system() or to setenv()
              // the buffer may contain untrusted commands or characters leading to unpredictable program behavior
              // ...
              close(sockfd);
              return n;
          }
    good:
      c:
        - |
          #include <sys/socket.h>
          #include <arpa/inet.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <unistd.h>

          #define BUF_SZ 256

          int foo(void)
          {
              int n;
              char buffer[BUF_SZ];
              int sockfd = socket(AF_INET, SOCK_STREAM, 0);

              if (sockfd < 0)
              {
                  perror("ERROR opening socket");
                  exit(1);
              }

              struct sockaddr_in addr;
              memset(&addr, 0, sizeof(addr));
              addr.sin_family = AF_INET;
              addr.sin_addr.s_addr = htonl(INADDR_ANY);
              addr.sin_port = htons(3128);
              if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
              {
                  perror("ERROR binding socket");
                  exit(1);
              }

              if (listen(sockfd, 0) < 0)
              {
                  perror("ERROR listening socket");
                  exit(1);
              }

              close(sockfd);
              return n;
          }
  language: c/c++
  likelihood: P
  master_id: 142
  msg_templ: >-
    In file ${si.filename}, line ${si.line}, function ${si.func} is performed in
    wrong phase of lifetime.
  name: Wrong Phase of Lifetime Operation
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: M
  standards:
    cwe:
      - '666'
- alias: {}
  category: VUL
  code: MBSP
  cost: M
  csv_string:
    - MBSP0
  desc: Multiple sockets should not bind to the same port
  details: >
    #### Abstract

    Multiple sockets should not bind to the same port


    #### Explanation

    If multiple sockets bind to the same port, other services of that port may
    be stolen.
  examples:
    bad:
      c:
        - |-
          #include <sys/socket.h>
          #include <arpa/inet.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <unistd.h>

          void func( void )
          {
              // create socket one
              int sockfd_one;
              int server_len;
              struct sockaddr_in addr;
              sockfd_one = socket(AF_INET, SOCK_STREAM, 0);
              memset(&addr, 0, sizeof(addr));
              addr.sin_family = AF_INET;
              addr.sin_addr.s_addr = htonl(INADDR_ANY);
              addr.sin_port = htons(6789);
              server_len = sizeof(struct sockaddr_in);

              // set SO_REUSEADDR and bind socket one to port
              int opt = 1;
              setsockopt( sockfd_one, SOL_SOCKET,SO_REUSEADDR, (const void *)&opt, sizeof(opt) );
              bind(sockfd_one, (struct sockaddr *) &addr, server_len);

              // create socket two
              int sockfd_two;
              sockfd_two = socket(AF_INET, SOCK_DGRAM, 0);

              // set SO_REUSEADDR and bind socket two to port
              opt = 1;
              setsockopt( sockfd_two, SOL_SOCKET,SO_REUSEADDR, (const void *)&opt, sizeof(opt) );
              bind(sockfd_two, (struct sockaddr *) &addr, server_len);
          }
    good:
      c:
        - |-
          #include <sys/socket.h>
          #include <arpa/inet.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <unistd.h>

          void func( void )
          {
              // create socket one and bind to port
              int sockfd_one;
              int server_len;
              struct sockaddr_in addr;
              sockfd_one = socket(AF_INET, SOCK_STREAM, 0);
              memset(&addr, 0, sizeof(addr));
              addr.sin_family = AF_INET;
              addr.sin_addr.s_addr = htonl(INADDR_ANY);
              addr.sin_port = htons(6789);
              server_len = sizeof(struct sockaddr_in);
              bind(sockfd_one, (struct sockaddr *) &addr, server_len);
          }
  language: c/c++
  likelihood: P
  master_id: 143
  msg_templ: In file ${si.filename}, multiple sockets bind to the same port.
  name: Multiple Sockets Bind to Same Port
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: M
  standards:
    cwe:
      - '605'
- alias: {}
  category: ''
  code: MSR_2_3
  compliance: A
  cost: H
  csv_string:
    - MSR_2_3
  desc: A project should not include undefined data types
  details: >-
    #### Abstract

    A project should not include undefined data types


    #### Explanation

    An undefined data type will cause a waste of resources. When reviewing the
    code, it will also be difficult to determine whether the data type is not
    used due to an error in the programming process or if it is just extra
    code. 
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          typedef int used; // type is declared but not used

          int main()
          {
              printf("finished");
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          typedef int used; // type is declared here

          int main()
          {
              used a = 1; // type is used here
              printf("%d",a);
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: ''
  name: A project should not include undefined data types
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_2_3
- alias: {}
  category: ''
  code: MSR_2_6
  compliance: A
  cost: H
  csv_string:
    - MSR_2_6
  desc: Unused tags cannot be declared in the function
  details: >-
    #### Abstract

    Unused tags cannot be declared in the function


    #### Explanation

    The reviewer of the code cannot judge whether the unused tag is redundant or
    is not used due to negligence, so the unused label cannot be declared. 
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int func( void )
          {
              int i = 5;
              if (i != 5) i = 5;
          lab1: // unused label declared
              return i;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          int func( void )
          {
              int i = 5;
              goto lab1; // label used
              if (i != 5) i = 5;
          lab1: // label declared
              return i;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, unused tags are declared in
    ${so.func}.
  name: Unused label in function not allowed
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_2_6
- alias: {}
  category: ''
  code: MSR_2_7
  compliance: A
  cost: H
  csv_string:
    - MSR_2_7
  desc: Unused parameters should not appear in the function
  details: >-
    #### Abstract

    Unused parameters should not appear in the function


    #### Explanation

    The function should use all its parameters. If the function does not use all
    its parameters, the implementation will not match the declaration of the
    function. 
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int Addtion(int a,int b,int c);

          int main()
          {
              printf("%d",Addtion(1,2,3));
              return 0;
          }
           // three parameters are defined
          int Addtion(int a,int b,int c)
          {
              return a+b; // only two of them are used
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          int Addtion(int a,int b,int c);

          int main()
          {
              printf("%d",Addtion(1,2,3));
              return 0;
          }
          int Addtion(int a,int b,int c)
          {
              return a+b+c; // every parameter is used
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, unused parameters appear in
    ${so.func}.
  name: All declared parameters must be used
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_2_7
- alias: {}
  category: ''
  code: MSR_5_1
  compliance: R
  cost: H
  csv_string:
    - MSR_5_1
  desc: The external identifier must be distinguishable
  details: >-
    #### Abstract

    The external identifier must be distinguishable


    #### Explanation

    In the C99 standard, external identifiers should be distinguished by at
    least the first 31 characters. The external identifiers must be distinct
    with respect to the first 31 characters, so they are deemed unique by the
    compiler. 
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int main()
          {
              // the first 31 characters are not distinct
              int this_is_a_non_compliant_example_a = 1;
              int this_is_a_non_compliant_example_b = 2; 
              int a;
              a = this_is_a_non_compliant_example_a + this_is_a_non_compliant_example_b;
              printf("%d\n",a);
              return 0;
          } 
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          int main()
          {
              // the first 31 characters are distinct
              int a_non_compliant_example_a = 1;
              int a_non_compliant_example_b = 2; 
              int a;
              a = a_non_compliant_example_a + a_non_compliant_example_b;
              printf("%d\n",a);
              return 0;
          } 
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, external identifiers
    are not unique.
  name: All external identifiers must be unique up to 31 characters
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_5_1
- alias: {}
  category: ''
  code: MSR_5_2
  compliance: R
  cost: H
  csv_string:
    - MSR_5_2
  desc: >-
    Identifiers declared in the same scope and name space should be
    distinguishable
  details: >-
    #### Abstract

    Identifiers declared in the same scope and name space should be
    distinguishable


    #### Explanation

    In the same scope, the first 31 characters of different identifiers should
    not be exactly the same to ensure they are distinguishable.
  examples:
    bad:
      c:
        - >-

          #include <stdio.h>


          // this example have two identifiers, first 31 characters are the same

          extern int a_non_compliant_example_a = 1;

          extern int a_non_compliant_example_b = 2; // two indistinct
          identifiers are defined in the same scope


          int main()

          {
              int a;
              a = 1 + a_non_compliant_example_b;
              printf("%d\n",a);
              return 0;
          } 
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - >-

          #include <stdio.h>


          // this example have two identifiers, first 31 characters are the same

          extern int this_is_a_non_compliant_example_a = 1; // first identifier,
          global scope


          int main()

          {
              int a;
              int this_is_a_non_compliant_example_b = 2; // two identifiers are defined in local scope
              a = 1 + this_is_a_non_compliant_example_b;
              printf ("%d\n",a);
              return 0;
          } 
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, identifiers are not
    distinguishable.
  name: Identifiers of same scope and name space must be unique
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_5_2
- alias: {}
  category: ''
  code: MSR_5_3
  compliance: R
  cost: H
  csv_string:
    - MSR_5_3
  desc: >-
    The identifier of the internal scope should be different from the identifier
    of the external scope
  details: >-
    #### Abstract

    The identifier of the internal scope should be different from the identifier
    of the external scope


    #### Explanation

    When defining variables in the internal scope, you should avoid having the
    same name as the external scope to prevent creating ambiguity.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int a = 3; // identifier defined, outer scope

          int main()
          {
              int a; // identifier defined, inner scope, covering the outer one
              a = 4;
              printf("%d",a);
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          int a = 3; // identifier defined, outer scope

          int main()
          {
              int b; // identifier defined, inner scope, different form the outer one
              b = 4;
              printf("%d",b);
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, identifiers are not
    distinct.
  name: Identifiers in inner and outer scope must be distinct
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_5_3
- alias: {}
  category: ''
  code: MSR_5_6
  compliance: R
  cost: H
  csv_string:
    - MSR_5_6
  desc: A typedef identifier must be unique
  details: >-
    #### Abstract

    A typedef identifier must be unique


    #### Explanation

    Unless the alias is defined in the header file, and the header file is
    included, the alias defined by the typedef used must be unique in all
    namespaces.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          typedef int my_name; // typedef declared

          int main()
          {
              int my_name = 1; // variable declared, same identifier
              printf("%d",my_name);
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          typedef int my_name; // unique typedef declared

          int main()
          {
              int my_name_2 = 1; // unique variable declared 
              printf("%d",my_name_2);
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the typedef identifier
    is not unique.
  name: typedef name should be a unique identifier
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_5_6
- alias: {}
  category: ''
  code: MSR_5_7
  compliance: R
  cost: H
  csv_string:
    - MSR_5_7
  desc: A tag must be unique
  details: >-
    #### Abstract

    A tag must be unique


    #### Explanation

    Unless the tag is defined in the header file, and the header file is
    included, the tag used must be unique in all namespaces.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          struct my_name // tag declared
          {
              int a;
              int b;
          };

          int main()
          {
              int my_name = 1; // variable declared, same identifier
              printf("%d",my_name);
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          struct my_name // unique tag declared
          {
              int a;
              int b;
          };

          int main()
          {
              int my_name_2 = 1; // unique variable declared
              printf("%d",my_name_2);
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, tag names are not
    unique identifiers.
  name: Tag names should be a unique identifier
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_5_7
- alias: {}
  category: ''
  code: MSR_6_1
  compliance: R
  cost: H
  csv_string:
    - MSR_6_1
  desc: Bit fields must be declared as appropriate data types
  details: >-
    #### Abstract

    Bit fields must be declared as appropriate data types


    #### Explanation

    When declaring a bit field, it must be declared as one of the specified data
    types either signed or unsigned. It cannot be omitted in the declaration.
  examples:
    bad:
      c:
        - |-

          struct str {
            int a:2;
            unsigned int b1:2;
          };


          struct str1 {
            unsigned int b1:2;
            short b:2;
          };

          int foo()
          {
            printf("finished\n");
            return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          struct str
          {
              signed int a:2;   // signed int permitted
              unsigned int b:2; // unsigned int permitted
          };

          int main()
          {
              printf("finished");
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, bit fields are not
    appropriate data types.
  name: Bit field types must not be builtin types
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_6_1
- alias: {}
  category: ''
  code: MSR_6_2
  compliance: R
  cost: H
  csv_string:
    - MSR_6_2
  desc: A bit field that only occupies one bit cannot be signed data
  details: >-
    #### Abstract

    A bit field that only occupies one bit cannot be signed data


    #### Explanation

    Since signed data requires the first sign bit, a bit field that only
    occupies one bit is not allowed to be defined as a signed data type.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          struct str
          {
              signed int a:1;   // single-bit bit field declared signed
          };

          int main()
          {
              printf("finished");
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          struct str
          {
              unsigned int a:1;   // single-bit bit field declared unsigned
          };

          int main()
          {
              printf ("finished") ;
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the single-bit named
    field is signed data.
  name: Single-bit named field must be unsigned
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_6_2
- alias: {}
  category: ''
  code: MSR_7_4
  compliance: R
  cost: H
  csv_string:
    - MSR_7_4
  desc: >-
    Always assign a string literal through a const qualified pointer to char
    type
  details: >-
    #### Abstract

    Always assign a string literal through a const qualified pointer to char
    type


    #### Explanation

    Since the constant string is stored in the static storage area, the
    modification operation will cause an error. Only the constant string can be
    copied to the pointer to the constant string to prevent its modification
    operation.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          extern int foo (char *a);
          extern int foo2 (char *b);

          int func()
          {
              char *str = "string"; // str is not const-qualified
              foo ( "string" );
              foo2 ( "string" ); // may be modified by foo
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          extern int foo (const char *a);
          extern int foo2 (const char *b);

          int func()
          {
              const char *str = "string"; // str is not const-qualified
              foo ( "string" );
              foo2 ( "string" ); // string can not be modified
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, a string literal is not
    assigned to char type.
  name: String literal must only be assigned to a const char pointer
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_7_4
- alias: {}
  category: ''
  code: MSR_8_4
  compliance: R
  cost: H
  csv_string:
    - MSR_8_4
  desc: >-
    Defining objects that have external linkage should be compatible with their
    declarations
  details: >-
    #### Abstract

    Defining objects that have external linkage should be compatible with their
    declarations


    #### Explanation

    When defining an object or function with external linkage, the data type,
    number of parameters, etc. of the object or function must be compatible with
    the external declaration.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          extern int x = 0; // x not declared before

          extern int func1(int a); // extern function declared

          int func1(int a, int b) // parameters different
          {
              return 0;
          }

          int func2( void )
          {
              // func2 not declared before
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          extern int x;
          int x = 0; // compliant

          extern int func1(int a); // extern function declared

          int func1(int a) // extern compatible funtion defined
          {
              return 0;
          }

          // compliant for functions with internal linkage
          static int func2 ( void )
          {
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the external object is
    not compatible with its declaration.
  name: External object, when defined must be the same as a visble declaration.
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_8_4
- alias: {}
  category: ''
  code: MSR_8_8
  compliance: R
  cost: H
  csv_string:
    - MSR_8_8
  desc: The static specifier should be added to the object that has internal linkage
  details: >-
    #### Abstract

    The static specifier should be added to the object that has internal linkage


    #### Explanation

    When declaring an object or function with internal linkage, a static
    specifier must be added to ensure the declaration is correct. 
  examples:
    bad:
      c:
        - |-

          // this example will cause compilation error
          extern int func (int a); // declare external scope

          static int func (int a) // function with internal linkage declared
          {
              return a;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          static int func (int a) // function defined with "static"
          {
              return a;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the object with
    internal linkage is not declared static.
  name: 'Objects with internal linkage should be declared static '
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_8_8
- alias: {}
  category: ''
  code: MSR_8_9
  compliance: A
  cost: H
  csv_string:
    - MSR_8_9
  desc: The object should only be defined in the scope in which it appears
  details: >-
    #### Abstract

    The object should only be defined in the scope in which it appears


    #### Explanation

    When an object only functions in a certain scope, it should be defined in
    that scope to prevent other scopes from changing its value.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          extern int foo(int *a);
          extern void foo2( void );
          static int num = 0; // object declared, global scope

          int count( void )
          {
              num++; // object appears only in this function
              return num;
          }

          extern void foo2( void )
          {
              foo(&num); // object may be modified at outer scope
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          extern int foo (int *a);
          extern void foo2 ( void );

          int count ( void )
          {
              static int num = 0; // object declared at block scope
              num++; // object appears only in this function
              return num;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the object is not
    defined in the scope in which it appears.
  name: >-
    An object should be defined at block scope if its identifier only appears in
    a single function
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_8_9
- alias: {}
  category: ''
  code: MSR_8_10
  compliance: R
  cost: H
  csv_string:
    - MSR_8_10
  desc: A static storage class should be used to declare inline functions
  details: >-
    #### Abstract

    A static storage class should be used to declare inline functions


    #### Explanation

    Referencing an inline function of an external linkage may affect the
    execution time, so the inline function should be declared with a static
    storage class.
  examples:
    bad:
      c:
        - >-

          #include <stdio.h>


          extern inline int func( void ); // inline function declared with
          external linkage


          int func2( void )

          {
              func();
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - >-

          #include <stdio.h>


          static inline int func( void ); // inline function declared with
          internal linkage


          int func2( void )

          {
              func();
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, inline function ${so.func} does not
    have static declaration.
  name: Inline function should have a static declaration
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_8_10
- alias: {}
  category: ''
  code: MSR_8_11
  compliance: A
  cost: H
  csv_string:
    - MSR_8_11
  desc: The size of the array of external linkage must be explicitly specified
  details: >-
    #### Abstract

    The size of the array of external linkage must be explicitly specified


    #### Explanation

    In order to ensure consistency and determine the boundaries of the storage
    area, the size of the array must be determined when declaring an externally
    linked array.
  examples:
    bad:
      c:
        - >-

          #include <stdio.h>


          extern int array[]; // declare array with external linkage but without
          size


          int foo ( void )

          {
              return array[10]; // 10 may be bigger than actual array size
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - >-

          #include <stdio.h>


          extern int array[20]; // declare array with external linkage and its
          size


          int foo ( void )

          {
              return array[10];
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the size of the array
    of external linkage is not explicitly specified.
  name: >-
    When an array with external linkage is declared, its size should be
    explicitly specified
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_8_11
- alias: {}
  category: ''
  code: MSR_8_12
  compliance: R
  cost: H
  csv_string:
    - MSR_8_12
  desc: The value of the enumeration member assigned by default must be unique
  details: >-
    #### Abstract

    The value of the enumeration member assigned by default must be unique


    #### Explanation

    In order to avoid the incorrect repetition of the value of the enumeration
    member, the value of the enumeration member should be 
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          // implicitly-specified enmueration sat is not unique
          typedef enum weekday {thu = 4, fri, sat, sun = 6};
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          // all implicitly-specified enmueration constants is unique
          typedef enum weekday {thu = 4, fri, sat = 6, sun = 6};
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the implicitly
    specified enum constant list is not unique.
  name: An implicitly specified enum constant list should be unique
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_8_12
- alias: {}
  category: ''
  code: MSR_8_13
  compliance: A
  cost: H
  csv_string:
    - MSR_8_13
  desc: Try to declare pointers with const qualifier
  details: >-
    #### Abstract

    Try to declare pointers with const qualifier


    #### Explanation

    A pointer should always point to the same underlying qualified type. Mixed
    type assignments should be always explicitly casted.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func (char *ptr);

          void func (char *ptr) // pointer declared is not const-qualified
          {
              // ptr pointed to is not modified, it should be const-qualified
              printf ("%c", *ptr);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func (const char *ptr);

          void func (const char *ptr) // pointer declared const-qualified
          {
              // ptr pointed to is not modified
              printf ("%c", *ptr);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the pointer is not
    declared with const qualifier.
  name: A pointer should point to a const-qualified type whenever possible
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_8_13
- alias: {}
  category: ''
  code: MSR_8_14
  compliance: R
  cost: H
  csv_string:
    - MSR_8_14
  desc: Try to avoid using the restrict type qualifier
  details: >-
    #### Abstract

    Try to avoid using the restrict type qualifier


    #### Explanation

    In order to prevent problems such as overlapping of the areas pointed to by
    the pointer, the restrict type qualifier should be avoided as much as
    possible.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          // restrict-qualified parameters declared
          extern void func (int * restrict ptr1, int * restrict ptr2);

          void func2(void)
          {
              int i;
              int *a,*b;
              a = b = &i;
              // overlap memory areas
              func (a, b);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          // restrict type qualifier removed
          extern void func (int * ptr1, int * ptr2);

          void func2(void)
          {
              int i;
              int *a,*b;
              a = b = &i;
              func (a, b);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the restrict type
    qualifier is used
  name: Restrict qualifier should not be used
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_8_14
- alias: {}
  category: ''
  code: MSR_9_3
  compliance: R
  cost: H
  csv_string:
    - MSR_9_3
  desc: Arrays must not be partially initialized
  details: >-
    #### Abstract

    Arrays must not be partially initialized


    #### Explanation

    In order to ensure that there are no unprocessed values in the array after
    explicitly initializing the array, all elements in the array must also be
    explicitly initialized.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int func ( void )
          {
              int a[10] = {0, 0, 0}; // array only initialized three elements
              return a[9]; // a[9] is still unknown value
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          int func ( void )
          {
              int a[10] = {0}; // array totally initialized
              return a[9];
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, arrays are partially
    initialized
  name: Arrays should not be partially initialized
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_9_3
- alias: {}
  category: ''
  code: MSR_9_4
  compliance: R
  cost: H
  csv_string:
    - MSR_9_4
  desc: The elements in the object can only be initialized once
  details: >-
    #### Abstract

    The elements in the object can only be initialized once


    #### Explanation

    When initializing arrays and structures that are not in the default order,
    you must not initialize the same element(s) repeatedly.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func( void )
          {
              // a[0] initialized twice
              int arr[3] = { [ 0 ] = 3, [ 1 ] = 2, [ 2 ] = 1, [ 0 ] = 4};
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func( void )
          {
              // all elements initialized once
              int arr[3] = { [ 0 ] = 3, [ 1 ] = 2, [ 2 ] = 1};
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the elements in the
    object have been initialized more than once
  name: Multiple initialization of elements in an object is not allowed
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_9_4
- alias: {}
  category: ''
  code: MSR_9_5
  compliance: R
  cost: H
  csv_string:
    - MSR_9_5
  desc: >-
    The size of the array must be declared if an explicit initializer is used on
    the array
  details: >-
    #### Abstract

    The size of the array must be declared if an explicit initializer is used on
    the array


    #### Explanation

    In order to determine the maximum number of elements in the array, when this
    array is explicitly initialized, the array size must be specified.
  examples:
    bad:
      c:
        - |-

          // This is example from MISRA document
          // Non-compliant - probably unint entional to have single element
          int a1[ ] = { [ 0 ] = 1 };
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          // This is example from MISRA document
          // Compliant
          int a2[ 10 ] = { [ 0 ] = 1 };
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the size of the array
    that uses explicit initializer is not declared
  name: If initializers are used in an array, its size must be known
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_9_5
- alias: {}
  category: ''
  code: MSR_10_3
  compliance: R
  cost: H
  csv_string:
    - MSR_10_3
  desc: You cannot assign values to objects with different essential types
  details: >-
    #### Abstract

    You cannot assign values to objects with different essential types


    #### Explanation

    It is erroneous to assign the value of an expression to an object with an
    inappropriate type or is not large enough to represent the data type of the
    value.
  examples:
    bad:
      c:
        - |-

          #include <stdint.h>
          #include <stdbool.h>

          void func ( void )
          {
              short short_a;
              long int b;
              short_a = b;            // b assigned to narrower essential type
              uint16_t c = 0.5f;    // float to unsigned
              bool d = 1;             // signed to boolean
              char e = 3;             // signed to char
              uint32_t f = 'test';  // char to unsigned
              uint16_t g = 5;       // signed to unsigned
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdint.h>
          #include <stdbool.h>

          void func ( void )
          {
              short short_a;
              int b;              // b declared as int for illustration
              b = short_a;        // short_a assigned to wider essential type object
              uint16_t c = 0;   // compliant by exception
              bool d = false;     // compliant
              uint16_t e = 5;   // compliant by exception
              char f = "f_char";  // char to char
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func} includes down casting of
    an expression
  name: Down casting of an expression is not allowed
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_10_3
- alias: {}
  category: ''
  code: MSR_10_4
  compliance: R
  cost: H
  csv_string:
    - MSR_10_4
  desc: >-
    The two operands of the same operator must be of the same essential type
    category
  details: >-
    #### Abstract

    The two operands of the same operator must be of the same essential type
    category


    #### Explanation

    Using binary or ternary operands for two different types of operands may
    cause some information of the resulting value to be lost. Therefore, in
    general, the two operands of the uniform operator should be of the same
    type.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int int_var;
              char char_var;
              // float 1.0f added to char char_var, not permitted
              char_var += 1.0f;
              // float 1.0f added to int int_var, differnt type
              int_var += 1.0f;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int int_var;
              char char_var;
              // int 1 added to char char_var, permitted
              char_var += 1;
              // int 1 added to int int_var, same type
              int_var += 1;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the two operands of the
    same operator are not of the same essential type category
  name: operands and type conversion
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_10_4
- alias: {}
  category: ''
  code: MSR_10_6
  compliance: R
  cost: H
  csv_string:
    - MSR_10_6
  desc: >-
    The use of composite expressions to assign values to objects of larger data
    types should use explicit conversions
  details: >-
    #### Abstract

    The use of composite expressions to assign values to objects of larger data
    types should use explicit conversions


    #### Explanation

    Explicit conversion must be used when converting the value of a composite
    expression to a data type with more storage space and assigning it to an
    object.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              long int long_var;
              short int short_a, short_b;
              short_a = short_b = 1;
              long_var = short_a + short_b; // implicitly converted to long
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              long long_var;
              short short_a, short_b;
              short_a = 1;
              short_b = 1;
              long_var = ( long )short_a + short_b; // explicitly converted to long
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the use of composite
    expressions to assign values to objects of larger data types does not use
    explicit conversions
  name: 'Assignment from a composite expression should remain the same size '
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_10_6
- alias: {}
  category: ''
  code: MSR_10_7
  compliance: R
  cost: H
  csv_string:
    - MSR_10_7
  desc: >-
    An explicit conversion is used when a composite expression is converted to a
    larger data type as an operand
  details: >-
    #### Abstract

    An explicit conversion is used when a composite expression is converted to a
    larger data type as an operand


    #### Explanation

    When a composite expression is used as one of the operands of an operator
    and needs to be converted to a larger data type, explicit conversion must be
    used.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              short int short_a, short_b;
              long int long_a, long_b;
              long_a = 1;
              short_a = short_b = 2;
              long_b = (short_a * short_b) * long_a; // implicitly converted to long
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              short int short_a, short_b;
              long int long_a, long_b;
              long_a = 1;
              short_a = short_b = 2;
              long_b = ( ( long ) short_a * short_b ) * long_a; // explicitly converted to long
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, an explicit conversion
    is not used when a composite expression is converted to a larger data type
    as an operand
  name: For composite expressions, any up casting on either side is not allowed
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_10_7
- alias: {}
  category: ''
  code: MSR_10_8
  compliance: R
  cost: H
  csv_string:
    - MSR_10_8
  desc: >-
    The value of a composite expression cannot be cast to an inappropriate data
    type
  details: >-
    #### Abstract

    The value of a composite expression cannot be cast to an inappropriate data
    type


    #### Explanation

    The data type cast conversion may cause the loss or change of data.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>
          #include<stdint.h>

          void func ( void )
          {
              float float_a, float_b;
              int int_var;
              float_a = float_b = 1.0f;
              int_var = ( int ) ( float_a + float_b ); // casted to inappropriate type int

              uint8_t uint_var;
              uint_var = ( uint8_t ) ( float_a + float_b ); // different essential type
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
          #include <stdint.h>

          void func ( void )
          {
              float float_a, float_b;
              int int_var;
              float_a = float_b = 1.0f;
              int_var = ( int ) float_a + ( int ) float_b; // float_a and float_b casted to type int

              uint8_t uint_var;
              uint_var = ( uint8_t ) int_var; // compliant
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the value of a
    composite expression is cast to an inappropriate data type
  name: Composite expression cannot be up casted
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_10_8
- alias: {}
  category: ''
  code: MSR_11_2
  compliance: R
  cost: H
  csv_string:
    - MSR_11_2
  desc: >-
    Pointers to incomplete types cannot be converted to pointers of other types
    and vice versa 
  details: >-
    #### Abstract

    Pointers to incomplete types cannot be converted to pointers of other types
    and vice versa 


    #### Explanation

    Type conversion operations between pointers to incomplete types may destroy
    the encapsulation of incomplete types, so pointers of incomplete types
    cannot be converted to pointers of other types.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          union uni; // incomplete type declared

          void func ( void )
          {
              union uni *ptr_union;
              int *ptr_int; 
              // ptr_int converted to pointer to incomplete type
              ptr_union = ( union uni * ) ptr_int;
              // ptr_union (incomplete type) converted to int pointer
              ptr_int = ( int * )ptr_union;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          union uni
          {
              int i;
              char c;
          }; // union declared

          void func ( void )
          {
              union uni union_var;
              union_var.i =1;
              int *ptr_int;
              // ptr_int point to union_var.i
              ptr_int = &union_var.i;

              // exception 1
              struct a;
              struct a *p;
              p = NULL;

              // exception 2
              struct a *test ( void );
              ( void ) test ();
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, pointers to incomplete
    types are converted to pointers of other types
  name: No conversion of pointer to incomplete type convert to any other type
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_11_2
- alias: {}
  category: ''
  code: MSR_11_3
  compliance: R
  cost: H
  csv_string:
    - MSR_11_3
  desc: Pointers cannot be cast to pointers of other types
  details: >-
    #### Abstract

    Pointers cannot be cast to pointers of other types


    #### Explanation

    Casting one type of pointer to another type of pointer may be incorrectly
    aligned causing undefined behavior, so you cannot convert pointers to other
    types of pointers.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int *ptr_int;                 // pointer to int declared
              char *ptr_char;               // pointer to char declared
              ptr_int = ( int * ) ptr_char; // convert to int type pointer

              const int * const * ptr_const_int;
              ptr_const_int = ( const int * const * ) ptr_int; // convert to constant-qualified int type pointer
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int *ptr_int;    // pointer to int declared
              char *ptr_char;  // pointer to char declared
              *ptr_char = NULL;
              *ptr_int = NULL; // pointers point to null
              const *ptr_const;
              const volatile *ptr_const_v;
              ptr_const_v = (const volatile *) ptr_const; // compliant
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, pointers are cast to
    pointers of other types
  name: No casting between pointers of different types
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_11_3
- alias: {}
  category: ''
  code: MSR_11_4
  compliance: A
  cost: H
  csv_string:
    - MSR_11_4
  desc: Avoid the conversion between pointers and integers
  details: >-
    #### Abstract

    Avoid the conversion between pointers and integers


    #### Explanation

    Implementing the conversion between pointers and integers may result in data
    overflow of the integers or mis-alignment of the pointers. Avoid conversion
    between pointers and integers as much as possible.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int *ptr_int;
              int int_a, int_b;
              int_a = 1;
              ptr_int = ( int * ) int_a; // convert int to pointer
              int_b = ( int ) ptr_int;   // convert pointer to type int
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int *ptr_int;
              int int_a, int_b;
              int_a = 1;
              ptr_int = &int_a; // ptr_int point to int_a
              int_b = *ptr_int; // *ptr_int assigned to int_b
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, there is conversion
    between pointers and integers
  name: No conversion of int type to pointer
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_11_4
- alias: {}
  category: ''
  code: MSR_11_5
  compliance: A
  cost: H
  csv_string:
    - MSR_11_5
  desc: Avoid converting null pointers to pointers to objects
  details: >-
    #### Abstract

    Avoid converting null pointers to pointers to objects


    #### Explanation

    Conversion from pointer to void into pointer to object may result in
    undefined behaviour.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              void *ptr_void; // void pointer declared
              int *ptr_int;   // int pointer declared
              int int_var;
              ptr_void = &int_var;
              // convert void pointer into int pointer
              ptr_int = ( int * ) ptr_void;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              void *ptr_void; // void pointer declared
              int *ptr_int;   // int pointer declared
              int int_var;
              ptr_int = &int_var;
              // convert int pointer into void pointer
              ptr_void = ( void * ) ptr_int;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, null pointers are
    coverted to pointers to objects
  name: No conversion from pointers to void into pointer to object
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_11_5
- alias: {}
  category: ''
  code: MSR_11_6
  compliance: R
  cost: H
  csv_string:
    - MSR_11_6
  desc: Cannot perform a null type pointer and arithmetic type conversion
  details: >-
    #### Abstract

    Cannot perform a null type pointer and arithmetic type conversion


    #### Explanation

    During data conversion, data type conversion between null pointers and
    arithmetic types may cause unalignment with undefined behavior during data
    conversion.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              void *ptr_void;
              int int_var;
              // convert int_var to void pointer
              ptr_void = ( void * ) int_var;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          #define ZERO 0

          void func ( void )
          {
              void *ptr_void;
              int int_var;
              // ptr_void point to the address of int_var
              ptr_void = &int_var;
              ptr_void = (void *)ZERO;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, there is null type
    pointer and arithmetic type conversion
  name: No casting between a void pointer and an arithmatic type
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_11_6
- alias: {}
  category: ''
  code: MSR_11_7
  compliance: R
  cost: H
  csv_string:
    - MSR_11_7
  desc: Cannot cast pointers to objects and non-integer arithmetic types
  details: >-
    #### Abstract

    Cannot cast pointers to objects and non-integer arithmetic types


    #### Explanation

    In order to prevent undefined behavior during the type conversion process,
    the data type conversion between the pointer to the object and the
    non-integer arithmetic is not allowed. 
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              char a, b;
              int *p;
              a = ( char ) p;  // non-compliant
              p = ( int * ) b; // non-compliant
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int a, b;
              int *p;
              a = ( int ) p; // compliant
              p = ( int * ) b; // compliant
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, there is casting
    between pointers to objects and non-integer arithmetic types
  name: No casting between void pointer and a non-int arithmatic type
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_11_7
- alias: {}
  category: ''
  code: MSR_11_8
  compliance: R
  cost: H
  csv_string:
    - MSR_11_8
  desc: Pointer data type cast cannot remove const or volatile qualifiers
  details: >-
    #### Abstract

    Pointer data type cast cannot remove const or volatile qualifiers


    #### Explanation

    The const and volatile qualifiers in the definition cannot be removed when
    the pointer data type is converted. This may cause errors in the reading and
    writing process of the pointer.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>
          #include <malloc.h>

          void func ( void );

          void func ( void )
          {
              int * const *p_constpt;
              volatile int *p_volatile;
              // pointer to const declared
              const int * ptr_const = ( int *) malloc ( sizeof ( int ) );
              int *ptr_int;
              int * *p_ptr_int;
              // const qualifier removed in a cast
              ptr_int = ( int * ) ptr_const;
              ptr_int = ( int * ) p_volatile;
              p_ptr_int = ( int * * ) p_constpt;
              // more code that may change ptr_const
              // ... 
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
          #include <malloc.h>

          void func ( void );

          void func ( void )
          {
              // const pointer declared
              int * const ptr_const = ( int *) malloc ( sizeof ( int ) );
              int *ptr_int;
              // ptr_int point to the address of ptr_const
              ptr_int = ptr_const;
              // more code that may change ptr_const
              // ...
              
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, pointer data type cast
    removes const or volatile qualifiers
  name: 'Const or volatile pointers to pointed should not be cast away '
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_11_8
- alias: {}
  category: ''
  code: MSR_11_9
  compliance: R
  cost: H
  csv_string:
    - MSR_11_9
  desc: A null integer pointer can only point to the macro NULL
  details: >-
    #### Abstract

    A null integer pointer can only point to the macro NULL


    #### Explanation

    An integer constant expression with the value 0 should be derived from
    expansion of the macro NULL if it appears as the value being assigned to a
    pointer or an operand of equal/not-equal, or operand of a trigraph.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func ( void );

          void func ( void )
          {
              int *int_ptr = 0; // 0 assigned to ptr_int
              // 0 appear as an operand with the other operand a pointer
              if ( int_ptr != 0 )
              {
                  *int_ptr = NULL;
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func ( void );

          void func ( void )
          {
              int *int_ptr = NULL; // ptr_int point to NULL
              // NULL appear as an operand with the other operand a pointer
              if ( int_ptr != (int *)NULL )
              {
                  *int_ptr = NULL;
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, a null integer pointer
    not only points to the macro NULL
  name: int null pointer const must be the NULL macro
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_11_9
- alias: {}
  category: ''
  code: MSR_12_2
  compliance: R
  cost: H
  csv_string:
    - MSR_12_2
  desc: >-
    The right operand of the shift operator should be taken from zero to one
    less than the number of bits in the left operand
  details: >-
    #### Abstract

    The right operand of the shift operator should be taken from zero to one
    less than the number of bits in the left operand


    #### Explanation

    The right operand of the shift operator should be a positive integer, the
    value range is from zero to one less than the number of digits in the left
    operand. Any value beyond this range will cause undefined behavior.
  examples:
    bad:
      c:
        - |-

          #include <stdint.h>

          void func ( void );

          void func ( void )
          {
              uint16_t uint16_var = 2;
              // 17 is bigger than the size of uint16_var
              uint16_var = uint16_var << 17;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdint.h>

          void func ( void );

          void func ( void )
          {
              uint16_t uint16_var = 2;
              uint32_t uint32_var;
              // 17 is in the range 0 to the size of uint16_var
              uint32_var = uint32_var << 17;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the right operand of
    the shift operator is not taken from zero to one less than the number of
    bits in the left operand
  name: Shift amount of shift operator must be smaller than the bit size of operand
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_12_2
- alias: {}
  category: ''
  code: MSR_12_3
  compliance: A
  cost: H
  csv_string:
    - MSR_12_3
  desc: Try not to use the comma operator
  details: >-
    #### Abstract

    Try not to use the comma operator


    #### Explanation

    Since using the comma operator will reduce the readability of the code, try
    to avoid using the comma operator.
  examples:
    bad:
      c:
        - |-

          #include <stdint.h>

          static char a[ 10 ];

          void func ( void )
          {
              int i;
              char *p;
              // comma operator would reduce the readability of code
              for ( i = 0, p = &a[ 0 ]; i < 10 ; ++i, *p++ = i)
              {
                  foo(p);
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdint.h>

          static char a[ 10 ];

          void func ( void )
          {
              int i;
              char *p;
              // same effect achieved by other mean
              p = &a[ 0 ];
              for ( i = 0; i < 10 ; ++i)
              {
                  *p++ = i;
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the comma operator is
    used
  name: Comma operator not allowed
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_12_3
- alias: {}
  category: ''
  code: MSR_12_4
  compliance: A
  cost: H
  csv_string:
    - MSR_12_4
  desc: A constant expression should not cause an unsigned integer wrap-around
  details: >-
    #### Abstract

    A constant expression should not cause an unsigned integer wrap-around


    #### Explanation

    To prevent wrap-around, the value range of the unsigned integer constant
    expression should be in the range of zero to the maximum value that the
    unsigned integer can represent.
  examples:
    bad:
      c:
        - >-

          #include <stdio.h>


          #define MAXIMUM 0xffffffffu // value of unsigned int (assume int is 32
          bits)

          #define ONE     0x1u

          void func( void );


          void func( void )

          {
              unsigned int uint_var;
              // the value of MAXIMUM + 1 lead to wrap-around
              uint_var = MAXIMUM + ONE;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          #define MAXIMUM 0xffffffffu // maximum value of unsigned int

          const unsigned int const_int = 1;
          void func( void );

          void func( void )
          {
              unsigned int uint_var;
              // 0xffffffff assigned to long_long_var
              uint_var = MAXIMUM;
              // uint_var + 1 and uint_var + const_int is not a constant expression
              uint_var = uint_var + 1;
              uint_var = uint_var + const_int;
              
              if (( 1 < 0 ) || ( 0u - 10u ))
              {
                  // compliant
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, a constant expression
    causes an unsigned integer wrap-around
  name: Const expression should not cause unsigned wrap-around
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_12_4
- alias: {}
  category: ''
  code: MSR_13_1
  compliance: R
  cost: H
  csv_string:
    - MSR_13_1
  desc: The initialization list should not have side effects
  details: >-
    #### Abstract

    The initialization list should not have side effects


    #### Explanation

    In order to avoid causing errors in the initialization content and side
    effects affecting the operation of the program, operations that produce side
    effects such as assigning other parameters to other parameters, should not
    be performed in the initialization list.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func( void )
          {
              int x = 0;
              // object x modified due to side effect
              int arr[2] = { ++x, ++x };
              // more code may call x
              // ...
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func( void )
          {
              int x = 0;
              // array initialized with no side effect
              int arr[2] = { 1, 2 };
              // more code may call x
              // ...
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the initialization list
    has side effects
  name: Initializer lists should not contain persistent side effects
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_13_1
- alias: {}
  category: ''
  code: MSR_13_2
  compliance: R
  cost: H
  csv_string:
    - MSR_13_2
  desc: >-
    The values and side effects of all expressions in the execution order must
    be the same
  details: >-
    #### Abstract

    The values and side effects of all expressions in the execution order must
    be the same


    #### Explanation

    Since the expression may have multiple execution orders, the design
    expression should ensure that the value of the expression and its side
    effects are the same in all possible execution orders.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int func( void )
          {
              int a = 6;

              a += a -= a*a;
              return a;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          int func( void )
          {
              int a = 6;
              // the value will sure to be -60
              a -= a*a;
              a += a;
              return a;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, the value of ${so.func} is not
    deterministic in all possible execution orders.
  name: Persistent side effect expressions should be the same
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_13_2
- alias: {}
  category: ''
  code: MSR_13_3
  compliance: A
  cost: H
  csv_string:
    - MSR_13_3
  desc: >-
    The increment (++) or decrement (--) operators cannot have additional side
    effects
  details: >-
    #### Abstract

    The increment (++) or decrement (--) operators cannot have additional side
    effects


    #### Explanation

    Avoid mixing increment or decrement operators with other operators in
    expressions, including function calls, as this will cause an undefined
    behavior. Doing so will impair readability of the code.
  examples:
    bad:
      c:
        - "\n#include <stdio.h>\n\nint func1( void )\n{\n    int int_a, int_b, int_c;\n    int_a = int_b = 1;\n    // the\_complex\_expression\_impairs\_the\_readability\n    int_c = ++int_a * int_b--;\n    return int_c;\n}\n\nvoid func2 ( void )\n{\n    int x = 1;\n    // function call is side effect\n    if ( ( func1() - ++x ) > 5)\n    {\n        // non-compliant\n    }\n}"
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          int func( void )
          {
              int int_a, int_b, int_c;
              int_a = int_b = 1;
              // make the code more readable by this mean
              ++int_a;
              int_c = int_a * int_b;
              int_b--;
              return int_c;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the increment (++) or
    decrement (--) operators have additional side effects
  name: Side effect free expr (except ++, --)
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_13_3
- alias: {}
  category: ''
  code: MSR_13_4
  compliance: A
  cost: H
  csv_string:
    - MSR_13_4
  desc: The result of the assignment operator cannot be used
  details: >-
    #### Abstract

    The result of the assignment operator cannot be used


    #### Explanation

    The result of the assignment operator should not be used since it introduces
    additional side-effects. Doing so also impairs readability of the code.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>
          #include <stdbool.h>

          int test( void )
          {
            return 0;
          }

          int func(int x, int y)
          {
            int ret_var;
            ret_var = 1;
            bool bool_var;

            if ( ( ret_var == 1 ) || ( bool_var = true ) )
            {
              // non-compliant
            }

            if ( ( ret_var = test() ) > 1 )
            {
              // non-compliant
            }

            while (0) {
              // ...
              if (x = 0) {  // typical typo interpreted as an assignment
                ret_var = x = y; // non-compliant
              }
            }
            return ret_var;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
          #include <stdbool.h>

          void func( void )
          {
              bool bool_var;
              bool_var = true;
              // == is not an assignment operator
              while (bool_var == true)
              {
                  // some code that change bool_var
                  // ...
              }
              
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the result of the
    assignment operator is used
  name: 'Assign operators inside an expression '
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_13_4
- alias: {}
  category: ''
  code: MSR_13_5
  compliance: R
  cost: H
  csv_string:
    - MSR_13_5
  desc: The right operand of the && and || operators cannot have side effects
  details: >-
    #### Abstract

    The right operand of the && and || operators cannot have side effects


    #### Explanation

    The evaluation of the right hand operand of the && and || operators is
    conditional on the value of the left-hand operand. The right hand operand
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>
          #include <stdbool.h>

          static int int_a;
          void func( void );
          int func2( void );
          bool return_true( void );

          void func( void )
          {
              int int_b;
              
              // int_a is not modified as intended
              if( return_true() || int_b == func2() );
              // more code that may read int_a
              // ...
          }

          int func2( void )
          {
              int_a++; // side effect: int_a is modified
              return int_a;
          }

          bool return_true( void )
          {
              return true;
          }

          void func3( void )
          {
              volatile int x;
              int y = 1;
              if ( ( y != 0) || ( x != 1 ) );
              // access volatile object x has persistent side effect
          }

          void func4( void )
          {
              int *fp = func2;
              if ( (fp == NULL) || (*fp) );
              // fp points to function with persistent effect
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
          #include <stdbool.h>

          static int int_a;
          void func( void );
          int func2( void );
          bool return_true( void );

          void func( void )
          {
              int int_b;
              
              // right operand do not have side effect
              if( return_true() || int_b == func2() );
              // more code that may read int_a
              // ...
          }

          int func2( void )
          {
              return int_a + 1; // do not have side effect
          }

          bool return_true( void )
          {
              return true;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the right operand of
    the && and || operators have side effects
  name: >-
    The right operand of the && and || operators should not contain persistent
    side effect
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_13_5
- alias: {}
  category: ''
  code: MSR_13_6
  compliance: M
  cost: H
  csv_string:
    - MSR_13_6
  desc: The operand of sizeof operator cannot have persistent side effects
  details: >-
    #### Abstract

    The operand of sizeof operator cannot have persistent side effects


    #### Explanation

    Since sizeof operator does not necessarily execute the expression in its
    operand, the operand of sizeof must not produce side effects.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func( void )
          {
              int int_a, int_b;
              
              // int_b is not modified as intended
              int_a = sizeof( int_b++ );
              // some code that may read int_b
              // ...
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func( void )
          {
              int int_a, int_b;

              // the operand do not have side effect
              int_a = sizeof( int_b );
              int_b++; // int_b modified as intended
              // some code that may read int_b
              // ...
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the operand of sizeof
    operator has persistent side effects
  name: The operand of sizeof operator should not have potential side effects
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_13_6
- alias: {}
  category: ''
  code: MSR_18_4
  compliance: A
  csv_string:
    - MSR_18_4
  desc: Pointer arithmatic should not be used, except for ++ and --
  details: >-
    #### Abstract

    Pointer arithmatic should not be used, except for ++ and --


    #### Explanation

    Pointer arithmetic is confusing to the novice programmers. The expression
    ptr+1 may be mistakenly interpreted as adding one byte to the address held
    in ptr.
  examples:
    bad:
      c:
        - |-

          void func(){
              int arr[3] = {0, 1, 2};

              int *ptr;
              ptr = arr;

              * (ptr + 1) = 0; // Using + in pointer arithmatic is confusing
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          void func(){
              int arr[3] = {0, 1, 2};

              int *ptr;
              ptr = arr;
              ptr++;  // ++ operator is allowed
              ptr[1] = 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, pointer arithmatic is
    used, except for ++ and --
  name: Pointer arithmatic should not be used, except for ++ and --
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: L
  standards:
    mc:
      - MSR_18_4
- alias: {}
  category: ''
  code: MSR_18_8
  compliance: R
  cost: H
  csv_string:
    - MSR_18_8
  desc: Variable length array types should not be used
  details: >-
    #### Abstract

    Variable length array types should not be used


    #### Explanation

    The use of variable-length array types would make it impossible to determine
    statically the amount of memory that must be reserved for a stack
  examples:
    bad:
      c:
        - |-

          void foo(int n) {
              int arr[n];
          }

          void func() {
              foo(-1);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          void foo() {
              // Don't use variable-length array
              int arr[5];
          }

          void func() {
              foo();
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, variable length array
    types are used
  name: Variable length array types should not be used
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_18_8
- alias: {}
  category: ''
  code: MSR_19_2
  compliance: A
  csv_string:
    - MSR_19_2
  desc: Union should not be used
  details: >-
    #### Abstract

    Union should not be used


    #### Explanation

    If the union member read is wider than the member written then the value is
    unspecified. Since it is possible to access bytes with unspecified values,
    unions should not be used.
  examples:
    bad:
      c:
        - |-

          typedef union UnionT
          {
            int    i;
            char   c;
            double d;
          } UNIONT;

          typedef struct MyData
          {
            int     tag;
            UNIONT  u;
          } MYDATA;


          int foo(char ch_param)
          {
             MYDATA md;

             md.tag = 0;  // say, 0 for int, 1 for char, 2 for double
             md.u.c = ch_param;

             return md.u.i; // return is undefined
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
          #include <string.h>

          struct Foo {
              int i;
              float f;
              char str[10];
          };

          void func() {
              struct Foo data;

              data.i = 5;
              data.f = 10.5;
              strcpy(data.str, "string");

              // Use struct instead of union to keep everything
              printf("%d\n", data.i);
              printf("%f\n", data.f);
              printf("%s\n", data.str);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: In file ${so.filename}, line ${so.line}, ${so.func}, union is used
  name: Union should not be used
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_19_2
- alias: {}
  category: ''
  code: MSR_21_3
  compliance: R
  csv_string:
    - MSR_21_3
  desc: Memory allocation related functions in stdlib.h shall not be used
  details: >-
    #### Abstract

    Memory allocation related functions in stdlib.h shall not be used


    #### Explanation

    The use of memory allocation related functions in stdlib.h can lead to an
    undefined behaviour. For example:  memory that was dynamically allocated may
    not be freed subsequently.
  examples:
    bad:
      c:
        - |-

          #include <string.h>
          #include <stdio.h>
          #include <stdlib.h>

          void func() {
              char *str;

              str = (char *) malloc(10);
              strcpy(str, "string");
              printf("%s", str);

              free(str);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <string.h>
          #include <stdio.h>
          #include <stdlib.h>

          void func() {

              #define MAX_STR_SZ 10   
              char str[MAX_STR_SZ];
              strncpy(str, "string", MAX_STR_SZ);
              
              strcpy(str, "string");
              printf("%s", str);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, memory allocation related function
    ${so.func} in stdlib.h is used
  name: Memory allocation related functions in stdlib.h shall not be used
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_21_3
- alias: {}
  category: ''
  code: MSR_21_4
  compliance: R
  csv_string:
    - MSR_21_4
  desc: setjmp.h should not be used
  details: >-
    #### Abstract

    setjmp.h should not be used


    #### Explanation

    Setjmp allows the normal function call/return mechanisms to be bypassed. The
    use of that can lead to undefined and unspecified behavior.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>
          #include <stdlib.h>
          #include <setjmp.h>

          void func() {
              int val;
              jmp_buf env_buffer;

              val = setjmp(env_buffer);

              // Set value to val after lngjmp
              if (val != 0) {
                  printf("Return from longjmp with value = %d", val);
                  exit(0);
              }

              // Jump back to top
              printf("Jump to top");
              // Using longjmp and setjmp can cause undefined behaviour
              longjmp(env_buffer, 10);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
          #include <stdlib.h>

          // Do not use functions from setjmp.h
          void func() {
              int val;
              val = 10;
              printf("%d", val);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: In file ${so.filename}, line ${so.line}, ${so.func}, setjmp.h is used
  name: setjmp.h should not be used
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_21_4
- alias: {}
  category: ''
  code: MSR_21_5
  compliance: R
  csv_string:
    - MSR_21_5
  desc: signal.h should not be used
  details: >-
    #### Abstract

    signal.h should not be used


    #### Explanation

    Since signal handling contains an implementation-defined and undefined
    behaviour, signal.h should not be used for C90 and C99 modes.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>
          #include <signal.h>
          #include <stdbool.h>
          #include <unistd.h>

          void sig_handler(int signum) {
              printf("\nInside handler function\n");
          }

          void func() { 
              // Register signal handler
              // Using functions from signal.h can lead to undefined behaviour
              signal(SIGINT,sig_handler); 
            
              while(true) {    
                  printf("Inside func()");    
                  sleep(1);  
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
          #include <stdbool.h>
          #include <unistd.h>

          void func() { 
              // Do not use signal handler functions 

              while(true) {    
                  printf("Inside func()");    
                  sleep(1);  
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: In file ${so.filename}, line ${so.line}, ${so.func}, signal.h is used
  name: signal.h should not be used
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_21_5
- alias: {}
  category: ''
  code: MSR_21_6
  compliance: R
  csv_string:
    - MSR_21_6
  desc: I/O functions in stdio.h should not be used
  details: >-
    #### Abstract

    I/O functions in stdio.h should not be used


    #### Explanation

    Since I/O have unspecified, undefined and implementation-defined
    behaviours，I/O functions and their wide char equivalents in stdio.h should
    not be used for C90 and C99 modes.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void bar_c(void* ptr)
          {
              int* dest = (int*)ptr;
              int data = (*dest);
              int i;
              int Buffer[10] = { 0 };
              if(data >= 0)
                {
                   Buffer[data] = 1;
                   for(i=0; i<10; i++)
                   {
                       printf("%d", Buffer[i]);
                   }
               }
           }

           void foo_v()
           {
               int data;
               data = -1;
               fscanf(stdin, "%d", &data); // this can easily cause array out of bound
               bar_c(&data);
           } 
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          void func() {
              // Do something
              // Do not use stdio.h functions
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, I/O functions in
    stdio.h is used
  name: I/O functions in stdio.h should not be used
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_21_6
- alias: {}
  category: ''
  code: MSR_21_7
  compliance: R
  csv_string:
    - MSR_21_7
  desc: ascii conversion functions in stdlib.h should not be used
  details: >-
    #### Abstract

    ascii conversion functions in stdlib.h should not be used


    #### Explanation

    Since atof, atol and atoll functions have undefined behaviors associated
    with them when the string cannot be converted, they should not be used for
    C90 and C99 modes.
  examples:
    bad:
      c:
        - |-

          #include <iostream>
          #include <cstdlib>

          int foo()
          {
            char s[] = "98";
            long num;

            num = atol(s);

            std::cout << "number in long = " << num << std::endl;
              
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
          #include <stdlib.h>
          #include <string.h>

          void func() {
             float val;
             char str[10];
             
             strcpy(str, "914");
             val = 914.000; //Do not use atof, atol, atoll, atoi
             printf("String value = %s, Float value = %f\n", str, val);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, ascii conversion
    functions in stdlib.h is used
  name: ascii conversion functions in stdlib.h should not be used
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_21_7
- alias: {}
  category: ''
  code: MSR_21_8
  compliance: R
  csv_string:
    - MSR_21_8
  desc: getenv, getenv and exit functions should not be used
  details: >-
    #### Abstract

    getenv, getenv and exit functions should not be used


    #### Explanation

    Since getenv, getenv and exit functions have undefined and
    implementation-defined behaviors, they should not be used for C90 and C99
    modes.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>
          #include <stdlib.h>

          int main(void)
          {
            char* ptr_h;
            char h[64];

            ptr_h = getenv("HOME");  // value of HOME could be > 64, need size guard
            if (ptr_h != NULL) {
              // ...
            }
            return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
          #include <stdlib.h>

          void func () {
             printf("Start of program\n");
             
             // Do not use abort, exit, getenv or system

             printf("End of program\n");

             return(0);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, getenv, getenv and exit functions
    are used
  name: getenv, getenv and exit functions should not be used
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_21_8
- alias: {}
  category: ''
  code: MSR_21_9
  compliance: R
  csv_string:
    - MSR_21_9
  desc: bsearch and qsort should not be used
  details: >-
    #### Abstract

    bsearch and qsort should not be used


    #### Explanation

    If bsearch and qsort function do not behave consistently when comparing
    elements, or they modify any of the elements, the behavior is undefined. So
    they should not be used for C90 and C99 modes.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>
          #include <stdlib.h>


          int cmpfunc(const void * a, const void * b) {
             return ( *(int*)a - *(int*)b );
          }

          int arr[] = { 1, 2, 3, 4, 5 };

          void func () {
             int *item;
             int key = 3;

             // use bsearch to compare and find values of 3 in the array arr
             item = (int*) bsearch (&key, arr, 5, sizeof (int), cmpfunc);
             if( item != NULL ) {
                printf("Found item");
             } else {
                printf("Item is not in the array");
             }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
          #include <stdlib.h>

          int arr[] = { 1, 2, 3, 4, 5 };

          void func () {
             int key = 3;

             // Use other method other than bsearch for searching element in an array
             for (int i = 0; i < sizeof(arr) / 4; i++) {
                if (arr[i] == key) {
                   printf("Item found");
                   break;
                }
             }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: ''
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, bsearch and qsort is
    used
  name: bsearch and qsort should not be used
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_21_9
- alias: {}
  category: ''
  code: MSR_21_10
  compliance: R
  csv_string:
    - MSR_21_10
  desc: Time and date functions in stdlib.h should not be used
  details: >-
    #### Abstract

    Time and date functions in stdlib.h should not be used


    #### Explanation

    Since the time and date functions have unspecified, undefined and
    implementation-defined behaviors, they should not be used for C90 and C99
    modes.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>
          #include <time.h>
           
          void func (){
             // Using time and date function can lead to undefined behaviour
             printf("%ld", time(NULL));
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
           
          void func (){
             // Do something
             // Do not use time and date function
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, time and date functions
    in stdlib.h are used
  name: Time and date functions in stdlib.h should not be used
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_21_10
- alias: {}
  category: ''
  code: MSR_5_0_1
  compliance: R
  cost: H
  csv_string:
    - MSR_5_0_1
  desc: >-
    For an evaluation of any expression and its side effects, the value must be
    the same under any evaluation order permitted by the language standard
  details: >-
    #### Abstract

    For an evaluation of any expression and its side effects, the value must be
    the same under any evaluation order permitted by the language standard


    #### Explanation

    Since the expression may have multiple execution orders, the design for any
    expression, should ensure that the value of the expression and its side
    effects are the same in all possible execution orders as prescribed by the
    lexical rule for the expression.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #define LEN 1024

          int array_int[LEN];

          int foo(int i, int j)
          { 
            if (j > 0) {
              return i+1;
            }
            else
              return i;
          }

          int bar(unsigned int parm_b)
          {
            if (parm_b < LEN)
              array_int[parm_b++] = parm_b ; // behavior is undefined
            return parm_b;
          }
            
          int call_foo(int i)
          {
            return foo(i++, i); // return value is implementation defined
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #define LEN 1024

          int array_int[LEN];

          int foo(int i, int j)
          {
            if (j > 0) {
              return i+1;
            }
            else
              return i;
          }

          int bar(unsigned int parm_b)
          {
            if (parm_b < LEN) 
            {
              unsigned int temp = parm_b++;
              array_int[temp] = parm_b ; // behavior is deterministic
            }
            return parm_b;
          }

          int call_foo(int i)
          {
            int j = i++;
            return foo(j, i); // return value non-ambiguous
          }
      general:
        - ''
      java:
        - ''
  language: c++
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, the value of ${so.func} is not the
    same under any evaluation order permitted by the language standard
  name: >-
    The value of an expression should be the same under any order of evaluation
    permitted by the standard
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mcpp:
      - MSR_5_0_1
- alias: {}
  category: ''
  code: MSR_5_0_8
  compliance: R
  cost: H
  csv_string:
    - MSR_5_0_8
  desc: >-
    The value of an expression cannot be cast to sizes larger than the
    underlying type of the expression
  details: >-
    #### Abstract

    The value of an expression cannot be cast to sizes larger than the
    underlying type of the expression


    #### Explanation

    When the value of an expression is cast to a size larger than its underlying
    type, there may be information loss such as signedness of the value.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          void func_5_0_8(int si, short sh_j, float flt_k)
          {
            short  local_sh = 0x1234;
            int    local_int1, local_int2;
            float  local_flt = 1.0;
            double local_dbl, local_dbl2;

            local_int1 = static_cast< int > (local_sh + sh_j);  // non-compliant

            local_dbl2 = static_cast<double> (flt_k + local_flt);  // non-compliant
            
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          void func_5_0_8(int si, short sh_j, float flt_k)
          {
            short  local_sh = 0x1234;
            int    local_int1, local_int2;
            float  local_flt = 1.0;
            double local_dbl, local_dbl2;

            local_int1 = static_cast< int > (local_sh) + sh_j;  // compliant
            local_int2 = static_cast< int > (local_int1) + si;     // compliant

            local_dbl2 = static_cast<double> ((double)flt_k) + local_flt;  // compliant
            
          }
      general:
        - ''
      java:
        - ''
  language: c++
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, the value of ${so.func} is cast to
    sizes larger than the underlying type of the expression
  name: >-
    The value of an expression cannot be cast to sizes larger than the
    underlying type of the expression
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mcpp:
      - MSR_5_0_8
- alias: {}
  category: ''
  code: MSR_5_0_19
  compliance: R
  cost: H
  csv_string:
    - MSR_5_0_19
  desc: >-
    Declaration of objects cannot contain more than two levels of pointer
    indirection
  details: >-
    #### Abstract

    Declaration of objects cannot contain more than two levels of pointer
    indirection


    #### Explanation

    Having more than two levels of indirection, which gives, at least three
    levels of dereferencing an object, means it can be very hard to understand
    the intended behavior of the program.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          int array[10][20];

          int mlk_three_indirect(int val)
          {
            int j = val;
            int *p = &j;
            int **p_2, **r_2;
            int *p_2_array = &array[*p][0];
            int ***p3;

            // ... 
            p_2 = &p;
            
            // ...
            array[val][0] = **p_2;
            
            //...
            r_2 = &p_2_array;
            
            // ...
            p3 = &r_2;
            
            // ... 
            return ***p3;

          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          int array[10][20];

          // this example is equivalent to the "avoid" example
          // 
          int mlk_three_indirect(int val)
          {
            int j = val;
            int *p = &j;
            int **p_2, **r_2;
            int *p_2_array = &array[*p][0];
            int p3;
            
            array[val][0] = val;
            p3 = array[val][0];
            return p3;

          }
      general:
        - ''
      java:
        - ''
  language: c++
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, declaration of objects
    contains more than two levels of pointer indirection
  name: More than 2 indirections
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mcpp:
      - MSR_5_0_19
- alias: {}
  category: ''
  code: MSR_8_5_3
  compliance: R
  cost: H
  csv_string:
    - MSR_8_5_3
  desc: >-
    The only explicit initialization of an enum with the “=” construct is such
    that all, none or the first one, are initialized
  details: >-
    #### Abstract

    The only explicit initialization of an enum with the “=” construct is such
    that all, none or the first one, are initialized


    #### Explanation

    Explicit and uniform initialization of an enum list prevents mixing of
    automatic and manual assignment, which is error-prone. The compiler can also
    detect possible out of range errors for the enum.
  examples:
    bad:
      c:
        - ''
      cpp:
        - "\ntypedef enum color { red=3 } GoodEnum;   // compliant\n\ntypedef enum bad_enum_color { white=0,\n\t\t\t      blue=1,\n\t\t\t      yellow } BadEnum;  // non-compliant\n\ntypedef enum no_assign { NO_ONE, NO_TWO, NO_THREE } GoodEnum_NoAssign;\n\nextern void bar( color c, bad_enum_color b, no_assign n);\n\nvoid func_use(void)\n{\n  color var_color = red;\n  bad_enum_color var_bad_color = blue;\n  no_assign var_no_assign = NO_TWO;\n\n  bar(var_color, var_bad_color, var_no_assign);\n  return;\n}"
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          typedef enum color { red=3 } GoodEnum;   // compliant

          // compliant (but assignment not in sequence )
          typedef enum bad_enum_color { white=0,
                   blue=1,         // 2 is not used 
                   yellow=3 } BadEnum;  

          typedef enum no_assign { NO_ONE, NO_TWO, NO_THREE } GoodEnum_NoAssign;

          extern void bar( color c, bad_enum_color b, no_assign n);

          void func_use(void)
          {
            color var_color = red;
            bad_enum_color var_bad_color = blue;
            no_assign var_no_assign = NO_TWO;

            bar(var_color, var_bad_color, var_no_assign);
            return;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the enum initialization
    is incorrect
  name: Bad enum initialization
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mcpp:
      - MSR_8_5_3
- alias: {}
  category: ''
  code: MSR_10_1_3
  compliance: R
  cost: H
  csv_string:
    - MSR_10_1_3
  desc: >-
    A base class should not be both, virtual and non-virtual in a multiple
    inheritance hierarchy
  details: >-
    #### Abstract

    A base class should not be both, virtual and non-virtual in a multiple
    inheritance hierarchy


    #### Explanation

    If the base class is both virtual and non-virtual in a multiple inheritance
    hierarchy, then there will be multiple copies of the base class sub-object
    in the derived object. This is likely a declaration error.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          class Base {};

          class Derived1 : public virtual Base {};

          class Derived2 : public Base { };


          class V_and_nonV : public Derived1, public Derived2 { };
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |

          class Base {};

          class Derived1 : public virtual Base {}; // Base is virtual

          class Derived2 : public virtual Base {}; // Base virtual

          // This hierarchy has two derived class from virtual base class
          class V_and_V : public Derived1, public Derived2 { /* code here */ };
            
      general:
        - ''
      java:
        - ''
  language: c++
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, a base class is virtual
    and non-virtual in a multiple inheritance hierarchy
  name: Base class has virtual and non-virtual
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mcpp:
      - MSR_10_1_3
- alias: {}
  category: ''
  code: MSR_12_1_1
  compliance: R
  csv_string:
    - MSR_12_1_1
  desc: >-
    An object’s dynamic type cannot be used from the body of its constructor or
    destructor
  details: >-
    #### Abstract

    An object’s dynamic type cannot be used from the body of its constructor or
    destructor


    #### Explanation

    A non-static member of an object can have an initialization with the
    declaration of the member in its body (NSDMI). To avoid confusion, any
    member initialized this way (NSDMI) or with a constructor should be the
    same.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <typeinfo>

          class Base {
          public:
            virtual void func_char();
            
            Base() {
              func_char();   // dynamic, virtual call to a virtual function
              typeid(Base);  // dynamic typeid on a class with virtual function
            };
          };


          void foo(void)
          {
            Base example;

            example.func_char();  //  
            return;
          }
            
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          class Base {
          public:
            virtual void func_char();
            
            Base() {
              Base::func_char();   // dynamic, non-virtual call
            };
          };


          void foo(void)
          {
            Base example;

            example.func_char();  //  
            return;
          }
            
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, an object’s dynamic
    type is used from the body of its constructor or destructor
  name: Dynamic type in ctor or dtor
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_12_1_1
- alias: {}
  category: ''
  code: MSR_12_1_2
  compliance: A
  csv_string:
    - MSR_12_1_2
  desc: ctor must explicitly call ctor for all its immediate base classes
  details: >-
    #### Abstract

    ctor must explicitly call ctor for all its immediate base classes


    #### Explanation

    If ctor call ctor for all its immediate base classes, it would reduce
    confusion over which constructor and parameters to use.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          class Base {
          public:
            Base() {}
            Base(int i);
          };


          class Derived1 : public virtual Base {
          public:
            Derived1() {}
            Derived1(int) : Base(0) {}
          }; 

          class Derived2 : public virtual Base {
          public:
            Derived2() {}
            Derived2(int) : Base(1) {}
          }; 


          class Hier : public Derived1, public Derived2 {
            //  Hier()    {}
            Hier(int) {} // constructor used is ambiguous w.r.t. Derived1 or Derived2

          };
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          class Base {
          public:
            Base() {}
            Base(int i);
          };
          class Derived1 : public virtual Base {
          public:
            //  Derived1() {}
            Derived1(int) : Base(0) {}
          };
          class Derived2 : public virtual Base {
          public:
            //  Derived2() {}
            Derived2(int) : Base(1) {}
          };
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, ctor does not
    explicitly call ctor for all its immediate base classes
  name: ctor must explicitly call ctor for all its immediate base classes
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_12_1_2
- alias: {}
  category: ''
  code: MSR_12_1_3
  compliance: R
  csv_string:
    - MSR_12_1_3
  desc: ctor with single parameter of basic type should be explicit
  details: |
    #### Abstract
    ctor with single parameter of basic type should be explicit

    #### Explanation
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-


          class Base {
          public:
            Base(void) {}
            Base(int i);
          };


          class Derived1 : public virtual Base {
          public:
            Derived1() {}
            Derived1(int) : Base(0) {}
          }; 

          class Derived2 : public virtual Base {
          public:
            Derived2() {}
            Derived2(int) : Base(1) {}
          }; 

          class Hier : public Derived1, public Derived2 {
            Hier(int)    {}
          };
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          class Base {
          public:
            Base() {}
            explicit Base(int i);
          };


          class Derived1 : public virtual Base {
          public:
            Derived1() {} 
            explicit Derived1(int) : Base(0) {}    // make explicit
          }; 

          class Derived2 : public virtual Base {
          public:
            Derived2() {}
            explicit Derived2(int) : Base(1) {}    // make explicit
          }; 


          class Hier : public Derived1, public Derived2 {
            explicit Hier(int) : Derived1(2), Derived2(), Base() {}  // make explicit

          };
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, ctor with single
    parameter of basic type is not explicit
  name: ctor with single parameter of basic type should be explicit
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_12_1_3
- alias: {}
  category: ''
  code: MSR_11_0_1
  compliance: R
  csv_string:
    - MSR_11_0_1
  desc: Non-POD member in a class must be private
  details: |
    #### Abstract
    Non-POD member in a class must be private

    #### Explanation
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdint.h>

          typedef char    Letter;  
          typedef Letter* pLetter;
            
          class Class_Without_POD    
          {
          public:
            Letter  c;  
            pLetter p;
          };

          class Class_with_POD
          {
          public:
            int8_t   c;         // POD has no default constructor
            char*   pc;  
          };
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          typedef char    Letter;  
          typedef Letter* pLetter;
            
          class Class_Without_POD    
          {
          public:
            Letter  c;  
            pLetter p;
          };

          class Class_with_POD
          {
          private:
            char    c;         // will need interfaces to access and modify
            char*   pc;  
          };
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, non-POD member in a
    class is not private
  name: Non-POD member in a class must be private
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_11_0_1
- alias: {}
  category: ''
  code: MSR_10_2_1
  compliance: A
  csv_string:
    - MSR_10_2_1
  desc: All visible names within an inheritance hierarchy must be unique
  details: |
    #### Abstract
    All visible names within an inheritance hierarchy must be unique

    #### Explanation
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-


          class Base {
          public:
            void func(char) {};
          };

          class Derived : public Base {
          public:
            void func(int) {};
          };


          int foo(void)
          {
            int   i;
            char ch;
            Derived example;

            example.func(i);
            example.func(ch);  // func(char) in Base is not visible 
            
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          class Base {
          public:
            Base() {}
            void func_char(char) {};
          };

          class Derived : public Base {
          public:
            Derived() : Base() {}
            void func_int(int) {};
          };


          int foo(void)
          {
            int   i;
            char ch;
            Derived example;

            example.func_int(i);

            example.func_char(ch);  // func(char) in Base is not visible

            return i;  
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the visiable names
    within a inheritance hierarchy are not unique
  name: All visible names within an inheritance hierarchy must be unique
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_10_2_1
- alias: {}
  category: ''
  code: MSR_17_7
  compliance: R
  csv_string:
    - MSR_17_7
  desc: >-
    The value returned by a function which has non-void return type should be
    used
  details: >-
    #### Abstract

    The value returned by a function which has non-void return type should be
    used


    #### Explanation

    Calling a function without using the return value may be an error for a C90
    and a C99 mode. Return value of a function should be cast to the void type
    if it is intended not to be used explicitly.
  examples:
    bad:
      c:
        - |-

          extern int func_ret_int(int);


          void bar(int n, int m)
          {
            if (n > 0) {
              n += func_ret_int(n);
            }
            else {
              func_ret_int(m); // func return value ignored
            }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |

          extern int func_ret_int(int, int);


          void bar(int n, int m)
          {
            if (n > 0) {
              n += func_ret_int(n, m);
            }
            else {
              (void)func_ret_int(m, m); // func return value ignored
            }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, value returned by ${so.func} is not
    used
  name: Value returned by a function should be used
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_17_7
- alias: {}
  category: ''
  code: MSR_17_8
  compliance: A
  csv_string:
    - MSR_17_8
  desc: The parameter of a function should not be modified
  details: >-
    #### Abstract

    The parameter of a function should not be modified


    #### Explanation

    Modifying the parameter of a function can be confusing and in conflict with
    programmer expectations for C90 and C99 modes. So the The parameter of a
    function should not be modified.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int param_0 =1;

          void func(int param){
              // Modifying parameter can cause confusion
              param = param_0;
              printf("%d\n", param);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func(int param){
              // Only use param, do not ever modify it by assigning another value
              printf("%d\n", param);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, a function parameter is
    modified
  name: A function parameter should not be modified
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_17_8
- alias: {}
  category: ''
  code: MSR_10_2
  csv_string:
    - MSR_10_2
  desc: Use basic character variables appropriately for addition and subtraction
  details: >-
    #### Abstract

    Use basic character variables appropriately for addition and subtraction


    #### Explanation

    Since the data in the basic character variable does not represent a numeric
    value, the basic character variable should be used appropriately in the
    addition and subtraction expressions.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int func( void );

          int func( void )
          {
              // essentially character type declared
              char char_var;
              int numb;
              char_var = '9';
              // the result of char_var + '>' do not make sense
              numb = char_var + '>';
              return numb;

          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |

          #include <stdio.h>

          int func( void );

          int func( void )
          {
              // essentially character type declared
            char char_var;   
            char numb;
            char_var = '9';
            // convert numa to digit value 9
            numb = char_var - '0';
            return numb

          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, char is used in arithmatic
    expression ${so.func}
  name: char not allowed in arithmatic expression
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_10_2
- alias: {}
  category: ''
  code: MSR_14_2
  compliance: R
  csv_string:
    - MSR_14_2
  desc: >-
    A loop consists of three clauses. Firstly, a loop counter properly assigned
    and defined (empty is permissible). Secondly, a loop terminating expression
    that uses the loop counter, with no persistent side effects. And that
    expression does not contain objects modified in the loop body. Thirdly, an
    expression with the loop counter being modified and no other objects used
    that are modified in the loop body.
  details: >-
    #### Abstract

    A for loop should be well-formed


    #### Explanation

    The second and third clause of the for loop statement should not use any
    object that is modified in the for loop body. Using a restricted form of for
    loop will make code easier to check and review.
  examples:
    bad:
      c:
        - |-

          void func() {
              for (int i = 0; i < 5; i++) {
                  // modifying the induction variable i. Error prone and hard to review
                  i = i + 4;
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          void func() {
              for (int i = 0; i < 5; i++) {
                  // Do something 
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: ''
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the for loop is not
    well-formed
  name: A for loop should be well-formed
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_14_2
- alias: {}
  category: ''
  code: MSR_14_3
  compliance: R
  csv_string:
    - MSR_14_3
  desc: Controlling expression of a statement should not be invariant
  details: >-
    #### Abstract

    Controlling expression of a statement should not be invariant


    #### Explanation

    Using invariant values as controlling expresson can cause programming error.
    The compiler might even remove the code as it may not be able to be reached
    due to invariant expression. This might result in unwanted removal of
    defensive code.
  examples:
    bad:
      c:
        - |-

          void func() {
              // The if statement always evaluates to false, dead code
              if (10 > 11) {
                  // Do something
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdbool.h>

          void func() {
              // Compliant by exception 1
              while (true) {
                  // Do something
              } 

              // Compliant by exception 2
              do {
                  // Do something
              } while (0 == 1);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func} is using an invariant
    value for controlling expressions
  name: Controlling expressions should not be invariant
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_14_3
- alias: {}
  category: ''
  code: MSR_15_1
  compliance: A
  csv_string:
    - MSR_15_1
  desc: The goto statement should not be used
  details: >-
    #### Abstract

    The goto statement should not be used


    #### Explanation

    Using the goto statement without constraints can lead to unstructured and
    extremely difficult to understand programs.
  examples:
    bad:
      c:
        - |-

          void func() {
              int num = 0;

              P1:
              num += 1;

              // Using the goto statement can cause confusion
              goto P1;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          void func() {
              int num = 0;

              num += 1;
              // Do not use the goto statement
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: In file ${so.filename}, line ${so.line}, ${so.func} uses the goto statement
  name: The goto statement should not be used
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_15_1
- alias: {}
  category: ''
  code: MSR_15_2
  compliance: R
  csv_string:
    - MSR_15_2
  desc: If a goto statement is really needed, it shall be a forward goto.
  details: >-
    #### Abstract

    If a goto statement is really needed, it shall be a forward goto.


    #### Explanation

    Since using the goto statement without constraints can lead to unstructured
    and extremely difficult to understand programs, the use of goto statement
    should be restricted. Using language provided iteration statement results in
    much more readable code.
  examples:
    bad:
      c:
        - |

          void func() {
              int num = 0;

              P1:
              num += 1;

              // Non-compliant as back jump is allowed
              goto P1;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |

          void func() {
              int num = 0;

              // No back jump in the code
              goto P1;

              P1:
              num += 1;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the goto statement does
    not jump to a label declared later in the same function
  name: >-
    The goto statement should jump to a label declared later in the same
    function
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_15_2
- alias: {}
  category: ''
  code: MSR_15_3
  compliance: R
  csv_string:
    - MSR_15_3
  desc: Label should be declared in the same scope as its goto statement.
  details: >-
    #### Abstract

    Label should be declared in the same scope as its goto statement.


    #### Explanation

    Using the goto statement without constraints can lead to unstructured and
    extremely difficult to understand programs. Allowing goto statement to jump
    between blocks or into nested blocks to a reference label make the code
    visually complex.
  examples:
    bad:
      c:
        - |-

          void func() {
              int num = 0;

              P1:
                  if (num == 5) {
                  P2:
                      num += 1;
                  }

              // Jumping into nested label is non-compliant
              goto P2;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |

          void func() {
              int num = 0;

              P1:
                  if (num == 5) {
                  P2:
                      num += 1;
                  }

              // Jumping into the reference label outside of the nested block
              goto P1;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, a goto statement and
    its label are not in the same scope
  name: A goto statement and its label must be in the same scope
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_15_3
- alias: {}
  category: ''
  code: MSR_15_4
  compliance: A
  csv_string:
    - MSR_15_4
  desc: There should not be more than one break or goto for early loop termination
  details: >-
    #### Abstract

    There should not be more than one break or goto for early loop termination


    #### Explanation

    Using the goto statement without constraints can lead to unstructured and
    extremely difficult to understand programs. Restricting the number of exits
    in a loop helps simplify the source code.
  examples:
    bad:
      c:
        - |-

          void func() {
              for (int i = 0; i < 5; i++) {
                  // Multiple early termination
                  if (i == 2) {
                      break;
                  }
                  // Multiple early termination
                  else if (i == 2) {
                      goto EXIT;
                  }
                  else {
                      // Continue
                  }
              }

              EXIT:
                  ;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          void func() {
              for (int i = 0; i < 5; i++) {
                  // Only use either break or goto, don
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, loop early exits use
    both break and goto in the same loop
  name: There should not be more than one break or goto for early loop termination
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_15_4
- alias: {}
  category: ''
  code: MSR_15_7
  compliance: R
  csv_string:
    - MSR_15_7
  desc: Each if-else should have an if statement and end with an else statement.
  details: >-
    #### Abstract

    Each if-else should have an if statement and end with an else statement.


    #### Explanation

    Using the else statement to terminate the if ... else if constructs
    complements the requirement for a default clause in a switch statement ad is
    a kind of defensive programming.
  examples:
    bad:
      c:
        - |-

          #include <stdbool.h>

          void func() {
              bool flag;

              if (flag == true) {
                  // Do something
              }
              else if (flag == false) {
                  // Do something
              }
              // Non-compliant as there is no else statement
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdbool.h>

          void func() {
              bool flag;

              if (flag == true) {
                  // Do something
              }
              else {
                  // Add else statement as defensive programming
                  // Do something
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func} did not end with an else
    statement.
  name: Each if statement in if-else should have an else statement
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_15_7
- alias: {}
  category: ''
  code: MSR_16_5
  compliance: R
  csv_string:
    - MSR_16_5
  desc: >-
    The default label for the switch statement should be placed in first or
    last.
  details: >-
    #### Abstract

    The default label for the switch statement is not placed in first or last.


    #### Explanation

    Putting the default label anywhere else other than the first or last in a
    switch statement makes it difficult to locate.
  examples:
    bad:
      c:
        - |-

          int loop_cnt(int count, int input)
          {
            int idx = count;
            
            switch (input) {
              
            case 0:
              idx--;
              break;
              
            default:  // default in between case statements
              break;
              
            case 1:
              idx++;
              break;    

            }
            
            // ...
            return idx;
          }


          int loop_cnt_ex2(int count, int input)
          {
            int idx = count;
            
            switch (input) {
              
            // missing default statement in begin nor end 
              
            case 0:
              idx--;
              break;
              
            case 1:
              idx++;
              break;

            }
            
            // ...
            return idx;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          int loop_cnt(int count, int input)
          {
            int idx = count;
            
            switch (input) {
            case 0:
              idx--;
              break;
              
            case 1:
              idx++;
              break;
              
            default:
              break;
            }
            
            // ...
            return idx;
          }


          int loop_cnt_ex2(int count, int input)
          {
            int idx = count;
            
            switch (input) {
              
            default:   // default at beginning of switch
              break;
              
            case 0:
              idx--;
              break;
              
            case 1:
              idx++;
              break;

            }
            
            // ...
            return idx;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the default label for
    the switch statement was not placed in first or last.
  name: >-
    A default label should appear as either the first or the last switch label
    of a switch statement
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_16_5
- alias: {}
  category: ''
  code: MSR_16_7
  compliance: R
  csv_string:
    - MSR_16_7
  desc: A switch expression should not be of boolean type.
  details: >-
    #### Abstract

    A switch expression should not be of boolean type.


    #### Explanation

    Although it is possible to implement a switch statement controlling
    expression with a Boolean, it would be more appropriate to implement the
    logic with an if-else construct as defined by the standard.
  examples:
    bad:
      c:
        - |-

          #include <stdbool.h>
          #include <stdio.h>

          void func() {
              int num = 0;
              // Switch with boolean caluse as the controlling expression is redundant
              switch(num == 0) {
                  case true:
                      printf("True case");
                      break;
                  default:
                      printf("default case");
                      break;
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdbool.h>
          #include <stdio.h>

          void func( int num ) {
              // If else is more appropriate than switch for controlling expression with boolean
              if (num == 0) {
                  printf("True");
              }
              else {
                  printf("default");
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, a switch expression was
    of boolean type.
  name: A switch-expression should not have essentially Boolean type
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_16_7
- alias: {}
  category: ''
  code: MSR_17_1
  compliance: R
  csv_string:
    - MSR_17_1
  desc: The features of <stdarg.h> should not be used.
  details: >-
    #### Abstract

    The features of <stdarg.h> should not be used.


    #### Explanation

    va_list, va_arg, va_start, va_end, and va_copy should never be used. There
    are many instances of undefined behaviour when the source code are not
    organized properly causing inconsistency in type or usages.
  examples:
    bad:
      c:
        - |-

          #include <stdarg.h>

          void func(va_list var_arg) {
              double var;
              
              // Using va_list and va_arg can cause undefined behaviour
              var = va_arg(var_arg, double);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          void func(double arg) {
              double var;
              
              // Should not use <stdarg.h> for variable argument processing
              var = arg;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func},  features of <stdarg.h>
    were used.
  name: The features of <stdarg.h> should not be used
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_17_1
- alias: {}
  category: ''
  code: MSR_17_2
  compliance: R
  csv_string:
    - MSR_17_2
  desc: >-
    Functions should not call themselves, either directly or indirectly -
    recursive function (direct or indirect) should not be reused.
  details: >-
    #### Abstract

    Functions should not call themselves, either directly or indirectly -
    recursive function (direct or indirect) should not be reused.


    #### Explanation

    When a function is calling itself, i.e. recursion, it can lead to stack
    space exhaustion. It is not possible to determine what the worst-case stack
    usage is before execution.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func(int num){
              if (num == 0) {
                  return;
              }

              printf("%d\n", num);

              func(num - 1); // Using recursion unless tightly controlled can exceed available stack
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func(int num){
              // Implement recursion using for loop instead
              for (int i = num; i == 0; i--){
                  printf("%d\n", i);
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: In file ${so.filename}, line ${so.line}, ${so.func} called itself.
  name: Functions should not call themselves, either directly or indirectly
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_17_2
- alias: {}
  category: ''
  code: MSR_17_5
  compliance: A
  csv_string:
    - MSR_17_5
  desc: Parameters of array type should have specified sizes.
  details: >-
    #### Abstract

    Parameters of array type should have specified sizes.


    #### Explanation

    Although it is legal in C to pass an array of the unspecified size to a
    parameter with a specified size, doing so can lead to unexpected behaviour
    such as array out of bound.
  examples:
    bad:
      c:
        - |-

          void arr1 (int array[4]) {
              // Do something
          }

          void func(int num){
              int arr[3] = {1, 2, 3};

              // Array size does not match prototype
              arr1(arr);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          void fun_arr1 (int array[4]) {
              // Do something
          }

          void func(int num){
              int arr[4] = {1, 2, 3, 4};

              // Array size match prototype
              func_arr1(arr);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, parameters of array
    type did not have specific sizes.
  name: Parameters of array type should have specified sizes
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_17_5
- alias: {}
  category: ''
  code: MSR_18_1
  compliance: R
  csv_string:
    - MSR_18_1
  desc: Pointer arithmatic should not cause an array out of bound access
  details: >-
    #### Abstract

    Pointer arithmatic should not cause an array out of bound access


    #### Explanation

    Compilers can only determine at compile time whether an array boundary has
    been exceeded. No checks are done at run-time for invalid array indexing.
    Using invalid indexing can cause program to have erroneous behaviour.
  examples:
    bad:
      c:
        - |-

          void func(){
              int arr[3] = {0, 1, 2};

              // Points to two beyond, undefined
              int *p = &arr[4];
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          void func(){
              int arr[3] = {0, 1, 2};

              // Points to one beyond only, still defined
              int *p = &arr[3];
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: ''
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func} assessed an undefined
    location with a pointer that went out of bound.
  name: >-
    A pointer resulting from arithmetic on a pointer operand shall address an
    element of the same array as that pointer operand
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_18_1
- alias: {}
  category: ''
  code: MSR_21_11
  compliance: R
  csv_string:
    - MSR_21_11
  desc: The standard header file <tgmath.h> should not be used
  details: >-
    #### Abstract

    The standard header file <tgmath.h> should not be used


    #### Explanation

    Since using functions declared in tgmath.h can result in undefined
    behaviour, <tgmath.h> shall not be used
  examples:
    bad:
      c:
        - |-

          #include <tgmath.h>

          void func() {
             float f1;
             // Generic square root is used, can cause undefined behaviour
             f1 = sqrt(49);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <math.h>

          void func() {
             float f1;
             // Float version of square root is used, safer
             f1 = sqrt(49);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func} use the standard header
    file <tgmath.h>
  name: The standard header file <tgmath.h> should not be used
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_21_11
- alias: {}
  category: ''
  code: MSR_21_12
  compliance: A
  csv_string:
    - MSR_21_12
  desc: The program used exception handling features declared in <fenv.h>
  details: >-
    #### Abstract

    The program used exception handling features declared in <fenv.h>


    #### Explanation

    The floatin-point status flags may become unspecified in some circumstances.
    Attempting to access them may cause undefined behaviour. 
  examples:
    bad:
      c:
        - |-

          #include <fenv.h>
          #include <stdio.h>
          #include <math.h>

          void func() {
             // Using exception handlinf features can cause undefined behaviour
             feclearexcept(FE_ALL_EXCEPT);
             
             sqrt(-1);

             if (fetestexcept(FE_INVALID)) {
                printf("FE_INVALID casued by sqrt(-1");
             }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <fenv.h>
          #include <stdio.h>
          #include <math.h>

          void func() {
             // Do not use functions from fenv.h for exception handling
             sqrt(-1);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func} use exception handling
    features declared in <fenv.h>
  name: The exception handling features of <fenv.h> should not be used
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_21_12
- alias: {}
  category: ''
  code: MSR_14_1
  compliance: R
  csv_string:
    - MSR_14_1
  desc: >-
    The program uses floating point as a loop counter which can cause mismatch
    betweeen expected and actual result.
  details: >-
    #### Abstract

    The program uses floating point as a loop counter which can cause mismatch
    betweeen expected and actual result.


    #### Explanation

    Using a floating point as a loop counter can cause accumulation of rounding
    errors. This might cause mismatch between the expected number of iterations
    and the actual number of iterations when the program runs depending on the
    implementation.
  examples:
    bad:
      c:
        - |-

          void func() {
              // Using float as a loop counter can lead to unexpected result
              for (float f = 0.0f; f < 10.0f; f += 0.1f) {
                  // Do something
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          void func() {
              // Using int as a loop counter
              for (int i = 1; i < 10; i++) {
                  // Do something
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func} use floating point as a
    loop counter
  name: A loop counter should not have essentially floating type
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_14_1
- alias: {}
  category: ''
  code: MSR_16_6
  compliance: R
  csv_string:
    - MSR_16_6
  desc: Every switch statement should have more than one switch-clause
  details: >-
    #### Abstract

    Every switch statement should have more than one switch-clause


    #### Explanation

    Having a single path for a switch statement is not only redundant but also
    an indicative of programming error.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func() {
              int num = 2;
              switch(num + 2) {
                  default:
                      // Only one switch-clause
                      printf("default case");
                      break;
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          int func ( char grade )
          {
              // Switch statement have at least two switch-clauses
              switch( grade ) 
              {        
                  case 'A':
                      printf( "great" );
                      break;
                  case 'B':
                      printf( "good" );
                      break;
                  default:
                      printf( "not so well" );
                      break;
              }
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: ''
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func} have less than two
    switch-clause
  name: Every switch statement should have at least two switch-clauses
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_16_6
- alias: {}
  category: ''
  code: MSR_9_1
  compliance: M
  csv_string:
    - MSR_9_1
  desc: Local variables should be initialized before being read
  details: >-
    #### Abstract

    Local variables should be initialized before being read


    #### Explanation

    Objects with static storage duration are automatically initialized to zero
    unless initialized explicitly. Objects with atutomatic storage duration are
    not automatically initialized so that they can have indeterminate values.
  examples:
    bad:
      c:
        - ''
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: ''
  mapping: ''
  msg_templ: ''
  name: Local variables should be initialized before being read
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_9_1
- alias: {}
  category: ''
  code: MSR_18_2
  compliance: R
  csv_string:
    - MSR_18_2
  desc: >-
    Pointer subtraction should not cause access violation, such as array out of
    bound.
  details: >-
    #### Abstract

    Pointer subtraction should not cause access violation, such as array out of
    bound.


    #### Explanation

    If pointers do not point to elements of the same array or the element one
    beyond the end of that array, the subtraction between them is undefined
    behaviour.
  examples:
    bad:
      c:
        - |-

          #include <stddef.h>

          void func()
          {
              int arr[3] = {0, 1, 2};

              // Points to two beyond
              int *p1 = &arr[0];
              int *p2 = &arr[2];

              ptrdiff_t diff;
              diff = p1 - p2; // undefined
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}，pointer subtraction
    causes an array out of bound access
  name: >-
    Subtraction between pointers should only be applied to pointers that address
    elements of the same array
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_18_2
- alias: {}
  category: ''
  code: MSR_18_6
  compliance: R
  csv_string:
    - MSR_18_6
  desc: >-
    Address of a local variable should not be passed outside of the variable's
    scope
  details: >-
    #### Abstract

    Address of a local variable should not be passed outside of the variable's
    scope


    #### Explanation

    When the lifetime of one object expires, its address becomes indeterminate.
    Then the use of that inderterminate address would result in undefined
    behaviour.
  examples:
    bad:
      c:
        - ''
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, address of a local
    variable is passed outside of the variable's scope
  name: >-
    Address of a local variable should not be passed outside of the variable's
    scope
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_18_6
- alias: {}
  category: ''
  code: MSR_22_1
  compliance: R
  csv_string:
    - MSR_22_1
  desc: >-
    Resources obtained dynamically from Standard library functions should be
    relaeased.
  details: >-
    #### Abstract

    Resources obtained dynamically from Standard library functions should be
    relaeased.


    #### Explanation

    It is possible for a failure to occur due to exhaustion of resources if
    those resources are not explicitly released . Releasing resources as soon as
    possible reduces the possibility of exhaustion.
  examples:
    bad:
      c:
        - ''
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}，resources obtained
    dynamically from Standard library functions are not relaeased.
  name: >-
    All resources obtained dynamically by means of Standard Library functions
    should be released
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_22_1
- alias: {}
  category: ''
  code: MSR_22_2
  compliance: M
  csv_string:
    - MSR_22_2
  desc: >-
    A block of memory should only be freed if it was allocated by Standard
    Library function
  details: >-
    #### Abstract

    A block of memory should only be freed if it was allocated by Standard
    Library function


    #### Explanation

    It is undefined behavior to freeing non-allocated memory or freeing the same
    allocated memory more than one time.
  examples:
    bad:
      c:
        - ''
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}，a block of memory is
    freed when it was not allocated by Standard Library function
  name: >-
    A block of memory should only be freed if it was allocated by Standard
    Library function
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_22_2
- alias: {}
  category: ''
  code: MSR_22_4
  compliance: M
  csv_string:
    - MSR_22_4
  desc: Read-only stream should not be written to
  details: >-
    #### Abstract

    Read-only stream should not be written to


    #### Explanation

    Since the Standard does not specify the behaviour if an attempt is made to
    write to a read-only stream, writting to a read-only stream is unsafe.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              FILE *fp;
              fp = fopen ( "test_file", "r" );
              fprintf( fp, "write to a read-only stream" ); // non-compliant
              fclose( fp );
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              FILE *fp;
              fp = fopen ( "test_file", "w+" );
              fprintf( fp, "write to a stream" ); // compliant
              fclose( fp );
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the stream which is
    opened as read-only is written to.
  name: >-
    There should be no attempt to write to a stream which has been opened as
    read-only
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_22_4
- alias: {}
  category: ''
  code: MSR_14_4
  compliance: R
  csv_string:
    - MSR_14_4
  desc: >-
    The controlling expression of an if or iteration statement should basically
    be of boolean type
  details: >-
    #### Abstract

    The controlling expression of an if or iteration statement should basically
    be of boolean type


    #### Explanation

    The controlling expression without basically Boolean type of an if statement
    or iteration-statement would lead to a weak typing.
  examples:
    bad:
      c:
        - |-

          int foo(int *p_int)
          {
            int ret = 0;
            int i;
            
            while (p_int) {   // p_int is a pointer
              i = *p_int;
              
              if (i) {   // i is int, not boolean
                ret++;
              }

              ret++;
              p_int--;
            } 
            return ret;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - "\n#define NULL 0\n\nint foo(int *p_int)\n{\n  int ret = 0;\n  int i;\n  \n  while (p_int != NULL) {   // p_int is a pointer\n      i = *p_int;\n      \n      if (i != 0) {   // i != 0 is a boolean expression\n\tret++;\n      }\n    ret++;\n    p_int--;\n    if (ret > 5)\n    {\n      break;\n    }\n  } \n  return ret;\n}"
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the controlling
    expression of an if statement does not have Boolean type.
  name: >-
    The controlling expression of an if statement and iteration-statement should
    have Boolean type
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_14_4
- alias: {}
  category: ''
  code: MSR_18_7
  compliance: R
  csv_string:
    - MSR_18_7
  desc: The program should not declare flexible array members
  details: >-
    #### Abstract

    Flexible array members should not be declared


    #### Explanation

    Since the assignment of a structure that contains a flexible array member to
    another similar type may behave unexpectedly, flexible array members should
    not be declared.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          struct Books
          {
              char    title[20];
              char    author[10];
              int     id[ ]; // flexible array menber
          } book;
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          // compliant
          struct Books
          {
              char    title[20];
              char    author[10];
              int     id[5];
          } book;
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the flexible array
    menbers are declared.
  name: Flexible array members should not be declared
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_18_7
- alias: {}
  category: ''
  code: MSR_8_1
  compliance: R
  csv_string:
    - MSR_8_1
  desc: The program should explicitly specify the types for all objects
  details: |-
    #### Abstract
    The program should explicitly specify the types for all objects

    #### Explanation
    If an explicit type is omitted, it may lead to declaration confusion.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          // Non-compliant function type
          extern void g (char a, const b); // Implicit int type for b

          // Non-compliant object type
          const   p; // Implicit int type for p
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          // Compliant function type
          extern void g (char a, const int b); // Explicit int type for b

          // Compliant object type
          const int p; // Explicit int type for p
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, type is not clearly
    specified.
  name: Type should be clearly specified
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_8_1
- alias: {}
  category: ''
  code: MSR_11_1
  compliance: R
  csv_string:
    - MSR_11_1
  desc: A pointer to a function should not be converted into any other type
  details: |-
    #### Abstract
    The program should not convert a pointer to a function into any other type

    #### Explanation
     The function which uses an incompatible pointer type should not be called. Otherwise it would lead to undefined behaviour.
  examples:
    bad:
      c:
        - |2-
           
          #include <stdio.h>
           #include <stdlib.h>

          typedef char ( *f1 ) ( int );
          typedef char ( *f2 ) ( int );

          void func ( void )
          {
              int x = 1;
              int *p = &x;
              int *q[10];
              f1 a = ( f1 ) p; // function pointer converted into different one is non-compliant
              f2 b = ( f2 ) *q; // non-compliant
              f1 c = ( f1 ) 1; // function pointer converted into int is non-compliant
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
          #include <stdlib.h>

          void func ( void )
          {
              typedef void ( *fp ) ( int x );
              extern void f ( int y );
              typedef fp ( *test ) ( void );

              fp p = NULL; // null pointer constant into function pointer is compliant
              fp q = f; // function into function pointer is compliant
              test tfunc;
              ( void ) ( *tfunc( ) ); // function pointer into void
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, a pointer to a function
    is converted into other type.
  name: >-
    Conversions should not be performed between a pointer to a function and any
    other type
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_11_1
- alias: {}
  category: ''
  code: MSR_16_2
  compliance: R
  csv_string:
    - MSR_16_2
  desc: >-
    switch label should be used at the outermost level of of the compound
    statement
  details: >-
    #### Abstract

    switch label should be used at the outermost level of of the compound
    statement


    #### Explanation

    Placing the switch label before any statement in the body of a switch
    statement is unstructured code
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int main()
          {
              int s, i;

              switch (s)
              {
                  case 5: // Compliant
                      printf("%d", 5);
                      for( i=0; i<3; i++ )
                      {
                  case 10: // Unstructed code
                      printf("%c", "s");
                      }
                      break;
                  default:
                      break;
              }
              
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          int main( int s )
          {
              switch (s)
              {
                  case 1: // Compliant
                      printf("%d", 1);
                      break;
                  case 2: // Compliant
                      printf("%d", 2);
                      break;
                  default:
                      break;
              }

              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the switch label is
    placed before any statement.
  name: The use of a switch label
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_16_2
- alias: {}
  category: ''
  code: MSR_16_4
  compliance: R
  csv_string:
    - MSR_16_4
  desc: There should be a default label after every switch statement
  details: >-
    #### Abstract

    There should be a default label after every switch statement


    #### Explanation

    The default label makes the programming defensive. And there should be a
    statement or comment after the default label.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int main( int s )
          {
              switch (s)
              {
                  case 10:
                      printf("%s", "ten");
                      break;
                  case 20:
                      printf("%s", "twenty");
                      break;
              // default label is missing
              }

              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          int main( int s )
          {
              switch (s)
              {
                  case 10:
                      printf("%s", "ten");
                      break;
                  case 20:
                      printf("%s", "twenty");
                      break;
                  default: // Compliant
                      break;
              }

              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the switch statement
    does not have a default label
  name: Every switch statement should have a default label
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_16_4
- alias: {}
  category: ''
  code: MSR_17_4
  compliance: M
  csv_string:
    - MSR_17_4
  desc: There should be a return statement expression for non-void function
  details: >-
    #### Abstract

    There should be a return statement expression for non-void function


    #### Explanation

    It is undefined behaviour that the calling function uses the returned value
    while the non-void function does not return a value. 
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int func ( int x )
          {
              for ( ; x < 5; x++){
                  printf("less than five");
                  return 0;
              }
              // control may reach end of function without returning
          }

          int main()
          {
              func(10); // undefined behaviour
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          int func ( void )
          {
              printf("Hello");
              return 0; // compliant
          }

          int main()
          {
              func(); // compliant
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the return statement
    does not have an expression for non-void return type function
  name: All exit paths for a non-void function should have a return statement
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_17_4
- alias: {}
  category: ''
  code: MSR_17_6
  compliance: M
  csv_string:
    - MSR_17_6
  desc: There should not be static keyword in the declaration of an array parameter
  details: >-
    #### Abstract

    There should not be static keyword in the declaration of an array parameter


    #### Explanation

    If the number of elements contained by an array parameter is less than the
    minimum specified, it is undefined behaviour.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          // non-compliant for use of static in array parameter declaration
          void func(int arr[static 5])
          {
              int i = 0;
              for (int i =0; i < 5; i++)
              {
                  arr[i]++;
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          // array parameter declaration without static
          void func(int arr[10])
          {
              for (int i =0; i < 10; i++)
              {
                  arr[i]++;
                  printf("%d", arr[i]);
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the declaration of an
    array parameter contain the static keyword between the [ ]
  name: >-
    The declaration of an array parameter should not contain the static keyword
    between the [ ]
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_17_6
- alias: {}
  category: ''
  code: MSR_18_5
  compliance: A
  csv_string:
    - MSR_18_5
  desc: There should not be more than two levels of pointer nesting
  details: >-
    #### Abstract

    There should not be more than two levels of pointer nesting


    #### Explanation

    If there are more than two levels of pointer nesting for declaration, it
    would be confusing to understand the code.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int i = 0;
          int * ip1 = &i;
          int ** ip2 = &ip1;
          // more than two levels of pointer nesting should be avoided
          int ***ip3 = &ip2;
          int ****ip4 = &ip3;
          int *****ip5 = &ip4;
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          // compliant for no more than two pointer declarators
          int i = 0;
          int * ip1 = &i;
          int ** ip2 = &ip1;
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the declarations
    contain more than two levels of pointer nesting
  name: Declarations should not contain more than two levels of pointer nesting
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_18_5
- alias: {}
  category: ''
  code: MSR_3_1_2
  compliance: R
  csv_string:
    - MSR_3_1_2
  desc: There should not be function declaration at block scope
  details: >-
    #### Abstract

    There should not be function declaration at block scope


    #### Explanation

    Declaration of a function at block scope would lead to a member of enclosing
    namespace which is confusing.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( int x )
          {
              x++;
              void func_in_block(); // function declared in block
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( int x )
          {
              x++;
          }

          void func_out_block(); // function declared out of block
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the functions are
    declared at block scope
  name: Functions should not be declared at block scope
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_3_1_2
- alias: {}
  category: ''
  code: MSR_4_10_1
  compliance: R
  csv_string:
    - MSR_4_10_1
  desc: NULL should not be used as integer
  details: >-
    #### Abstract

    NULL should not be used as integer


    #### Explanation

    NULL should be considerded to be of pointer type in order to be different
    from 0.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( int x )
          {
              x++;   
          }

          int main ( )
          {
              func ( NULL ); // NULL used as an integer value
              return 0;
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( int *x )
          {
              x++;
          }

          int main ( )
          {
              func ( NULL ); // NULL used as an pointer
              return 0;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func},  NULL is used as an
    integer
  name: NULL should not be used as an integer
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_4_10_1
- alias: {}
  category: ''
  code: MSR_4_10_2
  compliance: R
  csv_string:
    - MSR_4_10_2
  desc: 0 should not be used as null-pointer-constant
  details: >-
    #### Abstract

    0 should not be used as null-pointer-constant


    #### Explanation

    0 should be considered to be of integer type in order to be different from
    NULL
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( int *x )
          {
              x++;   
          }

          int main ( )
          {
              func ( 0 ); // 0 used as an null pointer constant
              return 0;
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( int x )
          {
              x++;
          }

          int main ( )
          {
              func ( 0 ); // 0 used as an integer value
              return 0;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, 0 is used as
    null-pointer-constant
  name: 0 should not be used as null-pointer-constant
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_4_10_2
- alias: {}
  category: ''
  code: MSR_6_2_1
  compliance: R
  csv_string:
    - MSR_6_2_1
  desc: Assignment should not be used in sub-expressions
  details: >-
    #### Abstract

    Assignment should not be used in sub-expressions


    #### Explanation

    The assignment used in sub-expression would add side effect to the full
    expression and make = and == confusing.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int a,b,c;
              a = 5;
              b = 10;
              if ( ( c = b ) > a ) // assignment inside sub-expression
              {
                  printf("c bigger than a");
              }
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int a,b,c;
              a = 5;
              b = 10;
              c = b; // assignment outside sub-expression
              if ( c > a )
              {
                  printf("c bigger than a");
              }
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, assignment operators
    are used in sub-expressions
  name: Assignment operators should not be used in sub-expressions
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_6_2_1
- alias: {}
  category: ''
  code: MSR_6_4_1
  compliance: R
  csv_string:
    - MSR_6_4_1
  desc: The if/else construct should be followed by compound statement(s)
  details: >-
    #### Abstract

    The if/else construct should be followed by compound statement(s)


    #### Explanation

    An if construct without a compound statement would raise error if the
    required braces are failed to add when changing a single statement to a
    multi-statement.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int x, y;
              x = 5;
              y = 10;
              if ( x > y ); // if construct without compound statement
              {
                  x++;
              }
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int x, y;
              x = 5;
              y = 10;
              if ( x > y ) // if construct with compound statement
              {
                  printf("x bigger");
              }
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the if construct is not
    followed by a compound statement
  name: The if/else construct should be followed by compound statement(s)
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_6_4_1
- alias: {}
  category: ''
  code: MSR_6_5_2
  compliance: R
  csv_string:
    - MSR_6_5_2
  desc: >-
    loop-counter should only be used to <=, <, > or >= when not modified by --
    or ++
  details: >-
    #### Abstract

    loop-counter should only be used to <=, <, > or >= when not modified by --
    or ++


    #### Explanation

    If the loop-counter is modified by operator other than -- or ++, the use of
    == and != would result in infinite loop.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int i, j;
              j = 5;
              for ( i = 3; i != j; i += 3 ) // non-compliant
              {
                  printf("infinite loop");
              }
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int i, j;
              j = 5;
              for ( i = 3; i < j; i += 3 ) // compliant
              {
                  printf("i smaller than j");
              }
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, loop-counter is used to
    != when it is not modified by -- or ++
  name: >-
    if loop-counter is not modified by -- or ++, it should only be used as an
    operand to <=, <, > or >=
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_6_5_2
- alias: {}
  category: ''
  code: MSR_6_6_3
  compliance: R
  csv_string:
    - MSR_6_6_3
  desc: The continue statement should not be overused
  details: >-
    #### Abstract

    The continue statement should not be overused


    #### Explanation

    The overuse of the continue statement would make the code unnecessarily
    complex
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int j = 3;
              for ( int i = 5; i > j; i++ )
              {
                  if ( ( i % j == 0 ) )
                  {
                      printf("not well-formed");
                      continue; // infinite loop
                  }
              }
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int j = 2;
              for ( int i = 10; i < j; i-- )
              {
                  if ( ( i % j == 0 ) )
                  {
                      printf("well-formed");
                      continue; // finite loop
                  }
              }
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the continue statement
    is overused
  name: The continue statement should only be used within a well-formed for loop
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_6_6_3
- alias: {}
  category: ''
  code: MSR_7_5_3
  compliance: R
  csv_string:
    - MSR_7_5_3
  desc: Function should not return reference parameter as a temporary object
  details: >-
    #### Abstract

    Function should not return reference parameter as a temporary object


    #### Explanation

    The use of the reference parameter as a temporary object when the function
    returns is undefined behaviour.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          int & func ( int & test )
          {
              int & t = test;
              return t;
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          int t;
          int test = 1;

          int func( t )
          {   
              t = test;
              return t; // compliant
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, function returns
    reference parameter as a temporary object
  name: >-
    Function should not return a reference or a pointer to a parameter passed by
    reference or const reference
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_7_5_3
- alias: {}
  category: ''
  code: MSR_8_4_4
  compliance: R
  csv_string:
    - MSR_8_4_4
  desc: Function identifiers should be used to call the functions or preceded by &
  details: >-
    #### Abstract

    Function identifiers should be used to call the functions or preceded by &


    #### Explanation

    The conversion of function identifier to function pointer may make it
    unclear between the address of the funtion and the calling of it.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          int func ( void )
          {
              return 0;
          }

          int main ( void )
          {
              if( func == 0 ) // unclear use of func
              {
                  printf("the use of func is not clear");
              }
              return 0;
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          int func ( void )
          {
              return 0;
          }

          int main ( void )
          {
              if( &func == 0 ) // compliant
              {
                  func(); // call the function
                  printf("the use of func is clear");
              }
              return 0;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the function
    identifiers are not used to call the functions or preceded by &
  name: A function identifier should be used to call the function or preceded by &
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_8_4_4
- alias: {}
  category: ''
  code: MSR_4_2
  compliance: A
  csv_string:
    - MSR_4_2
  desc: Trigraphs should not be used
  details: >-
    #### Abstract

    Trigraphs should not be used


    #### Explanation

    The use of trigraphs can cause accidental confusion with other two question
    marks.
  examples:
    bad:
      c:
        - |-

          extern void prints(char *, char *);

          // trigraph is used
          char TRG_STR[] = "[??)"; // "??)" represents "]"

          int foo()
          {
            prints("This example uses %s", TRG_STR);
            return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          #define NON_TRG_STR "NON-Trigraph string"

          int foo()
          {
            printf("This example uses %s", NON_TRG_STR); // trigraph is not used
            return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: In file ${so.filename}, line ${so.line}, ${so.func}, trigraph is used
  name: Trigraphs should not be used
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_4_2
- alias: {}
  category: ''
  code: MSR_5_4
  compliance: R
  csv_string:
    - MSR_5_4
  desc: Macro identifiers should be unique
  details: >-
    #### Abstract

    Macro identifiers should be unique


    #### Explanation

    It is undefined behavior that macro identifiers are different only in
    non-significant characters.
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          /*
           this example does not guarantee the same result for
           different compilers with std C90 or before
          */

          #define VERY_VERY_LONG_NAME2123456789312   10

          #define VERY_VERY_LONG_NAME21234567893123  20

          int main()
          {
            int i;
            if (VERY_VERY_LONG_NAME2123456789312 == VERY_VERY_LONG_NAME21234567893123) {
              i = 0;
            }
            else {
              i = 1;
            }
            printf("i = %d\n", i);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          #define VERY_VERY_LONG_NAME_FST 10

          #define VERY_VERY_LONG_NAME_SEC 20 // compliant

          int main()
          {
            int i;
            if (VERY_VERY_LONG_NAME_FST == VERY_VERY_LONG_NAME_SEC) {
              i = 0;
            }
            else {
              i = 1;
            }
            printf("i = %d\n", i);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, macro identifiers are
    not unique
  name: Macro identifiers should be unique
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_5_4
- alias: {}
  category: ''
  code: MSR_5_5
  compliance: R
  csv_string:
    - MSR_5_5
  desc: Macro names should not be the same as identifiers in a program
  details: |-
    #### Abstract
    Macro names should not be the same as identifiers in a program

    #### Explanation
    If the macro names are the same as identifiers, it would raise confusion.
  examples:
    bad:
      c:
        - |-

          #include <string.h>

          extern int Both_Macro_and_Var_name(int, int);
           
          // this example will get compilation error
          #define Both_Macro_and_Var_name(a, b) ((a) * (b))

          int foo(int j) {
            int i = 5;
            i = Both_Macro_and_Var_name(i, j);
            return i;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          /*
           this example does not guarantee the same result for
           different compilers with std C90 or before
          */

          #define VERY_VERY_LONG_NAME   10

          int     VERY_VERY_LONG_NAME_test;  // compliant
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, macro names are the
    same as identifiers
  name: identifiers should be different from macro names
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_5_5
- alias: {}
  category: ''
  code: MSR_8_2
  compliance: R
  csv_string:
    - MSR_8_2
  desc: >-
    Function declaration should be in prototype form and parameters in prototype
    should be named
  details: >-
    #### Abstract

    Function declaration should be in prototype form and parameters in prototype
    should be named


    #### Explanation

    The specification of parameter types and function types help avoid undefined
    behaviors.
  examples:
    bad:
      c:
        - |


          extern int functionX(int, char *);  /* parameters without name */

          int foo(int a1, char *c2)
          {
            int i = functionX(a1, c2);
            if (i != 0)
              return i;
            return -1;
          }


          int bar(b1, b2)
          int b1;
          char *b2;
          {
            int i = functionX(b1, b2);
            if (i != 0)
              return i;
            else
              return -1;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |


          extern int functionX(int, char *);  /* parameters without name */

          int foo(int a1, char *c2)
          {
            int i = functionX(a1, c2);
            if (i != 0)
              return i;
            return -1;
          }


          int bar(int b1, char *b2)    /* declaration in prototype form */
          {
            int i = functionX(b1, b2);
            if (i != 0)
              return i;
            else
              return -1;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, function types are not
    in prototype form with named parameters
  name: Function types should be in prototype form with named parameters
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_8_2
- alias: {}
  category: ''
  code: MSR_15_6
  compliance: R
  csv_string:
    - MSR_15_6
  desc: >-
    The body of iterative or selection statements should be inside a compound
    statement
  details: >-
    #### Abstract

    The body of iterative or selection statements should be inside a compound
    statement


    #### Explanation

    The use of compound-statement could clearify which statements form the body
    of iterative or selection statements.
  examples:
    bad:
      c:
        - |-

          int foo(int i)
          {
            int ret = i;
            
            if (i == 0)  // conditional with non-compound statement
              return i++;
            else if (i < 0) 
              return -i;
            else 
              ; // empty else


            // loop with one non compound statement in body
            while (i != 0) 
              ret--;
            
            return ret;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          int foo(int i)
          {
            int ret = i;
            
            if (i == 0) {
              return i++;
            }
            else if (i < 0) {
              return -i;
            }
            else {
              ; // empty else
            }

            // loop with compound statement
            while (ret < 0) {
              ret++;
            }
            return ret;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the body of iterative
    or selection statements are not compound-statements
  name: The body of iteration or selection statements should be compound-statements
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_15_6
- alias: {}
  category: ''
  code: MSR_16_3
  compliance: R
  csv_string:
    - MSR_16_3
  desc: All switch statement should have a terminating break statement
  details: >-
    #### Abstract

    All switch statement should have a terminating break statement


    #### Explanation

    The switch-clause without a break statement may fall into switch-clause
    which are added later.
  examples:
    bad:
      c:
        - |-

          int loop_cnt_ex2(int count, int input)
          {
            int idx = count;
            int ret = 0;
            
            switch (input) {
              
            default:   // default at beginning of switch
              
            case 0:
              idx--;
              break;
              
            case 1:    // this case at end of switch has no break
              idx++;

            }
            
            // ...
            return ret;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          int loop_cnt(int count, int input)
          {
            int idx = count;
            int ret = 0;
            
            switch (input) {
            case 0:
              idx--;
              ret++;
              break;
              
            case 1:
              idx++;
              ret++;
              break;
              
            default:   // default with a break statement
              break;
            }
            
            // ...
            return ret;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, switch statements do
    not have terminating break statements
  name: All switch statement should have a terminating break statement
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_16_3
- alias: {}
  category: ''
  code: MSR_15_0_2
  compliance: A
  csv_string:
    - MSR_15_0_2
  desc: There should not be exception object of pointer type
  details: >-
    #### Abstract

    There should not be exception object of pointer type


    #### Explanation

    It is unclear which function should destroy the exception object if it has
    pointer type and refers to a dynamically created object.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |


          class A {
          public:
            A(void) {}
            A(const A &b) {
              // ...
            }
            A(int) {}

            int Priv_int() const { return priv_int; }
          private:
            static int priv_int;
          };

          void foo(int i)
          {
            A varA;
            // local is dynamically created with local scope
            A *local = new A;
            
            if (varA.Priv_int() < 0) {
              throw(&varA);  // addr of local exposed (stack address)
            }
            else {
              throw(local);  // this could cause a heap object not properly deleted
            }
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          class A {
          public:
            A(void) {}
            A(const A &b) {
              // ...
            }
            A(int) {}

            int Priv_int() const { return priv_int; }
          private:
            static int priv_int;
          };

          void foo(int i)
          {
            A varA;
            // local is dynamically created with local scope
            A *local = new A;
            
            if (varA.Priv_int() == 0) {
              throw(varA);    // varA is not address
            }
            else {
              int l = local->Priv_int();
              delete local;
              throw(l); // return value copy of local's content, no heap address exposed
            }
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, a exception object has
    pointer type
  name: There should not be exception object of pointer type
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_15_0_2
- alias: {}
  category: ''
  code: MSR_15_1_1
  compliance: R
  csv_string:
    - MSR_15_1_1
  desc: When constructing an exception object, an exception should not be thrown
  details: >-
    #### Abstract

    When constructing an exception object, an exception should not be thrown


    #### Explanation

    If an exception is thrown during the construction of an exception object, it
    propagates in preference to the one about to be thrown, which may be out of
    expectation.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <iostream>
           
          using namespace std;

          class MyException
          {
            public:
              MyException ()
              {
                throw "Exception thrown when constructing an exception object"; // non-compliant
              }
          };

          void func ( int n ) throw (int, MyException)
          {
            if ( n == 1 )
            {
              throw 1;
            }
            else
            {
              throw MyException();
            }
          }

          int main( void )
          {
            try
            {
              func(2);
            }

            catch ( int n )
            {
              cout << "catch int ..." << endl;
            }
            catch (MyException)
            {
              cout << "catch MyException ..." << endl;
            }
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <iostream>

          using namespace std;

          class MyException
          {
            public:
              MyException ()
              {
                cout << "constructor does not cause exception" << endl; // compliant
              }
          };

          void func ( int n ) throw (int, MyException)
          {
            if ( n == 1 )
            {
              throw 1;
            }
            else
            {
              throw MyException();
            }
          }

          int main( void )
          {
            try
            {
              func(2);
            }

            catch ( int n )
            {
              cout << "catch int ..." << endl;
            }
            catch (MyException)
            {
              cout << "catch MyException ..." << endl;
            }
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, an exception is thrown
    when constructing an exception object
  name: When constructing an exception object, an exception should not be thrown
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_15_1_1
- alias: {}
  category: ''
  code: MSR_15_1_2
  compliance: R
  csv_string:
    - MSR_15_1_2
  desc: >-
    Throwing a NULL will be caught by an integer handler, this may be unexpected
    behavior
  details: >-
    #### Abstract

    Throwing a NULL will be caught by an integer handler, this may be unexpected
    behavior


    #### Explanation

    Throw NULL would be caught by an integer handler, which may not match
    developer expectations.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |

          #include <iostream>
           
          using namespace std;

          class Str {
          public:
            int Report()  const { cout << "Str error "; return 0; }
            void NullReport(void) { cout << "Null pointer"; }
            
          public:
            Str() {} 
            void setLength( double len );
            int  Length( void ) {
              if (length == 0)
                throw Report();
              else
                return length;
            }
           
          private:
            int length;
          };


          void foo(class Str *p)
          {
            // ...
            
            try {
              if (p->Length() < 0) {
                throw (NULL);    // throw NULL
              }
              // ...
            }
            catch (int m) {
              if (m == 0) {
                p->NullReport();
              }
              // ...
            }

            // ..
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |

          #include <iostream>
           
          using namespace std;

          class Str {
          public:
            int Report()    const { cout << "Str error "; return 0; }
            void NullReport(void) { cout << "Null pointer"; }  
            
          public:
            Str() {} 
            void setLength( double len );
            int  Length( void ) {
              if (length <= 0)
                throw Report();
              else
                return length;
            }
           
          private:
            int length;
          };


          int main(class Str *p)
          {
            // ...
            
            try {
              p->Length();  // Legth() fully handle throw
              // ...
            }
            catch (int m) {
              if (m == 0)
                p->NullReport();
              // ...
            }
            catch (...) {
              // ...
            }

            // ..
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, NULL is thrown
    explicitly 
  name: NULL should not be thrown explicitly
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_15_1_2
- alias: {}
  category: ''
  code: MSR_15_1_3
  compliance: R
  csv_string:
    - MSR_15_1_3
  desc: An empty throw shall not be used outside a catch handler
  details: >-
    #### Abstract

    An empty throw shall not be used outside a catch handler


    #### Explanation

    Use of empty throw outside a catch handler would terminate the program since
    there is no exception object to re-thrown. The behavior is implementation
    defined.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |

          #include <iostream>
           
          using namespace std;

          class Str {
          public:
            int Report()  const { cout << "Str error "; return 0; }
            void NullReport(void) { cout << "Null pointer"; }
            
          public:
            Str() {} 
            void setLength( double len );
            int  Length( void ) {
              if (length == 0)
                throw Report();
              else
                return length;
            }
           
          private:
            int length;
          };


          void foo(class Str *p)
          {
            // ...
            
            try {
              if (p->Length() < 0) {
                throw;    // empty throw
              }
              // ...
            }
            catch (int m) {
              if (m == 0)
                p->NullReport();
              else {
                throw;
              }
              // ...
            }

            // ..
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |

          #include <iostream>
           
          using namespace std;

          class Str {
          public:
            int Report()    const { cout << "Str error "; return 0; }
            void NullReport(void) { cout << "Null pointer"; }  
            
          public:
            Str() {} 
            void setLength( double len );
            int  Length( void ) {
              if (length <= 0)
                throw Report();
              else
                return length;
            }
           
          private:
            int length;
          };


          void foo(class Str *p)
          {
            // ...
            
            try {
              p->Length();
              // ...
            }
            catch (int m) {
              if (m == 0)
                p->NullReport();
              else {
                throw;  // re-throw - allowed
              }
              // ...
            }

            // ..
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, an empty throw is used
    outside a catch handler
  name: An empty throw should only be used in a catch handler
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_15_1_3
- alias: {}
  category: ''
  code: MSR_15_3_2
  compliance: A
  csv_string:
    - MSR_15_3_2
  desc: >-
    An exception handler to catch all otherwise unhandled exceptions should be
    provided
  details: >-
    #### Abstract

    An exception handler to catch all otherwise unhandled exceptions should be
    provided


    #### Explanation

    An exception handler to catch all otherwise unhandled exceptions ensures
    that unexpected exceptions can also be caught.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |


          #include <stdlib.h>

          void f()
          {

            // code
            // ...
            
            exit(0);
          }


          int main(int argc, char *argv[])
          {
            try {
              
              // code with no call to f()

            }
            catch (int m) {    
              // handle any uncaught exception
            }
            
            return 0;
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |


          #include <stdlib.h>

          class X {
            
          public:
            X() { }  // constructor that does not throw
            void setLen( double len );
            int check_and_handle_error(int) {
              if (len < 0)
                throw 0;
              return len;
            }  
          private:
            int  len;
          };

          void f()
          {
            X local_x;
            int i;
            
            // code
            // ...

            // where check_and_error() resides inside main
            // such that all exceptions are caught
            i = local_x.check_and_handle_error(0);
            // ...
          }


          int main(int argc, char *argv[])
          {
            try {
              
              // code can call f() which may throw exception
              // ...
             
            }
            catch (int m) {    
              // handle any uncaught exception
            }
            
            return 0;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, an exception handler to
    catch all otherwise unhandled exceptions is not provided
  name: >-
    An exception handler to catch all otherwise unhandled exceptions should be
    provided
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_15_3_2
- alias: {}
  category: ''
  code: MSR_15_3_3
  compliance: R
  csv_string:
    - MSR_15_3_3
  desc: >-
    In ctor/dtor, handlers of a function-try-block should not reference
    non-static members from this class or its bases
  details: >-
    #### Abstract

    In ctor/dtor, handler of a function-try-block should not reference
    non-static members from this class or its bases


    #### Explanation

    It is undefined behavior to access a non-static member of a class or a base
    class in the handler of a function-try-block.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <iostream>
           
          using namespace std;

          class Count {
          public:
            int Report()  const { cout << "argument C "; return 0; }
            void NullReport(void) { cout << "Null pointer"; }
            
          public:
            int local_x;
            Count( void ) {
              try {
                // ...
              }
              catch (int m) {
                // reference local that may be in unknown state
                if (local_x == 0) throw Report();  
              }
            }
            ~Count( void ) {
              try {
                // ...
              }
              catch (int m) {
                // reference local who
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |

          #include <iostream>
           
          using namespace std;

          class Count {
          public:
            int Report()  const { cout << "argument C "; return 0; }
            void NullReport(void) { cout << "Null pointer"; }
            
          public:
            static int static_x;  // static scope variable
            Count( void ) {
              try {
                // ...
              }
              catch (int m) {
                // static var will have deterministic state
                if (static_x == 0) throw Report();  
              }
            }
            void setCount( int c );

          };

          Count ct; 

          int main(int argc, char *argv[])
          {

            // ...
            // main code

            return 0;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, handlers of a
    function-try-block reference non-static members from this class or its bases
  name: >-
    handlers of a function-try-block should not reference non-static members
    from this class or its bases
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_15_3_3
- alias: {}
  category: ''
  code: MSR_15_3_5
  compliance: R
  csv_string:
    - MSR_15_3_5
  desc: 一个类类型异常对象应仅通过引用捕获
  details: |-
    #### 概要
    一个类类型异常对象应仅通过引用捕获

    #### 解释
    如果类类型异常对象不是通过引用捕获的，则无法访问派生类中的其他成员数据。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |

          class Base {
          public:
            Base(void) {}
            Base(const Base &b) {}
            virtual const char* test() {
              return "Base";
            }; 
          private:
            static int priv_int;
          };


          class Derived : public virtual Base {
          public:
            Derived() {}
            virtual const char* test() {
              return "Derived";
            };
          private:
            int d;
            
            void foo()
            {    
              try {
                // ...
                throw Derived();
                throw Base();
              }
              catch (Base b) {
                b.test();
                throw b;
              }
            }
          };
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |

          class Base {
          public:
            Base(void) {}
            Base(const Base &b) {}
            virtual const char* test() {
              return "Base";
            };

          private:
            static int priv_int;
          };


          class Derived : public virtual Base {
          public:
            Derived() {}
            //  Derived1(int) : Base(0) {}
            virtual const char* test() {
              return "Derived";
            };
            
            
            void foo()
            {
              Derived D1;
              
              try {
                // ...
                throw Derived();
                throw Base();
              }
              catch (Base &b) {
                b.test();
                throw b;
              }
              catch (Derived &d) {
                d.test();
                throw d;
              }
            }
          };
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 类类型异常对象未被引用捕获
  name: 一个类类型异常对象应仅通过引用捕获
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_15_3_5
- alias: {}
  category: ''
  code: MSR_12_5
  compliance: M
  csv_string:
    - MSR_12_5
  desc: >-
    function parameter declared as "array of type" should not be used as
    operator for sizeof
  details: >-
    #### Abstract

    function parameter declared as "array of type" should not be used as
    operator for sizeof


    #### Explanation

    Since the function parameters declared as arrays would degenerate to pointer
    to type, the use of size of cannot return the size of the array.
  examples:
    bad:
      c:
        - |-

          #include <stdint.h>

          void func( int arr1[ 5 ], int arr2[ 3 ] )
          {
              int a = sizeof( arr1 ) - sizeof (arr2);
              /*
                  non-compliant;
                  arr1, arr2 have type int *;
                  sizeof arr1, arr2 do not return the size of array
              */
              printf( a );
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdint.h>

          int arr1[] = {1, 2, 3};
          int arr2[] = {1, 2};

          void func( void )
          {
              int a = sizeof( arr1 ) - sizeof (arr2);
              /*
                  compliant;
                  sizeof arr1, arr2 return the size of arrays
              */
              printf( a );
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, sizeof operator is used
    to function parameters declared as "array of type"
  name: >-
    sizeof operator should not be used to function parameters declared as "array
    of type"
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_12_5
- alias: {}
  category: ''
  code: MSR_2_10_6
  compliance: R
  csv_string:
    - MSR_2_10_6
  desc: An identifier should not refer to a type and an object in the same scope
  details: >-
    #### Abstract

    An identifier should not refer to a type and an object in the same scope


    #### Explanation

    An identifier which refers to both a type and object or a type and function
    can lead to confusion.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          // a name refer to both a type and an object
          typedef struct test1 { int x; int y; } test1;

          /* 
          a name refer to both a type and a function,
          this example will get compilation error
          */
          typedef struct test2 { int a; int b; } test2;

          int test2( void )
          {
              return 1;
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          // different names refer to a type and an object
          typedef struct test1 { int x; int y; } test2;
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, an identifier refer to
    a type and an object in the same scope
  name: An identifier should not refer to a type and an object in the same scope
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_2_10_6
- alias: {}
  category: ''
  code: MSR_4_5_1
  compliance: R
  csv_string:
    - MSR_4_5_1
  desc: >-
    Bool expression should not be used as operands to built-in operators other
    than =, &&, ||, !, ==, !=, &, ?:
  details: >-
    #### Abstract

    Bool expression should not be used as operands to built-in operators other
    than =, &&, ||, !, ==, !=, &, ?:


    #### Explanation

    The use of bool operands with other operators is unmeaningful.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          bool a = true;
          bool b = false;

          void func( void )
          {
              if ( a < b ) // the use of bool and < is unmeaningful
              {
                  printf("non-compliant");
              }
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          bool a = true;
          bool b = false;

          int func( void )
          {
              if ( a && b )           // the use of bool and && is meaningful
              {
                  printf("compliant");
              }
              else if ( a != b )      // the use of bool and != is meaningful
              {
                  printf("compliant");
              }
              return 0;   
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, bool expression is used
    as operands to built-in operators other than =, &&, ||, !, ==, !=, &, ?:.
  name: >-
    Bool expression should not be used as operands to built-in operators other
    than =, &&, ||, !, ==, !=, &, ?:
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_4_5_1
- alias: {}
  category: ''
  code: MSR_7_3_4
  compliance: R
  csv_string:
    - MSR_7_3_4
  desc: Using-directives should not be used
  details: >-
    #### Abstract

    Using-directives should not be used


    #### Explanation

    Using-directives increases the possibility that the identifier found by the
    compiler creates confusion while using-declarations is a safer choice.
  examples:
    bad:
      c:
        - ''
      cpp:
        - "\n#include <iostream>\n\nnamespace T1\n{\n\tint t{ 5 };\n}\n\nnamespace T2\n{\n\tint t{ 1 };\n}\n\n/* This example may cause compilation error;\nusing directives raises confusion for \n\"std::cout << t\" of which t to refer to*/\nint func( void )\n{   \n    using namespace T1; \n    using namespace T2;\n    std::cout << t;\n    return 0;\n}"
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - "\n#include <iostream>\n\nnamespace T1\n{\n\tint t{ 5 };\n}\n\nnamespace T2\n{\n\tint t{ 1 };\n}\n\nint func( void )\n{   \n    using T2::t; // using declaration is compliant\n    std::cout << t;\n    return 0;\n}"
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, using-directives is
    used.
  name: Using-directives should not be used
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_7_3_4
- alias: {}
  category: ''
  code: A5_0_3
  compliance: A
  cost: H
  csv_string:
    - A5_0_3
  desc: >-
    The value of the expression cannot be converted to an inappropriate
    essential type
  details: >-
    #### Abstract

    The value of the expression cannot be converted to an inappropriate
    essential type


    #### Explanation

    Cast conversion between two inappropriate types may result in the loss or
    change of data, so the value of the expression cannot be cast to an
    inappropriate type.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
           
          void func ( void );
           
          bool bool_var;
          char char_var;
          enum enum_var {} enum_var;
          signed signed_var;
          unsigned unsigned_var;
          float float_var;
           
          void func ( void )
          {
            // expression 1.0f cast to an narrower type char
            char_var = ( char ) 1.0f;
            // char_var cast to narrower type bool
            bool_var = ( bool ) char_var;
            char_var = ( char ) bool_var; // non-compliant
            enum_var = ( enum enum_var ) bool_var; // non-compliant
            signed_var = ( signed ) bool_var; // non-compliant
            unsigned_var = ( unsigned ) bool_var; // non-compliant
            float_var = ( float ) bool_var; // non-compliant
            bool_var = ( bool ) char_var; // non-compliant
            enum_var = ( enum enum_var ) char_var; // non-compliant
            float_var = ( float ) char_var; // non-compliant
            bool_var = ( bool ) enum_var; // non-compliant
            bool_var = ( enum enum_var ) enum_var; // non-compliant
            bool_var = ( bool ) signed_var; // non-compliant
            bool_var = ( enum enum_var ) signed_var; // non-compliant
            bool_var = ( bool ) unsigned_var; // non-compliant
            bool_var = ( enum enum_var ) unsigned_var; // non-compliant
            bool_var = ( bool ) float_var; // non-compliant
            bool_var = ( enum enum_var ) float_var; // non-compliant
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( void );

          void func ( void )
          {
              char char_var;
              bool bool_var;
              // int can be cast to char
              char_var = ( char ) 1;
              // int 1 can be cast to bool by exception
              bool_var = ( bool ) 1;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  likelihood: L
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the value of the
    expression is converted to an inappropriate essential type
  name: 'Same essential type within an expression '
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  severity: H
  standards: {}
- alias: {}
  category: ''
  code: A3_3_1
  compliance: R
  csv_string:
    - A3_3_1
  desc: >-
    Objects or functions with external linkage should be declared in a header
    file
  details: >-
    #### Abstract

    Objects or functions with external linkage should be declared in a header
    file


    #### Explanation

    The object and functions without external linkage should be declared in an
    unnamed namespace or declared static in order to reduce visibility of them.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
          #include "header.h"

          int x = 5;
          int y = 10; // non-compliant
          int test ( void ) // non-compliant
          {
              x = 10;
              y = 5;
              return 0;
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |

          #include <stdio.h>
          #include "header.h"

          int x = 5;
          static int y = 10; // compliant
          void func ( void ) // compliant
          {
              x = 10;
              y = 5;
          }

          static int test ( void ) // compliant
          {
              x = 10;
              y = 5;
              return 0;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, objects or functions
    with external linkage are not declared in a header file
  name: >-
    Objects or functions with external linkage should be declared in a header
    file
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A3_9_1
  compliance: R
  csv_string:
    - A3_9_1
  desc: Fixed width integer types should replace the basic numerical types
  details: >-
    #### Abstract

    Fixed width integer types should replace the basic numerical types


    #### Explanation

    Specific length types from <cstdint> should be used to replace basic
    numerical types of char, int, short, long
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
          #include <stdint.h>

          void func ( void )
          {
              int a = 1; // basic numerical types
              int b = 5;
              int c = 10;
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
          #include <stdint.h>

          void func ( void )
          {
              int8_t a = 1; // fixed width integer types
              int16_t b = 5;
              int32_t c = 10;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the basic numerical
    types are used instead of fixed width integer types
  name: >-
    Fixed width integer types should be used in place of the basic numerical
    types
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A2_11_5
  compliance: A
  csv_string:
    - A2_11_5
  desc: Identifier with static storage duration should not be reused
  details: >-
    #### Abstract

    Identifier with static storage duration should not be reused


    #### Explanation

    The reuse of identifier with static storage duration would possibly make
    unrelated variables incorrectly associted with the same name.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
          #include <stdint.h>

          namespace TEST1
          {
              static int a = 1;
          }

          namespace TEST2
          {
              void func ( void )
              {
                  int a; // reused identifier a
                  a++;
              }
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
          #include <stdint.h>

          namespace TEST1
          {
              static int a = 1;
          }

          namespace TEST2
          {
              void func ( void )
              {
                  int b; // not reused identifier b
                  b++;
              }
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, identifiers with static
    storage duration are reused
  name: Identifier with static storage duration should not be reused
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: 枚举不应用于算术
  code: A4_5_1
  compliance: R
  csv_string:
    - A4_5_1
  desc: Enumerations should not be used in arthmetic conditions
  details: >-
    #### Abstract

    Enumerations should not be used in arthmetic conditions


    #### Explanation

    Enumerations have implementation-defined representations. Eums can be used
    as operands only to operators including [ ], =, ==, !=, <, <=, >, >=. 
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
          #include <stdint.h>

          extern void extern_func(char *);

          enum {a, b, c} test;

          void func ( void )
          {
              if ( ( a + b ) == test ) // non-compliant
              {
                  extern_func("test_1");
              }
              else if ( ( a - c  ) != b ) // non-compliant
              {
                  extern_func("test_2");
              }
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
          #include <stdint.h>

          enum {a, b, c} test;

          void func ( void )
          {
              if ( a != b )  // compliant
              {
                  printf("test_1");
              }
              else if ( b <= c ) // compliant
              {
                  printf("test_2");
              }
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, enumerations are used
    in arthmetic conditions
  name: Enumerations should not be used in arthmetic conditions
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A5_1_1
  compliance: R
  csv_string:
    - A5_1_1
  desc: Literal values should not be used apart from type initialization
  details: >-
    #### Abstract

    Literal values should not be used apart from type initialization


    #### Explanation

    The use of literal value has bad effect on readability and maintainability
    of the code.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
          #include <stdint.h>
          #include <iostream>

          void function( void )
          {
            for (int32_t i = 0; i < 100; i++)  // non-compliant
              {
                printf("magic number for 100"); // compliant by exception
                std::cout << "magic number" << i << '\n'; // compliant by exception
              }
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
          #include <stdint.h>

          #include <stdio.h>
          #include <stdint.h>

          void function( void )
          {
              const int max_length = 100;
              for (int i = 0; i < max_length; i++)
              {
                  printf("avoid magic numbers"); // compliant
              }
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: In file ${so.filename}, line ${so.line}, ${so.func}, literal values are used
  name: Literal values should not be used apart from type initialization
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A2_10_1
  compliance: R
  csv_string:
    - A2_10_1
  desc: >-
    An identifier declared in an inner scope should not be the same as an outer
    one
  details: >-
    #### Abstract

    An identifier declared in an inner scope should not be the same as an outer
    one


    #### Explanation

    If an identifier declared in an inner scope uses the same name as an
    identifier in an out er scope, it would raise confusion for developer.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          int i, j;

          int func ( int i, int j ) // non-compliant
          {
              i = 1;
              j = 2;
              if ( i - j < 0 )
              {
                  return 0;
              }
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          int i;

          int func1 ( int j ) // compliant
          {
              j ++;
              return 0;
          }

          namespace test1
          {
              int t;
              namespace test2
              {
                  int t; // compliant by exception
              }
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, An identifier declared
    in an inner scope  hides an outer one
  name: An identifier declared in an inner scope should not hide an outer one
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A2_11_1
  compliance: R
  csv_string:
    - A2_11_1
  desc: Volatile keyword should not be used
  details: |-
    #### Abstract
    Volatile keyword should not be used

    #### Explanation
    Volatile keyword is error-prone and is often misused by developers.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          int func ( void )
          {
              volatile int i = 10; // non-compliant
              int a, b;
              a = i;
              /*
              ...
              do something
              */
              b = i;
              return 0;
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          int func ( void )
          {
              int i = 10; // compliant
              int a;
              a = i;
              return a;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, volatile keyword is
    used
  name: Volatile keyword should not be used
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A2_13_5
  compliance: A
  csv_string:
    - A2_13_5
  desc: Hexadecimal constants should be upper case
  details: >-
    #### Abstract

    Hexadecimal constants should be upper case


    #### Explanation

    Use of upper case for hexadecimal constants makes source code consistent and
    reduces developer confusion.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
          #include <cstdint>

          int   i = 0xa;    // non-compliant
          short j = 0x4b;   // non-compliant
          short k = 0x0f5c; // non-compliant

          int foo(int i, short s1, short s2)
          {
            return i + (int)j + (int)k;
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
          #include <cstdint>

          int16_t i = 0xA;    // compliant
          int16_t j = 0x4B;   // compliant
          int16_t k = 0x0F5C; // compliant
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, hexadecimal constants
    is not upper case
  name: Hexadecimal constants should be upper case
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A2_13_4
  compliance: R
  csv_string:
    - A2_13_4
  desc: String literals should not be assigned to non-constant pointers
  details: >-
    #### Abstract

    String literals should not be assigned to non-constant pointers


    #### Explanation

    String literals should be changed to constant pointers in order to prevent
    from calling an inappropriate function which might modify its argument.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              char non_const1[] = "str_literal";      // non-compliant
              char* non_const2 = "str_literal";       // non-compliant
              char non_const3[ 12 ] = "str_literal";  // non-compliant
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              const char a1[] = "str_literal";    // compliant
              const char* a2 = "str_literal";     // compliant
              const char a3[12] = "str_literal";  // compliant
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, string literals are
    assigned to non-constant pointers
  name: String literals should not be assigned to non-constant pointers
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A7_2_2
  compliance: R
  csv_string:
    - A7_2_2
  desc: Enumeration underlying base type should be explicitly defined
  details: >-
    #### Abstract

    Enumeration underlying base type should be explicitly defined


    #### Explanation

    The enumeration underlying type must be able to represent the enumeration
    values.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          enum test // non-compliant
          {   
              t1,
              t2,
              t3
          };
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          enum test : int // compliant
          {   
              t1,
              t2,
              t3
          };
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, enumeration underlying
    base type is not explicitly defined.
  name: Enumeration underlying base type should be explicitly defined
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A5_16_1
  compliance: R
  csv_string:
    - A5_16_1
  desc: The ternary conditional operators should not be used as sub-expressions
  details: >-
    #### Abstract

    The ternary conditional operators should not be used as sub-expressions


    #### Explanation

    The use of ternary conditional operators as sub-expressions would make code
    less readable.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          int func ( int x, int y )
          {
              // ternary conditional operator used as sub-expression
              int z = y - (x > y ? 10 : ( y > 5 ? 2 : ( x + y )));
              return z;
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |

          #include <stdio.h>

          int func ( int x, int y )
          {
              int z = x > y ? 10 : x; // compliant
              return z;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, the ternary conditional
    operators are used as sub-expressions
  name: The ternary conditional operators should not be used as sub-expressions
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A7_1_6
  compliance: R
  csv_string:
    - A7_1_6
  desc: typedef specifier should not be used for defining alias
  details: >-
    #### Abstract

    typedef specifier should not be used for defining alias


    #### Explanation

    The using syntax should be used to replace typedef since typedef makes code
    less readable.
  examples:
    bad:
      c:
        - ''
      cpp:
        - >-

          #include<string>


          // defining aliases with typedef

          typedef unsigned int uint_t;

          typedef int *p;

          typedef int f( void );


          // template <typename Test>

          // typedef func_t: void (*)(Test, Test); // this example would raise
          compilation error
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          // defining aliases with using
          using uint_t = unsigned int;

          template <typename Test>
          using func_t = void (*)(Test, Test);
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, typedef specifier is
    used.
  name: typedef specifier should not be used for defining alias
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A7_2_3
  compliance: R
  csv_string:
    - A7_2_3
  desc: Enumerations should be declared as scoped enum classes
  details: >-
    #### Abstract

    Enumerations should be declared as scoped enum classes


    #### Explanation

    The declaration of unscoped enumeration enum in global scope may be
    confusing, so  enum-class should be used as enumeration.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          // unscoped enumeration enum is declared in a global scope
          enum test : int
          {   
              t1,
              t2,
              t3
          };
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          // Using enum-class as enumeration is compliant
          enum class test : int
          {   
              t1,
              t2,
              t3
          };
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, enumerations are not
    declared as scoped enum classes
  name: Enumerations should be declared as scoped enum classes
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A7_2_4
  compliance: R
  csv_string:
    - A7_2_4
  desc: >-
    In enumeration, either none, the first or all enumerators should be
    initialized.
  details: >-
    #### Abstract

    In enumeration, either none, the first or all enumerators should be
    initialized.


    #### Explanation

    Initialization of only some enumerators in enumeration is confusing.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          enum class test1 : int // non-compliant
          {   
              t1,
              t2 = 10,
              t3
          };

          enum class test2 : int // non-compliant
          {   
              t4,
              t5 = 10,
              t6 = 11
          };
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |

          enum class test1 : int // compliant
          {   
              t1,
              t2,
              t3
          };

          enum class test2 : int // compliant
          {   
              t4 = 1,
              t5,
              t6
          };

          enum class test3 : int // compliant
          {   
              t7 = 1,
              t8 = 2,
              t9 = 3
          };
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, only partial
    enumerators in enumeration are initialized.
  name: >-
    In enumeration, either none, the first or all enumerators should be
    initialized.
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A10_1_1
  compliance: R
  csv_string:
    - A10_1_1
  desc: 'Class should not be derived from more than one non-interface base class '
  details: >-
    #### Abstract

    Class should not be derived from more than one non-interface base class 


    #### Explanation

    Classes derived from more than one non-interface base class would make the
    code more difficult to maintain.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          class Base1
          {
              public:
                  void func1(){}
          };

          class Base2
          {
              public:
                  void func2(){}
          };

          // Non-compliant
          // Base1 and Base2 are both not interface classes
          class Derived : public Base1,
                          public Base2
          {};
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          class Base1 
          {
              public:
                  virtual void func1() = 0;
                  virtual void func2() = 0;
          };

          class Base2
          {
              public:
                  void func3(){}
                  void func4(){}
          };

          class Base3
          {
              public:
                  virtual void func5() = 0;
                  virtual void func6() = 0;
          };


          // compliant
          // Only Base2 is not interface class
          class Derived1 : public Base1,
                           public Base2
          {};

          // compliant
          // Both Base1 and Base3 are interface classes
          class Derived2 : public Base1,
                           public Base3
          {};
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, class is derived from
    more than one non-interface base class 
  name: 'Class should not be derived from more than one non-interface base class '
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A11_0_1
  compliance: A
  csv_string:
    - A11_0_1
  desc: Non-POD type should be defined as class
  details: >-
    #### Abstract

    Non-POD type should be defined as class


    #### Explanation

    The class specifier forces the non-POD type to provide private access
    control for all its members by default, which is consistent with developer
    expectations.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdint.h>

          typedef char    Letter;  
          typedef Letter* pLetter;
            
          struct Struct_With_non_POD    
          {
          public:
            Letter  c;  
            pLetter p;
          };
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - >-

          #include <stdint.h>


          typedef char    Letter;  

          typedef Letter* pLetter;
            
          class Xlass_With_non_POD    

          {

          public:
            Letter  c;  
            pLetter p;
          };


          struct Struct_with_POD // declared as struct

          {
            char*   pc;
          };



          class Class_with_POD // declared as class

          {

          public:              // POD declared as public, not conformed to
          M11-0-1
            int8_t   c;        
            char*   pc;
          private:
            int32_t  x;        // data member is private
          };
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, non-POD type is not
    defined as class
  name: Non-POD type should be defined as class
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A12_1_6
  compliance: R
  csv_string:
    - A12_1_6
  desc: >-
    Use inheriting constructors when derived classes do not need further
    initialization
  details: >-
    #### Abstract

    Use inheriting constructors when derived classes do not need further
    initialization


    #### Explanation

    Reimplementation of constructors which do not need further initialization
    may lead to using wrong base class constructor.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <cstdint>
          #include <iostream>

          class Base {
            
          public:
            // destructor non-virtual
            ~Base(void) { std::cout << "Base dtor called\n"; }
            explicit Base(std::int32_t x) : Base(x+1) {}
          };

          class Derived : public Base {
            
          public:

            ~Derived(void)  { std::cout<< "Derived dtor called\n"; }
            explicit Derived(std::int32_t) : Base(x-1) {}
          }; 


          int main()
          {
              Base* b = new Derived;
              delete b;
          }

          // bad example from document
          class A  
          {
              public: 
                  A(std::int32_t x, std::int32_t y) : x(x + 8), y(y) {}
                  explicit A(std::int32_t x) : A(x, 0) {}

                  private:
                      std::int32_t x;
                      std::int32_t y;
          };


          class B : public A
          {
              public:
                  B(std::int32_t x, std::int32_t y) : A(x, y) {}
                  explicit B(std::int32_t x) : A(x) {}
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <iostream>

          class Base {
            
          public:
            // destructor non-virtual
            ~Base(void) { std::cout << "Base dtor called\n"; }
          };

          class Derived : public Base {
            
          public:
              using Base::Base;
          }; 


          int main()
          {
              Base* b = new Derived;
              delete b;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, when derived classes do
    not need further initialization, it does not use inheriting constructors.
  name: >-
    Use inheriting constructors when derived classes do not need further
    initialization
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A13_5_1
  compliance: R
  csv_string:
    - A13_5_1
  desc: Operator[] should not be overloaded with only a non-const version
  details: >-
    #### Abstract

    Operator[] should not be overloaded with only a non-const version


    #### Explanation

    If non-const version of operator[] is implemented, it only allows the object
    to be modified. But it does not allow reading from const object without a
    const version overload.
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          // Both const and non-const version of operator[] are implemented
          class Test{
              public:
                  int& operator[](int n) {
                      return elements[n];
                  }
                  const int& operator[](int n) const {
                      return elements[n];
                  }
              private:
                  int* elements;
          };
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          // Only non-const version of operator[] is implemented
          class Test{
              public:
                  int& operator[](int n) {
                      return elements[n];
                  }
              private:
                  int* elements;
          };
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    In file ${so.filename}, line ${so.line}, ${so.func}, operator[] is
    overloaded with only a non-const version
  name: Operator[] should not be overloaded with only a non-const version
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
