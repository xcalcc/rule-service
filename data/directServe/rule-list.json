{
  "dataVersion": {
    "xcalscan_rule_version": "V2.04-0916",
    "copyright": "(C) 2021 Xcalibyte Inc."
  },
  "counts": 206,
  "rules": [
    {
      "master_id": 1,
      "category": "BAD_PRACTICE",
      "language": "c,c++",
      "code": "CSL",
      "name": "Call stack level exceeds limit",
      "desc": "The program has a call sequence that causes the runtime stack to exceed the call depth limit set by the user.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} has a call sequence that exceeds call level limit set from scan configuration.",
      "severity": "M",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has a call sequence that causes the runtime stack to exceed the call depth limit set by the user.\r\n\r\n#### Explanation\r\nFunction A calls another function B. Function B may in turn call another function C. This call chain can go on infinitely. In embedded systems, when the call stack is too deep, it may cause unintended side effects like running out of memory, inefficient execution time, etc.\r\n",
      "examples": {
        "good": {},
        "bad": {
          "general": [
            "// This case does not need an example.\r\n// The complete call level from function A to Z, i.e. A() ==> B() ==> .... ==> Z(), is too deep."
          ]
        }
      },
      "standards": {
        "cwe": [
          "121"
        ]
      },
      "csv_string": [
        "CSL0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 2,
      "category": "BAD_PRACTICE",
      "language": "c,c++",
      "code": "CSS",
      "name": "Call stack size exceeds limit",
      "desc": "The program has a call sequence that causes the runtime stack size to exceed the set limit.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} has a call sequence that exceeds stack size limit set at scan configuration time.",
      "severity": "M",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has a call sequence that causes the runtime stack size to exceed the set limit.\r\n\r\n#### Explanation\r\nWhen function A calls another function B, the parameters passed to the called function, and the return value from the called function to the caller function will be placed on the execution stack. Local variables will also be placed on the execution stack.\r\n",
      "examples": {
        "good": {
          "c": [
            "// Assume that stack size is 8 bytes for parameter, 4 bytes for return value (assume) 32 bit ABI\r\n// Assume we limit the size of stack to that of 32 bytes\r\n\r\nint func_callee(int *a, int i)\r\n{\r\n    return a[i];\r\n}\r\n\r\n// stack size is 0 byte (no parameter), 12 byte for local variable, 4 bytes for return value\r\nint func_caller()\r\n{\r\n    int a[3] = {0, 1}, b;\r\n    b = func_callee(a, 1);\r\n    // callee stack size if 12 bytes\r\n    return 0;\r\n}\r\n\r\n// total stack size for the call sequence func_caller -> func_callee is 28 bytes\r\n// (assume ABI specifies all parameters uses stack and not register)"
          ]
        },
        "bad": {
          "c": [
            "// Assume that stack size is 8 bytes for parameter, 4 bytes for return value (assume) 32 bit ABI\r\n// Assume we limit the size of stack to that of 16 bytes\r\nint func_callee(int *a, int i)\r\n{\r\n    return a[i];\r\n}\r\n\r\nint func_caller()\r\n{\r\n    int a = 4, b;\r\n    // a and b use total of 8 bytes, so matches runtime stack size\r\n    b = func_callee(a, 1);\r\n    // callee stack size if 12 bytes\r\n    return 0;\r\n}\r\nÃŸ"
          ],
          "general": [
            "// Assuming that stack size is 8 bytes for parameter, 4 bytes for return value (assume) 32 bit ABI\r\nint func_callee(int* a, int i)\r\n{\r\n return a[i];\r\n}\r\n\r\n// stack size is 0 byte (no parameter), 12 byte for local variable, 4 bytes for return value\r\nint func_caller() {\r\n int a[3] = {0, 1}, b;\r\n b = assign(a, 1); /* callee stack size if 12 bytes\r\n return 0;\r\n}\r\n\r\n// total stack size for the call sequence func_caller -> func_callee is 28 bytes\r\n// (assume ABI specifies all parameters uses stack and not register)"
          ]
        }
      },
      "standards": {
        "cwe": [
          "787"
        ]
      },
      "csv_string": [
        "CSS0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 3,
      "category": "VUL",
      "language": "c,c++",
      "code": "DBF",
      "name": "Resource was freed multiple times",
      "desc": "The program has freed some resources (e.g. heap memory, I/O stream object, etc.) on multiple occasions.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, resource variable ${si.var} at function ${si.func} has been released multiple times. Such variable is first released at file  ${so.filename}, line ${so.line}.",
      "severity": "H",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has freed some resources (e.g. heap memory, I/O stream object, etc.) multiple times.\r\n\r\n#### Explanation\r\nThe program has called functions such as free(), close() multiple times to release the same resource object. This could cause system inconsistencies such as corruption of the system's heap management data strutures or I/O stream subclasses. This in turn may allow malicious users to access arbitrary memory or cause an IOException.\r\n\r\n",
      "examples": {
        "good": {
          "general": [
            "int func_1(void *p) {\r\n if (p != NULL) {\r\n free(p); // free p\r\n }\r\n}\r\n\r\nint func_2(void *p) {\r\n if (p != NULL) {\r\n free(p); // free p\r\n }\r\n}\r\n\r\nint main() {\r\n int i, *p, *q;\r\n p = malloc(10 * sizeof(int));\r\n if (p == NULL)\r\n return 1;\r\n for (i=0; i < 10; ++i)\r\n p[i] = i;\r\n q = p;\r\n func_1(p); // free p the first time and only time\r\n return 0;\r\n}"
          ]
        },
        "bad": {
          "general": [
            "int func_1(void *p) {\r\n if (p != NULL) {\r\n free(p); // free p\r\n }\r\n}\r\n\r\nint func_2(void *p) {\r\n if (p != NULL) {\r\n free(p); // free p\r\n }\r\n}\r\n\r\nint main() {\r\n int i, *p, *q;\r\n p = malloc(10 * sizeof(int));\r\n if (p == NULL)\r\n return 1;\r\n for (i=0; i < 10; ++i)\r\n p[i] = i;\r\n q = p;\r\n func_1(p); // free p the first time\r\n func_2(q); // free p the second time due to value of p copied into q\r\n return 0;\r\n}"
          ]
        }
      },
      "standards": {
        "cwe": [
          "415"
        ]
      },
      "csv_string": [
        "DBF0"
      ],
      "alias": {
        "cert": [
          "MEM51-CPP"
        ]
      },
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 4,
      "category": "VUL",
      "language": "c,c++",
      "code": "FMT",
      "name": "Format string overflow",
      "desc": "The program is calling one of the printf families with a number (or type) of parameter(s) that are used differently from the format string declaration.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, the format specification in function ${si.func}, argument ${si.num} has unknown format characters in the format string declaration.",
      "severity": "H",
      "likelihood": "U",
      "cost": "L",
      "details": "#### Abstract\r\nThe program is calling one of the printf families with a number (or type) of parameter(s) used differently from format string declaration.\r\n\r\n#### Explanation\r\nIn a printf (or family with this type of system call), the format string specifier is inconsistent with the actual parameters or, that specifier has unsupported characters in the format string. When the actual parameters being passed are different, what is printed out will be unpredictable.\r\n",
      "examples": {
        "good": {
          "c": [
            "\r\nfoo(int a, int guard)\r\n{  int x = 0;\r\n  int int_result = 0;\r\n  if (guard != 0) int_result = a * x;\r\n\r\n  // number of actuals match that with format statement\r\n  printf(\"result %d is %x truncated\", int_result, int_result); \r\n  return 0;\r\n}\r\n\r\n"
          ]
        },
        "bad": {
          "c": [
            "foo(int a, int guard)\r\n{\r\n  int x = 0;\r\n  int int_result = 0;\r\n  if (guard != 0) int_result = a * x;\r\n  \r\n  // The format string specified two values to be printed,\r\n  // only one actual parameter is passed. The second output is unpredictable\r\n  printf(\"result %d is %x truncated\", int_result); \r\n  return 0;\r\n}\r\n\r\n"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A3",
          "A1",
          "A6"
        ],
        "cwe": [
          "787",
          "88",
          "119"
        ]
      },
      "csv_string": [
        "FMT2",
        "FMT1",
        "FMT0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 5,
      "category": "ROBUSTNESS",
      "language": "c,c++",
      "code": "MSF",
      "name": "Missing free",
      "desc": "The program has allocated heap memory but failed to free that piece of memory.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, variable ${si.var} in function ${si.func} has not been freed. Such variable is first assigned heap memory acquired in file ${so.filename} at line ${so.line}.",
      "severity": "H",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has allocated heap memory but failed to free that piece of memory.\r\n\r\n#### Explanation\r\nHeap memory has been allocated and the allocated memory address is stored in a variable of reference (pointer) type. That heap memory has never been released after its lifetime has effectively ended, and its corresponding reference still points to that memory space. This could result in sensitive data leakage or unexpected program behavior such as denial of service.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <stdio.h>\r\n\r\nstruct S\r\n{\r\n    int *p;\r\n};\r\n\r\nint main()\r\n{\r\n    int *p;\r\n    struct S *s;\r\n    p = malloc(10 * sizeof(int)); // heap memory allocated and pointed to by p\r\n    if (p == NULL)\r\n    {\r\n        return 1;\r\n    }\r\n    s = (struct S *)malloc(sizeof(struct S)); // heap memory allocated and pointed to by s\r\n    if (s == NULL)\r\n    {\r\n        free(p);\r\n        return 1;\r\n    }\r\n    s->p = p;\r\n    // both s and p are freed\r\n    free(s); \r\n    free(p); \r\n    return 0;\r\n}"
          ]
        },
        "bad": {
          "c": [
            "#include <stdio.h>\r\n\r\nstruct S\r\n{\r\n    int *p;\r\n};\r\n\r\nint main()\r\n{\r\n    int *p;\r\n    struct S *s;\r\n    p = malloc(10 * sizeof(int)); // heap memory allocated and pointed to by p\r\n    if (p == NULL)\r\n    {\r\n        return 1;\r\n    }\r\n    s = (struct S *)malloc(sizeof(struct S)); // heap memory allocated and pointed to by s\r\n    if (s == NULL)\r\n    {\r\n        free(p);\r\n        return 1;\r\n    }\r\n    s->p = p;\r\n    free(s); // only s is freed\r\n    // s->p, which is copied from p is not freed\r\n    return 0;\r\n}"
          ],
          "general": [
            "struct S {\r\n int *p;\r\n};\r\n\r\nint main() {\r\n int *p;\r\n struct S *s;\r\n p = malloc(10 * sizeof(int)); // heap memory allocated and pointed to by p\r\n if (p == NULL)\r\n return 1;\r\n s = (struct S*)malloc(sizeof(struct S)); // heap memory allocated and pointed to by s\r\n if (s == NULL) {\r\n free(p);\r\n return 1;\r\n }\r\n s->p = p;\r\n free(s); // only s is freed\r\n // s->p, which is copied from p is not freed\r\n return 0;\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A3"
        ]
      },
      "csv_string": [
        "MSF2",
        "MSF1",
        "MSF0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 6,
      "category": "VUL",
      "language": "c,c++",
      "code": "RAL",
      "name": "Return address of local",
      "desc": "The function returns the address of a stack variable and will cause unintended program behavior.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, address of the local variable ${si.var} has been returned to the caller.",
      "severity": "H",
      "likelihood": "L",
      "cost": "L",
      "details": "#### Abstract\r\nThe function returns the address of a stack variable and will cause unintended program behavior.\r\n\r\n#### Explanation\r\nBecause local variables are allocated to the stack, when a function returns to the caller, the callee's stack address is no longer valid. A subsequent function call is likely to re-use this same stack address, thereby overwriting the previous value.\r\n",
      "examples": {
        "good": {
          "c": [
            "int foo()\r\n{\r\n    int *c;\r\n    return *c; // item *c is pointing to returned\r\n}"
          ]
        },
        "bad": {
          "c": [
            "int foo()\r\n{\r\n    int *c;\r\n    return &c; //return a local address to caller\r\n}"
          ],
          "general": [
            "int foo()\r\n{\r\n int *c;\r\n return &c; //return a local address to caller\r\n}"
          ]
        }
      },
      "standards": {
        "autosar": [
          "M7-5-1"
        ]
      },
      "csv_string": [
        "RAL1",
        "RAL0"
      ],
      "alias": {
        "cert": [
          "EXP54-CPP",
          "DCL30-C"
        ]
      },
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 7,
      "category": "VUL",
      "language": "c,c++",
      "code": "RXS",
      "name": "Read from external socket",
      "desc": "The program has read from external sockets which may include untrusted data.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} is receiving untrusted data from external socket. The socket has been created in file ${si.filename} at line ${si.line}.",
      "severity": "M",
      "likelihood": "L",
      "cost": "L",
      "details": "#### Abstract\r\nThe program has read from external sockets which may include untrusted data.\r\n\r\n#### Explanation\r\nThe external interface allows the program to interact with the external world, so it is very important to ensure that the external interface does not receive security sensitive or untrusted input.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <sys/socket.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\n#define BUF_SZ 256\r\n\r\nint foo(void)\r\n{\r\n    int n;\r\n    char buffer[BUF_SZ];\r\n    char *cp = buffer; \r\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\r\n\r\n    if (sockfd < 0)\r\n    {\r\n        perror(\"ERROR opening socket\");\r\n        exit(1);\r\n    }\r\n\r\n    // filter out untrusted data and characters\r\n    static char approved[] = \"abcdefghijklmnopqrstuvwxyz\"\r\n                             \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\r\n                             \"1234567890_-.@\";\r\n    const char *end = buffer + strlen(buffer);\r\n    for (cp += strspn(cp, approved); cp != end; cp += strspn(cp, approved))\r\n    {\r\n        *cp = '_';\r\n    }\r\n\r\n    n = read(sockfd, buffer, 255);\r\n\r\n    // use buffer\r\n    // if buffer is used as argument to system() or to setenv()\r\n    // the buffer may contain untrusted commands or characters leading to unpredictable program behavior\r\n    // ...\r\n}"
          ]
        },
        "bad": {
          "c": [
            "#include <sys/socket.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\n#define BUF_SZ 256\r\n\r\nint foo(void)\r\n{\r\n    int n;\r\n    char buffer[BUF_SZ];\r\n    int sockfd = socket(AF_INET, SOCK_STREAM, 0);\r\n\r\n    if (sockfd < 0)\r\n    {\r\n        perror(\"ERROR opening socket\");\r\n        exit(1);\r\n    }\r\n\r\n    n = read(sockfd, buffer, 255);\r\n\r\n    // use buffer\r\n    // if buffer is used as argument to system() or to setenv()\r\n    // the buffer may contain untrusted commands or characters leading to unpredictable program behavior\r\n    // ...\r\n}"
          ],
          "general": [
            "#include <sys/socket.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\n#define BUF_SZ 256\r\n\r\nint foo(void)\r\n{\r\n int n;\r\n char buffer[BUF_SZ];\r\n sockfd = socket(AF_INET, SOCK_STREAM, 0);\r\n\r\n if (sockfd < 0) {\r\n perror(\\\"ERROR opening socket\\\");\r\n exit(1);\r\n }\r\n\r\n n = read(sockfd,buffer,255);\r\n\r\n // use buffer\r\n // if buffer is used as argument to system() or to setenv()\r\n // the buffer may contain untrusted commands or characters leading to unpredictable program behavior\r\n // ...\r\n}\r\n"
          ]
        }
      },
      "standards": {
        "cwe": [
          "577"
        ]
      },
      "csv_string": [
        "RXS0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 8,
      "category": "VUL",
      "language": "c,c++",
      "code": "UAF",
      "name": "Use after free",
      "desc": "The program has referenced memory after it has been freed. It can cause the program to crash or lead to an unexpected program behavior.",
      "msg_templ": "In file ${so.filename}, line ${so.line}, variable ${so.var} in function ${so.func} was used. However, it has been freed at line ${so.line} in file ${so.filename}.",
      "severity": "H",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has referenced memory after it has been freed. It can cause the program to crash or an unexpected program behavior.\r\n\r\n#### Explanation\r\nUse after free is a variation of dangling pointer reference. It typically occurs when the pointer is not updated after the memory object it points to has been freed. This pointer will be pointing to inappropriate memory leading to unauthorized access when the pointer is used.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <stdio.h>\r\n\r\nint g = 2;\r\n\r\nvoid my_free(void *p)\r\n{\r\n    if (p != NULL) \r\n    {\r\n        free(p); // free p\r\n    }\r\n        \r\n}\r\n\r\nint main()\r\n{\r\n    int i, j, *p, *q;\r\n    p = malloc(10 * sizeof(int));\r\n    if (p == NULL)\r\n    {\r\n        return 1;\r\n    }\r\n    for (i = 0; i < 10; ++i) \r\n    {\r\n        p[i] = i;\r\n    }    \r\n    q = p;\r\n    my_free(p); // p is freed\r\n    j = 0;\r\n\r\n    // checks if q is illegal before running the for loop\r\n    if (q == 0 || q == NULL)\r\n    {\r\n        exit(1);\r\n    }\r\n    \r\n    for (i = 0; i < 10; ++i)\r\n    {\r\n        // Use after free here (note the statement q = p), read of q[i] is illegal\r\n        j += q[i]; \r\n    }\r\n        \r\n    return j;\r\n}"
          ]
        },
        "bad": {
          "c": [
            "#include <stdio.h>\r\n\r\nint g = 2;\r\n\r\nvoid my_free(void *p)\r\n{\r\n    if (p != NULL) \r\n    {\r\n        free(p); // free p\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int i, j, *p, *q;\r\n    p = malloc(10 * sizeof(int));\r\n    if (p == NULL)\r\n    {\r\n        return 1;\r\n    }\r\n    for (i = 0; i < 10; ++i) \r\n    {\r\n        p[i] = i;\r\n    }\r\n    q = p;\r\n    my_free(p); // p is freed\r\n    j = 0;\r\n    for (i = 0; i < 10; ++i)\r\n    {\r\n        j += q[i]; // Use after free here (note the statement q = p), read of q[i] is illegal\r\n    }\r\n    return j;\r\n}"
          ],
          "general": [
            "#include <stdio.h>\r\n\r\nint g = 2;\r\n\r\nvoid my_free(void *p) {\r\n if (p != NULL)\r\n free(p); // free p\r\n}\r\n\r\nint main() {\r\n int i, j, *p, *q;\r\n p = malloc(10 * sizeof(int));\r\n if (p == NULL)\r\n return 1;\r\n for (i=0; i < 10; ++i)\r\n p[i] = i;\r\n q = p;\r\n my_free(p); // p is freed\r\n j = 0;\r\n for (i=0; i < 10; ++i)\r\n j += q[i]; // Use after free here (note the statement q = p), read of q[i] is illegal\r\n return j;\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A1",
          "A3"
        ],
        "cwe": [
          "416",
          "672"
        ]
      },
      "csv_string": [
        "UAF3",
        "UAF2",
        "UAF1",
        "UAF0"
      ],
      "alias": {
        "cert": [
          "MEM50-CPP",
          "MEM01-C",
          "MEM30-C",
          "MEM00-C"
        ]
      },
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 9,
      "category": "VUL",
      "language": "c,c++",
      "code": "UDR",
      "name": "Use dangling reference",
      "desc": "Dangling pointer has been used to refer to an invalid memory resource.",
      "msg_templ": "In file ${so.filename}, line ${so.line}, the memory reference variable ${so.var} in function ${so.func} is used. Such variable is first assigned as a memory reference that may not be valid in file ${so.filename}, line ${so.line}.",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "details": "#### Abstract\r\nDangling pointer has been used to refer to an invalid memory resource.\r\n\r\n#### Explanation\r\nDangling pointers are pointers that refer to invalid or inappropriate memory resources. Referencing these memory resources may create memory corruption, resulting in unpredictable program behavior or system instablity.\r\n",
      "examples": {
        "good": {
          "c": [
            "void assign(int *c)\r\n{\r\n    *c = 1;\r\n    return;\r\n}\r\n\r\nint foo()\r\n{\r\n    int a;\r\n    assign(&a); \r\n    printf(\"assigned value: %d\", a); // pointer is not dangling\r\n    return 0;\r\n}\r\n\r\n"
          ]
        },
        "bad": {
          "c": [
            "int *assign()\r\n{\r\n    int *c;\r\n    c = 1;\r\n    return &c;\r\n}\r\n\r\nint foo()\r\n{\r\n    int *a;\r\n    a = assign(); // return a stack address and assign to a\r\n    printf(\"assigned value: %d\", a); // use dangling pointer\r\n    return 0;\r\n}"
          ],
          "general": [
            "int *assign()\r\n{\r\n int *c;\r\n c = 1;\r\n return &c;\r\n}\r\n\r\nint foo()\r\n{\r\n int *a;\r\n a = assign(); // return a stack address and assign to a\r\n printf(\\\"assigned value: %d\\\", a); // use dangling pointer\r\n return 0;\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A1",
          "A2",
          "A3"
        ],
        "cwe": [
          "590"
        ]
      },
      "csv_string": [
        "UDR5",
        "UDR4",
        "UDR3",
        "UDR2",
        "UDR1",
        "UDR0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 10,
      "category": "VUL",
      "language": "c,c++",
      "code": "WRF",
      "name": "Write to file for read only",
      "desc": "The program is performing write operations to a file that is available for read only.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} is performing write operations to a read-only file .",
      "severity": "H",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program is performing a write operation to a file that is available for read only\r\n\r\n#### Explanation\r\nWhen the file that is opened for read and later then written upon, the fwrite will report an error. If the result of fwrite is not checked, the program will continue and the file may not be updated as expected.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <stdio.h>\r\n#include <unistd.h>\r\n#include <sys/stat.h>\r\n#include <fcntl.h>\r\n\r\nint file_operation()\r\n{\r\n    struct stat statBefore, statAfter;\r\n\r\n    lstat(\"/tmp/x\", &statBefore);\r\n\r\n    // file open for read\r\n    FILE *fp_open_readonly = fopen(\"/tmp/x\", \"w\");\r\n    lstat(\"/tmp/x\", &statAfter);\r\n\r\n    if (statAfter.st_ino == statBefore.st_ino)\r\n    {\r\n        if (fp_open_readonly != NULL)\r\n        {\r\n            // writing to the file\r\n            fwrite(\"HELLO!\", 1, 5, fp_open_readonly);\r\n        }\r\n    }\r\n\r\n    fclose(fp_open_readonly);\r\n    return 0;\r\n}"
          ]
        },
        "bad": {
          "c": [
            "#include <stdio.h>\r\n#include <unistd.h>\r\n#include <sys/stat.h>\r\n#include <fcntl.h>\r\n\r\nint file_operation()\r\n{\r\n    struct stat statBefore, statAfter;\r\n\r\n    lstat(\"/tmp/x\", &statBefore);\r\n\r\n    // file open for read\r\n    FILE *fp_open_readonly = fopen(\"/tmp/x\", \"r\");\r\n    lstat(\"/tmp/x\", &statAfter);\r\n\r\n    if (statAfter.st_ino == statBefore.st_ino)\r\n    {\r\n        if (fp_open_readonly != NULL)\r\n        {\r\n            // writing to the file\r\n            fwrite(\"HELLO!\", 1, 5, fp_open_readonly);\r\n        }\r\n    }\r\n\r\n    fclose(fp_open_readonly);\r\n    return 0;\r\n}"
          ],
          "general": [
            "int file_operation(two_level *p, two_level *q)\r\n{\r\n struct stat statBefore, statAfter;\r\n\r\n lstat(\\\"/tmp/x\\\", &statBefore);\r\n\r\n // file open for read\r\n FILE *fp_open_readonly = fopen(\\\"/tmp/x\\\", \\\"r\\\");\r\n lstat(\\\"/tmp/x\\\", &statAfter);\r\n\r\n if (statAfter.st_ino == statBefore.st_ino) {\r\n if (fp_open_readonly != NULL) {\r\n // writing to the file\r\n fwrite(\\\"HELLO!\\\", 1, 5, fp_open_readonly);\r\n }\r\n }\r\n\r\n fclose(fp_open_readonly);\r\n return 0;\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A5"
        ],
        "cwe": [
          "275"
        ]
      },
      "csv_string": [
        "WRF0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 11,
      "category": "VUL",
      "language": "c,c++,java",
      "code": "AOB",
      "name": "Array out of bounds",
      "desc": "The program is accessing data outside the declared boundary (before or after) of the intended buffer.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, an array out of bound has been detected for variable ${si.var} in function ${si.func}.",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "details": "#### Abstract\r\nThe program is accessing data outside (i.e. before or after) the declared boundary of the intended buffer.\r\n\r\n#### Explanation\r\nTypically, this can allow attackers to cause a crash during program execution. A crash can occur when the code reads sensitive information from other memory locations or causable amount of data and assumes that a sentinel exists to stop the read operation, such as a NUL in a string. The expected sentinel might not be located in the out-of-bounds memory, causing excessive data to be read, leading to a segmentation fault or a buffer overflow. The software may modify an index or perform pointer arithmetic that references a memory location that is outside of the boundaries of the buffer. A subsequent read operation then produces undefined or unexpected results.\r\n",
      "examples": {
        "good": {
          "general": [
            "int assign(int* a, int i)\r\n{\r\n return a[i]; /* called by main\r\n a only has 2 elements but i is 2 */\r\n}\r\n\r\n#define ARR_SZ 2\r\nint main() {\r\n int a[ARR_SZ] = {0, 1}, b;\r\n if ()\r\n b = assign(a, (ARR_SZ-1)); // call assign with a and i\r\n // a has two elements and i is 2\r\n // a[2] is out-of-bound and also uninitialized\r\n printf(\"value of b = %d\\\\\", b);\r\n return 0;\r\n}"
          ]
        },
        "bad": {
          "general": [
            "int assign(int* a, int i)\r\n{\r\n return a[i]; /* called by main\r\n a only has 2 elements but i is 2 */\r\n}\r\n\r\nint main() {\r\n int a[2] = {0, 1}, b;\r\n b = assign(a, 2); // call assign with a and i\r\n // a has two elements and i is 2\r\n // a[2] is out-of-bound and also uninitialized\r\n printf(\"value of b = %d\\\\\", b);\r\n return 0;\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A1",
          "A2",
          "A3",
          "A5"
        ],
        "cwe": [
          "787",
          "125",
          "121",
          "122",
          "126"
        ]
      },
      "csv_string": [
        "AOB4",
        "AOB3",
        "AOB2",
        "AOB1",
        "AOB0"
      ],
      "alias": {
        "cert": [
          "ARR38-C",
          "ARR30-C"
        ]
      },
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 12,
      "category": "BAD_PRACTICE",
      "language": "c,c++,java",
      "code": "CRF",
      "name": "Use recursive function",
      "desc": "The program has a call sequence that results in recursion at runtime.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} is calling itself.",
      "severity": "M",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has a call sequence that results in recursion at runtime\r\n\r\n#### Explanation\r\nRecursion happens when a function (e.g. A) calls another function in such a way that the call sequence eventually calls A again. In its most simple form, a function simply calls itself during the execution. If not programmed correctly, this could lead to an infinite loop. It can also cause an excessive use of stack space and may lead to running out of memory or stack space problems.\r\n",
      "examples": {
        "good": {
          "c": [
            "// suppose first call to func_recurse is (p_glbl, 6)\r\n\r\nconst int MAXIMUM_LIMIT = 100;\r\nint global = 5;\r\nstatic *p_glbl = &global;\r\nint func_recurse(int *p, int i)\r\n{\r\n    if (i > MAXIMUM_LIMIT) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\t\r\n\t\tif (i != 0) {\r\n        // recursion bottoms out when second argument tends to 0\r\n        return func_recurse(p_glbl, i - 1);                                           \r\n    }\r\n    return 0;\r\n}"
          ]
        },
        "bad": {
          "c": [
            "// Most simple forms of recursion.\r\n// if first call to func_recurse is: func_recurse(p_glbl, 6)\r\n// this code segment will recurse and get into an infinite loop\r\n\r\nint global = 5;\r\nstatic *p_glbl = &global;\r\nint func_recurse(int *p, int i)\r\n{\r\n    if ((p != 0) && (*p != i))\r\n    {\r\n        return func_recurse(p, 2); // calls itself directly\r\n    }\r\n    return 0;\r\n}"
          ],
          "general": [
            "// Most simple forms of recursion.\r\n// if first call to func_recurse is: func_recurse(p_glbl, 6)\r\n// this code segment will recurse and get into an infinite loop\r\n\r\nint global = 5;\r\nstatic *p_glbl = &global;\r\nint func_recurse(int* p, int i)\r\n{\r\n if ((p != 0) && (*p != i))\r\n return func_recurse(p, 2); // calls itself directly\r\n return 0;\r\n}",
            "// Indirect recursion.\r\n// if first call to func_recurse is: func_recurse(p_glbl, 6)\r\n// this code segment will call func_recurse inside func_b\r\n\r\nint global = 5;\r\nstatic *p_glbl = &global;\r\n\r\nint func_b(int *q, int j)\r\n{\r\n if (q != 0) {\r\n return func_recurse(q, 5);\r\n }\r\n else\r\n return 5;\r\n}\r\n\r\nint func_recurse(int *p, int i)\r\n{\r\n if ((p != 0) && (*p != i))\r\n return func_b(p, i); // calls func_recurse indirectly\r\n return 0;\r\n}"
          ]
        }
      },
      "standards": {
        "cwe": [
          "674"
        ]
      },
      "csv_string": [
        "CRF0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 13,
      "category": "CORRECTNESS",
      "language": "c,c++,java",
      "code": "DBZ",
      "name": "Division by zero",
      "desc": "The program is trying to divide a value by zero.",
      "msg_templ": "In file ${so.filename}, line ${so.line}, variable ${so.var} in function ${so.func}, a division by zero has been detected. Such variable has a value of zero.",
      "severity": "L",
      "likelihood": "P",
      "cost": "H",
      "details": "#### Abstract\r\nThe program is trying to divide a value by zero.\r\n\r\n#### Explanation\r\nThis can occur when an unexpected constant zero is assigned to the divisor, or if an error occurs that is not properly detected (for example, return value of a function call).\r\n\r\n",
      "examples": {
        "good": {
          "c": [
            "int divide(int num, int denom) {\r\n\r\n    // checks if denom is 0, and always throws an\r\n    // error when trying to divide by 0\r\n    if (denom == 0) \r\n    {\r\n        printf(\"Cannot divide a number by 0\");\r\n        exit(133);\r\n    }\r\n\r\n    return num/denom;\r\n}"
          ]
        },
        "bad": {
          "c": [
            "int divide(int num, int denom)\r\n{\r\n    // denom could be of value 0, and dividing \r\n    // by 0 results in undefined behavior\r\n    return num / denom;\r\n}\r\n\r\n"
          ],
          "general": [
            "int foo(int a, int guard)\r\n{\r\n int x = 0;\r\n int result = 0;\r\n if (guard != 0)\r\n result = a / x; // did not check for zero\r\n printf(\\\"result is %d\\\", result);\r\n return 0;\r\n}"
          ]
        }
      },
      "standards": {
        "cwe": [
          "369"
        ]
      },
      "csv_string": [
        "DBZ2",
        "DBZ1",
        "DBZ0"
      ],
      "alias": {
        "cert": [
          "FLP03-C",
          "INT33-C",
          "NUM02-J"
        ]
      },
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 14,
      "category": "BAD_PRACTICE",
      "language": "c,c++,java",
      "code": "DDC",
      "name": "Unreachable code after jump",
      "desc": "Unreachable code after a jump statement.",
      "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line} is unreachable during execution.",
      "severity": "L",
      "likelihood": "U",
      "cost": "M",
      "details": "#### Abstract\r\nUnreachable code after a jump statement.\r\n\r\n#### Explanation\r\nExecution will never reach statements that come immediately after a jump statement or function calls that do not return. This could be due to unintended edits and is a code quality issue.\r\n",
      "examples": {
        "good": {
          "c": [
            "void abort();\r\nvoid exit();\r\nint foo();\r\n\r\nint f1()\r\n{\r\n    foo(); // reachable\r\n}\r\nint f2()\r\n{\r\n    foo(); // reachable\r\n}\r\n\r\nint f3()\r\n{\r\n    foo();\r\n    goto L;\r\n    L:\r\n        foo();  // reachable\r\n}\r\n"
          ]
        },
        "bad": {
          "c": [
            "void abort();\r\nvoid exit();\r\nint foo();\r\n\r\nint f1()\r\n{\r\n    abort();\r\n    foo(); // unreachable\r\n}\r\nint f2()\r\n{\r\n    exit();\r\n    foo(); // unreachable\r\n}\r\n\r\nint f3()\r\n{\r\n    foo();\r\n    goto L;\r\n    foo(); // unreachable\r\nL:\r\n    foo();\r\n}\r\n\r\nint f4(int x)\r\n{\r\n    foo();\r\n    goto L;\r\n    if (x > 5)\r\n    { // unreachable\r\n    L:\r\n        foo();\r\n    }\r\n}\r\n"
          ],
          "general": [
            "void abort();\r\nvoid exit();\r\nint foo();\r\n\r\nint f1() {\r\n abort();\r\n foo(); // unreachable\r\n}\r\nint f2() {\r\n exit();\r\n foo(); // unreachable\r\n}\r\n\r\nint f3() {\r\n foo();\r\n goto L;\r\n foo(); // unreachable\r\nL:\r\n foo();\r\n}\r\n\r\nint f4(int x) {\r\n foo();\r\n goto L;\r\n if (x>5) { // unreachable\r\nL:\r\n foo();\r\n }\r\n}\r\n"
          ]
        }
      },
      "csv_string": [
        "DDC1",
        "DDC0"
      ],
      "standards": {},
      "alias": {
        "cert": [
          "MSC07-C",
          "MSC12-C"
        ]
      },
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 15,
      "category": "PFM",
      "language": "c,c++,java",
      "code": "DDV",
      "name": "Dead variable",
      "desc": "Execution of this statement will be nullified by another statement following it, or the result of this statement is never used.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, variable ${si.var} in function ${si.func}, a dead assignment has been detected.",
      "severity": "L",
      "likelihood": "U",
      "cost": "M",
      "details": "#### Abstract\r\nExecution of this statement will be nullified by another statement following it, or the result of this statement is never used.\r\n\r\n#### Explanation\r\nSuch error usually indicates either a typo or that some type of statement has been removed through time.\r\n",
      "examples": {
        "good": {
          "c": [
            "void assign(int input)\r\n{\r\n    int a = input; // a is only used once and does not get nullified\r\n    printf(\"a value: %d\", a);\r\n}"
          ]
        },
        "bad": {
          "c": [
            "void assign(int input)\r\n{\r\n    int a = 0; // dead code\r\n    a = input; // result of \\\"a = 0\\\" will be nullified by this statement\r\n    printf(\"a value: %d\", a);\r\n}"
          ],
          "general": [
            "void assign(int input)\r\n{\r\n int a = 0; // dead code\r\n a = input; // result of \\\"a = 0\\\" will be nullified by this statement\r\n printf(\\\"a value: %d\\\", a);\r\n}"
          ]
        }
      },
      "csv_string": [
        "DDV0"
      ],
      "standards": {},
      "alias": {
        "cert": [
          "MSC12-C"
        ]
      },
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 16,
      "category": "VUL",
      "language": "c,c++,java",
      "code": "FAM",
      "name": "Formal and actual parameter mismatch",
      "desc": "The program is calling a function with a number of parameter(s) that are used differently from the prototype declaration.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, the arguments in function ${si.func} do not match the function declaration in file ${si.filename}, line ${si.line}.",
      "severity": "H",
      "likelihood": "P",
      "cost": "H",
      "details": "#### Abstract\r\nThe program is calling a function with number of parameter(s) that are used different from that of the prototype declaration.\r\n\r\n#### Explanation\r\nIn a call site, the number of actual parameters passed is different from that of the function declaration. If the actuals passed is less than that of the declaration, the missing actual will ended up being \\\"wild\\\" and could cause unpreditable behavior.\r\n",
      "examples": {
        "good": {
          "c": [
            "int foo(int a, int guard)\r\n{\r\n    int x = 0;\r\n    int result = 0;\r\n    if (guard != 0)\r\n    {\r\n        result = a * x;\r\n    }\r\n    foo(result, guard); // no parameters missing\r\n    return 0;\r\n}"
          ]
        },
        "bad": {
          "c": [
            "int foo(int a, int guard)\r\n{\r\n    int x = 0;\r\n    int result = 0;\r\n    if (guard != 0) \r\n    {\r\n        result = a * x;\r\n    } \r\n    foo(result); // missing one parameter, and \\\"guard\\\" will have random value during execution at this point\r\n    return 0;\r\n}"
          ],
          "general": [
            "int foo(int a, int guard)\r\n{\r\n int x = 0;\r\n int result = 0;\r\n if (guard != 0)\r\n result = a * x;\r\n foo(result); // missing one parameter, and \\\"guard\\\" will have random value during execution at this point\r\n return 0;\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A3",
          "A6"
        ]
      },
      "csv_string": [
        "FAM2",
        "FAM1",
        "FAM0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 17,
      "category": "ROBUSTNESS",
      "language": "c,c++,java",
      "code": "NPD",
      "name": "Null pointer dereference",
      "desc": "The program is accessing memory through a pointer with NULL value. This could cause a segmentation fault or unpredictable program behavior.",
      "msg_templ": "In file ${so.filename}, line ${so.line}, an NPD defect has been detected in function ${so.func} for variable ${so.var}. Such variable has a value of zero.",
      "severity": "H",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program is accessing memory through a pointer with a NULL value. This will cause a segmentation fault or unpredictable program behavior. This vulnerability is equivalent to EXP34-C\r\n\r\n#### Explanation\r\nOn a system with memory protection, such as Linux, dereferencing a null pointer will cause a segmentation fault. For embedded systems, it will cause unpredicted program behavior. In Java, a null pointer dereference will trigger a null pointer exception.\r\n",
      "examples": {
        "good": {
          "c": [
            "extern int bar(int);\r\n\r\nint assign(int* a)\r\n{\r\n int i;\r\n if (a != 0)\r\n i = bar(*a); // dereference a\r\n else {\r\n // handle error and exit gracefully (such exit program)\r\n exit(1);\r\n }\r\n return i;\r\n}\r\n\r\nint foo(void)\r\n{\r\n int *p = 0; // p as a pointer has been initialized to 0 (null)\r\n assign(p);\r\n}"
          ],
          "java": [
            "class User {\r\n public String getName() {\r\n return null;\r\n }\r\n}\r\n\r\nclass Bar {\r\n private User findUser(String uid) {\r\n if (user.containsKey(uid)) {\r\n return user.get(uid);\r\n }\r\n else\r\n return null;\r\n }\r\n public void Npd(String uid) {\r\n // program continues\r\n // ...\r\n User user = findUser(uid); \r\n if (user == null) {\r\n throw new RuntimeException(\\\"Null String\\\");\r\n }\r\n String getName() {\r\n return null;\r\n }\r\n }\r\n}"
          ]
        },
        "bad": {
          "c": [
            "extern int bar(int);\r\n\r\nint assign(int* a)\r\n{\r\n int i = bar(*a) // dereference a\r\n return i;\r\n}\r\n\r\nint foo(void)\r\n{\r\n int *p = 0; // p as a pointer has been initialized to 0 (null)\r\n assign(p);\r\n}"
          ],
          "java": [
            "class User {\r\n public String getName() {\r\n return null;\r\n }\r\n}\r\n\r\nclass Bar {\r\n private User findUser(String uid) {\r\n if (user.containsKey(uid)) {\r\n return user.get(uid);\r\n }\r\n else\r\n return null;\r\n }\r\n public void Npd(String uid) {\r\n // program continues\r\n // ...\r\n User user = findUser(uid); // Throws NPE if \\\"user\\\" has not been properly initialized\r\n String getName() {\r\n return null;\r\n }\r\n }\r\n}"
          ]
        }
      },
      "standards": {
        "cwe": [
          "476"
        ]
      },
      "csv_string": [
        "NPD0"
      ],
      "alias": {
        "cert": [
          "EXP34-C"
        ]
      },
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 18,
      "category": "BAD_PRACTICE",
      "language": "c,c++,java",
      "code": "RCD",
      "name": "Redundant control dependency",
      "desc": "Redundant statements that are control dependent.",
      "msg_templ": "In file ${si.filename}, function ${si.func}, the statement at line ${si.line} is redundant.",
      "severity": "L",
      "likelihood": "U",
      "cost": "M",
      "details": "#### Abstract\r\nRedundant statements that are control dependent.\r\n\r\n#### Explanation\r\nWhen there are two conditional statements that are dependent in execution flow, then one conditional can logically subsume the other conditional statement. In that case, the other conditional is redundant and unnecessary. This could be due to an editing error and is a code quality issue.\r\n",
      "examples": {
        "good": {
          "c": [
            "int foo();\r\nint bar();\r\n\r\nint f1(int x)\r\n{\r\n    if (x > 16) // removed x>15 since unnecessary\r\n        foo();\r\n}\r\n\r\nint f2(int x)\r\n{\r\n    if (x > 16) // removed x>15 since unnecessary\r\n        foo();\r\n}\r\n\r\nint f3(int x)\r\n{\r\n    if (x > 16)\r\n    {\r\n        foo();\r\n        bar(); // bar will always run anyways so no need an if statement\r\n    }\r\n}\r\n\r\nint f4(int x)\r\n{\r\n    if (x > 15)\r\n    {\r\n        foo();\r\n        if (x > 16) \r\n        {\r\n            bar();\r\n        }\r\n    }\r\n}"
          ]
        },
        "bad": {
          "c": [
            "int foo();\r\nint bar();\r\n\r\nint f1(int x)\r\n{\r\n    if (x > 15 && x > 16) // x>16 will subsume x>15\r\n        foo();\r\n}\r\n\r\nint f2(int x)\r\n{\r\n    if (x > 16 && x > 15) // x>16 implies x>15, hence x>15 is redundant\r\n        foo();\r\n}\r\n\r\nint f3(int x)\r\n{\r\n    if (x > 16)\r\n    {\r\n        foo();\r\n        if (x > 15) // x>16 implies x>15, hence this check is unnecessary\r\n            bar();\r\n    }\r\n}\r\n\r\nint f4(int x)\r\n{\r\n    if (x > 15)\r\n    {\r\n        foo();\r\n        if (x > 16) // x>15 does not imply x>16, this check is not redundant\r\n            bar();\r\n    }\r\n}"
          ],
          "general": [
            "int foo();\r\nint bar();\r\n\r\nint f1(int x) {\r\n if (x>15 && x>16) // x>16 will subsume x>15\r\n foo();\r\n}\r\n\r\nint f2(int x) {\r\n if (x>16 && x>15) // x>16 implies x>15, hence x>15 is redundant\r\n foo();\r\n}\r\n\r\nint f3(int x) {\r\n if (x>16) {\r\n foo();\r\n if (x>15) // x>16 implies x>15, hence this check is unnecessary\r\n bar();\r\n }\r\n}\r\n\r\nint f4(int x) {\r\n if (x>15) {\r\n foo();\r\n if (x>16) // x>15 does not imply x>16, this check is not redundant\r\n bar();\r\n }\r\n}"
          ]
        }
      },
      "csv_string": [
        "RCD0"
      ],
      "standards": {},
      "alias": {
        "cert": [
          "MSC12-C"
        ]
      },
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 19,
      "category": "BAD_PRACTICE",
      "language": "c,c++,java",
      "code": "SCB",
      "name": "Same code block",
      "desc": "Same code blocks inside a conditional statement.",
      "msg_templ": "In file ${si.filename}, function ${si.func}, the blocks of code are the same on either side of the conditional statement at line ${si.line}.",
      "severity": "L",
      "likelihood": "U",
      "cost": "M",
      "details": "#### Abstract\r\nSame code block inside conditional statements.\r\n\r\n#### Explanation\r\nTwo code blocks are the same inside a conditional statement. This is likely due to an editing error. It is a code quality issue.\r\n",
      "examples": {
        "good": {
          "c": [
            "int foo();\r\nint a, b;\r\n\r\nint f1(int x)\r\n{\r\n    foo(); // no dead code\r\n}\r\n\r\nint f2(int x)\r\n{\r\n    return foo();\r\n}\r\n"
          ]
        },
        "bad": {
          "c": [
            "int foo();\r\nint a, b;\r\n\r\nint f1(int x)\r\n{\r\n    if (a) \r\n    {\r\n        foo();\r\n    } \r\n    else \r\n    {\r\n        foo();\r\n    }\r\n}\r\n\r\nint f2(int x)\r\n{\r\n    return x ? foo() : foo();  // equivalent to above\r\n}\r\n"
          ],
          "general": [
            "int foo();\r\nint a, b;\r\n\r\nint f1(int x) {\r\n if (x) // in this condition (if-then-else, block 1 and block 2 are the same. Effectively making the conditional statement useless)\r\n foo(); // block 1\r\n else\r\n foo(); // block 2\r\n}\r\n\r\nint f2(int x) {\r\n return x ? foo() : foo(); // similar code written differently\r\n}\r\n"
          ]
        }
      },
      "standards": {
        "cwe": [
          "223"
        ]
      },
      "csv_string": [
        "SCB0"
      ],
      "alias": {
        "cert": [
          "MSC12-C"
        ]
      },
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 20,
      "category": "BAD_PRACTICE",
      "language": "c,c++,java",
      "code": "SSE",
      "name": "Same sub-expression",
      "desc": "The program has the same sub-expressions.",
      "msg_templ": "In file ${si.filename}, function ${si.func}, line ${si.line} has sub-expressions that are conditionally the same.",
      "severity": "L",
      "likelihood": "U",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has the same sub-expressions. \r\n\r\n#### Explanation\r\nThe same expressions are found in a statement, where the value of variables in the expression has not changed in value. It could be due to a typo in the program. This is a code quality issue.\r\n",
      "examples": {
        "good": {
          "c": [
            "int foo();\r\nint a, b;\r\n\r\nint f3(int x, int *p)\r\n{\r\n    if (*p && *p) // same sub-expression\r\n        foo();\r\n}\r\n\r\nint f4(int x, int y)\r\n{\r\n    if ((x + y++) && (y + x)) // not same sub-expression due to y++\r\n        foo();\r\n}"
          ]
        },
        "bad": {
          "c": [
            "int foo();\r\nint a, b;\r\n\r\nint f3(int x, int *p)\r\n{\r\n    if (*p && x) // both expressions are not the same \r\n    {\r\n        foo();\r\n    }  \r\n}\r\n\r\nint f4(int x, int y)\r\n{\r\n    if ((x + y++) && (y + x)) \r\n    {\r\n        foo();\r\n    }\r\n        \r\n}"
          ],
          "general": [
            "int foo();\r\nint a, b;\r\n\r\n\r\nint f3(int x, int *p) {\r\n if (*p && *p) // same sub-expression\r\n foo();\r\n}\r\n\r\nint f4(int x, int y) {\r\n if ((x+y++) && (y+x)) // not same sub-expression due to y++\r\n foo();\r\n}"
          ]
        }
      },
      "csv_string": [
        "SSE0"
      ],
      "standards": {},
      "alias": {
        "cert": [
          "MSC07-C"
        ]
      },
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 21,
      "category": "BAD_PRACTICE",
      "language": "c,c++,java",
      "code": "UIC",
      "name": "Uninitialized field in constructor",
      "desc": "A field of a class is not initialized in its constructor.",
      "msg_templ": "In file ${si.filename}, constructor ${si.func} at line ${si.line} has a field ${si.var} that is not initialized.",
      "severity": "L",
      "likelihood": "L",
      "cost": "L",
      "details": "#### Abstract\r\nA field of a class is not initialized in its constructor.\r\n\r\n#### Explanation\r\nConstructor of a class typically includes initialization of fields inside the class. When a field is not initialized, it is likely due to an editing error and is a code quality issue.\r\n",
      "examples": {
        "good": {
          "cpp": [
            "#include <stdio.h>\r\n\r\nclass Construct_Init\r\n{\r\nprivate:\r\n    int a;\r\n    int b;\r\n\r\npublic:\r\n    // all variables in all constructors are\r\n    // initialized\r\n    Construct_Init()\r\n    {\r\n        a = 0;\r\n        b = 0;\r\n    };\r\n    Construct_Init(int i)\r\n    {\r\n        a = i;\r\n        b = 0;\r\n    }\r\n    Construct_Init(int i, int j)\r\n    {\r\n        a = i;\r\n        b = j;\r\n    }\r\n\r\n    void CI_Run() { printf(\"%d:%d\", a, b); }\r\n};\r\n\r\nint main(int argc, char **argv)\r\n{\r\n    Construct_Init ci;\r\n    ci.CI_Run();\r\n    Construct_Init ci1(1);\r\n    ci1.CI_Run();\r\n    Construct_Init ci2(1, 2);\r\n    ci2.CI_Run();\r\n}"
          ]
        },
        "bad": {
          "cpp": [
            "#include <stdio.h>\r\n\r\nclass Construct_Init\r\n{\r\nprivate:\r\n    int a;\r\n    int b;\r\n\r\npublic:\r\n    // all variables in all constructors are\r\n    // initialized\r\n    Construct_Init() {};\r\n    Construct_Init(int i)\r\n    {\r\n        a = i;\r\n    }\r\n    Construct_Init(int i, int j)\r\n    {\r\n        a = i;\r\n        b = j;\r\n    }\r\n\r\n    void CI_Run() { printf(\"%d:%d\", a, b); }\r\n};\r\n\r\nint main(int argc, char **argv)\r\n{\r\n    Construct_Init ci;\r\n    ci.CI_Run();\r\n    Construct_Init ci1(1);\r\n    ci1.CI_Run();\r\n    Construct_Init ci2(1, 2);\r\n    ci2.CI_Run();\r\n}\r\n"
          ],
          "general": [
            "#include <stdio.h>\r\n\r\nclass Construct_Init{\r\nprivate:\r\n int a;\r\n int b;\r\npublic:\r\n Construct_Init();\r\n Construct_Init(int i): a(i) {}; // did not initialize b\r\n Construct_Init(int i, int j) { a = i; b = j; }\r\n\r\n void CI_Run() { printf(\\\"%d:%d\\\r\n\\\", a, b); }\r\n};\r\n\r\nint main(int argc, char**argv)\r\n{\r\n Construct_Init ci;\r\n ci.CI_Run();\r\n Construct_Init ci1(1);\r\n ci1.CI_Run();\r\n Construct_Init ci2(1,2);\r\n ci2.CI_Run();\r\n}\r\n"
          ]
        }
      },
      "standards": {
        "cwe": [
          "909"
        ]
      },
      "csv_string": [
        "UIC0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 22,
      "category": "CORRECTNESS",
      "language": "c,c++,java",
      "code": "UIV",
      "name": "Uninitialized variable",
      "desc": "The program is using a variable before it has been initialized.",
      "msg_templ": "In file ${so.filename}, line ${so.line}, variable ${so.var} in function ${so.func} has been used but never assigned a value.",
      "severity": "H",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nThe program is using a variable before it has been initialized.\r\n\r\n#### Explanation\r\nStack variables in C and C++ are not initialized by default. Non-static global variables are not guaranteed to be zeroed. Their initial values are determined by the values that happen to be in their location in memory at the time the function is invoked. Doing so will cause an unexpected program behavior.\r\n",
      "examples": {
        "good": {
          "c": [
            "int assign(int *a)\r\n{\r\n    return *a; // dereference a\r\n}\r\n\r\nint main()\r\n{\r\n    int a = 100; // a is assigned as 100\r\n    int b;\r\n    b = assign(&a); \r\n    printf(\"value of b = %d\", b);\r\n    return 0;\r\n}"
          ]
        },
        "bad": {
          "c": [
            "int assign(int *a)\r\n{\r\n    return *a; // dereference a\r\n}\r\n\r\nint main()\r\n{\r\n    int a, b;\r\n    b = assign(&a); // call assign with a uninitialized variable\r\n    printf(\"value of b = %d\", b);\r\n    return 0;\r\n}"
          ],
          "general": [
            "int assign(int* a)\r\n{\r\n return *a; // dereference a\r\n}\r\n\r\nint main() {\r\n int a, b;\r\n b = assign(&a); // call assign with a uninitialized\r\n printf(\\\"value of b = %d\\\r\n\\\", b);\r\n return 0;\r\n}"
          ]
        }
      },
      "csv_string": [
        "UIV1",
        "UIV0"
      ],
      "standards": {},
      "alias": {
        "cert": [
          "EXP33-C",
          "EXP53-CPP"
        ]
      },
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 23,
      "category": "BAD_PRACTICE",
      "language": "c++,java",
      "code": "ECB",
      "name": "Empty catch block",
      "desc": "The program has an exception construct with an empty catch block.",
      "msg_templ": "In file ${si.filename}, function ${si.func}, the catch block in line ${si.line} is empty.",
      "severity": "L",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has an exception construct with an empty catch block.\r\n\r\n#### Explanation\r\nEmpty catch block effectively suppressed an exception from being correctly handled by another try block. The \\\"uncaught\\\" exception may cause unintended program behavior.\r\n",
      "examples": {
        "good": {
          "general": [
            "#include <iostream>\r\n\r\nint integer_divide(int a, int b) {\r\n if (b == 0) {\r\n throw \\\"division by zero error\\\";\r\n }\r\n else return (a/b);\r\n}\r\n\r\nint foo(int x, int y) {\r\n try {\r\n int z = integer_divide(x, y);\r\n std::cout << z << std::endl;\r\n }\r\n catch (const char* msg) {\r\n // non-empty catch body and return error\r\n std::cout << \\\"division exception\\\" << std::endl;\r\n return 1;\r\n }\r\n return 0;\r\n}"
          ]
        },
        "bad": {
          "general": [
            "#include <iostream>\r\n\r\nint integer_divide(int a, int b) {\r\n if (b == 0) {\r\n throw \\\"division by zero error\\\";\r\n }\r\n else return (a/b);\r\n}\r\n\r\nint foo(int x, int y) {\r\n try {\r\n int z = integer_divide(x, y);\r\n std::cout << z << std::endl;\r\n }\r\n catch (const char* msg) {\r\n // empty catch body, zero as divisor notice suppressed\r\n }\r\n return 0;\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A3",
          "A5"
        ],
        "cwe": [
          "223"
        ]
      },
      "csv_string": [
        "ECB1",
        "ECB0"
      ],
      "alias": {
        "cert": [
          "ERR00-J"
        ]
      },
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 24,
      "category": "VUL",
      "language": "c,c++",
      "code": "FIO37-C",
      "name": "fgets() and fgetws() may return an empty string",
      "desc": "The program is calling fgets() or fgetws(), assuming the string returned is a non-empty string.",
      "msg_templ": "In file ${si.filename}, line ${si.line},  ${si.func} may return a null string.",
      "severity": "H",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nThe program is calling fgets() or fgetws() and assuming the string returned is a non-empty string.\r\n\r\n#### Explanation\r\nThe two functions may return a null string (e.g. the file may be a binary file).\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <stdio.h>\r\n\r\n#define BUF_SZ 1024\r\n\r\nvoid read_string(void)\r\n{\r\n char buf[BUF_SZ];\r\n FILE *fp = fopen(\"/myfile\", \"+r\");\r\n // check fp valid\r\n // ...\r\n\r\n if (fgets(buf, BUF_SZ, fp) != 0) {\r\n // replace newline character if it is there\r\n char *pchar = strchr(buf, '');\r\n if (pchar) *pchar = '\\\\0';\r\n\r\n printf(\"Size of string read = %d\", strlen(buf)-1);\r\n }\r\n\r\n}"
          ]
        },
        "bad": {
          "c": [
            "#include <stdio.h>\r\n\r\n#define BUF_SZ 1024\r\n\r\nvoid read_string(void)\r\n{\r\n char buf[BUF_SZ];\r\n FILE *fp = fopen(\"/myfile\", \"+r\");\r\n // check fp valid\r\n // ...\r\n\r\n if (fgets(buf, BUF_SZ, fp) != 0) {\r\n // if the first character of buf is '\\\\0', a random meaningless large number will be printed\r\n printf(\"Size of string read = %d\", strlen(buf)-1);\r\n }\r\n\r\n}"
          ]
        }
      },
      "standards": {
        "cwe": [
          "119",
          "241"
        ]
      },
      "csv_string": [
        "F37C1",
        "F37C0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 25,
      "category": "VUL",
      "language": "c,c++",
      "code": "MSC32-C",
      "name": "Pseudo-random number generators should be properly seeded before use",
      "desc": "The program is using a pseudo random number generator with seeding (initial state) that will produce a deterministic sequence of numbers.",
      "msg_templ": "In file ${si.filename}, ${si.func}, line ${si.line} is calling variable ${si.var}. This generator will produce a deterministic sequence.",
      "severity": "M",
      "likelihood": "L",
      "cost": "L",
      "details": "#### Abstract\r\nThe program is using a pseudo random number generator with seeding (initial state) that will produce a deterministic sequence of numbers.\r\n\r\n#### Explanation\r\nA properly seeded PRNG will generate a different number sequence each time it runs (e.g. call srandom() before invoking the random function). This prevents potential attackers to predict the number sequence generated. Alternatively, use random number generators that cannot be seeded.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n// function calls random() with proper seeding\r\nvoid print_rand(void)\r\n{\r\n    srandom(time(NULL));\r\n    for (int i = 0; i < 20; i++)\r\n    {\r\n        printf(\"%lx \\n\", random());\r\n    }\r\n}\r\n"
          ]
        },
        "bad": {
          "c": [
            "#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n// this function calls random() without proper seeding it\r\n// output of this function will be the same each time it is called\r\nvoid print_rand(void)\r\n{\r\n    for (int i = 0; i < 20; i++)\r\n    {\r\n        printf(\"%lx \\n\", random());\r\n    }\r\n}\r\n\r\n\r\n\r\n"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A2",
          "A3"
        ],
        "cwe": [
          "522",
          "327"
        ]
      },
      "csv_string": [
        "M32C1",
        "M32C0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 26,
      "category": "VUL",
      "language": "c,c++",
      "code": "ENV32-C",
      "name": "Exit handlers must return normally",
      "desc": "The program is using an exit handler that does not return normally.",
      "msg_templ": "In file ${si.filename}, function ${si.func} is registered at line ${si.line} as exit handler. The program will exit and not return normally.",
      "severity": "M",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program is using some exit handler that does not return normally.\r\n\r\n#### Explanation\r\nThe following three functions _Exit(), exit(), quick_exit() are C standard exit functions. exit() and quick_exit() will call exit handlers atexit() and at_quick_exit() respectively for cleanup purposes, while _Exit() will not. User can define their own handlers and register with the system provided handlers. These exit handlers must return normally so that all exit handlers (thus all cleanup tasks) are properly performed. Furthermore, all exit handlers should not call exit().\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\nstatic int file_opened;\r\n\r\nvoid my_exit1(void)\r\n{\r\n // some clean up code for opened file\r\n fprintf(stderr, \"abnormal exit from my_exit1() with file closed\\\\\");\r\n exit(0); // this exit handler does not return normally. exit() is called the second time when value of file_opened is 1.\r\n}\r\n\r\nvoid my_exit2(void)\r\n{\r\n if (file_opened == 1) {\r\n my_exit1();\r\n }\r\n fprintf(stderr, \"abnormal exit with errno %d\", errno());\r\n // other cleanup code\r\n // if file_opened is 1, the clean up code here will not be executed\r\n // ...\r\n return;\r\n\r\n}\r\n\r\nint main() {\r\n // ...\r\n file_opened = 1;\r\n if (atexit(my_exit2) != 0) {\r\n // handle error\r\n }\r\n}\r\n return 0;\r\n}"
          ]
        },
        "bad": {
          "c": [
            "#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\nextern int file_opened;\r\n\r\nint my_exit1(void)\r\n{\r\n // some clean up code for opened file\r\n fprintf(stderr, \"abnormal exit from my_exit1() with file closed\\\\\");\r\n exit(0); // this exit handler does not return normally. exit() is called the second time when value of file_opened is 1.\r\n}\r\n\r\nint my_exit2(void)\r\n{\r\n if (file_opened == 1) {\r\n my_exit1();\r\n }\r\n fprintf(stderr, \"abnormal exit with errno %d\", errno());\r\n // other cleanup code\r\n // if file_opened is 1, the clean up code here will not be executed\r\n // ...\r\n return 1;\r\n\r\n}\r\n\r\nint main() {\r\n // ...\r\n if (atexit(my_exit2) != 0) {\r\n // handle error\r\n }\r\n}\r\n return 0;\r\n}"
          ]
        }
      },
      "csv_string": [
        "N32C0"
      ],
      "standards": {},
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 27,
      "category": "VUL",
      "language": "c,c++",
      "code": "ENV33-C",
      "name": "Please pay attention to the direct call to system()",
      "desc": "The program is calling the C standard system() function. When not properly protected, it could lead to various types of exploitation.",
      "msg_templ": "In file ${si.filename}, function ${si.func}, system() at line ${si.line} carries input parameters that have not been sanitized.",
      "severity": "H",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nThe program is calling the C standard system() function. When not properly protected, it could lead to various exploitations.\r\n\r\n#### Explanation\r\nThe program is calling the system() function where the parameter is a character string. Such a string must be properly protected (examples: sanitized string, normalized path). Failure to do so will cause arbitrary program execution, privilege elevation or other unpredictable behavior.\r\n\r\n",
      "examples": {
        "good": {
          "c": [
            "void func_call_sys(const char *in)\r\n{\r\n // system() is called with a string \\\"in\\\" passed from outside of this function\r\n // There is no evidence that \\\"in\\\" has been sanitized\r\n // Sanitize input to system()\r\n // use full path name for directory for example\r\n sanitise(in); // e.g. for file or directory name, do not include \\\"../\\\" substring\r\n system(in);\r\n}"
          ]
        },
        "bad": {
          "c": [
            "void func_call_sys(const char *in)\r\n{\r\n // system() is called with a string \\\"in\\\" passed from outside of this function\r\n // There is no evidence that \\\"in\\\" has been sanitized\r\n // for example, if \\\"in\\\" is the string \\\"rm *\\\"\r\n // executing the system() call could be devastating\r\n system(in);\r\n}"
          ]
        }
      },
      "standards": {
        "cwe": [
          "88",
          "77",
          "78",
          "917"
        ]
      },
      "csv_string": [
        "N33C3",
        "N33C2",
        "N33C1",
        "N33C0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 28,
      "category": "VUL",
      "language": "c,c++",
      "code": "ERR33-C",
      "name": "Please check and handle standard library return errors",
      "desc": "The program is calling the standard library function but failed to check and handle the function error returns.",
      "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line}, the system library call ${si.var} is used without checking for error return.",
      "severity": "H",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program is calling the standard library function but failed to check and handle the function error returns.\r\n\r\n#### Explanation\r\nThe program is calling a standard library function(s). These functions typically return a valid value, or some form of value that indicates an error. Failure to check if the call is successful leads to an unexpected or undefined behavior. Please refer to the language or system specification for a full description of the standard interface. Please note that there are system functions for which return values do not need to be checked. The list of these functions can also be found in the system or language specification. Notably the most popular ones are printf, vprintf, memcpy, memmove, strcpy, strcat, memset (and their wide char versions).\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <stdlib.h>\r\n#include <string.h>\r\n\r\ntypedef struct {\r\n int len;\r\n int *data;\r\n} vec_rec, *vec_rec_ptr;\r\n\r\nenum { VEC_SZ = 32 };\r\n\r\nvec_rec vr[VEC_SZ] = { 0 }; // initialize table content\r\nvec_rec_ptr func_call_stdlib(int len, vec_rec_ptr in_vec)\r\n{\r\n vec_rec_ptr vrp = (vec_rec_ptr)(malloc(sizeof(vec_rec) * len));\r\n\r\n // Checks if vrp is NULL, such as when malloc failed\r\n if (vrp == NULL) \r\n {\r\n  printf(\"Malloc has failed, the program will terminate.\");\r\n  return NULL;\r\n }\r\n\r\n // this memcpy may enable an attacker to access memory causing remote code execution\r\n memcpy(vrp, in_vec, len);\r\n\r\n}\r\n"
          ]
        },
        "bad": {
          "c": [
            "#include <stdlib.h>\r\n#include <string.h>\r\n\r\ntypedef struct {\r\n int len;\r\n int *data;\r\n} vec_rec, *vec_rec_ptr;\r\n\r\nenum { VEC_SZ = 32 };\r\n\r\nvec_rec vr[VEC_SZ] = { 0 }; // initialize table content\r\nvec_rec_ptr func_call_stdlib(int len, vec_rec_ptr in_vec)\r\n{\r\n vec_rec_ptr vrp = (vec_rec_ptr)(malloc(sizeof(vec_rec) * len));\r\n // vrp may be NULL if malloc failed\r\n // this code did not check that vrp may be invalid\r\n\r\n // this memcpy may enable an attacker to access memory causing remote code execution\r\n memcpy(vrp, in_vec, len);\r\n\r\n}"
          ]
        }
      },
      "csv_string": [
        "E33C0"
      ],
      "standards": {},
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 29,
      "category": "VUL",
      "language": "c,c++",
      "code": "FIO34-C",
      "name": "EOF or WEOF as \"char\" size objects are different from chars read from a file",
      "desc": "The program is using a return value of file read (such as getchar(), getc(), getwc()...) to check for EOF/WEOF as an end of file read operation.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} is using a return value of file read to check for EOF.",
      "severity": "H",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nThe program is using a return value of file read (such as getchar(), getc(), getwc(),..) to check for EOF/WEOF as an end of file read operation.\r\n\r\n#### Explanation\r\nThe function that read characters from a file returned an int type. Directly comparing the character read with EOF/WEOF may cause an unexpected result because EOF and WEOF are implementation defined.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <stdio.h>\r\n\r\nvoid read_char(void)\r\n{\r\n\tFILE *fp = fopen(\"/tmp/myfile\", \"+r\");\r\n\t// check fp valid\r\n\t// ...\r\n\t\r\n\tint c = getc(fp);\r\n\t\r\n\t// make sure it is really an EOF character and that the EOF is due to end-of-file\r\n\t\r\n\twhile (c != EOF || (feof(stdin) && !ferror(stdin)) \r\n\t{\r\n\tputchar(c); // echo what is read in\r\n\tc = getc(fp);\r\n\t}\r\n}"
          ]
        },
        "bad": {
          "c": [
            "#include <stdio.h>\r\n\r\nvoid read_char(void)\r\n{\r\n FILE *fp = fopen(\"/tmp/myfile\", \"+r\");\r\n // check fp valid\r\n // ...\r\n\r\n int c = getc(fp);\r\n while (c != EOF) // this check does not guarantee read has reached end of file\r\n {\r\n putchar(c); // echo what is read in\r\n c = getc(fp);\r\n }\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A1"
        ],
        "cwe": [
          "197"
        ]
      },
      "csv_string": [
        "F34C0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 30,
      "category": "VUL",
      "language": "c,c++",
      "code": "FIO42-C",
      "name": "Close files when done with them",
      "desc": "The program has opened a file but then failed to close it when done or before the program terminated.",
      "msg_templ": "In file ${si.filename}, function ${si.func}, line ${si.line}, file ${si.var} was opened and not closed.",
      "severity": "M",
      "likelihood": "U",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has opened a file but then failed to close the file when finished or before the program has terminated.\r\n\r\n#### Explanation\r\nIt is important to close a file when it is no longer needed. Failure to do so may expose resource (such as non-flushed data) associated with the file to attackers.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <stdio.h>\r\n\r\nint open_file(const char *fname)\r\n{\r\n FILE *fp = fopen(fname, \"+r\");\r\n if (fp == NULL) return -1;\r\n\r\n // program continues\r\n\r\n if (fclose(fp) == EOF) {\r\n // handle error\r\n ...\r\n }\r\n return 0; // file is properly closed on return\r\n\r\n}"
          ]
        },
        "bad": {
          "c": [
            "#include <stdio.h>\r\n\r\nint open_file(const char *fname)\r\n{\r\n FILE *fp = fopen(fname, \"+r\");\r\n if (fp == NULL) return -1;\r\n\r\n // program continues\r\n return 0; // file is not properly closed on return\r\n\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A3"
        ],
        "cwe": [
          "459",
          "772",
          "404"
        ]
      },
      "csv_string": [
        "F42C2",
        "F42C1",
        "F42C0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 31,
      "category": "VUL",
      "language": "c,c++",
      "code": "FIO45-C",
      "name": "File access may have race conditions and should be avoided",
      "desc": "Race conditions while accessing files (time of check, time of use) may happen and should be avoided.",
      "msg_templ": "In file ${si.filename} function ${si.func}, line ${si.line}, the file ${si.var} has TOCTOU problem.",
      "severity": "H",
      "likelihood": "P",
      "cost": "H",
      "details": "#### Abstract\r\nRace conditions while accessing files (time of check, time of use) may happen and should be avoided.\r\n\r\n#### Explanation\r\nIn a shared file system, two or more processes may access the same file, causing a race condition. Attackers can change the file between two accesses or replace the file (symbolic or hard linked) with a different file.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <stdio.h>\r\n#include <unistd.h>\r\n#include <sys/stat.h>\r\n#include <fcntl.h>\r\n\r\nint file_s1(char *p, char *q)\r\n{\r\n    struct stat statBefore, statAfter;\r\n\r\n    lstat(\"/tmp/x\", &statBefore);\r\n    \r\n    // \"x\" mode will cause fopen() to fail\r\n    // if the file exists.  \r\n    // NOTE: Only works for C11 and above or\r\n    // systems that support this feature\r\n    FILE *f = fopen(\"/tmp/x\", \"wx\");\r\n    if (statAfter.st_ino == statBefore.st_ino)\r\n    {\r\n        if (f != NULL)\r\n            fwrite(\"HELLO!\", 1, 5, f);\r\n    }\r\n\r\n    fclose(f);\r\n    return 0;\r\n}"
          ]
        },
        "bad": {
          "c": [
            "#include <stdio.h>\r\n#include <unistd.h>\r\n#include <sys/stat.h>\r\n#include <fcntl.h>\r\n\r\n// This example is modified from example in \r\n// CERT-C FIO45 site\r\nint file_s1(char *p, char *q)\r\n{\r\n    struct stat statBefore, statAfter;\r\n\r\n    lstat(\"/tmp/x\", &statBefore);\r\n    // previous contents of file gets destroyed \r\n    // with \"w\" mode\r\n    FILE *f = fopen(\"/tmp/x\", \"w\");\r\n    lstat(\"/tmp/x\", &statAfter);\r\n    if (statAfter.st_ino == statBefore.st_ino)\r\n    {\r\n        if (f != NULL)\r\n            fwrite(\"HELLO!\", 1, 5, f);\r\n    }\r\n\r\n    fclose(f);\r\n    return 0;\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A3"
        ]
      },
      "csv_string": [
        "F45C0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 32,
      "category": "VUL",
      "language": "c,c++",
      "code": "MEM35-C",
      "name": "Make sure sufficient memory has been allocated for an object",
      "desc": "The program has used the malloc family of functions to allocate memory that is smaller than the memory required by the program.",
      "msg_templ": "In file ${si.filename}, function ${si.func}, line ${si.line}, out of range memory access occurs.",
      "severity": "H",
      "likelihood": "P",
      "cost": "H",
      "details": "#### Abstract\r\nThe program has used malloc family of functions to allocate memory that is smaller than the memory required by the program.\r\n\r\n#### Explanation\r\nThe parameter corresponding to size arguments to the malloc functions should have sufficient range to represent the size of objects to be stored. Failure to do so will cause a buffer overflow leading to an unexpected program behavior.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <stdlib.h>\r\n\r\ntypedef struct\r\n{\r\n    size_t len;\r\n    int *data;\r\n} vect_record, *vect_ptr;\r\n\r\nvect_record *vector_new(size_t len)\r\n{\r\n    vect_record *vect;\r\n    // dereferenced pointer type means correct amount \r\n    // of memory is allocated for the struct tm object\r\n    vect_ptr result = (vect_ptr)malloc(sizeof(*vect));\r\n    if (result == NULL)\r\n    {\r\n        // handle error and return\r\n        return NULL;\r\n    }\r\n\r\n    // initialize vector\r\n    result[0].len = 1;\r\n    result[1].len = 2;\r\n    // ...\r\n    return result;\r\n}"
          ]
        },
        "bad": {
          "c": [
            "#include <stdlib.h>\r\n\r\ntypedef struct\r\n{\r\n    size_t len;\r\n    int *data;\r\n} vect_record, *vect_ptr;\r\n\r\nvect_record *vector_new(size_t len)\r\n{\r\n    vect_record *vect;\r\n    // size of pointer used to determine size of pointed-to object\r\n    vect_ptr result = (vect_ptr)malloc(sizeof(vect));\r\n    if (result == NULL)\r\n    {\r\n        // handle error and return\r\n        return NULL;\r\n    }\r\n\r\n    // initialize vector\r\n    result[0].len = 1;\r\n    result[1].len = 2;\r\n    // ...\r\n    return result;\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A3",
          "A1"
        ]
      },
      "csv_string": [
        "m35C1",
        "m35C0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 33,
      "category": "VUL",
      "language": "c,c++",
      "code": "MEM36-C",
      "name": "Calling realloc() may cause misalignment for previously aligned objects",
      "desc": "The program has used realloc() that causes a pointer with alignment which is less restrictive than before the memory reallocation.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} has used realloc().",
      "severity": "LOW",
      "likelihood": "PROBABLE",
      "cost": "HIGH",
      "details": "#### Abstract\r\nThe program has used realloc() that causes a pointer with alignment which is then less restrictive than before the memory reallocation.\r\n\r\n#### Explanation\r\nrealloc() will allocate new memory and set the previously allocated memory pointer to the newly allocated area. If the previously allocated memory has more restricted alignment (e.g. 16B), the memory that is newly pointed to it will not satisfy this restriction resulting in an unexpected program behavior.\r\n",
      "examples": {
        "good": {},
        "bad": {
          "c": [
            "#include <stdlib.h>\r\n\r\nint *vector_calc(size_t vec_sz, int elements)\r\n{\r\n size_t align_vec = 1 << vec_sz;\r\n int *ptr_align;\r\n\r\n if ((ptr_align = (int *)aligned_alloc(align_vec, sizeof(int)*elements)) == NULL) {\r\n // handle error and return;\r\n // ...\r\n }\r\n\r\n // program continues\r\n // ...\r\n if ((ptr1 = (int *) realloc(ptr_align, sizeof(int)*elements * 2)) == NULL) {\r\n // handle error and return\r\n //...\r\n }\r\n\r\n // program continues\r\n // but ptr1 is not guaranteed to properly aligned with the vector objects previous allocated\r\n\r\n return ptr1;\r\n\r\n}"
          ]
        }
      }
    },
    {
      "master_id": 34,
      "category": "VUL",
      "language": "c,c++",
      "code": "MSC33-C",
      "name": "Use of asctime() function must pass the parameter needed with valid ranges",
      "desc": "The program is calling an asctime() function. However, the input parameter for that function is from an untrusted source.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, function asctime is called with ${si.var} as parameter, which may not have been sanitized.",
      "severity": "H",
      "likelihood": "L",
      "cost": "L",
      "details": "#### Abstract\r\nThe program is calling asctime() function, however the input parameter for that function is from an untrusted source.\r\n\r\n#### Explanation\r\nThe function asctime() does not validate the value or range of its input parameter. The subsequent use of the result from this function may cause a buffer overflow and other security violations when trying to print to a string.\r\n",
      "examples": {
        "good": {
          "c": [
            "#define __STDC_WANT_LIB_EXT1__ 1\r\n#include <time.h>\r\n#include <stdio.h>\r\n\r\nenum\r\n{\r\n    max = 50\r\n};\r\n\r\nvoid read_time(struct tm *time_info)\r\n{   \r\n    // checks for invalid data below and handles \r\n    // error if exists\r\n    char buffer[max];\r\n    if (asctime_s(buffer, max, &time_info))\r\n    {\r\n        /* Handle error */\r\n    }\r\n\r\n    char *time = asctime(time_info);\r\n    printf(\"time is %s\", time);\r\n}\r\n    \r\n\r\n\r\n"
          ]
        },
        "bad": {
          "c": [
            "#include <time.h>\r\n#include <stdio.h>\r\n\r\nvoid read_time(struct tm *time_info)\r\n{\r\n    // does not check for invalid or potentially\r\n    // unsanitised data\r\n    char *time = asctime(time_info);\r\n    printf(\"time is %s\", time);\r\n}"
          ]
        }
      },
      "csv_string": [
        "M33C0"
      ],
      "standards": {},
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 35,
      "category": "VUL",
      "language": "c,c++",
      "code": "MSC37-C",
      "name": "Non-void functions should always exit this function through a return statement",
      "desc": "The program has an execution path that might reach the exit point of a non-void function without going through a \"return\" statement.",
      "msg_templ": "In file ${si.filename} at line ${si.line}, function ${si.func} is declared to return non-void but has reached end of function without a return statement.",
      "severity": "H",
      "likelihood": "U",
      "cost": "L",
      "details": "#### Abstract\r\nThe program has an execution path that might reach the exit point of a non-void function without going through a \\\"return\\\" statement.\r\n\r\n#### Explanation\r\nWhen the program exits that function on an execution path without a return statement, then the return value will be non-deterministic causing an unexpected program behavior. If the function happens to be \\\"main\\\", or if the function is marked with \\\"no-return\\\" attribute, then there is no problem.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <string.h>\r\n#define BUF_SZ 1024\r\nint has_char(const char *s)\r\n{\r\n    if (s != NULL)\r\n    {\r\n        int l = strlen(s);\r\n        int i;\r\n        for (i = 0; i < l; i++)\r\n        {\r\n            if (s[i] == 'c')\r\n                return i;\r\n        }\r\n    }\r\n    // return statement ensures control never reaches end of\r\n    // the function, returns -1 if no letter 'c'\r\n    return -1;\r\n}\r\n"
          ]
        },
        "bad": {
          "c": [
            "#include <string.h>\r\n\r\n#define BUF_SZ 1024\r\n\r\nint has_char(const char *s)\r\n{\r\n    if (s != NULL)\r\n    {\r\n        int l = strlen(s);\r\n        int i;\r\n        for (i = 0; i < l; i++)\r\n        {\r\n            if (s[i] == 'c')\r\n                return i;\r\n        }\r\n    }\r\n    // missing return here, return value will be undefined\r\n}"
          ]
        }
      },
      "csv_string": [
        "M37C0"
      ],
      "standards": {},
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 36,
      "category": "VUL",
      "language": "c,c++",
      "code": "POS30-C",
      "name": "The readlink() function will only fill the buffer in the second argument not including the null terminator",
      "desc": "The program has called function readlink() and the number of characters written on the buffer (second argument) is not enough to hold a valid string.",
      "msg_templ": "In file ${si.filename} at line ${si.line}, the function readlink() is called and assigned to ${si.var}. The string read is not null terminated.",
      "severity": "H",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has called function readlink() and the number of characters written on the buffer (second argument) is not enough to hold a valid string.\r\n\r\n#### Explanation\r\nThe number of characters written by readlink() may overflow the buffer specified in the second parameter. Also one needs to ensure that the end of the string is null terminated.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <stdio.h>\r\n\r\n#define BUF_SZ 1024\r\n\r\nint func(char *env_str)\r\n{\r\n    char buf[BUF_SZ];\r\n\r\n    // if len is >= sizeof(buf), up till the last byte of buf is non-null\r\n    ssize_t len = readlink(\"/usr/somedir/symlinkfile\", buf, sizeof(buf)); \r\n\r\n    // case handled when len is an invalid value\r\n    if (len >= sizeof(buf) || len == -1) {\r\n        // Handle Exception \r\n        return;\r\n    }\r\n\r\n    buf[len] = '\\0'; // len is always within buf size range\r\n    return;\r\n}"
          ]
        },
        "bad": {
          "c": [
            "#include <stdio.h>\r\n\r\n#define BUF_SZ 1024\r\n\r\nint func(char *env_str)\r\n{\r\n    char buf[BUF_SZ];\r\n\r\n    // if len is >= sizeof(buf), up till the last byte of buf is non-null\r\n    ssize_t len = readlink(\"/usr/somedir/symlinkfile\", buf, sizeof(buf));\r\n\r\n    // len is outside of buf size range (i may be -1 or i >= sizeof(buf))\r\n    buf[len] = '\\0'; \r\n    return;\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A1",
          "A7"
        ],
        "cwe": [
          "170"
        ]
      },
      "csv_string": [
        "P30C1",
        "P30C0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 37,
      "category": "VUL",
      "language": "c,c++",
      "code": "POS34-C",
      "name": "The pointer argument in the putenv() call should not point to local objects",
      "desc": "The program has called putenv() with an argument that points to a local object.",
      "msg_templ": "In file ${si.filename} at line ${si.line}, the system function putenv() is called with variable ${si.var} as a parameter.",
      "severity": "H",
      "likelihood": "U",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has called putenv() with an argument that points to a local object.\r\n\r\n#### Explanation\r\nThe system that calls putenv() will save the argument (which is a pointer to the intended string) into the environment array. When the function returns to the caller, the local object with the environment string may be overwritten. This will cause an unpredictable program behavior.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <string.h>\r\n\r\n#define BUF_SZ 1024\r\n\r\nint func(char *env_str)\r\n{\r\n    // use a static array so that call to putenv() is \r\n    // only necessary the first time func() is called\r\n    static char buf[BUF_SZ];\r\n    // ...\r\n    if (strlen(env_str) < BUF_SZ)\r\n    {\r\n        strcpy(buf, env_str);\r\n        return putenv(buf);\r\n    }\r\n    else\r\n    {\r\n        // handle error\r\n        // ...\r\n    }\r\n    return 0;\r\n}"
          ]
        },
        "bad": {
          "c": [
            "#include <string.h>\r\n\r\n#define BUF_SZ 1024\r\n\r\n// TEST environment variable may take on unintended value\r\n\r\nint func(char *env_str)\r\n{\r\n    char buf[BUF_SZ];\r\n    // ...\r\n    if (strlen(env_str) < BUF_SZ)\r\n    {\r\n        strcpy(buf, env_str);\r\n        return putenv(buf);\r\n    }\r\n    else\r\n    {\r\n        // handle error\r\n        // ...\r\n    }\r\n    return 0;\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A2",
          "A3",
          "A5"
        ],
        "cwe": [
          "252",
          "253",
          "391"
        ]
      },
      "csv_string": [
        "P34C2",
        "P34C1",
        "P34C0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 38,
      "category": "VUL",
      "language": "c,c++",
      "code": "POS35-C",
      "name": "When checking for validity of a symbolic link, there could be a race condition that may nullify the checked result",
      "desc": "The program has called function lstat() to check the named file for symbolic linkage. Results of this check may not be valid when the file is later accessed.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} has called lstat() to check the named file for symbolic linkage.",
      "severity": "H",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has called function lstat() to check the named file for symbolic linkage. Result of this check may not be valid when the file is later accessed.\r\n\r\n#### Explanation\r\nChecking that a file is a symbolic link suffers from time of call, time of use (TOCTOU) problem. In other words, when the file is finally opened for access, that the file is of symbolic link status may not be valid anymore.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <sys/stat.h>\r\n\r\n#define BUF_SZ 1024\r\n\r\nstruct stat link_info;\r\nint val;\r\n\r\nint func(char *fname)\r\n{\r\n    FILE *fp;\r\n    // Race condition eliminated by using O_NOFOLLOW \r\n    // to cause open() to fail if passed a symbolic link\r\n    int fd = open(fp, \"O_RDWR\"|\"O_NOFOLLOW\");\r\n    if (fd == -1)\r\n    {\r\n        /* Handle error */\r\n        return 0;\r\n    }\r\n\r\n    return 1;\r\n}"
          ]
        },
        "bad": {
          "c": [
            "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <sys/stat.h>\r\n\r\n#define BUF_SZ 1024\r\n\r\nstruct stat link_info;\r\nint val;\r\n\r\nint func(char *fname)\r\n{\r\n    FILE *fp;\r\n    if (lstat(fname, &link_info) == -1)\r\n    {\r\n        // handle error\r\n        // ...\r\n        printf(\"lstat return error\");\r\n        return 0;\r\n    }\r\n    else if (S_ISLNK(link_info.st_mode))\r\n    {\r\n\r\n        // both fopen and lstat operate on a file name\r\n        // the name can be manipulated asynchronously such that\r\n        // lstat and fopen referred to different files in reality\r\n        fp = fopen(fname, \"O_RDWR\"); \r\n        if (fp == 0)\r\n        {\r\n            // handle error\r\n            return 0;\r\n        }\r\n\r\n        size_t i = fread(&val, sizeof(int), 1, fp);\r\n        // ...\r\n    }\r\n    return 1;\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A3"
        ],
        "cwe": [
          "363"
        ]
      },
      "csv_string": [
        "P35C0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 39,
      "category": "VUL",
      "language": "c,c++",
      "code": "POS37-C",
      "name": "When manipulating system privilege through the set/set uid/euid functions, please make sure that privileges are relinquished successfully",
      "desc": "The program has one of the get/set uid/euid set of functions which manipulates user ID privileges. The result of calling such functions is not checked which can cause the program's privilege to be in an unexpected state.",
      "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line}, privilege has not been properly restored.",
      "severity": "H",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has one of the get/set uid/euid set of functions which manipulates user id privileges. The result of calling such functions is not checked which will cause the program's privilege to be in an unexpected state.\r\n\r\n#### Explanation\r\nPrivilege capabilities are implementation defined. To ensure that the privileges are set and relinquished as expected, it is important to check the error conditions on return. Failure to do this may result in the program being run with root permission.\r\n",
      "examples": {
        "good": {
          "c": [
            " // ...\r\n\r\n // the following check alone is not sufficient. need to make sure privilege can be restored\r\n if (setuid(getuid()) != 0) {\r\n // Handle error\r\n }\r\n\r\n // check for failure to set uid when the caller is UID 0\r\n // failure to do this will result in a serious security risk\r\n if (setuid(0) != -1) {\r\n // privilege can be restored. Handle error\r\n }"
          ]
        },
        "bad": {
          "c": [
            "#include <stdio.h>\r\n#include <unistd.h>\r\n\r\nvoid func()\r\n{\r\n    // Permanently drop privileges\r\n    if (setuid(getuid()) != 0) {\r\n        // Handle error\r\n    }\r\n    \r\n    // Check for failure of privilege relinquishmnet has to be done here\r\n    // Else, attacker can regain elevated privileges    \r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A2"
        ],
        "cwe": [
          "273",
          "299",
          "200"
        ]
      },
      "csv_string": [
        "P37C2",
        "P37C1",
        "P37C0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 40,
      "category": "VUL",
      "language": "c,c++",
      "code": "POS54-C",
      "name": "When using POSIX library, please make sure to detect and appropriately handle errors on function returns",
      "desc": "The program has called some POSIX library functions but failed to check and handle the return error condition.",
      "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line} a POSIX function is called, and the call result was used without being validated.",
      "severity": "H",
      "likelihood": "L",
      "cost": "L",
      "details": "#### Abstract\r\nThe program has called some POSIX library function but failed to check and handle the return error condition.\r\n\r\n#### Explanation\r\nEach POSIX library has a well defined error return. Failure to check the return value for an indication of an error condition and handle the error appropriately will lead to an unexpected program behavior.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <sys/types.h>\r\n#include <sys/mman.h>\r\n#include <err.h>\r\n#include <fcntl.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\nint main(void)\r\n{\r\n    const char str1[] = \"string 1\";\r\n    int fd = -1;\r\n    void *rwrite;\r\n\r\n    if ((fd = open(\"/usr/somefile\", O_RDWR, 0)) == -1)\r\n    {\r\n        err(1, \"open\");\r\n    }\r\n\r\n    rwrite = (char *)mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\r\n\r\n    // checks if rwrite fails and handles error so that\r\n    // strcpy() works properly below\r\n    if (rwrite == NULL) \r\n    {\r\n        // Handle error\r\n    }\r\n\r\n    strcpy(rwrite, str1);\r\n\r\n    // ... continue\r\n}"
          ]
        },
        "bad": {
          "c": [
            "#include <sys/types.h>\r\n#include <sys/mman.h>\r\n#include <err.h>\r\n#include <fcntl.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n\r\nint main(void)\r\n{\r\n    const char str1[] = \"string 1\";\r\n    int fd = -1;\r\n    void *rwrite;\r\n\r\n    if ((fd = open(\"/usr/somefile\", O_RDWR, 0)) == -1)\r\n    {\r\n        err(1, \"open\");\r\n    }\r\n\r\n    rwrite = (char *)mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\r\n\r\n    // rwrite may not be valid pointer since mmap may have failed\r\n    strcpy(rwrite, str1);\r\n\r\n    // ... continue\r\n}"
          ]
        }
      },
      "csv_string": [
        "P54C0"
      ],
      "standards": {},
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 41,
      "category": "VUL",
      "language": "c,c++",
      "code": "SIG30-C",
      "name": "Signal handlers can only invoke asynchronous safe functions",
      "desc": "The program is calling non-asynchronous safe functions inside signal handlers.",
      "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line}, a call to signal with handler ${si.var} occurs. Such handler will call functions that are not asynchronous-safe.",
      "severity": "H",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program is calling non-asynchronous safe functions inside signal handlers.\r\n\r\n#### Explanation\r\nThe table of asynchronous safe functions are functions that can be called safely without side effects by a signal handler. Non-reentrant functions are typically not safe. Users can check the system user manual for a full list of all safe functions to use.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <signal.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nchar *messg = NULL;\r\n// sets flag of type volatile\r\nvolatile sig_atomic_t eflag = 0;\r\nint errflag;\r\n\r\n#define BUF_SZ 1024\r\n\r\nvoid put_messg(void)\r\n{\r\n    fputs(messg, stderr);\r\n}\r\n\r\nvoid handler(int signum)\r\n{\r\n    errflag = 1;\r\n}\r\n\r\nint main(void)\r\n{\r\n    if (signal(SIGINT, handler) == SIG_ERR)\r\n    {\r\n        // handle error\r\n    }\r\n    messg = (char *)malloc(BUF_SZ);\r\n    if (messg == 0)\r\n    {\r\n        // handle error\r\n    }\r\n\r\n    while (!errflag)\r\n    {\r\n        put_messg();\r\n        // ...\r\n    }\r\n\r\n    // put_messg() and free() are directly called from main()\r\n    put_messg();\r\n    free(messg);\r\n    messg = NULL;\r\n\r\n    return 0;\r\n}\r\n"
          ]
        },
        "bad": {
          "c": [
            "#include <signal.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nchar *messg = NULL;\r\nint errflag;\r\n\r\n#define BUF_SZ 1024\r\n\r\nvoid put_messg(void)\r\n{\r\n    fputs(messg, stderr);\r\n}\r\n\r\nvoid handler(int signum)\r\n{\r\n    put_messg(); // this is not asynchronous safe\r\n    free(messg); // this is not asynchronous safe\r\n    errflag = 1;\r\n}\r\n\r\nint main(void)\r\n{\r\n    if (signal(SIGINT, handler) == SIG_ERR)\r\n    {\r\n        // handle error\r\n    }\r\n    messg = (char *)malloc(BUF_SZ);\r\n    if (messg == 0)\r\n    {\r\n        // handle error\r\n    }\r\n\r\n    if (!errflag)\r\n    {\r\n        put_messg();\r\n        // ...\r\n    }\r\n    return 0;\r\n}\r\n"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A1"
        ],
        "cwe": [
          "479"
        ]
      },
      "csv_string": [
        "G30C0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 42,
      "category": "VUL",
      "language": "c,c++",
      "code": "SIG31-C",
      "name": "Signal handlers accessing shared variables or objects may result in race conditions",
      "desc": "The program is accessing a shared variable or an object inside a signal handler.",
      "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line}, a call to signal with handler ${si.var} is made. Such handler eventually will access a sharable memory object.",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "details": "#### Abstract\r\nThe program is accessing a shared variable or object inside a signal handler.\r\n\r\n#### Explanation\r\nOther than variables of type \\\"volatile sig_atomic_t\\\", accessing any other type of objects from a signal handler may cause a race condition resulting in an undefined behavior.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <signal.h>\r\n#include <stdlib.h>\r\n#include <sys/socket.h>\r\n\r\nchar *messg = NULL;\r\n#define BUF_SZ 1024\r\nint sockfd; // as a simple example, we assume sockfd has been properly initialized and connected\r\n\r\nint errflag; // this is a shared variable\r\n\r\nssize_t put_messg(void)\r\n{\r\n    ssize_t err = send(sockfd, (const void *)messg, BUF_SZ, MSG_DONTWAIT);\r\n    return err;\r\n}\r\n\r\nvoid handler(int signum)\r\n{\r\n    errflag = 1; // access shared variable inside handler\r\n}\r\n\r\nint main(void)\r\n{\r\n    messg = (char *)malloc(1024);\r\n    if (messg == 0)\r\n    {\r\n        // handle error\r\n    }\r\n\r\n    if (signal(SIGINT, handler) == SIG_ERR)\r\n    {\r\n        // handle error\r\n    }\r\n\r\n    if (!errflag)\r\n    {\r\n        if (put_messg() >= 0)\r\n        {\r\n            // messg sent\r\n            // ...\r\n        }\r\n        else\r\n        {\r\n            // ...\r\n        }\r\n    }\r\n    return 0;\r\n}"
          ]
        },
        "bad": {
          "c": [
            "#include <signal.h>\r\n#include <stdlib.h>\r\n#include <sys/socket.h>\r\n\r\nchar *messg = NULL;\r\n#define BUF_SZ 1024\r\nint sockfd; // as a simple example, we assume sockfd has been properly initialized and connected\r\n\r\nvolatile sig_atomic_t errflag = 0;\r\n\r\nssize_t put_messg(void)\r\n{\r\n    ssize_t err = send(sockfd, (const void *)messg, BUF_SZ, MSG_DONTWAIT);\r\n    return err;\r\n}\r\n\r\nvoid handler(int signum)\r\n{\r\n    errflag = 1; // access shared variable inside handler\r\n}\r\n\r\nint main(void)\r\n{\r\n    messg = (char *)malloc(1024);\r\n    if (messg == 0)\r\n    {\r\n        // handle error\r\n    }\r\n\r\n    if (signal(SIGINT, handler) == SIG_ERR)\r\n    {\r\n        // handle error\r\n    }\r\n\r\n    if (!errflag)\r\n    {\r\n        if (put_messg() >= 0)\r\n        {\r\n            // messg sent\r\n            // ...\r\n        }\r\n        else\r\n        {\r\n            // ...\r\n        }\r\n    }\r\n    return 0;\r\n}"
          ]
        }
      },
      "standards": {
        "cwe": [
          "662",
          "828"
        ]
      },
      "csv_string": [
        "G31C1",
        "G31C0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 43,
      "category": "VUL",
      "language": "c,c++",
      "code": "STR02-C",
      "name": "Data passed to external packages or subsystems should be sanitized",
      "desc": "The program is passing string data to external packages or subsystems. These data as strings need to be sanitized.",
      "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line}, {si.var} is passed to a system call. This variable is declared and considered unsanitized through the program flow.",
      "severity": "H",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program is passing string data to external packages or subsystems, these data strings need to be sanitized.\r\n\r\n#### Explanation\r\nWhen data containing sensitive information is passed to system calls, databases or other external third party components, it is important to ensure that only data that is acceptable to both producer and consumer will be passed.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\nchar *messg = NULL;\r\n#define BUF_SZ 1024\r\n\r\nvoid foo(char *argv)\r\n{\r\n    int len;\r\n    char buf[BUF_SZ];\r\n\r\n\r\n    // filter out invalid data and characters\r\n    static char approved[] = \"abcdefghijklmnopqrstuvwxyz\"\r\n                             \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\r\n                             \"1234567890_-.@\";\r\n    const char *end = *argv + strlen(*argv);\r\n    for (argv += strspn(argv, approved); argv != end; argv += strspn(argv, approved))\r\n    {\r\n        *argv = '_';\r\n    }\r\n\r\n    if (*argv != 0)\r\n        len = snprintf(buf, BUF_SZ, \"%s\", *argv); \r\n    if (len < 0)\r\n    {\r\n        // report error\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        if (system(buf) == -1)\r\n        {\r\n            // report error\r\n            return;\r\n        }\r\n    }\r\n}\r\n"
          ]
        },
        "bad": {
          "c": [
            "#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\nchar *messg = NULL;\r\n#define BUF_SZ 1024\r\n\r\nvoid foo(char *argv)\r\n{\r\n    int len;\r\n    char buf[BUF_SZ];\r\n\r\n    if (*argv != 0)\r\n        len = snprintf(buf, BUF_SZ, \"%s\", *argv); // buf will be fed into system call later. \\\"argv\\\" needs to be sanitized\r\n    if (len < 0)\r\n    {\r\n        // report error\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        if (system(buf) == -1)\r\n        {\r\n            // report error\r\n            return;\r\n        }\r\n    }\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A3",
          "A1"
        ],
        "cwe": [
          "88",
          "78",
          "917"
        ]
      },
      "csv_string": [
        "S02C2",
        "S02C1",
        "S0200"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 44,
      "category": "VUL",
      "language": "c,c++",
      "code": "STR31-C",
      "name": "Strings should have sufficient storage for all characters including the null terminator",
      "desc": "Ensure that the destination storage of a string is sufficiently large that it includes the terminating null.",
      "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line}, a pointer to character ${si.var} was used to fill another character array/pointer. ${si.var} is not null terminated and may cause memory access error.",
      "severity": "H",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nEnsure that the destination storage of a string is sufficiently large that it includes the terminating null.\r\n\r\n#### Explanation\r\nA string is terminated by the null character and should be part of the string size/length. If the storage for the string is not sufficiently large enough, it will cause a buffer overflow or other spurious errors.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <stdlib.h>\r\n#include <string.h>\r\n#include <stdio.h>\r\n\r\nvoid get_passwd(void)\r\n{\r\n    // length is not fixed, so no buffer overflow\r\n    \r\n    char *buf;\r\n    char *passwd = getenv(\"PASSWORD\");\r\n    if (passwd == NULL)\r\n    {\r\n        printf(\"Error getting password\");\r\n        exit(1);\r\n    }\r\n\r\n    size_t length = strlen(passwd) + 1;\r\n    buf = (char *)malloc(length);\r\n    if (buf == NULL)\r\n    {\r\n        // handle error\r\n    }\r\n\r\n    memcpy(buf, passwd, length);\r\n    free(buf);\r\n}\r\n\r\n"
          ]
        },
        "bad": {
          "c": [
            "#include <stdlib.h>\r\n#include <string.h>\r\n#include <stdio.h>\r\n\r\nvoid get_passwd(void)\r\n{\r\n    char buf[256];\r\n    char *passwd = getenv(\"PASSWORD\");\r\n    if (passwd == NULL)\r\n    {\r\n        printf(\"Error getting password\");\r\n        exit(1);\r\n    }\r\n    //\r\n    // copy environmental string to a fixed-length can cause buffer overflow\r\n    //\r\n    strcpy(buf, passwd);\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A3",
          "A1"
        ],
        "cwe": [
          "122",
          "767",
          "787",
          "125",
          "119"
        ]
      },
      "csv_string": [
        "S31C4",
        "S31C3",
        "S31C2",
        "S31C1",
        "S31C0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 45,
      "category": "VUL",
      "language": "c,c++",
      "code": "STR32-C",
      "name": "String parameters to library functions should be properly null-terminated",
      "desc": "The program is calling a library function with a string parameter. That string may not be properly terminated.",
      "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line}, ${si.var} is passed to a library function. This variable is not null terminated.",
      "severity": "H",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nThe program is calling a library function with a string parameter. That string may not be properly terminated.\r\n\r\n#### Explanation\r\nLibrary functions that operate on a string that is not null terminated can result in accessing memory outside of the string object. This in turn will cause an unexpected program behavior.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\nchar *messg = NULL;\r\n#define BUF_SZ 3\r\n\r\nvoid foo(void)\r\n{\r\n    char buf[] = \"123\";\r\n\r\n    printf(\"string is %s\", buf); \r\n\r\n    // ...\r\n}"
          ]
        },
        "bad": {
          "c": [
            "#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\nchar *messg = NULL;\r\n#define BUF_SZ 3\r\n\r\nvoid foo(void)\r\n{\r\n    char buf[BUF_SZ] = \"123\";\r\n\r\n    printf(\"string is %s\", buf); // buf may not be null terminated since the array is a local array\r\n\r\n    // ...\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A3",
          "A1"
        ],
        "cwe": [
          "119",
          "125",
          "123",
          "170",
          "787"
        ]
      },
      "csv_string": [
        "S32C4",
        "S32C3",
        "S32C2",
        "S32C1",
        "S32C0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 46,
      "category": "VUL",
      "language": "c,c++",
      "code": "STR38-C",
      "name": "Do not confuse narrow and wide character strings and functions",
      "desc": "The program is using functions and parameters with mismatching character size or type for the size of characters in the string.",
      "msg_templ": "In file ${si.filename}, at line ${si.line}, ${si.var} is erroneously used for function ${si.func}.",
      "severity": "H",
      "likelihood": "L",
      "cost": "L",
      "details": "#### Abstract\r\nThe program is using functions and parameter with mismatching character size or type for the size of characters in the string.\r\n\r\n#### Explanation\r\nThe program is passing a pointer to an object and a size parameter to the library function. The two parameters, when combined, will cause the library function to access this object but outside its valid range, resulting in an undefined behavior.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <stddef.h>\r\n#include <stdlib.h>\r\n#include <wchar.h>\r\n\r\n#define ARRAY_SZ 2\r\nint mismatch_char_type()\r\n{\r\n    char char_array[] = \"0123456789\";\r\n    char char_array_2[] = \"0123456789\";\r\n\r\n    // char type is the same, so comparing is acceptable\r\n    strncpy(&char_array[0], &char_array[2], sizeof(char_array));\r\n    return 0;\r\n}"
          ]
        },
        "bad": {
          "c": [
            "#include <stddef.h>\r\n#include <stdlib.h>\r\n#include <wchar.h>\r\n\r\n#define ARRAY_SZ 2\r\nint mismatch_char_type()\r\n{\r\n    char char_array[] = \"0123456789\";\r\n    wchar_t wchar_array[] = \"0123456789\";\r\n\r\n    // size of char_array is smaller than wchar_array due to different char type\r\n    memcpy(&char_array[0], &wchar_array[0], sizeof(wchar_array));\r\n    return 0;\r\n}"
          ]
        }
      },
      "csv_string": [
        "S38C0"
      ],
      "standards": {},
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 47,
      "category": "VUL",
      "language": "c++",
      "code": "STR50-CPP",
      "name": "Ensure string storage is adequate for the content",
      "desc": "The program is using inappropriate string methods to process characters which may lead to validation checks that are bypassed or a memory leakage.",
      "msg_templ": "In file ${si.filename} at line ${si.line}, copying data into the buffer may result to buffer overflow.",
      "severity": "H",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program is using inappropriate string methods to process characters which may lead to validation checks that are bypassed or a memory leakage.\r\n\r\n#### Explanation\r\nWhen trying to construct a string of char type in C or C++ , we must declare the maximum length if it is not initialized. When trying to input more characters into the variable (i.e. from console) than the variable can handle, a buffer overflow will occur. A buffer overflow will expose programs to attacks.\r\n",
      "examples": {
        "good": {
          "cpp": [
            "void f(){\r\nstd:;string x;\r\nstd::cin >> x;\r\n}"
          ]
        },
        "bad": {
          "cpp": [
            "#include <string>\r\n#include <iostream>\r\nvoid f(){\r\nchar x[5];\r\nstd::cin>>x;\r\n}"
          ]
        }
      },
      "csv_string": [
        "S50P0"
      ],
      "standards": {},
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 48,
      "category": "VUL",
      "language": "c++",
      "code": "ERR54-CPP",
      "name": "Order the catch handlers from most specific to the least specific",
      "desc": "Program fails to manage the catch handlers for exceptions in the correct order after a try statement. The current order is from the least derived (more general) to the most derived (more specific). Hence, catch handlers for the most derived will never be executed.",
      "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line}, the order of catch handler is not properly arranged.",
      "severity": "MEDIUM",
      "likelihood": "LIKELY",
      "cost": "LOW",
      "details": "#### Abstract\r\nProgram fails to manage the catch handlers for exceptions in the correct order after a try statement. The current order is from least derived(more general) to most derived(more specific).\r\n \r\n#### Explanation\r\nCatch handlers go in order of declaration after a try statement. The correct order should be from the most derived to the least derived, from the most specific to the least specific.\r\nIf the catch starts from the least derived which may possibly be a problem caught from the most derived. This way, the catch handler for the most derived will never be executed, and that behaviour is not desirable.\r\n",
      "examples": {
        "good": {
          "cpp": [
            "// Classes used for exception handling\r\n#include <iostream>\r\n \r\nclass Base {};\r\n \r\nclass Derived1 : public Base {};\r\nclass Derived2 : public Derived1 {};\r\n \r\nvoid foo();\r\nvoid bar();\r\n \r\nvoid foo()\r\n{\r\n std::cout << \"foo\" << std::endl;\r\n}\r\nvoid bar() {\r\n std::cout << \"bar\" << std::endl;\r\n}\r\n \r\nvoid f()\r\n{\r\n try {\r\n foo();\r\n bar();\r\n // ...\r\n }\r\n catch (Derived1 &) {\r\n // ...\r\n }\r\n catch (Base &)\r\n {\r\n // ...\r\n }\r\n try {\r\n foo();\r\n bar();\r\n // ...\r\n }\r\n catch (Derived2 &) {\r\n // ...\r\n }\r\n catch (Base &) //\r\n {\r\n // ...\r\n }\r\n \r\n try {\r\n foo();\r\n bar();\r\n // ...\r\n }\r\n catch (Derived1 *) {\r\n // ...\r\n }\r\n catch (Base *) { //\r\n // ...\r\n }\r\n}\r\n \r\nint main() {\r\n f();\r\n}"
          ]
        },
        "bad": {
          "cpp": [
            "// Classes used for exception handling\r\n#include <iostream>\r\n \r\nclass Base {};\r\n \r\nclass Derived1 : public Base {};\r\nclass Derived2 : public Derived1 {};\r\n \r\nvoid foo();\r\nvoid bar();\r\n \r\nvoid foo()\r\n{\r\n std::cout << \"foo\" << std::endl;\r\n}\r\nvoid bar()\r\n{\r\n std::cout << \"bar\" << std::endl;\r\n}\r\n \r\nvoid f()\r\n{\r\n try {\r\n foo();\r\n bar();\r\n // ...\r\n }\r\n catch (Base &) {\r\n // ...\r\n }\r\n catch (Derived1 &) { // violation here in Line 19\r\n // ...\r\n }\r\n try {\r\n foo();\r\n bar();\r\n // ...\r\n }\r\n catch (Base &) {\r\n // ...\r\n }\r\n catch (Derived2 &) // violation here in Line 31\r\n {\r\n // ...\r\n }\r\n \r\n try {\r\n foo();\r\n bar();\r\n // ...\r\n }\r\n catch (Base *) {\r\n // ...\r\n }\r\n catch (Derived1 *) { // violation here in Line 44\r\n // ...\r\n }\r\n}\r\n \r\nint main() {\r\n f();\r\n}"
          ]
        }
      }
    },
    {
      "master_id": 49,
      "category": "VUL",
      "language": "c++",
      "code": "MEM55-CPP",
      "name": "User-defined dynamic storage management should follow the language requirements",
      "desc": "The program has replaced the function for dynamic memory allocation or deallocation that does not meet the semantic requirements specified by the C++ standard.",
      "msg_templ": "In file ${si.filename}, function${si.func}, line ${si.line}, the replacement function for allocation/deallocation violates the required semantics specified by the C++ standard.",
      "severity": "H",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has replaced the function for a dynamic memory allocation or a deallocation that does not meet the semantic requirements specified by the C++ standard.\r\n\r\n#### Explanation\r\nThe replacement function for allocation contains an external declaration that may return nullptr. The function \\\"new\\\" will instead return a nullptr instead of the supposed \\\"std::bad_alloc\\\". \r\n",
      "examples": {
        "good": {
          "cpp": [
            "#include <cstdio>\r\n#include <cstdlib>\r\n#include <new>\r\n#include <iostream>\r\n\r\nextern void* cust_allocator(std::size_t);\r\n\r\nclass Person {\r\n int age; \r\n std::string name;\r\n \r\npublic:\r\n Person(){}\r\n void* operator new(size_t s)\r\n {\r\n if (((void*) ret = cust_allocator) == 0)\r\n return ret;\r\n return cust_allocator(s);\r\n }\r\n};"
          ]
        },
        "bad": {
          "cpp": [
            "#include <cstdio>\r\n#include <cstdlib>\r\n#include <new>\r\n#include <iostream>\r\n\r\nextern void* cust_allocator(std::size_t);\r\n\r\nclass Person {\r\n int age; \r\n std::string name;\r\n \r\npublic:\r\n Person(){}\r\n void* operator new(size_t s)\r\n {\r\n return cust_allocator(s);\r\n }\r\n};"
          ]
        }
      },
      "csv_string": [
        "m55P0"
      ],
      "standards": {},
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 50,
      "category": "VUL",
      "language": "c++",
      "code": "MSC51-CPP",
      "name": "A proper seeding of pseudorandom generator is required",
      "desc": "The program doesn't properly seed the pseudorandom number generator. It has used a constant seed OR a non-constant seed that is predictable (i.e. time).",
      "msg_templ": "In file ${si.filename}, function ${si.func}, line ${si.line} uses a pseudorandom number generator that is not properly seeded. Seed is either constant or predictable.",
      "severity": "M",
      "likelihood": "L",
      "cost": "L",
      "details": "#### Abstract\r\nThe program doesn't properly seed the pseudorandom number generator. It has used a constant seed OR it has used a seed that is predictable creating the same sequence over and over.\r\n\r\n#### Explanation\r\nWhen calling a pseudorandom number generator (PRNG) with the same initial state, like using the same seed, it will always generate the exact same sequence of numbers. An attacker will be able to easily predict the sequence of numbers and cause security issues.\r\n",
      "examples": {
        "good": {
          "cpp": [
            "#include <stdlib.h>\r\n#include <iostream>\r\n#include <vector>\r\n\r\n#define MAX_VALUE 100\r\n#define VECTOR_SIZE 10\r\n\r\nint main() \r\n{\r\n std::vector<int> vec;\r\n std::random_device rd;\r\n\r\n srand(rd()); // seed is randomized again for every execution\r\n for(int i = 0 ; i < VECTOR_SIZE; ++i) {\r\n vec.push_back(rand()%MAX_VALUE); // no repeated sequence \r\n }\r\n\r\n for(int j=0 ; j < vec.size() ; ++j ) {\r\n std::cout << vec[j] << \\\" \\\";\r\n }\r\n std::cout << '\\\r\n';\r\n}"
          ]
        },
        "bad": {
          "cpp": [
            "#include <stdlib.h>\r\n#include <iostream>\r\n#include <vector>\r\n\r\n#define MAX_VALUE 100\r\n#define VECTOR_SIZE 10\r\nint main()\r\n{ \r\n std::vector<int> vec;\r\n \r\n for(int i = 0 ; i < VECTOR_SIZE; ++i) {\r\n vec.push_back(rand()%MAX_VALUE); // using the same initial seed \r\n }\r\n\r\n // printing\r\n for(int j=0 ; j < vec.size() ; ++j ) {\r\n std::cout << vec[j] << \\\" \\\";\r\n }\r\n std::cout << '\\\r\n';\r\n}"
          ]
        }
      },
      "csv_string": [
        "M51P0"
      ],
      "standards": {},
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 51,
      "category": "VUL",
      "language": "c++",
      "code": "MSC54-CPP",
      "name": "Ensure signal handlers are a plain old function",
      "desc": "The signal handler function in the program is not a plain old function. The particular signal handler function uses pure C++ linkage with no linkage with C.",
      "msg_templ": "In file ${si.filename}, function ${si.func}, it is not a POF (plain old function) even though it exhibits a signal handler behaviour.",
      "severity": "H",
      "likelihood": "P",
      "cost": "H",
      "details": "#### Abstract\r\nThe signal handler function in the program is not a plain old function. The particular signal handler function uses pure C++ linkage and no linkage with C. \r\n\r\n#### Explanation\r\nPOF or 'Plain Old Function' is a function that uses a feature on the common subset between C and C++ language. All signal handlers declared in a C++ source code must have a C linkage, otherwise it may cause an undefined behaviour.\r\n",
      "examples": {
        "good": {
          "cpp": [
            "#include <iostream>\r\n#include <csignal>\r\nusing namespace std;\r\n\r\n// use C signature\r\nextern \\\"C\\\" void handle_signal(int signum)\r\n{\r\n cout << \\\"Signal to interrupt \\\" << signum << endl;\r\n exit(signum);\r\n}\r\n\r\nint main() \r\n{\r\n signal(SIGINT, handle_signal);\r\n // ....\r\n\r\n}"
          ]
        },
        "bad": {
          "cpp": [
            "#include <iostream>\r\n#include <csignal>\r\nusing namespace std;\r\n\r\n\r\n\r\nvoid handle_signal(int signum) \r\n{\r\n cout << \\\"Signal to interrupt \\\" << signum << endl;\r\n exit(signum);\r\n}\r\n\r\nint main() \r\n{\r\n signal(SIGINT, handle_signal);\r\n // ....\r\n\r\n}"
          ]
        }
      },
      "csv_string": [
        "M54P0"
      ],
      "standards": {},
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 52,
      "category": "VUL",
      "language": "Java",
      "code": "IDS16-J",
      "name": "XMLStrings intended for XML processing must be validated before processing",
      "desc": "The program is manipulating XMLStrings intended for XML processing without validating the string.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, the string ${si.var} in function ${si.func} is not sanitized before being passed to XML query.",
      "severity": "H",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nThe program is manipulating XMLString objects intended for XML processing without validating the string.\r\n\r\n#### Explanation\r\nWhen XMLString objects are not sanitized, the XML string could be maliciously injected and mistaken for valid XML, resulting in an XML injection attack.\r\n",
      "examples": {
        "good": {
          "java": [
            "import java.io.BufferedOutputStream;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.IOException;\r\n \r\npublic class j_ids16_1 {\r\n public static void createXMLStreamBad(final BufferedOutputStream outStream,\r\n final String number) throws IOException {\r\n String xmlString = \\\"<item>\\\r\n<description>Widget</description>\\\r\n\\\"\r\n + \\\"<level>500</>\\\r\n\\\";\r\n\r\n if (number != null) {\r\n int sanitizedNumber = Integer.parseUnsignedInt(number);\r\n // the string xmlString should be validated\r\n // to prevent XML injection\r\n\\t xmlString = xmlString + \\\"<number>\\\" + sanitizedNumber\r\n + \\\"</number></item>\\\";\r\n }\r\n outStream.write(xmlString.getBytes());\r\n outStream.flush();\r\n }\r\n}"
          ]
        },
        "bad": {
          "java": [
            "import java.io.BufferedOutputStream;\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.IOException;\r\n \r\npublic class j_ids16_1 {\r\n public static void createXMLStreamBad(final BufferedOutputStream outStream,\r\n final String number) throws IOException {\r\n String xmlString = \\\"<item>\\\r\n<description>Widget</description>\\\r\n\\\"\r\n + \\\"<level>500</>\\\r\n\\\";\r\n\r\n if (number != null) {\r\n // the string xmlString should be validated\r\n // to prevent XML injection\r\n\\t xmlString = xmlString + \\\"<number>\\\" + number\r\n + \\\"</number></item>\\\";\r\n }\r\n outStream.write(xmlString.getBytes());\r\n outStream.flush();\r\n }\r\n}\r\n"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A4",
          "A1"
        ],
        "cwe": [
          "79",
          "776"
        ],
        "p3c-sec": [
          "4"
        ]
      },
      "csv_string": [
        "I16J1",
        "I16J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 53,
      "category": "VUL",
      "language": "Java",
      "code": "MSC02-J",
      "name": "Use strong random number generators",
      "desc": "The program has used random number generators (PRNG) that are not strong enough.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, the method ${si.var} in function ${si.func} does not generate strong random numbers.",
      "severity": "H",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has used random number generators (PRNG) that are not strong.\r\n\r\n#### Explanation\r\nJava API provides a PRNG in java.util.Random class which generates the same sequence when the same seed is used. For security sensitive programs, a more secure PRNG such as java.security.SecureRandom class should be used.\r\n",
      "examples": {
        "good": {
          "java": [
            "// The Random() generates identical sequences in the following cases\r\nimport java.util.Random;\r\nimport java.lang.Math;\r\n\r\npublic class msc02_0 {\r\n\r\n public void foo0() {\r\n Random number = new SecureRandom(); // use SecureRandom class \r\n for (int i = 0; i < 20; i++) {\r\n int n = number.nextInt();\r\n System.out.println(n);\r\n }\r\n }\r\n\r\n public void foo1() {\r\n Random number = new SecureRandom.getInstanceStrong(); // use strong algorithm \r\n System.out.println(number.nextLong());\r\n }\r\n\r\n}"
          ]
        },
        "bad": {
          "java": [
            "// The Random() generates identical sequences in all three cases\r\nimport java.util.Random;\r\nimport java.lang.Math;\r\n\r\npublic class msc02_0 {\r\n\r\n public void foo0() {\r\n Random number = new Random(123L);\r\n for (int i = 0; i < 20; i++) {\r\n int n = number.nextInt();\r\n System.out.println(n);\r\n }\r\n }\r\n\r\n public void foo1() {\r\n Random number = new Random();\r\n System.out.println(number.nextLong());\r\n }\r\n\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A3",
          "A5"
        ],
        "cwe": [
          "327"
        ]
      },
      "csv_string": [
        "M02J1",
        "M02J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 54,
      "category": "VUL",
      "language": "Java",
      "code": "SEC07-J",
      "name": "Call the superclass' getPermissions() method to implement a custom class loader",
      "desc": "The program has a custom class loader and failed to call the super.getPermission() method.",
      "msg_templ": "In file ${si.filename} at line ${si.line}, function ${si.func}, ${si.var} overrides getPermission() without invoking superclass' permission.",
      "severity": "H",
      "likelihood": "P",
      "cost": "L",
      "details": "#### Abstract\r\nThe program has a custom class loader and failed to call super.getPermission() method. \r\n\r\n#### Explanation\r\nThe program has a custom class loader to override the getPermission() method. The implementation should invoke the superclass's getPermission() to get the default system policy before assigning custom permission to the program. This way, both system wide security policies are also applied.\r\n",
      "examples": {
        "good": {
          "java": [
            "import java.net.URL;\r\nimport java.net.URLClassLoader;\r\nimport java.security.CodeSource;\r\nimport java.security.PermissionCollection;\r\nimport java.security.Permissions;\r\n\r\npublic class j_sec07_0 extends URLClassLoader { \r\n\r\n public j_sec07_0(URL[] urls) {\r\n super(urls);\r\n }\r\n\r\n protected PermissionCollection getPermissions(CodeSource cs) {\r\n // apply default system wide security policy\r\n PermissionCollection pc = superPermissions(cs);\r\n // Allow exit from the VM anytime\r\n pc.add(new RuntimePermission(\\\"exitVM\\\"));\r\n return pc;\r\n }\r\n\r\n public static boolean checkRtPermission(URL[] urls, String tag) {\r\n j_sec07_0 loader = new j_sec07_0(urls);\r\n PermissionCollection pc = loader.getPermissions(null);\r\n RuntimePermission rp = new RuntimePermission(tag);\r\n if(pc.implies(rp)) {\r\n System.out.println(\\\"Able to exit vm\\\");\r\n return true;\r\n } else {\r\n System.out.println(\\\"Not Able to exit VM\\\");\r\n return false;\r\n }\r\n }\r\n\r\n public static void main(String[] args) {\r\n URL[] urls = new URL[0];\r\n checkRtPermission(urls, \\\"exitVM\\\");\r\n checkRtPermission(urls, \\\"stopVM\\\");\r\n }\r\n\r\n}\r\n"
          ]
        },
        "bad": {
          "java": [
            "import java.net.URL;\r\nimport java.net.URLClassLoader;\r\nimport java.security.CodeSource;\r\nimport java.security.PermissionCollection;\r\nimport java.security.Permissions;\r\n\r\npublic class j_sec07_0 extends URLClassLoader { \r\n\r\n public j_sec07_0(URL[] urls) {\r\n super(urls);\r\n }\r\n\r\n protected PermissionCollection getPermissions(CodeSource cs) {\r\n PermissionCollection pc = new Permissions();\r\n // Allow exit from the VM anytime\r\n pc.add(new RuntimePermission(\\\"exitVM\\\"));\r\n return pc;\r\n }\r\n\r\n public static boolean checkRtPermission(URL[] urls, String tag) {\r\n j_sec07_0 loader = new j_sec07_0(urls);\r\n PermissionCollection pc = loader.getPermissions(null);\r\n RuntimePermission rp = new RuntimePermission(tag);\r\n if(pc.implies(rp)) {\r\n System.out.println(\\\"Able to exit vm\\\");\r\n return true;\r\n } else {\r\n System.out.println(\\\"Not Able to exit VM\\\");\r\n return false;\r\n }\r\n }\r\n\r\n public static void main(String[] args) {\r\n URL[] urls = new URL[0];\r\n checkRtPermission(urls, \\\"exitVM\\\");\r\n checkRtPermission(urls, \\\"stopVM\\\");\r\n }\r\n\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A9"
        ]
      },
      "csv_string": [
        "C07J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 55,
      "category": "VUL",
      "language": "Java",
      "code": "DCL00-J",
      "name": "Program should not have a class initialization cycle",
      "desc": "The program has a class initialization that forms a cycle.",
      "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line}, the class ${si.var} forms an initialization cycle.",
      "severity": "L",
      "likelihood": "U",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has class initialization that forms a cycle.\r\n\r\n#### Explanation\r\nStatic field triggers the initialization of a class. When the static field is dependent on the initialization of another class, a cycle will be created.\r\n",
      "examples": {
        "good": {
          "java": [
            "import java.util.Calendar;\r\npublic class j_dcl00_0 {\r\n private int elapse;\r\n private static final int curr_year = Calendar.getInstance().get(Calendar.YEAR);\r\n private static final j_dcl00_0 obj = new j_dcl00_0(); // curr_year is initialized before used in constructor\r\n \r\n public j_dcl00_0() {\r\n if(200 > Calendar.getInstance().get(Calendar.YEAR))\r\n elapse = curr_year - 2000; \r\n }\r\n\r\n public static void main(String[] args) {\r\n System.out.println(\\\"It was \\\" + obj.elapse + \\\" years since 2000\\\");\r\n }\r\n \r\n}"
          ]
        },
        "bad": {
          "java": [
            "import java.util.Calendar;\r\npublic class j_dcl00_0 {\r\n private int elapse;\r\n private static final j_dcl00_0 obj = new j_dcl00_0(); // self cycle (call constructor)\r\n private static final int curr_year = Calendar.getInstance().get(Calendar.YEAR);\r\n \r\n public j_dcl00_0() {\r\n if(200 > Calendar.getInstance().get(Calendar.YEAR))\r\n elapse = curr_year - 2000; // curr_year not initialized yet, due to constructor is called before curr_year assignment in line 73. \r\n // ( Remediate suggestion: swap lines 72 and line 73 will ensure initialized)\r\n }\r\n\r\n public static void main(String[] args) {\r\n System.out.println(\\\"It was \\\" + obj.elapse + \\\" years since 2000\\\");\r\n }\r\n \r\n}"
          ]
        }
      },
      "csv_string": [
        "D00J0"
      ],
      "standards": {},
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 56,
      "category": "VUL",
      "language": "Java",
      "code": "ENV03-J",
      "name": "Permissions should be granted explicitly and judiciously",
      "desc": "The program has called methods to grant permissions or a combination of permissions to the code.",
      "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line} with method ${si.var}, we detected a dangerous combination of permissions granted to an object.",
      "severity": "H",
      "likelihood": "L",
      "cost": "L",
      "details": "#### Abstract\r\nThe program has called methods to grant permissions or a combination of permissions to code, and this could be dangerous.\r\n\r\n#### Explanation\r\nA combination of permissions granting code could be dangerous. For example, when RuntimePermission is applied to createClassLoader it can create a custom class loader and assign arbitrary permissions. ReflectPermission and suppressAccessChecks together will suppress all standard checks. \r\n",
      "examples": {
        "good": {
          "java": [
            "import java.net.URL;\r\nimport java.net.URLClassLoader;\r\nimport java.net.MalformedURLException;\r\nimport java.security.cert.Certificate;\r\nimport java.security.CodeSource;\r\nimport java.security.PermissionCollection;\r\nimport java.security.Permissions;\r\nimport java.lang.reflect.*;\r\n\r\npublic class env03_0 extends URLClassLoader {\r\n\r\n public env03_0(URL[] urls) {\r\n super(urls);\r\n }\r\n\r\n protected PermissionCollection getPermissions(CodeSource cs) {\r\n PermissionCollection pc = super.getPermissions(cs);\r\n // ...\r\n // other permissions\r\n return pc;\r\n }\r\n\r\n public static boolean checkRtPermission(URL[] urls, String tag) throws MalformedURLException{\r\n env03_0 loader = new env03_0(urls);\r\n Certificate[] cert = null;\r\n CodeSource cs = new CodeSource(new URL(\"http://abc\"), cert);\r\n PermissionCollection pc = loader.getPermissions(cs);\r\n ReflectPermission rp = new ReflectPermission(tag);\r\n if(pc.implies(rp)) {\r\n System.out.println(\"Able to get suppressAccessChecks\");\r\n return true;\r\n } else {\r\n System.out.println(\"Not Able to get suppressAccessChecks\");\r\n return false;\r\n }\r\n }\r\n\r\n public static void main(String[] args) throws MalformedURLException{\r\n URL[] urls = new URL[0];\r\n checkRtPermission(urls, \"suppressAccessChecks\");\r\n }\r\n\r\n}\r\n"
          ]
        },
        "bad": {
          "java": [
            "import java.net.URL;\r\nimport java.net.URLClassLoader;\r\nimport java.net.MalformedURLException;\r\nimport java.security.cert.Certificate;\r\nimport java.security.CodeSource;\r\nimport java.security.PermissionCollection;\r\nimport java.security.Permissions;\r\nimport java.lang.reflect.*;\r\n\r\npublic class env03_0 extends URLClassLoader {\r\n\r\n public env03_0(URL[] urls) {\r\n super(urls);\r\n }\r\n\r\n protected PermissionCollection getPermissions(CodeSource cs) {\r\n PermissionCollection pc = super.getPermissions(cs); \r\n pc.add(new ReflectPermission(\"suppressAccessChecks\")); // add permission to create a class loader\r\n // includes granting \"suppressAccessChecks\"\r\n // ...\r\n // other permissions\r\n return pc;\r\n }\r\n\r\n public static boolean checkRtPermission(URL[] urls, String tag) throws MalformedURLException{\r\n env03_0 loader = new env03_0(urls);\r\n Certificate[] cert = null;\r\n CodeSource cs = new CodeSource(new URL(\"http://abc\"), cert);\r\n PermissionCollection pc = loader.getPermissions(cs);\r\n ReflectPermission rp = new ReflectPermission(tag);\r\n if(pc.implies(rp)) {\r\n System.out.println(\"Able to get suppressAccessChecks\");\r\n return true;\r\n } else {\r\n System.out.println(\"Not Able to get suppressAccessChecks\");\r\n return false;\r\n }\r\n }\r\n\r\n public static void main(String[] args) throws MalformedURLException{\r\n URL[] urls = new URL[0];\r\n checkRtPermission(urls, \"suppressAccessChecks\");\r\n }\r\n\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A2",
          "A5",
          "A6"
        ],
        "cwe": [
          "287",
          "732",
          "862"
        ]
      },
      "csv_string": [
        "N03J2",
        "N03J1",
        "N03J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 57,
      "category": "VUL",
      "language": "Java",
      "code": "ENV06-J",
      "name": "Debugged entry points should not remain in product code",
      "desc": "The program should strip all code used for debugging and is not intended to be shipped or deployed with the application.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, \"main\" is found, possibly left over for debugging purposes.",
      "severity": "H",
      "likelihood": "P",
      "cost": "L",
      "details": "#### Abstract\r\nThe program should strip all code used for debugging that is not intended to be shipped or deployed with the application. \r\n\r\n#### Explanation\r\nAlthough it is an acceptable practice to include \\\"main\\\" development, leaving that in production code could leave a backdoor entry point for an attacker. Methods that include \\\"main\\\" should be removed from production applications.\r\n",
      "examples": {
        "good": {
          "java": [
            "public class my_code {\r\n // DEBUG is set to false, but \\\"main\\\" is left behind\r\n private static final boolean DEBUG = false;\r\n // remove the following statement if DEBUG is set to FALSE\r\n // public static void main(String[] args) {\r\n // my_code f = new my_code();\r\n // }\r\n}"
          ]
        },
        "bad": {
          "java": [
            "public class my_code {\r\n // DEBUG is set to false, but \\\"main\\\" is left behind\r\n private static final boolean DEBUG = false;\r\n public static void main(String[] args) {\r\n my_code f = new my_code();\r\n }\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A2",
          "A9",
          "A3"
        ],
        "cwe": [
          "200"
        ]
      },
      "csv_string": [
        "N06J2",
        "N06J1",
        "N06J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 58,
      "category": "VUL",
      "language": "Java",
      "code": "ERR08-J",
      "name": "NullPointerException or any of its ancestors should not be caught",
      "desc": "The program is catching a NullPointerException.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, a NullPointerException is caught at the try block in function ${si.func}.",
      "severity": "M",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program is catching a NullPointerException. \r\n\r\n#### Explanation\r\nA NullPointerException thrown at runtime indicates an underlying defect that must be fixed in the application code. Catching this exception (or others like RuntimeException, Exception or Throwable) adds more runtime performance overhead. Furthermore, when this happens, the program is likely to be in an unknown state and any continued execution will cause unexpected results.\r\n",
      "examples": {
        "good": {
          "java": [
            "public class err08_0 {\r\n boolean isName(String s) {\r\n try {\r\n String names = s.concat(\"abc\");\r\n if (names.length() != 5) {\r\n return false;\r\n }\r\n return true;\r\n } \r\n }\r\n\r\n boolean foo1() {\r\n try {\r\n throw new RuntimeException(\"xyz\");\r\n } catch (RuntimeException e) {\r\n // this catch RuntimeException is ancestor of the NullPointerException\r\n return false;\r\n }\r\n }\r\n}"
          ]
        },
        "bad": {
          "java": [
            "public class err08_0 {\r\n boolean isName(String s) {\r\n try {\r\n String names = s.concat(\"abc\");\r\n if (names.length() != 5) {\r\n return false;\r\n }\r\n return true;\r\n } catch (NullPointerException e) {\r\n // catch Null pointer exception \r\n return false;\r\n }\r\n \r\n }\r\n\r\n boolean foo1() {\r\n try {\r\n throw new RuntimeException(\"xyz\");\r\n } catch (RuntimeException e) {\r\n // this catch RuntimeException is ancestor of the NullPointerException\r\n return false;\r\n }\r\n }\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A10"
        ],
        "cwe": [
          "476"
        ]
      },
      "csv_string": [
        "E08J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 59,
      "category": "VUL",
      "language": "Java",
      "code": "EXP02-J",
      "name": "The Object.equals() should not be used to compare two arrays",
      "desc": "The program is comparing two arrays using an Object.equals() method.",
      "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line}, Object.equals() has been used to compare ${si.var}.",
      "severity": "L",
      "likelihood": "L",
      "cost": "L",
      "details": "#### Abstract\r\nThe program is comparing two arrays using the Object.equals() method.\r\n\r\n#### Explanation\r\nTwo arrays are equal if they contain equivalent elements and in the same order. Using Object.equals() on arrays only compares array references, not their content.\r\n",
      "examples": {
        "good": {
          "java": [
            "// this example is modified from CERT-J site\r\nimport java.util.Arrays;\r\n\r\npublic class exp02_example {\r\n\r\n public static void println(int[] ar1, int[] ar2) {\r\n System.out.println(Arrays.equals(arr1, arr2)); // prints true\r\n }\r\n \r\n public static void main(String[] args) {\r\n int[] arr1 = new int[20]; // Initialized to 0\r\n int[] arr2 = new int[20]; // Initialized to 0\r\n println(arr1, arr2); \r\n }\r\n}"
          ]
        },
        "bad": {
          "java": [
            "// this example is modified from CERT-J site\r\nimport java.util.Arrays;\r\n\r\npublic class exp02_example {\r\n\r\n public static void println(int[] ar1, int[] ar2) {\r\n System.out.println(ar1.equals(ar2)); // prints false\r\n }\r\n \r\n public static void main(String[] args) {\r\n int[] arr1 = new int[20]; // Initialized to 0\r\n int[] arr2 = new int[20]; // Initialized to 0\r\n println(arr1, arr2); \r\n }\r\n}"
          ]
        }
      },
      "csv_string": [
        "X02J0"
      ],
      "standards": {},
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 60,
      "category": "VUL",
      "language": "Java",
      "code": "FIO02-J",
      "name": "File related errors should be checked and handled",
      "desc": "The program is attempting to manipulate a file but failed to check the validity of the return values from the method.",
      "msg_templ": "In file ${si.filename}, function ${si.func} at line ${si.line}, a new file object ${si.var} is requested. Subsequent call to such object at line ${si.line} fails to check if file manipulation is successful.",
      "severity": "M",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nThe program is attempting to manipulate a file but failed to check validity of the return values from the method.\r\n\r\n#### Explanation\r\nFile I/O operations in Java must check the return values of methods that perform the file I/O. For example, if not checked, File.delete() will silently fail.\r\n",
      "examples": {
        "good": {
          "java": [
            "import java.io.File;\r\nimport java.io.IOException;\r\n\r\npublic class j_fio02_0 {\r\n void foo(boolean b) {\r\n try {\r\n File f = new File(\"file\");\r\n if (b) {\r\n if (f.delete()) {\r\n System.out.println(\"Deletion error\");\r\n }\r\n }\r\n else {\r\n if (f.delete()) {\r\n System.out.println(\"Deletion error\");\r\n }\r\n \r\n }\r\n }\r\n catch(Exception e) {\r\n System.out.println(\"Exception\");\r\n }\r\n }\r\n}\r\n"
          ]
        },
        "bad": {
          "java": [
            "import java.io.File;\r\nimport java.io.IOException;\r\n\r\npublic class j_fio02_0 {\r\n void foo(boolean b) {\r\n try {\r\n File f = new File(\"file\");\r\n if (b) {\r\n if (f.delete()) {\r\n System.out.println(\"Deletion error\");\r\n }\r\n }\r\n else {\r\n f.delete(); // failed to check return value of delete()\r\n }\r\n }\r\n catch(Exception e) {\r\n System.out.println(\"Exception\");\r\n }\r\n }\r\n}"
          ]
        }
      },
      "standards": {
        "cwe": [
          "252"
        ]
      },
      "csv_string": [
        "F02J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 61,
      "category": "VUL",
      "language": "Java",
      "code": "FIO05-J",
      "name": "Buffers created with wrap() or duplicate() should not be exposed to untrusted code",
      "desc": "The program is using wrap() or duplicate() methods in buffer class in the java.nio package. These buffers are exposed to untrusted code in the program.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, the backing array of the buffer class ${si.var} can be exposed to untrusted code through function ${si.func}.",
      "severity": "M",
      "likelihood": "L",
      "cost": "L",
      "details": "#### Abstract\r\nThe program is using wrap() or duplicate() methods in buffer class in the java.nio package. These buffers are exposed to untrusted code in the program.\r\n\r\n#### Explanation\r\nThe methods will create a new Buffer object, backed by the given input array. Hence, the new Buffer object can be maliciously modified. It is important to use a read only Buffer or make sure the original buffer will not be modified. \r\n",
      "examples": {
        "good": {
          "java": [
            "// this example is modified from CERT-J example\r\nimport java.nio.CharBuffer;\r\n\r\npublic class j_fio05_0 {\r\n private char[] dataArray;\r\n private CharBuffer cb;\r\n\r\n public j_fio05_0() {\r\n dataArray = new char[10];\r\n }\r\n\r\n public CharBuffer getBufferCopy() {\r\n return CharBuffer.wrap(dataArray).asReadOnlyBuffer(); // attemp to modify will result in exception\r\n }\r\n}",
            "import java.nio.CharBuffer;\r\n\r\npublic class j_fio05_0 {\r\n private char[] dataArray;\r\n private CharBuffer cb;\r\n\r\n public j_fio05_0() {\r\n dataArray = new char[10];\r\n }\r\n\r\n public CharBuffer getBufferCopy() {\r\n return CharBuffer.wrap(dataArray).asReadOnlyBuffer();; // attempt to modify will result in exception\r\n }\r\n\r\n private void storeBuffer() {\r\n cb = CharBuffer.wrap(dataArray).asReadOnlyBuffer();; // attempt to modify will result in exception\r\n }\r\n\r\n public CharBuffer getBufferCopy2() {\r\n storeBuffer();\r\n return cb; \r\n }\r\n}"
          ]
        },
        "bad": {
          "java": [
            "// this example is modified from CERT-J example\r\nimport java.nio.CharBuffer;\r\n\r\npublic class j_fio05_0 {\r\n private char[] dataArray;\r\n private CharBuffer cb;\r\n\r\n public j_fio05_0() {\r\n dataArray = new char[10];\r\n }\r\n\r\n public CharBuffer getBufferCopy() {\r\n return CharBuffer.wrap(dataArray); // dataArray (private) is exposed through this wrap\r\n }\r\n}",
            "import java.nio.CharBuffer;\r\n\r\npublic class j_fio05_0 {\r\n private char[] dataArray;\r\n private CharBuffer cb;\r\n\r\n public j_fio05_0() {\r\n dataArray = new char[10];\r\n }\r\n\r\n public CharBuffer getBufferCopy() {\r\n return CharBuffer.wrap(dataArray); // dataArray (private) is exposed through this wrap\r\n }\r\n\r\n private void storeBuffer() {\r\n cb = CharBuffer.wrap(dataArray); // dataArray (private) is exposed, see comment in return statement below\r\n }\r\n\r\n public CharBuffer getBufferCopy2() {\r\n storeBuffer();\r\n return cb; // dataArray is exposed through cb which is assigned in storeBuffer()\r\n }\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A3",
          "A2"
        ],
        "cwe": [
          "522"
        ]
      },
      "csv_string": [
        "F05J1",
        "F05J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 62,
      "category": "VUL",
      "language": "Java",
      "code": "FIO14-J",
      "name": "At program termination, proper cleanup should be performed through Runtime.exit()",
      "desc": "The program did not perform a proper cleanup when the program terminated.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, resource associated with ${si.var} will not be properly cleaned up when the program is terminated.",
      "severity": "M",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program did not perform a proper cleanup when the program terminated.\r\n\r\n#### Explanation\r\nWhen irrecoverable errors are detected, it is common to quickly shut down the system and allow the operator to start over in a determinate state. This should include cleanup of the external resources. Failure to do so may leave important and sensitive data behind in the system.\r\n",
      "examples": {
        "good": {
          "java": [
            "import java.io.*;\r\n\r\npublic class fio14_example {\r\n public static void reg_hook(PrintStream out) {\r\n // shut down hook will be called when Runtime.exit(),\r\n // make sure in call hierarchy,\r\n // there is an edge from Runtime.exit() to Runtime.addShutdownHook\r\n Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {\r\n public void run() {\r\n System.out.println(\"exit without closing file, need out.close()\");\r\n out.close(); // report double close\r\n }\r\n }\r\n ));\r\n }\r\n\r\n public static void close2() throws FileNotFoundException {\r\n final PrintStream out =\r\n new PrintStream(new BufferedOutputStream(\r\n new FileOutputStream(\"foo.txt\")));\r\n reg_hook(out);\r\n out.println(\"hello\");\r\n Runtime.getRuntime().exit(1);\r\n }\r\n public static void main(String[] args) throws FileNotFoundException{\r\n close2();\r\n }\r\n}"
          ]
        },
        "bad": {
          "java": [
            "import java.io.*;\r\n\r\npublic class fio14_example {\r\n public static void reg_hook(PrintStream out) {\r\n // shut down hook will be called when Runtime.exit(),\r\n // make sure in call hierarchy,\r\n // there is an path from Runtime.exit() to Runtime.addShutdownHook\r\n Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {\r\n public void run() {\r\n System.out.println(\"exit without closing file, need out.close()\");\r\n out.close(); // report double close\r\n }\r\n }\r\n ));\r\n }\r\n\r\n public static void close2() throws FileNotFoundException {\r\n final PrintStream out =\r\n new PrintStream(new BufferedOutputStream(\r\n new FileOutputStream(\"foo.txt\")));\r\n reg_hook(out);\r\n out.println(\"register hook\");\r\n Runtime.getRuntime().exit(1);\r\n }\r\n public static void main(String[] args) throws FileNotFoundException{\r\n close2();\r\n }\r\n}\r\n"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A3"
        ],
        "cwe": [
          "705"
        ]
      },
      "csv_string": [
        "F14J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 63,
      "category": "VUL",
      "language": "Java",
      "code": "FIO16-J",
      "name": "Please canonicalize path names before validating them",
      "desc": "The program is validating pathnames without first canonicalizing them.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, the file name string ${si.var} in function ${si.func} is not canonicalized before the file is opened.",
      "severity": "M",
      "likelihood": "U",
      "cost": "M",
      "details": "#### Abstract\r\nThe program is validating pathnames without first canonicalizing them.\r\n\r\n#### Explanation\r\nPathnames may contain special characters that make validation difficult. Also, a pathname may be symbolic links or shadows which attackers could use to bypass security check. It is important to fully resolve/canonicalize a pathname before validation. \r\n",
      "examples": {
        "good": {
          "java": [
            "import javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport java.io.*;\r\n\r\npublic class fio16_example\r\n{\r\n\r\n public void bad_1(HttpServletRequest request, HttpServletResponse response) throws IOException\r\n {\r\n String fname = request.getParameter(\"FileName\");\r\n String info = request.getParameter(\"Info\");\r\n File fp = new File(fname);\r\n \r\n { \r\n String uniqPath = fp.getCanonicalPath();\r\n // va;odate after calling getCanonicalPath\r\n if (fp.exists() && is_safe(uniqPath) { \r\n FileOutputStream writer = new FileOutputStream(uniqPath);\r\n writer.write(info.getBytes());\r\n writer.close(); // info is written to validated location\r\n }\r\n }\r\n }\r\n \r\n private Boolean is_safe(String path)\r\n {\r\n // do path validation\r\n if(path.startsWith(\"/share/user\")) {\r\n return true;\r\n } else {\r\n return false;\r\n }\r\n }\r\n}"
          ]
        },
        "bad": {
          "java": [
            "import javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport java.io.*;\r\n\r\npublic class fio16_example\r\n{\r\n\r\n public void bad_1(HttpServletRequest request, HttpServletResponse response) throws IOException\r\n {\r\n String fname = request.getParameter(\"FileName\");\r\n String info = request.getParameter(\"Info\");\r\n File fp = new File(fname);\r\n \r\n if(fp.exists() && is_safe(fname)) { // fp validated but before calling getCanonicalPath,\r\n // hacker can bypass the validateion\r\n String uniqPath = fp.getCanonicalPath();\r\n FileOutputStream writer = new FileOutputStream(uniqPath);\r\n writer.write(info.getBytes());\r\n writer.close(); // info may be written to unkown location\r\n }\r\n }\r\n \r\n private Boolean is_safe(String path)\r\n {\r\n // do path validation\r\n if(path.startsWith(\"/share/user\")) {\r\n return true;\r\n } else {\r\n return false;\r\n }\r\n }\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A2",
          "A5"
        ],
        "cwe": [
          "22",
          "647"
        ]
      },
      "csv_string": [
        "F16J2",
        "F16J1"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 64,
      "category": "VUL",
      "language": "Java",
      "code": "IDS00-J",
      "name": "String input to any SQL query must be sanitized before the query",
      "desc": "String input to any SQL query must be sanitized before the query.",
      "msg_templ": "In file ${si.filename}, function ${si.func} the string ${si.var} is not sanitized before the SQL query at line ${si.line}.",
      "severity": "H",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nString input to any SQL query must be sanitized before the query.\r\n\r\n#### Explanation\r\nStrings that originated from an untrusted source must go through a sanitization and validation process to avoid being used as malicious input to a SQL database. Failure to do so may cause data leakage and privacy violations.\r\n",
      "examples": {
        "good": {
          "java": [
            "import java.sql.DriverManager;\r\nimport java.sql.PreparedStatement;\r\nimport java.sql.ResultSet;\r\nimport java.sql.SQLException;\r\nimport java.sql.Statement;\r\n\r\npublic class j_ids00_2 {\r\n\r\n public Connection getConnection() throws SQLException {\r\n String dbConnection = System.getProperty(\\\"db.connection\\\");\r\n return DriverManager.getConnection(dbConnection);\r\n }\r\n\r\n String hashPwd(char[] pwd) {\r\n // Create hash of password\r\n return new String(pwd);\r\n }\r\n\r\n public void doPrivilegedAction(\r\n String username, char[] password // username is unsanitized \r\n ) throws SQLException, SecurityException {\r\n Connection connection = getConnection();\r\n if (connection == null) {\r\n // Handle error\r\n }\r\n try {\r\n String pwd = hashPwd(password);\r\n // the string query is composed with sanitized string (username) input\r\n PreparedStatement stmt = connection.prepareStatement(\\\"SELECT * FROM db_user WHERE username = ? AND passwd = ?\\\");\r\n \r\n // use set*() to enforce strong type checking\r\n stmt.setString(1, username); // to be sure, username may still be considered \\\"tainted\\\"\r\n stmt.setString(2, pwd); // to be sure, pwd ma still be considered \\\"tainted\\\" \r\n\r\n ResultSet result = stmt.executeQuery();\r\n if (!result.next()) {\r\n throw new SecurityException(\\\"User name/password incorrect\\\");\r\n }\r\n\r\n // Authenticated\r\n } finally {\r\n try {\r\n connection.close();\r\n } catch (SQLException x) {\r\n // Forward to handler\r\n }\r\n }\r\n }\r\n}"
          ]
        },
        "bad": {
          "java": [
            "import java.sql.DriverManager;\r\nimport java.sql.PreparedStatement;\r\nimport java.sql.ResultSet;\r\nimport java.sql.SQLException;\r\nimport java.sql.Statement;\r\n\r\npublic class j_ids00_2 {\r\n\r\n public Connection getConnection() throws SQLException {\r\n String dbConnection = System.getProperty(\\\"db.connection\\\");\r\n return DriverManager.getConnection(dbConnection);\r\n }\r\n\r\n String hashPwd(char[] pwd) {\r\n // Create hash of password\r\n return new String(pwd);\r\n }\r\n\r\n public void doPrivilegedAction(\r\n String username, char[] password // username is unsanitized \r\n ) throws SQLException, SecurityException {\r\n Connection connection = getConnection();\r\n if (connection == null) {\r\n // Handle error\r\n }\r\n try {\r\n String pwd = hashPwd(password);\r\n // the string query is composed with unsanitized string (username) input\r\n String query = \\\"SELECT * from where product username =\\\" +\r\n username + \\\" and password =\\\" + pwd;\r\n \r\n PreparedStatement stmt = connection.prepareStatement(query);\r\n\r\n ResultSet result = stmt.executeQuery();\r\n if (!result.next()) {\r\n throw new SecurityException(\\\"User name/password incorrect\\\");\r\n }\r\n\r\n // Authenticated\r\n } finally {\r\n try {\r\n connection.close();\r\n } catch (SQLException x) {\r\n // Forward to handler\r\n }\r\n }\r\n }\r\n}\r\n"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A1",
          "A5",
          "A2"
        ],
        "cwe": [
          "116",
          "943",
          "564",
          "89"
        ],
        "p3c-sec": [
          "3",
          "5",
          "4"
        ]
      },
      "csv_string": [
        "I00J3",
        "I00J2",
        "I00J1",
        "I00J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 65,
      "category": "VUL",
      "language": "Java",
      "code": "IDS01-J",
      "name": "Do not validate strings that have not been normalized",
      "desc": "The program is validating strings that have not been normalized.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, the string is validated in function ${si.var} before being normalizedã€‚",
      "severity": "H",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nThe program is validating strings that have not been normalized.\r\n\r\n#### Explanation\r\nStrings have many representations such as \\\"char\\\", \\\"unicode\\\", etc. Many filtering or validation mechanisms are based on the strings' character data. Failure to filter out or normalize the string before validation could end up bypassing the validation mechanism, resulting in execution of arbitrary code.\r\n",
      "examples": {
        "good": {
          "java": [
            "import java.text.Normalizer;\r\nimport java.text.Normalizer.Form;\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n \r\npublic class j_ids01_0 { // inspired by CERT-J example\r\n public static String filterString(String str) {\r\n \r\n // Normalization form for validate String is NFKC\r\n String s = Normalizer.normalize(str, Form.NFKC); \r\n // compliant - Validate after the string is normalized\r\n Pattern pattern = Pattern.compile(\\\"<script>\\\");\r\n Matcher matcher = pattern.matcher(str);\r\n if (matcher.find()) {\r\n throw new IllegalArgumentException(\\\"Invalid input\\\");\r\n }\r\n return s;\r\n }\r\n \r\n public static void main(String[] args) {\r\n // \\\"\\\\ \\\" is a noncharacter code point\r\n String maliciousInput = \\\"<scr\\\" + \\\"\\\\ \\\" + \\\"ipt>\\\";\r\n String sb = filterString(maliciousInput);\r\n // sb = \\\"<script>\\\"\r\n }\r\n}\r\n"
          ]
        },
        "bad": {
          "java": [
            "import java.text.Normalizer;\r\nimport java.text.Normalizer.Form;\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n \r\npublic class j_ids01_0 { // inspired by CERT-J example\r\n public static String filterString(String str) {\r\n \r\n // Non-compliant - Validate before the string is normalized\r\n Pattern pattern = Pattern.compile(\\\"<script>\\\");\r\n Matcher matcher = pattern.matcher(str);\r\n if (matcher.find()) {\r\n throw new IllegalArgumentException(\\\"Invalid input\\\");\r\n }\r\n // Normalization form for validate String is NFKC\r\n String s = Normalizer.normalize(str, Form.NFKC); \r\n return s;\r\n }\r\n \r\n public static void main(String[] args) {\r\n // \\\"\\\\ \\\" is a noncharacter code point\r\n String maliciousInput = \\\"<scr\\\" + \\\"\\\\ \\\" + \\\"ipt>\\\";\r\n String sb = filterString(maliciousInput);\r\n // sb = \\\"<script>\\\"\r\n }\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A7",
          "A5",
          "A2"
        ],
        "cwe": [
          "180",
          "289",
          "79"
        ],
        "p3c-sec": [
          "4"
        ]
      },
      "csv_string": [
        "I01J2",
        "I01J1",
        "I01J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 66,
      "category": "VUL",
      "language": "Java",
      "code": "IDS11-J",
      "name": "Do not modify a string that has gone through validation",
      "desc": "The program has changed a string that has gone through validation.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, the program modified the string ${si.var} that had been validated but now made untrusted again.",
      "severity": "H",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has changed a string that has gone through validation.\r\n\r\n#### Explanation\r\nA string is modified after going through validation for processing.  The string may in turn become untrusted again which nullifies the previous validation effort. \r\n",
      "examples": {
        "good": {
          "java": [
            "import java.text.Normalizer;\r\nimport java.text.Normalizer.Form;\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n \r\npublic class j_ids11_0 {\r\n public static String filterString(String s) {\r\n // Normalize input string\r\n String str = Normalizer.normalize(s, Form.NFKC);\r\n \r\n // Delete noncharacter code\r\n // input string may have noncharacter code\r\n // however, the new string formed should go through normalize and validation again\r\n str = str.replaceAll(\\\"[\\\\\\\\p{Cn}]\\\", \\\"\\\");\r\n \r\n // Validate input after normalization\r\n Pattern pattern = Pattern.compile(\\\"<script>\\\");\r\n Matcher matcher = pattern.matcher(str);\r\n if (matcher.find()) {\r\n throw new IllegalArgumentException(\\\"Invalid input\\\");\r\n }\r\n \r\n return str;\r\n }\r\n // ... more code \r\n}"
          ]
        },
        "bad": {
          "java": [
            "import java.text.Normalizer;\r\nimport java.text.Normalizer.Form;\r\nimport java.util.regex.Matcher;\r\nimport java.util.regex.Pattern;\r\n \r\npublic class j_ids11_0 {\r\n public static String filterString(String s) {\r\n // Normalize input string\r\n String str = Normalizer.normalize(s, Form.NFKC);\r\n \r\n // Validate input after normalization\r\n Pattern pattern = Pattern.compile(\\\"<script>\\\");\r\n Matcher matcher = pattern.matcher(str);\r\n if (matcher.find()) {\r\n throw new IllegalArgumentException(\\\"Invalid input\\\");\r\n }\r\n \r\n // Delete noncharacter code\r\n // input string may have noncharacter code\r\n // however, the new string formed should go through normalize and validation again\r\n str = str.replaceAll(\\\"[\\\\\\\\p{Cn}]\\\", \\\"\\\");\r\n return str;\r\n }\r\n // ... more code \r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A7",
          "A2",
          "A3"
        ],
        "cwe": [
          "182"
        ],
        "p3c-sec": [
          "4"
        ]
      },
      "csv_string": [
        "I11J2",
        "I11J1",
        "I11J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 67,
      "category": "VUL",
      "language": "Java",
      "code": "IDS17-J",
      "name": "Improperly configured XML parser could cause XML external entity attack",
      "desc": "An external declaration that defines an external entity (typically specified by an URI) should be properly filtered.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, an external declaration is not properly filtered.",
      "severity": "M",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nAn external declaration that defines an external entity (typically specified by an URI) should be properly filtered. \r\n\r\n#### Explanation\r\nThe external entities should be filtered, either through a whitelist or pre-registration so that XML attacks can be contained. Failure to do so could result in denial of service or data leakage.\r\n",
      "examples": {
        "good": {
          "java": [
            "import java.io.IOException;\r\nimport org.xml.sax.EntityResolver;\r\nimport org.xml.sax.InputSource;\r\nimport org.xml.sax.SAXException;\r\nimport java.io.FileInputStream;\r\nimport java.io.InputStream;\r\n\r\nimport javax.xml.parsers.ParserConfigurationException;\r\nimport javax.xml.parsers.SAXParser;\r\nimport javax.xml.parsers.SAXParserFactory;\r\nimport org.xml.sax.XMLReader;\r\nimport org.xml.sax.helpers.DefaultHandler;\r\n\r\nclass ids17_CustomResolver implements EntityResolver {\r\n public InputSource resolveEntity(String publicId, String systemId)\r\n throws SAXException, IOException {\r\n // Check by whitelist good entity\r\n ....\r\n }\r\n}\r\n \r\npublic class ids17_example{\r\n private static void bad_receiveXMLStream(InputStream inStream,\r\n DefaultHandler defaultHandler)\r\n throws ParserConfigurationException, SAXException, IOException {\r\n SAXParserFactory factory = SAXParserFactory.newInstance();\r\n SAXParser saxParser = factory.newSAXParser();\r\n saxParser.parse(inStream, defaultHandler); // IDS17-J\r\n }\r\n\r\n private static void bad_receiveXMLStream2(InputStream inStream,\r\n DefaultHandler defaultHandler,\r\n Boolean do_sanitize) \r\n throws ParserConfigurationException, SAXException, IOException {\r\n try {\r\n SAXParserFactory factory = SAXParserFactory.newInstance();\r\n SAXParser saxParser = factory.newSAXParser();\r\n\r\n XMLReader reader = saxParser.getXMLReader();\r\n reader.setContentHandler(defaultHandler);\r\n // always sanitize\r\n reader.setEntityResolver(new ids17_CustomResolver()); // sanitized\r\n \r\n InputSource is = new InputSource(inStream);\r\n reader.parse(is); // no IDS17 complaince issue \r\n } catch (java.net.MalformedURLException mue) {\r\n System.err.println(\\\"Malformed URL Exception: \\\" + mue);\r\n }\r\n }\r\n\r\n \r\n public static void main(String[] args) throws ParserConfigurationException,\r\n SAXException, IOException {\r\n // invokes bad_receiveXMLStream and bad_receiveXMLStream2\r\n // ...\r\n }\r\n}"
          ]
        },
        "bad": {
          "java": [
            "import java.io.IOException;\r\nimport org.xml.sax.EntityResolver;\r\nimport org.xml.sax.InputSource;\r\nimport org.xml.sax.SAXException;\r\nimport java.io.FileInputStream;\r\nimport java.io.InputStream;\r\n\r\nimport javax.xml.parsers.ParserConfigurationException;\r\nimport javax.xml.parsers.SAXParser;\r\nimport javax.xml.parsers.SAXParserFactory;\r\nimport org.xml.sax.XMLReader;\r\nimport org.xml.sax.helpers.DefaultHandler;\r\n\r\nclass ids17_CustomResolver implements EntityResolver {\r\n public InputSource resolveEntity(String publicId, String systemId)\r\n throws SAXException, IOException {\r\n // Check by whitelist good entity\r\n ....\r\n }\r\n}\r\n \r\npublic class ids17_example{\r\n private static void bad_receiveXMLStream(InputStream inStream,\r\n DefaultHandler defaultHandler)\r\n throws ParserConfigurationException, SAXException, IOException {\r\n SAXParserFactory factory = SAXParserFactory.newInstance();\r\n SAXParser saxParser = factory.newSAXParser();\r\n saxParser.parse(inStream, defaultHandler); // IDS17-J\r\n }\r\n\r\n private static void bad_receiveXMLStream2(InputStream inStream,\r\n DefaultHandler defaultHandler,\r\n Boolean do_sanitize) \r\n throws ParserConfigurationException, SAXException, IOException {\r\n try {\r\n SAXParserFactory factory = SAXParserFactory.newInstance();\r\n SAXParser saxParser = factory.newSAXParser();\r\n\r\n XMLReader reader = saxParser.getXMLReader();\r\n reader.setContentHandler(defaultHandler);\r\n if(do_sanitize) {\r\n reader.setEntityResolver(new ids17_CustomResolver()); // sanitized\r\n }\r\n InputSource is = new InputSource(inStream);\r\n reader.parse(is); // IDS17-J, not setEntityResolver if !do_sanitize\r\n } catch (java.net.MalformedURLException mue) {\r\n System.err.println(\\\"Malformed URL Exception: \\\" + mue);\r\n }\r\n }\r\n\r\n \r\n public static void main(String[] args) throws ParserConfigurationException,\r\n SAXException, IOException {\r\n // invokes bad_receiveXMLStream and bad_receiveXMLStream2\r\n // ...\r\n }\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A4",
          "A1"
        ],
        "cwe": [
          "611",
          "116",
          "776"
        ]
      },
      "csv_string": [
        "I17J2",
        "I17J1",
        "I17J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 68,
      "category": "VUL",
      "language": "Java",
      "code": "MET06-J",
      "name": "Do not call overridable methods in clone()",
      "desc": "The program has called overridable methods in clone().",
      "msg_templ": "In file ${si.filename}, line ${si.line}, the overridable method ${si.var}, has been overridden by clone().",
      "severity": "M",
      "likelihood": "P",
      "cost": "L",
      "details": "#### Abstract\r\nThe program has called overridable methods in clone().\r\n\r\n#### Explanation\r\nA malicious subclass could override the methods in clone() causing insecure or unpredictable behavior. Also, trusted subclasses could modify cloned objects which are in the construction process such that the object being cloned will be in an inconsistent state.\r\n",
      "examples": {
        "good": {
          "java": [
            "import java.net.HttpCookie;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\nclass j_met06 implements Cloneable {\r\n HttpCookie[] cookies;\r\n\r\n j_met06(HttpCookie[] c) {\r\n cookies = c;\r\n }\r\n\r\n public Object clone() throws CloneNotSupportedException {\r\n // get shallow copy of object\r\n final j_met06 clone = (j_met06) super.clone();\r\n clone.doSomething(); // Can invoke overridable method\r\n\r\n // the class has mutable object, need to deep copy those field\r\n clone.cookies = clone.deepCopy();\r\n return clone;\r\n }\r\n\r\n final void doSomething() { // not overridable method\r\n for (int i = 0; i < cookies.length; i++) {\r\n cookies[i].setValue(\\\"\\\" + i);\r\n }\r\n }\r\n\r\n final HttpCookie[] deepCopy() { // not overridable method\r\n if (cookies == null) {\r\n throw new NullPointerException();\r\n }\r\n\r\n // implements deep copy\r\n List<HttpCookie> cloned_cookie = new ArrayList<>();\r\n // ...\r\n return (HttpCookie[]) cloned_cookie;\r\n }\r\n}\r\n\r\nclass j_met06_ext extends j_met06 {\r\n j_met06_ext(HttpCookie[] c) {\r\n super(c);\r\n }\r\n\r\n public Object clone() throws CloneNotSupportedException {\r\n final j_met06_ext clone = (j_met06_ext) super.clone();\r\n clone.doSomething();\r\n return clone;\r\n }\r\n\r\n void doSomething() { // will not be called\r\n for (int i = 0;i < cookies.length; i++) {\r\n cookies[i].setDomain(i + \\\".xxx.com\\\");\r\n }\r\n }\r\n\r\n public static void main(String[] args)\r\n throws CloneNotSupportedException {\r\n HttpCookie[] hc = new HttpCookie[20];\r\n for (int i = 0 ; i < hc.length; i++){\r\n hc[i] = new HttpCookie(\\\"cookie\\\" + i,\\\"\\\" + i);\r\n }\r\n // deep copy was invoked, the original object cannot be modified\r\n j_met06 badcookie = new j_met06_ext(hc);\r\n badcookie.clone();\r\n }\r\n}\r\n"
          ]
        },
        "bad": {
          "java": [
            "// this example is extended from CERT site\r\nimport java.net.HttpCookie;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\nclass j_met06 implements Cloneable {\r\n HttpCookie[] cookies;\r\n\r\n j_met06(HttpCookie[] c) {\r\n cookies = c;\r\n }\r\n\r\n public Object clone() throws CloneNotSupportedException {\r\n // get shallow copy of object\r\n final j_met06 clone = (j_met06) super.clone();\r\n clone.doSomething(); // Can invoke overridable method\r\n\r\n // the class has mutable object, need to deep copy those field\r\n clone.cookies = clone.deepCopy();\r\n return clone;\r\n }\r\n\r\n void doSomething() { // Overridable method\r\n for (int i = 0; i < cookies.length; i++) {\r\n cookies[i].setValue(\\\"\\\" + i);\r\n }\r\n }\r\n\r\n HttpCookie[] deepCopy() {\r\n if (cookies == null) {\r\n throw new NullPointerException();\r\n }\r\n\r\n // implements deep copy\r\n List<HttpCookie> cloned_cookie = new ArrayList<>();\r\n // ...\r\n return (HttpCookie[]) cloned_cookie;\r\n }\r\n}\r\n\r\nclass j_met06_ext extends j_met06 {\r\n j_met06_ext(HttpCookie[] c) {\r\n super(c);\r\n }\r\n\r\n public Object clone() throws CloneNotSupportedException {\r\n final j_met06_ext clone = (j_met06_ext) super.clone();\r\n clone.doSomething();\r\n return clone;\r\n }\r\n\r\n void doSomething() { // Erroneously executed\r\n for (int i = 0;i < cookies.length; i++) {\r\n cookies[i].setDomain(i + \\\".xxx.com\\\");\r\n }\r\n }\r\n\r\n public static void main(String[] args)\r\n throws CloneNotSupportedException {\r\n HttpCookie[] hc = new HttpCookie[20];\r\n for (int i = 0 ; i < hc.length; i++){\r\n hc[i] = new HttpCookie(\\\"cookie\\\" + i,\\\"\\\" + i);\r\n }\r\n // shallow copy was invoked, the original object can be modified\r\n j_met06 badcookie = new j_met06_ext(hc);\r\n badcookie.clone();\r\n }\r\n}\r\n"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A5",
          "A2"
        ]
      },
      "csv_string": [
        "T06J1",
        "T06J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 69,
      "category": "VUL",
      "language": "Java",
      "code": "MSC61-J",
      "name": "Security critical code must avoid using insecure or weak crypto algorithms",
      "desc": "The program is using weak cryptographic algorithms for security sensitive code.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, the encryption method ${si.var} in function ${si.func} used is generally weak and insecure.",
      "severity": "M",
      "likelihood": "P",
      "cost": "H",
      "details": "#### Abstract\r\nThe program is using weak cryptographic algorithms for security sensitive code.\r\n\r\n#### Explanation\r\nSecurity and privacy sensitive information should be using strong encryption algorithms. Strong algorithms may include AES with Galois/Counter Mode (GCM) and AES with Cipher Block Chaining mode.\r\n",
      "examples": {
        "good": {
          "java": [
            "import javax.crypto.*;\r\nimport java.io.UnsupportedEncodingException;\r\nimport java.security.InvalidKeyException;\r\nimport java.security.NoSuchAlgorithmException;\r\n\r\npublic class j_msc61_0 {\r\n \r\n public static SecretKey genKey() {\r\n // DES is a weak encryption algorithm\r\n // AES is also weak, however, if AES is to be used\r\n // GCM (Galois/Counter Mode) will do the encryption\r\n try {\r\n KeyGenerator keygen = KeyGenerator.getInstance(\\\"AES\\\");\r\n keygen.init(128);\r\n return keygen.generateKey();\r\n } catch (NoSuchAlgorithmException e) {\r\n // handle exception\r\n ...\r\n }\r\n }\r\n \r\n public static byteArray[] encryption(String strToBeEncrypted, SecretKey seckey) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, UnsupportedEncodingException, BadPaddingException, IllegalBlockSizeException {\r\n Cipher cipher = Cipher.getInstance(\\\"AES/GCM/NoPadding\\\");\r\n // please consult example in CERT-J site for MSC61-J\r\n ...\r\n }\r\n}"
          ]
        },
        "bad": {
          "java": [
            "import javax.crypto.*;\r\nimport java.io.UnsupportedEncodingException;\r\nimport java.security.InvalidKeyException;\r\nimport java.security.NoSuchAlgorithmException;\r\n\r\npublic class j_msc61_0 {\r\n public static byteArray[] encryption(String strToBeEncrypted) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, UnsupportedEncodingException, BadPaddingException, IllegalBlockSizeException {\r\n \r\n // DES is a weak encryption algorithm\r\n // AES is also weak, however, if AES is to be used\r\n // GCM (Galois/Counter Mode) will do the encryption\r\n SecretKey key = KeyGenerator.getInstance(\\\"DES\\\").generateKey();\r\n Cipher cipher = Cipher.getInstance(\\\"DES\\\");\r\n cipher.init(Cipher.ENCRYPT_MODE, key);\r\n\r\n // Encode bytes as UTF8; strToBeEncrypted contains\r\n // the input string that is to be encrypted\r\n byteArray[] encoded = strToBeEncrypted.getBytes(\\\"UTF8\\\");\r\n\r\n // Perform encryption\r\n byteArray[] encrypted = cipher.doFinal(encoded);\r\n return encrypted;\r\n }\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A3"
        ],
        "cwe": [
          "325",
          "326"
        ]
      },
      "csv_string": [
        "M61J1",
        "M61J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 70,
      "category": "VUL",
      "language": "Java",
      "code": "OBJ09-J",
      "name": "Comparing class names may cause mix and match attacks",
      "desc": "Comparing class names may cause mix and match attacks.",
      "msg_templ": "In file ${si.filename} function ${si.func}, line ${si.line}, name is used to compare classes.",
      "severity": "H",
      "likelihood": "U",
      "cost": "L",
      "details": "#### Abstract\r\nComparing class names may cause mix and match attacks.\r\n\r\n#### Explanation\r\nTwo classes are the same class only if they have the same qualified names. Classes with the same name may have different package names. Also distinct class loaders (or different instances of the class loader) will result in different classes with the same fully qualified names. \r\n",
      "examples": {
        "good": {},
        "bad": {
          "java": [
            "import java.lang.String;\r\npublic class j_obj09_1 {\r\n void callComp(Boolean v) {\r\n Class cls1 = getClass();\r\n Class cls2 = String.class;\r\n if(v) {\r\n badComp1(cls1.getName()); \r\n } else {\r\n badComp2(cls1.getName(), cls2.getName());\r\n }\r\n }\r\n Boolean badComp1(String clsName) {\r\n if(clsName.equals(\\\"j_obj09_0\\\")) {\r\n return true;\r\n }\r\n else {\r\n return false;\r\n }\r\n } \r\n\r\n Boolean badComp2(String name1, String name2)\r\n {\r\n if(name1.equals(name2)) {\r\n return true;\r\n }\r\n else {\r\n return false;\r\n }\r\n }\r\n}"
          ]
        }
      },
      "csv_string": [
        "O09J"
      ],
      "standards": {},
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 71,
      "category": "VUL",
      "language": "Java",
      "code": "OBJ11-J",
      "name": "Constructors should not throw exceptions",
      "desc": "Constructors throwing exceptions could leave the object in a partially initialized state.",
      "msg_templ": "Constructor ${si.func}, is throwing exception ${si.var} in ${si.filename}, line ${si.line}.",
      "severity": "H",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nConstructors throwing exceptions could leave the object in a partially initialized state.\r\n\r\n#### Explanation\r\nDuring objection construction, the object is in a partially initialized state. Throwing exceptions during construction could leave the object in an unstable state.\r\n",
      "examples": {
        "good": {},
        "bad": {
          "java": [
            "import java.io.IOException;\r\n\r\npublic class obj11_0 {\r\n public obj11_0()\r\n {\r\n // by throwing an exception in constructor\r\n // attacker can capture a reference to the partially initialized object of the obj11_0 class since\r\n // the object reference remains in the garbge collector\r\n if (!performVerification()) {\r\n throw new SecurityException(\\\"Access Denied!\\\");\r\n }\r\n }\r\n\r\n private boolean performVerification() {\r\n return false; // Returns true if data entered is valid, else false\r\n // Assume that the attacker always enters an invalid value\r\n }\r\n\r\n public void greeting() {\r\n System.out.println(\\\"Welcome user!\\\");\r\n }\r\n}"
          ]
        }
      },
      "csv_string": [
        "O11J0"
      ],
      "standards": {},
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 72,
      "category": "VUL",
      "language": "Java",
      "code": "SEC02-J",
      "name": "Security check code should not be based on untrusted sources",
      "desc": "The program has security checks whose sources are possibly from an untrusted origin.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, the method ${si.func} is returning untrusted sources to ${si.var} under assumed checked security.",
      "severity": "H",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has security checks whose sources are possibly from an untrusted origin.\r\n\r\n#### Explanation\r\nUntrusted code may have been from many different sources. The check method could be bypassed through overriding. The checked object may be overridden also after the check. Even if the object is saved after passing the security check, the copy method itself may not be sufficient if the method is not thorough enough (such as shallow copy).\r\n",
      "examples": {
        "good": {
          "java": [
            "import java.io.FileNotFoundException;\r\nimport java.io.RandomAccessFile;\r\nimport java.security.AccessController;\r\nimport java.security.PrivilegedAction;\r\nimport java.io.IOException;\r\n\r\npublic class sec02_0 {\r\n public static RandomAccessFile openFile(final java.io.File f) {\r\n // get a copy through getPath(), but not a clone\r\n final java.io.File copy = new java.io.File(f.getPath());\r\n // use copy of path later on\r\n if (copy.getPath().contains(\\\"passwd\\\")){\r\n return null;\r\n };\r\n // ...\r\n return (RandomAccessFile) AccessController.doPrivileged(new PrivilegedAction<Object>() {\r\n public Object run() {\r\n try {\r\n return new RandomAccessFile(copy.getPath(), \\\"r\\\");\r\n } catch (FileNotFoundException e) {\r\n e.printStackTrace();\r\n }\r\n return null;\r\n }\r\n });\r\n }\r\n}"
          ]
        },
        "bad": {
          "java": [
            "import java.io.FileNotFoundException;\r\nimport java.io.RandomAccessFile;\r\nimport java.security.AccessController;\r\nimport java.security.PrivilegedAction;\r\nimport java.io.IOException;\r\n\r\npublic class sec02_0 {\r\n public static RandomAccessFile openFile(final java.io.File f) {\r\n // getPath() can be extended, thus security check can pass the first time, \r\n // but getPath() changed the second time, bypass the good check\r\n if (f.getPath().contains(\\\"passwd\\\")){\r\n return null;\r\n };\r\n // ...\r\n return (RandomAccessFile) AccessController.doPrivileged(new PrivilegedAction<Object>() {\r\n public Object run() {\r\n try {\r\n return new RandomAccessFile(f, \\\"r\\\");\r\n } catch (FileNotFoundException e) {\r\n e.printStackTrace();\r\n }\r\n return null;\r\n }\r\n });\r\n }\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A2",
          "A6"
        ],
        "cwe": [
          "269",
          "862"
        ]
      },
      "csv_string": [
        "C02J1",
        "C02J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 73,
      "category": "VUL",
      "language": "Java",
      "code": "SEC06-J",
      "name": "The default automatic signature verifier provided by URLClassLoader and java.util.jar should not be used",
      "desc": "The program is using the default automatic signature verifier provided by the URLClassLoader and java.util.jar.",
      "msg_templ": "In file ${si.filename}, function ${si.func}, line ${si.line}, method ${si.var} uses the default automatic signature verification by URLClassLoader.",
      "severity": "H",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nThe program is using the default automatic signature verifier provided by the URLClassLoader and java.util.jar.\r\n\r\n#### Explanation\r\nUsing these packages as default automatic signature verification is not sufficient when the signature is used for privilege elevation purposes. It only performs an integrity check. Also it only uses a public key which may have been maliciously modified for authentication of loaded classes.\r\n",
      "examples": {
        "good": {
          "java": [
            "package io.xc5.cert;\r\nimport java.io.IOException;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Method;\r\nimport java.lang.reflect.Modifier;\r\nimport java.net.JarURLConnection;\r\nimport java.net.URL;\r\nimport java.net.URLClassLoader;\r\nimport java.util.jar.Attributes;\r\nimport java.security.GeneralSecurityException;\r\nimport java.security.KeyStore;\r\nimport java.security.cert.Certificate;\r\nimport java.io.FileInputStream;\r\n\r\npublic class j_sec06_fp_1 extends URLClassLoader {\r\n private URL url;\r\n public j_sec06_fp_1(URL url) {\r\n super(new URL[] { url });\r\n this.url = url;\r\n }\r\n\r\n Boolean verifyClass(Class c) throws ClassNotFoundException, NoSuchMethodException,\r\n InvocationTargetException, GeneralSecurityException,\r\n IOException {\r\n Certificate[] certs = c.getProtectionDomain().getCodeSource().getCertificates();\r\n if (certs == null) {\r\n return false;\r\n }\r\n else { \r\n KeyStore ks = KeyStore.getInstance(\\\"JKS\\\");\r\n ks.load(new FileInputStream(\\\"sec06.jks\\\"), \\\"loadkeystorepassword\\\".toCharArray());\r\n Certificate pubCert = ks.getCertificate(\\\"sec06\\\");\r\n // Check with the trusted public key, else throws exception\r\n certs[0].verify(pubCert.getPublicKey());\r\n return true;\r\n }\r\n }\r\n\r\n public void invokeClass(String name, String[] args)\r\n throws ClassNotFoundException, NoSuchMethodException,\r\n InvocationTargetException , GeneralSecurityException, IOException {\r\n Class c = loadClass(name);\r\n Method m = c.getMethod(\\\"getValue\\\", new Class[] { args.getClass() });\r\n m.setAccessible(true);\r\n \r\n // use customized, non-default verification method declared above\r\n if(verifyClass(c)) {\r\n try {\r\n m.invoke(null, new Object[] { args });\r\n } catch (IllegalAccessException e) {\r\n System.out.println(\\\"Access denied\\\");\r\n }\r\n }\r\n }\r\n}"
          ]
        },
        "bad": {
          "java": [
            "package io.xc5.cert;\r\nimport java.io.IOException;\r\nimport java.lang.reflect.InvocationTargetException;\r\nimport java.lang.reflect.Method;\r\nimport java.lang.reflect.Modifier;\r\nimport java.net.JarURLConnection;\r\nimport java.net.URL;\r\nimport java.net.URLClassLoader;\r\nimport java.util.jar.Attributes;\r\nimport java.security.GeneralSecurityException;\r\nimport java.security.KeyStore;\r\nimport java.security.cert.Certificate;\r\nimport java.io.FileInputStream;\r\n\r\npublic class j_sec06_1 extends URLClassLoader {\r\n private URL url;\r\n public j_sec06_1(URL url) {\r\n super(new URL[] { url });\r\n this.url = url;\r\n }\r\n\r\n public void invokeClass(String name, String[] args)\r\n throws ClassNotFoundException, NoSuchMethodException,\r\n InvocationTargetException , GeneralSecurityException, IOException {\r\n Class c = loadClass(name);\r\n Method m = c.getMethod(\\\"getValue\\\", new Class[] { args.getClass() });\r\n m.setAccessible(true);\r\n try {\r\n m.invoke(null, new Object[] { args });\r\n } catch (IllegalAccessException e) {\r\n System.out.println(\\\"Access denied\\\");\r\n }\r\n }\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A2",
          "A3"
        ],
        "cwe": [
          "256",
          "295",
          "285",
          "862"
        ]
      },
      "csv_string": [
        "C06J3",
        "C06J2",
        "C06J1",
        "C06J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 74,
      "category": "VUL",
      "language": "c,c++",
      "code": "FIO02-C",
      "name": "Canonicalize path names originating from tainted sources",
      "desc": "Path names, directory names, and file names may contain characters that make validation difficult and inaccurate. Furthermore, any path name component can be a symbolic link, which further obscures the actual location or identity of a file. To simplify file name validation, it is recommended that names be translated into their canonical form. Canonicalizing file names makes it much easier to verify a path, directory, or file name by making it easier to compare names. Because the canonical form can vary between operating systems and file systems, it is best to use operating-system-specific mechanisms for canonicalization.",
      "msg_templ": "In ${si.filename}, line ${si.line}, the function ${si.func} is opening a file without canonicalizing its name which may come from tainted source.",
      "severity": "M",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nPath and directory names from untrusted source should be canonicalized and validated.\r\n\r\n#### Explanation\r\nPath names, directory names and file names may contain characters that make validation difficult and inaccurate. Furthermore, any path name component can be a symbolic link, which further obscures the actual location or identity of a file. To simplify file name validation, it is recommended that names be translated into their canonical form. Canonicalizing file names makes it much easier to verify a path, directory, or file name by making it easier to compare names. Because the canonical form can vary between operating systems and file systems, it is best to use operating-system-specific mechanisms for canonicalization.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nFILE* f_open(char* fname, FILE *fptr)\r\n{\r\n    fptr = fopen(fname, \"r\");\r\n    return fptr;\r\n}\r\n\r\nchar *sanitize(char *fname);\r\n\r\n\r\nint main(int argc, char **argv[])\r\n{\r\n  FILE *fptr;\r\n  \r\n  if (!verify_file(sanitize(*argv[1]))) {  // sanitize file name first\r\n    printf(\"error\r\n\");\r\n    exit(1);\r\n  }\r\n  else {\r\n    fptr = f_open(*argv[1], fptr);\r\n  }\r\n  printf(\"File opened %x\r\n\", fptr);\r\n  // ...\r\n  exit(0);\r\n}"
          ]
        },
        "bad": {
          "c": [
            "#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nFILE* f_open(char* fname, FILE *fptr)\r\n{\r\n    fptr = fopen(fname, \"r\");\r\n    return fptr;\r\n}\r\n\r\nint main(int argc, char **argv[])\r\n{\r\n  FILE *fptr;\r\n  \r\n  if (!verify_file(*argv[1])) {\r\n    printf(\"error\r\n\");\r\n    exit(1);\r\n  }\r\n  else {\r\n    fptr = f_open(*argv[1], fptr);\r\n  }\r\n  printf(\"File opened %x\r\n\", fptr);\r\n  // ...\r\n  exit(0);\r\n}"
          ]
        }
      },
      "standards": {
        "cwe": [
          "22",
          "23",
          "28",
          "40",
          "41",
          "59",
          "73"
        ]
      },
      "csv_string": [
        "F02C6",
        "F02C5",
        "F02C4",
        "F02C3",
        "F02C2",
        "F02C1",
        "F02C0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 75,
      "category": "VUL",
      "language": "c,c++",
      "code": "STR07-C",
      "name": "Use the bounds-checking interfaces for string manipulation",
      "desc": "",
      "msg_templ": "",
      "severity": "HIGH",
      "likelihood": "PROBABLE",
      "cost": "MEDIUM",
      "details": "",
      "examples": {
        "good": {},
        "bad": {}
      }
    },
    {
      "master_id": 76,
      "category": "BAD_PRACTICE",
      "language": "c,c++",
      "code": "POS02-C",
      "name": "Follow the principle of least privilege",
      "desc": "",
      "msg_templ": "",
      "severity": "HIGH",
      "likelihood": "LIKELY",
      "cost": "HIGH",
      "details": "",
      "examples": {
        "good": {},
        "bad": {}
      }
    },
    {
      "master_id": 77,
      "category": "VUL",
      "language": "c,c++",
      "code": "POS36-C",
      "name": "Observe correct revocation order while relinquishing privileges",
      "desc": "",
      "msg_templ": "",
      "severity": "HIGH",
      "likelihood": "PROBABLE",
      "cost": "MEDIUM",
      "details": "#### Abstract\r\nCorrect order of privilege revocation is not maintained in the program.\r\n\r\n#### Explanation\r\nsetgid() must be run with superuser privileges, whereas setuid() will leave the effective user ID as nonzero. It is possible to regain group privileges with incorrect relinquishment order. Vulnerability might occur as attacker is able to regain the original group privileges. Hence, the order of setgid() and setuid() must be properly maintained, i.e. setgid() first.",
      "examples": {
        "good": {
          "c": [
            "#include <stdio.h>\r\n#include <unistd.h>\r\n\r\nvoid func() {\r\n    int gid_stat = setgid(getgid());\r\n    int uid_stat = setuid(getuid());\r\n    \r\n    // Correct order of privilege relinquishment\r\n}"
          ]
        },
        "bad": {
          "c": [
            "#include <stdio.h>\r\n#include <unistd.h>\r\n\r\nvoid func(){\r\n    int uid_stat = setuid(getuid());\r\n    int gid_stat = setgid(getfid());\r\n\r\n    // Possible to regain group privileges because of incorrect order\r\n    // Vulnerability allowing execution of arbitrary code\r\n}"
          ]
        }
      }
    },
    {
      "master_id": 80,
      "category": "VUL",
      "language": "java",
      "code": "MSC62-J",
      "name": "Passwords should be stored using a secure hash to prevent being exposed to malicious users.",
      "desc": "Storing passwords as cleartext risk these passwords exposed in a lots of ways. Using hash functions that are computationally feasible whose decoding are not computationally feasible is an acceptable. Users can test equality of passwords using their hash values.",
      "msg_templ": "In ${si.filename}, line ${si.line}, the function ${si.func} is using an unsecure hash to store passwords.",
      "severity": "H",
      "likelihood": "P",
      "cost": "L",
      "details": "#### Abstract\r\nStoring passwords in plain text may cause these passwords to be exposed in various ways. It is recommended to use a hash function that is computationally feasible but its decoding is not computationally feasible. Users can use the hash value to test whether the passwords are equivalent.\r\n\r\n#### Explanation\r\nPasswords should not be stored in clear text. To avoid exposure of them, they are typically stored in hash functions so that direct comparison is possible without requiring expensive encryption algorithms.\r\n",
      "examples": {
        "good": {
          "java": [
            "import java.security.MessageDigest;\r\nimport java.security.NoSuchAlgorithmException;\r\nimport java.security.SecureRandom;\r\n\r\npublic class j_msc62_ex {\r\n  private void regUser1(String userName, byte[] passwd, String regType) {\r\n    try {\r\n      String salt = genSalt();\r\n      String combPasswd = salt + passwd;\r\n      byte[] secureHash = secureHash(combPasswd.getBytes());\r\n      byte[] noSaltPasswd = secureHash(passwd);\r\n      byte[] unsecureHash = unSecureHash(combPasswd.getBytes());\r\n      if(regType.equals(\"NO_SALT_HASH\")) {\r\n        handleError(\"NO_SALT_HASH\");;             // MSC62-J, no salt, no hash\r\n      } else if(regType.equals(\"NO_SALT\")) {\r\n        handleError(\"NO_SALT_HASH\");        // MSC62-J no salt\r\n      } else if(regType.equals(\"UNSECURE_HASH\")){\r\n        handleError(\"UNSECURE_HASH\");       // MSC62-J unsecure hash\r\n      } else {\r\n        saveUser(userName, secureHash);         \r\n      }\r\n    } catch (NoSuchAlgorithmException e) {\r\n      e.printStackTrace();\r\n    }\r\n  } \r\n  private byte[] unSecureHash(byte [] passwd) throws NoSuchAlgorithmException{\r\n    MessageDigest msgDigest = MessageDigest.getInstance(\"MD5\");  // not secure hash algorithm\r\n    return msgDigest.digest(passwd);\r\n  }\r\n  \r\n  private byte[] secureHash(byte [] passwd) throws NoSuchAlgorithmException{\r\n    MessageDigest msgDigest = MessageDigest.getInstance(\"SHA256\");  // secure hash algorithm\r\n    return msgDigest.digest(passwd);\r\n  }\r\n\r\n  private void testRegUser(String userName, String passwd, String regType) {\r\n    regUser1(userName, passwd.getBytes(), regType);\r\n    regUser2(userName, passwd);  // MSC62-J passwd is String type\r\n  }\r\n\r\n} "
          ]
        },
        "bad": {
          "java": [
            "import java.security.MessageDigest;\r\nimport java.security.NoSuchAlgorithmException;\r\nimport java.security.SecureRandom;\r\n\r\npublic class j_msc62_ex {\r\n  private void regUser1(String userName, byte[] passwd, String regType) {\r\n    try {\r\n      String salt = genSalt();\r\n      String combPasswd = salt + passwd;\r\n      byte[] secureHash = secureHash(combPasswd.getBytes());\r\n      byte[] noSaltPasswd = secureHash(passwd);\r\n      byte[] unsecureHash = unSecureHash(combPasswd.getBytes());\r\n      if(regType.equals(\"NO_SALT_HASH\")) {\r\n        saveUser(userName, passwd);             // MSC62-J, no salt, no hash\r\n      } else if(regType.equals(\"NO_SALT\")) {\r\n        saveUser(userName, noSaltPasswd);       // MSC62-J no salt\r\n      } else if(regType.equals(\"UNSECURE_HASH\")){\r\n        saveUser(userName, unsecureHash);       // MSC62-J unsecure hash\r\n      } else {\r\n        saveUser(userName, secureHash);         // \r\n      }\r\n    } catch (NoSuchAlgorithmException e) {\r\n      e.printStackTrace();\r\n    }\r\n  } \r\n  private byte[] unSecureHash(byte [] passwd) throws NoSuchAlgorithmException{\r\n    MessageDigest msgDigest = MessageDigest.getInstance(\"MD5\");  // not secure hash algorithm\r\n    return msgDigest.digest(passwd);\r\n  }\r\n  // .. other code\r\n  private byte[] secureHash(byte [] passwd) throws NoSuchAlgorithmException{\r\n    MessageDigest msgDigest = MessageDigest.getInstance(\"SHA256\");  // secure hash algorithm\r\n    return msgDigest.digest(passwd);\r\n  }\r\n\r\n  private void testRegUser(String userName, String passwd, String regType) {\r\n    regUser1(userName, passwd.getBytes(), regType);\r\n    regUser2(userName, passwd);  // MSC62-J passwd is String type\r\n  }\r\n\r\n} "
          ]
        }
      },
      "standards": {
        "cwe": [
          "522"
        ]
      },
      "csv_string": [
        "M62J1",
        "M62J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 81,
      "category": "VUL",
      "language": "java",
      "code": "IDS03-J",
      "name": "Unsanitized user input should not appear in log",
      "desc": "Log entry containing unsanitized user input can lead to log injection attack and compromise data across a trust boundary.",
      "msg_templ": "In ${si.filename}, line ${si.line}, the function ${si.func} is logging data that has not been sanitized.",
      "severity": "M",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\nSensitive data leakage arises When unsanitized user input are logged or put out in standard output (stdout) device.\n\n#### Explanation\nLogging unsanitized user input can result in sensitive data leakage across a trusted boundary. A log injection attack may arise leading to further information leakage. This vulnerability is not limited to Java programs. C/C++ programs can subject to the same attack as show in the C example.",
      "examples": {
        "good": {
          "c": [
            "\nusing namespace mychain;\nusing namespace MyContract::Sample;\n\nclass demoBranch:public Contract {\npublic:\n    TransferPtr m_ptransfer;\n\n    demoBranch() {\n        m_ptransfer = GetTransferM();\n    }\n    INTERFACE void Init() {\n        InitRoot();\n    }\n    \n    INTERFACE void LeakToLog(const std::string& sAccountName ) {\n        if(!m_ptransfer) {\n            Revert(\"error\");\n        }\n\n\t// get account, balance etc\n        AccountMMapPtr pAccountMap = m_ptransfer->get_accounts();\n        if (!pAccountMap) {\n            Revert(\"AcountMMapPtr Error.\");\n        }\n\n        // obtain user account number and name\n\t// ...\n\n\t//\n        int32_t iBalanceRmb = pBalance->get_rmb();\n        std::string sBalanceTopic = std::to_string(iBalanceRmb);\n        std::vector<std::string> leak_msg;\n        leak_msg.push_back(sAccountName);\n        leak_msg.push_back(sBalanceTopic);\n\n        if (iBalanceRmb < 1) {\n\t  // Sanitize and clean up message before logging\n          Log(std::string(\"acc_bal\"), SanitizeUser(leak_msg));\n        }\n    }\n};\nINTERFACE_EXPORT(demoBranch, (Init) (LeakToLog))\n"
          ],
          "java": [
            "locationClient = new LocationClient(this, this, this);\nlocationClient.connect();\ncurrentUser.setLocation(locationClient.getLastLocation());\n... \n\ncatch (Exception e) {\n    AlertDialog.Builder builder = new AlertDialog.Builder(this);\n    builder.setMessage(\"Application Error.\");\n    AlertDialog alert = builder.create();\n    alert.show();\n\n    // user location is \"sanitized\" being written to log\n    Log.e(\"Example\", \"Caught exception: \" + e + \" User:\" + sanitizeUser(User.toString()));\n}\n"
          ]
        },
        "bad": {
          "c": [
            "\nusing namespace mychain;\nusing namespace MyContract::Sample;\n\nclass demoBranch:public Contract {\npublic:\n    TransferPtr m_ptransfer;\n\n    demoBranch() {\n        m_ptransfer = GetTransferM();\n    }\n    INTERFACE void Init() {\n        InitRoot();\n    }\n    \n    INTERFACE void LeakToLog(const std::string& sAccountName ) {\n        if(!m_ptransfer) {\n            Revert(\"error\");\n        }\n\n\t// get account, balance etc\n        AccountMMapPtr pAccountMap = m_ptransfer->get_accounts();\n        if (!pAccountMap) {\n            Revert(\"AcountMMapPtr Error.\");\n        }\n\n        // obtain user account number and name\n\t// ...\n\n\t//\n        int32_t iBalanceRmb = pBalance->get_rmb();\n        std::string sBalanceTopic = std::to_string(iBalanceRmb);\n        std::vector<std::string> leak_msg;\n        leak_msg.push_back(sAccountName);\n        leak_msg.push_back(sBalanceTopic);\n\t\n        if (iBalanceRmb < 1) {\n          Log(std::string(\"acc_bal\"), leak_msg);\n        }\n    }\n};\nINTERFACE_EXPORT(demoBranch, (Init) (LeakToLog))\n"
          ],
          "java": [
            "locationClient = new LocationClient(this, this, this);\nlocationClient.connect();\ncurrentUser.setLocation(locationClient.getLastLocation());\n... \n\ncatch (Exception e) {\n    AlertDialog.Builder builder = new AlertDialog.Builder(this);\n    builder.setMessage(\"Application Error.\");\n    AlertDialog alert = builder.create();\n    alert.show();\n\n    // user location is written to log\n    Log.e(\"Example\", \"Caught exception: \" + e + \" User:\" + User.toString());\n}\n"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A3"
        ],
        "cwe": [
          "117",
          "150",
          "144"
        ],
        "p3c-sec": [
          "2"
        ]
      },
      "csv_string": [
        "I03J2",
        "I03J1",
        "I03J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 82,
      "category": "VUL",
      "language": "c,c++",
      "code": "ARR38-C",
      "name": "Array out of bounds with the use of library functions",
      "desc": "The program is calling a library function with a pointer and a size parameter. The two parameters, when combined, will be outside of the legal range of the object.",
      "msg_templ": "In ${si.filename}, line ${si.line}, the function ${si.func} is calling a library function with a pointer and a size parameter.",
      "severity": "H",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program is calling a library function with a pointer and a size parameter. The two parameters, when combined, will be outside of the legal range of the object.\r\n\r\n#### Explanation\r\nThe program is passing a pointer to an object and a size parameter to the library function. The two parameters, when combined, will cause the library function to access this object but outside its valid range, resulting in an undefined behavior.\r\n\r\n",
      "examples": {
        "good": {
          "c": [
            "#define ARRAY_SZ 2\r\nint main()\r\n{\r\n int a[ARRAY_SZ] = {0, 1}, dest[ARRAY_SZ];\r\n\r\n int *p_dest = &dest[1]; // p points to beginning of dest[1];\r\n if (sizeof(dest[1] < sizeof(a)) {\r\n // report error and/exit with proper errno set\r\n }\r\n else \r\n memset(p_dest, a, sizeof(a)); // a + sizeof(a) will be one passed a[ARRAY_SZ]\r\n return 0;\r\n}",
            "#define ARRAY_SZ 2\r\nint main()\r\n{\r\nint a[ARRAY_SZ] = {0, 1}, dest[ARRAY_SZ];\r\n\r\nint *p_dest = &dest[1]; // p points to beginning of dest[1];\r\nif (sizeof(dest[1] < sizeof(a)) {\r\n     // report error and/exit with proper errno set\r\n     printf(\"target size is smaller than source size for memset\\n\");\r\n     exit(1);\r\n}\r\nelse \r\n   memset(p_dest, a, sizeof(a)); \r\n return 0;\r\n}\r\n"
          ]
        },
        "bad": {
          "c": [
            "#define ARRAY_SZ 2\r\nint main()\r\n{\r\n int a[ARRAY_SZ] = {0, 1}, dest[ARRAY_SZ];\r\n\r\n int *p_dest = &dest[1]; // p points to beginning of dest[1];\r\n memset(p_dest, a, sizeof(a)); // a + sizeof(a) will be the one passed to a[ARRAY_SZ]\r\n return 0;\r\n}"
          ]
        }
      },
      "standards": {
        "cwe": [
          "787",
          "119",
          "125"
        ]
      },
      "csv_string": [
        "A38C2",
        "A38C1",
        "A38C0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 83,
      "category": "VUL",
      "language": "c,c++",
      "code": "EXP34-C",
      "name": "Do not perform a dereference using a null pointer",
      "desc": "The program is accessing illegal memory through a pointer with a value.",
      "msg_templ": "In ${si.filename}, line ${si.line}, the function ${si.func} is accessing illegal memory through a pointer with value.",
      "severity": "HIGH",
      "likelihood": "LIKELY",
      "cost": "MEDIUM",
      "details": "#### Abstract\r\nThe program is accessing illegal memory through a pointer with value. This vulnerability is the same as the Xcalibyte NPD rule.\r\n\r\n#### Explanation\r\nPlease refer to rule NPD in the Xcalibyte vulnerability list for detailed explanation.\r\n",
      "examples": {
        "good": {},
        "bad": {
          "c": [
            "extern int bar(int);\r\n\r\nint assign(int* a)\r\n{\r\n int i = bar(*a) // dereference a\r\n return i;\r\n}\r\n\r\nint foo(void)\r\n{\r\n int *p = 0; // p as a pointer has been initialized to 0 (null)\r\n assign(p);\r\n}"
          ],
          "java": [
            "class User {\r\n public String getName() {\r\n return null;\r\n }\r\n}\r\n\r\nclass Bar {\r\n private User findUser(String uid) {\r\n if (user.containsKey(uid)) {\r\n return user.get(uid);\r\n }\r\n else\r\n return null;\r\n }\r\n public void Npd(String uid) {\r\n // do something\r\n // ...\r\n User user = findUser(uid); // Throws NPE if \\\"user\\\" has not been properly initialized\r\n String getName() {\r\n return null;\r\n }\r\n }\r\n}"
          ]
        }
      }
    },
    {
      "master_id": 84,
      "category": "VUL",
      "language": "c,c++",
      "code": "FIO47-C",
      "name": "Avoid using conflicting types to a format string",
      "desc": "The program is calling a function with a number of parameter(s) that are used differently from the prototype declaration.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, the arguments in function ${si.func} do not match the function declaration in file ${si.filename}, line ${si.line}.",
      "severity": "HIGH",
      "likelihood": "UNLIKELY",
      "cost": "LOW",
      "details": "#### Abstract\r\nThe program is calling a function with number of parameter(s) that are used different from that of the prototype declaration.\r\n\r\n#### Explanation\r\nIn a call site, the number of actual parameters passed is different from that of the function declaration. If the actuals passed is less than that of the declaration, the missing actual will ended up being \\\"wild\\\" and could cause unpreditable behavior.\r\n",
      "examples": {
        "good": {},
        "bad": {
          "c": [
            "int foo(int a, int guard)\r\n{\r\n int x = 0;\r\n int result = 0;\r\n if (guard != 0)\r\n result = a * x;\r\n foo(result); // missing one parameter, and \\\"guard\\\" will have random value during execution at this point\r\n return 0;\r\n}"
          ]
        }
      }
    },
    {
      "master_id": 85,
      "category": "VUL",
      "language": "c,c++",
      "code": "MEM30-C",
      "name": "Freed memory should not be accessed or used again",
      "desc": "The program is accessing memory that has been freed.",
      "msg_templ": "In ${si.filename}, line ${si.line}, the function ${si.func} is accessing memory that has been freed.",
      "severity": "HIGH",
      "likelihood": "LIKELY",
      "cost": "MEDIUM",
      "details": "#### Abstract\r\nThe program is accessing memory that has been freed.\r\n\r\n#### Explanation\r\nUse after free is a variation of dangling pointer reference. It typically occurs when the pointer is not updated after the memory object it points to has been freed. This pointer will be pointing to inappropriate memory leading to unauthorized access when the pointer is used.\r\n",
      "examples": {
        "good": {},
        "bad": {
          "c": [
            "int g = 2;\r\n\r\nvoid my_free(void *p) {\r\n if (p != NULL)\r\n free(p); // free p\r\n}\r\n\r\nint main() {\r\n int i, j, *p, *q;\r\n p = malloc(10 * sizeof(int));\r\n if (p == NULL)\r\n return 1;\r\n for (i=0; i < 10; ++i)\r\n p[i] = i;\r\n q = p;\r\n my_free(p); // p is freed\r\n j = 0;\r\n for (i=0; i < 10; ++i)\r\n j += q[i]; // Use after free here (note the statement q = p), read of q[i] is illegal\r\n return j;\r\n}"
          ]
        }
      }
    },
    {
      "master_id": 86,
      "category": "VUL",
      "language": "c++",
      "code": "MEM50-CPP",
      "name": "Access to freed memory should be prohibited",
      "desc": "The program reads a pointer variable that is already freed which may lead to an undefined behaviour that is unnoticeable.",
      "msg_templ": "In file ${so.filename}, line ${so.line}, variable ${so.var} in function ${so.func} was used. However, it has been freed at line ${so.line} in file ${so.filename}.",
      "severity": "HIGH",
      "likelihood": "LIKELY",
      "cost": "MEDIUM",
      "details": "#### Abstract\r\nThe program has referenced memory after it has been freed. It can cause the program to crash or an unexpected program behavior.\r\n\r\n#### Explanation\r\nUse after free is a variation of dangling pointer reference. It typically occurs when the pointer is not updated after the memory object it points to has been freed. This pointer will be pointing to inappropriate memory leading to unauthorized access when the pointer is used.\r\n",
      "examples": {
        "good": {},
        "bad": {
          "cpp": [
            "int g = 2;\r\n\r\nvoid my_free(void *p) {\r\n if (p != NULL)\r\n free(p); // free p\r\n}\r\n\r\nint main() {\r\n int i, j, *p, *q;\r\n p = malloc(10 * sizeof(int));\r\n if (p == NULL)\r\n return 1;\r\n for (i=0; i < 10; ++i)\r\n p[i] = i;\r\n q = p;\r\n my_free(p); // p is freed\r\n j = 0;\r\n for (i=0; i < 10; ++i)\r\n j += q[i]; // Use after free here (note the statement q = p), read of q[i] is illegal\r\n return j;\r\n}"
          ]
        }
      }
    },
    {
      "master_id": 87,
      "category": "VUL",
      "language": "c++",
      "code": "MEM51-CPP",
      "name": "Allocated resources require a proper deallocation",
      "desc": "The program failed to appropriately deallocate memories that were dynamically allocated.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, variable ${si.var} in function ${si.func} has not been freed.",
      "severity": "H",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has allocated heap memory but failed to free that piece of memory.\r\n\r\n#### Explanation\r\nHeap memory has been allocated and the allocated memory address is stored in a variable of reference (pointer) type. That heap memory has never been released after its lifetime has effectively ended and its corresponding reference still points to that memory space. This could result in sensitive data leakage or unexpected program behavior such as denial of service.\r\n",
      "examples": {
        "good": {},
        "bad": {
          "cpp": [
            "struct S {\r\n int *p;\r\n};\r\n\r\nint main() {\r\n int *p;\r\n struct S *s;\r\n p = malloc(10 * sizeof(int)); // heap memory allocated and pointed to by p\r\n if (p == NULL)\r\n return 1;\r\n s = (struct S*)malloc(sizeof(struct S)); // heap memory allocated and pointed to by s\r\n if (s == NULL) {\r\n free(p);\r\n return 1;\r\n }\r\n s->p = p;\r\n free(s); // only s is freed\r\n // s->p, which is copied from p is not freed\r\n return 0;\r\n}"
          ]
        }
      },
      "standards": {
        "cwe": [
          "401"
        ]
      },
      "csv_string": [
        "m51P0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 88,
      "category": "VUL",
      "language": "c++",
      "code": "EXP53-CPP",
      "name": "Reading uninitialized memory is prohibited",
      "desc": "The program is trying to read a piece of memory that is already declared but not yet initialized.",
      "msg_templ": "In file ${so.filename}, line ${so.line}, variable ${so.var} in function ${so.func} has been used but never assigned a value.",
      "severity": "MEDIUM",
      "likelihood": "UNLIKELY",
      "cost": "LOW",
      "details": "#### Abstract\r\nThe program is using a variable before it has been initialized.\r\n\r\n#### Explanation\r\nStack variables in C and C++ are not initialized by default. Non-static global variables are not guaranteed to be zeroed. Their initial values are determined by the values that happen to be in their location in memory at the time the function is invoked. Doing so will cause an unexpected program behavior.\r\n\r\n",
      "examples": {
        "good": {},
        "bad": {
          "cpp": [
            "int assign(int* a)\r\n{\r\n return *a; // dereference a\r\n}\r\n\r\nint main() {\r\n int a, b;\r\n b = assign(&a); // call assign with a uninitialized\r\n printf(\"value of b = %d\\\\\", b);\r\n return 0;\r\n}"
          ]
        }
      }
    },
    {
      "master_id": 89,
      "category": "VUL",
      "language": "c++",
      "code": "EXP54-CPP",
      "name": "Access object only during its lifetime",
      "desc": "The program tries to access the object outside of its lifetime, which will result to an undefined behaviour.",
      "msg_templ": "In file ${so.filename}, line ${so.line}, the memory reference variable ${so.var} in function ${so.func} is used. Such variable is first assigned as a memory reference that may not be valid in file ${so.filename}, line ${so.line}.",
      "severity": "HIGH",
      "likelihood": "UNLIKELY",
      "cost": "MEDIUM",
      "details": "#### Abstract\r\nDangling pointer has been used to refer to an invalid memory resource.\r\n\r\n#### Explanation\r\nDangling pointers are pointers that refer to invalid or inappropriate memory resources. Referencing these memory resources may create memory corruption, resulting in unpredictable program behavior or system instablity.\r\n",
      "examples": {
        "good": {},
        "bad": {
          "cpp": [
            "int *assign()\r\n{\r\n int *c;\r\n c = 1;\r\n return &c;\r\n}\r\n\r\nint foo()\r\n{\r\n int *a;\r\n a = assign(); // return a stack address and assign to a\r\n printf(\\\"assigned value: %d\\\", a); // use dangling pointer\r\n return 0;\r\n}"
          ]
        }
      }
    },
    {
      "master_id": 90,
      "category": "VUL",
      "language": "Java",
      "code": "ERR00-J",
      "name": "Exceptions must be handled appropriately",
      "desc": "The program has an exception construct with an empty catch block.",
      "msg_templ": "In file ${si.filename}, function ${si.func}, the catch block in line ${si.line} is empty.",
      "severity": "L",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nChecked exceptions must be handled appropriately.\r\n\r\n#### Explanation\r\nExceptions disrupt the expected control flow of the application. The catch block must either recover from the exceptional condition or throw an exception that is appropriate to the context of the catch block.\r\n",
      "examples": {
        "good": {
          "java": [
            "import java.io.*;\r\n\r\npublic class j_err00_0 {\r\n\r\n public void foo0(String fileName) {\r\n try {\r\n BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));\r\n int b;\r\n while ((b = reader.read()) != -1) {\r\n System.out.println(\"byte: \" + b);\r\n }\r\n } catch (IOException ioe) {\r\n throw new IllegalIOException(ioe.toString()); // we assume there is such exception handler here\r\n }\r\n }\r\n\r\n public void foo1(String fileName) {\r\n // indentation preserved to better show the difference with \\\"avoid\\\" example\r\n BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));\r\n int b;\r\n while ((b = reader.read()) != -1) {\r\n System.out.println(\"byte: \" + b);\r\n }\r\n\r\n }\r\n}\r\n"
          ]
        },
        "bad": {
          "java": [
            "import java.io.*;\r\n\r\npublic class j_err00_0 {\r\n\r\n public void foo0(String fileName) {\r\n try {\r\n BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));\r\n int b;\r\n while ((b = reader.read()) != -1) {\r\n System.out.println(\"byte: \" + b);\r\n }\r\n } catch (IOException ioe) {\r\n ioe.printStackTrace(); // print will not recover nor throw exception \r\n }\r\n }\r\n\r\n public void foo1(String fileName) {\r\n try {\r\n BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));\r\n int b;\r\n while ((b = reader.read()) != -1) {\r\n System.out.println(\"byte: \" + b);\r\n }\r\n } catch (IOException ioe) {\r\n // do nothing - no recovery of any kind\r\n }\r\n }\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A10"
        ],
        "cwe": [
          "223"
        ]
      },
      "csv_string": [
        "E00J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 91,
      "category": "VUL",
      "language": "Java",
      "code": "FIO08-J",
      "name": "Characters or bytes read from a stream and a -1 are different",
      "desc": "The program doesn't distinguish between characters read and end of the stream indicator by the read() method.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} does not distinguish between characters read and end of the stream indicator by the read() method.",
      "severity": "H",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nThe program doesn't distinguish between characters read and end of the stream indicator by the read() method.\r\n\r\n#### Explanation\r\nWhen reading byte data from stream with InputStream.read() and Reader.read(), end of stream is indicated with a 32 bit value of -1. Proper checking of end of stream must be done before conversion to a byte/char.\r\n",
      "examples": {
        "good": {
          "java": [
            "// read result is cast to byte after read and check for end of stream\r\npublic class j_fio08_0 {\r\n\r\n  // ...\r\n\r\n  static void readData(String fileName) throws FileNotFoundException, IOException {\r\n    FileInputStream t = new FileInputStream(fileName);\r\n    try {\r\n      int inputbuf;\r\n      byte data;\r\n      StringBuffer value = new StringBuffer();\r\n      while((inputbuf = t.read()) != -1) {\r\n\tdata = (byte) inputbuf;\r\n        value.append(data);\r\n      }\r\n      System.out.println(value.toString());\r\n    } finally {\r\n      t.close();\r\n    }\r\n  }\r\n\r\n  static void readData2(String fileName) throws IOException {\r\n    FileReader fr = new FileReader(fileName);\r\n    try {\r\n      int inputbuf;\r\n      char data;\r\n      StringBuffer sb = new StringBuffer();\r\n      while (inputbuf = fr.read()) != -1) {\r\n\tdata = (char)inputbuf;\r\n        sb.append(data);\r\n      }\r\n    } finally {\r\n      fr.close();\r\n    }\r\n  }\r\n\r\n  static void readData3(String fileName) throws IOException {\r\n    FileReader fr = new FileReader(fileName);\r\n    try {\r\n      byte data;\r\n      StringBuffer sb = new StringBuffer();\r\n      while (true) {\r\n        int i = fr.read();\r\n        int j = i;\r\n        data = (byte) j;\r\n        if (data == -1) {\r\n          break;\r\n        }\r\n        sb.append(data);\r\n      }\r\n    } finally {\r\n      fr.close();\r\n    }\r\n  }"
          ]
        },
        "bad": {
          "java": [
            "// read result is cast to byte, loop will halt prematurely if 0xFF is reached\r\npublic class j_fio08_0 {\r\n  // ... \r\n  static void readData(String fileName) throws FileNotFoundException, IOException {\r\n    FileInputStream t = new FileInputStream(fileName);\r\n    try {\r\n      byte data;\r\n      StringBuffer value = new StringBuffer();\r\n      while((data = (byte) t.read()) != -1) {\r\n        value.append(data);\r\n      }\r\n      System.out.println(value.toString());\r\n    } finally {\r\n      t.close();\r\n    }\r\n  }\r\n\r\n  static void readData2(String fileName) throws IOException {\r\n    FileReader fr = new FileReader(fileName);\r\n    try {\r\n      char data;\r\n      StringBuffer sb = new StringBuffer();\r\n      while ((data = (char) fr.read()) != -1) {\r\n        sb.append(data);\r\n      }\r\n    } finally {\r\n      fr.close();\r\n    }\r\n  }\r\n\r\n  static void readData3(String fileName) throws IOException {\r\n    FileReader fr = new FileReader(fileName);\r\n    try {\r\n      byte data;\r\n      StringBuffer sb = new StringBuffer();\r\n      while (true) {\r\n        int i = fr.read();\r\n        int j = i;\r\n        data = (byte) j;\r\n        if (data == -1) {\r\n          break;\r\n        }\r\n        sb.append(data);\r\n      }\r\n    } finally {\r\n      fr.close();\r\n    }\r\n  }"
          ]
        }
      },
      "csv_string": [
        "F08J0"
      ],
      "standards": {},
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 92,
      "category": "VUL",
      "language": "c,c++",
      "code": "FIO30-C",
      "name": "String parameters in format specification came from an untrusted source",
      "desc": "The program has a format specification that contains a parameter of char type (string) with an untrusted source, and hence, is considered tainted.",
      "msg_templ": "In file ${si.filename}, ${si.func}, line ${si.line} the printf family of calls were invoked at ${si.var} with format string from user input without being sanitized.",
      "severity": "H",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has a format specification that contains a parameter of char * type (aka string) with an untrusted source and is considered tainted.\r\n\r\n#### Explanation\r\nFormatted I/O functions can be tricked into overriding or reading the value of any arbitrary memory location. When the input source is untrusted it is better not to use format strings and related functions to perform I/O operation.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <stdio.h>\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n int var_to_hold_content; // the variable where printf will store content of an address\r\n if (argc > 2) {\r\n scanf(argv[1]); // get a string from stdin (user input)\r\n fputs(argv[1, stdout]); // do not use printf with format specification\r\n }\r\n}"
          ]
        },
        "bad": {
          "c": [
            "#include <stdio.h>\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n int var_to_hold_content; // the variable where printf will store content of an address\r\n if (argc > 2) {\r\n scanf(argv[1]); // get a string from stdin (user input)\r\n printf(argv[1]); // user can read any address to a variable using a format specification\r\n }\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A1",
          "A5"
        ],
        "cwe": [
          "20",
          "134"
        ]
      },
      "csv_string": [
        "F30C1",
        "F30C0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 93,
      "category": "VUL",
      "language": "c,c++",
      "code": "MSC41-C",
      "name": "Do not expose hard coded sensitive information in the program",
      "desc": "The program has hard coded sensitive information (such as password and keys) in a readable form.",
      "msg_templ": "In file ${si.filename}, line ${si.line}ï¼Œ function ${si.func} has hard coded sensitive information.",
      "severity": "H",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has hard coded sensitive information (such as password and keys) in readable form.\r\n\r\n#### Explanation\r\nSensitive information in strings or other readable forms can be examined even inside executables.\r\n",
      "examples": {
        "good": {
          "c": [
            "#include <stdio.h>\r\n\r\nint check_passwd(const char *s);\r\n\r\nint func(void)\r\n{\r\n    // user inputs password so no sensitive\r\n    // data leaked\r\n    #define PASSWORD_LEN 10\r\n    char password[PASSWORD_LEN];\r\n    printf(\"Please enter your password:\\n\");\r\n    fgets(password, sizeof(password), stdin);\r\n\r\n    int check = check_passwd(password);\r\n    memset_s(password, 0, sizeof(password));\r\n    // program logic\r\n    // ...\r\n    if (check)\r\n    {\r\n        // ... continue\r\n    }\r\n    else\r\n    {\r\n        // handle error\r\n        // ...\r\n    }\r\n}\r\n\r\n"
          ]
        },
        "bad": {
          "c": [
            "#include <stdio.h>\r\n\r\n#define BUF_SZ 1024\r\n\r\nint check_passwd(const char *s);\r\n\r\nint func(void)\r\n{\r\n    // program logic\r\n    // ...\r\n\r\n    // sensitive data is revealed below \r\n    if (check_passwd(\"admin\"))\r\n    {\r\n        // ... continue\r\n    }\r\n    else\r\n    {\r\n        // handle error\r\n        // ...\r\n    }\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A3",
          "A1",
          "A5"
        ],
        "cwe": [
          "798",
          "311",
          "259"
        ]
      },
      "csv_string": [
        "M41C2",
        "M41C1",
        "M41C0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 94,
      "category": "VUL",
      "language": "Java",
      "code": "FIO52-J",
      "name": "Sensitive information should be encrypted if it is stored on the client side",
      "desc": "The program has stored unencrypted sensitive information on the client side.",
      "msg_templ": "In file ${si.filename}, function ${si.func}, line ${si.line}, unencrypted sensitive data ${si.var} are saved on the client side.",
      "severity": "M",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has stored unencrypted sensitive information on the client side.\r\n\r\n#### Explanation \r\nIf unencrypted sensitive information is provided and stored on the client side, an attacker could get hold of the information either directly or indirectly to attack the client machine.\r\n",
      "examples": {
        "good": {
          "java": [
            "import javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport javax.servlet.http.Cookie;\r\ninterface Login {\r\n public Boolean isUserValid(String userName, char[] passwd);\r\n}\r\n\r\nclass LoginImpl implements Login {\r\n public Boolean isUserValid(String userName, char[] passwd) {\r\n // do the checking\r\n return true;\r\n }\r\n}\r\n\r\npublic class fio52_0 {\r\n protected void doPost(HttpServletRequest request, HttpServletResponse response) {\r\n \r\n String username = request.getParameter(\"username\");\r\n char[] password = request.getParameter(\"password\").toCharArray();\r\n String userInfo = request.getParameter(\"userInfo\");\r\n \r\n Login login = new LoginImpl();\r\n \r\n if (request.getCookies()[0] != null &&\r\n request.getCookies()[0].getValue() != null) {\r\n String[] value = request.getCookies()[0].getValue().split(\";\");\r\n \r\n if (!login.isUserValid(value[0], value[1].toCharArray())) {\r\n // Set error and return\r\n } else {\r\n // Forward to welcome page\r\n }\r\n } else {\r\n boolean validated = login.isUserValid(username, password);\r\n \r\n if (validated) {\r\n Cookie loginCookie = new Cookie(\"MyCookie\", username + \";\" + new String(password));\r\n Cookie infoCookie = new Cookie(\"userInfo\", username + \":\" + userInfo);\r\n loginCookie.setHttpOnly(true); // use http protocol only\r\n loginCookie.setSecure(true); // set loginCookie through secure protocol\r\n response.addCookie(loginCookie); // sensitive cookie is encrypted and sent through secure protocol \r\n infoCookie.setSecure(true); // set infoCookie sent by secure protocol\r\n response.addCookie(infoCookie);\r\n  \r\n // ... Forward to welcome page\r\n } else {\r\n // Set error and return\r\n }\r\n }\r\n } \r\n}"
          ]
        },
        "bad": {
          "java": [
            "import javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport javax.servlet.http.Cookie;\r\ninterface Login {\r\n public Boolean isUserValid(String userName, char[] passwd);\r\n}\r\n\r\nclass LoginImpl implements Login {\r\n public Boolean isUserValid(String userName, char[] passwd) {\r\n // do the checking\r\n return true;\r\n }\r\n}\r\n\r\npublic class fio52_0 {\r\n protected void doPost(HttpServletRequest request, HttpServletResponse response) {\r\n \r\n String username = request.getParameter(\"username\");\r\n char[] password = request.getParameter(\"password\").toCharArray();\r\n String userInfo = request.getParameter(\"userInfo\");\r\n \r\n Login login = new LoginImpl();\r\n \r\n if (request.getCookies()[0] != null &&\r\n request.getCookies()[0].getValue() != null) {\r\n String[] value = request.getCookies()[0].getValue().split(\";\");\r\n \r\n if (!login.isUserValid(value[0], value[1].toCharArray())) {\r\n // Set error and return\r\n } else {\r\n // Forward to welcome page\r\n }\r\n } else {\r\n boolean validated = login.isUserValid(username, password);\r\n \r\n if (validated) {\r\n Cookie loginCookie = new Cookie(\"MyCookie\", username + \";\" + new String(password));\r\n Cookie infoCookie = new Cookie(\"userInfo\", username + \":\" + userInfo);\r\n loginCookie.setSecure(false); // set loginCookie sent by any protocol\r\n response.addCookie(loginCookie); // [FIO52-J] sensitive cookie, should be encrypted or sent through secure protocol \r\n infoCookie.setSecure(true); // set infoCookie sent by secure protocol\r\n \\t response.addCookie(infoCookie);\r\n \\t \r\n // ... Forward to welcome page\r\n } else {\r\n // Set error and return\r\n }\r\n }\r\n } \r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A2",
          "A3"
        ],
        "cwe": [
          "522",
          "200",
          "312"
        ]
      },
      "csv_string": [
        "F52J2",
        "F52J1",
        "F52J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 95,
      "category": "VUL",
      "language": "Java",
      "code": "IDS07-J",
      "name": "Do not pass untrusted data as input to Runtime.exec() method",
      "desc": "The program has passed untrusted data as an input to the Runtime.exec() method.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, the string ${si.var} is not sanitized before being passed to runtime exec().",
      "severity": "H",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has passed untrusted data as input to Runtime.exec() method.\r\n\r\n#### Explanation\r\nUntrusted data passed to Runtime.exec() will expose the system to an argument injection attack. The string must be sanitized to get rid of characters such as spaces, double quotes, and '-'.\r\n",
      "examples": {
        "good": {
          "java": [
            "import java.io.InputStream;\r\n\r\npublic class ids07_0 { // example from CERT-J\r\n public static void main(String[] args) throws Exception {\r\n \r\n // dir is input from environment in which the app is running\r\n String dir = System.getProperty(\\\"dir\\\");\r\n if (!Pattern.matches(\\\"[0-9A-Za-z@.]+\\\", dir) { // whitelist characters allowed\r\n // report error and exit\r\n ...\r\n }\r\n Runtime rt = Runtime.getRuntime();\r\n \r\n // input from environment is directly concatenated and fed to Runtime.exec\r\n // Subject to command line injection\r\n Process proc = rt.exec(\\\"bash -c ls \\\" + dir);\r\n \r\n int result = proc.waitFor();\r\n if (result != 0) {\r\n System.out.println(\\\"process error: \\\" + result);\r\n }\r\n // continue processing\r\n // ...\r\n }\r\n}\r\n"
          ]
        },
        "bad": {
          "java": [
            "import java.io.InputStream;\r\n\r\npublic class ids07_0 { // example from CERT-J\r\n public static void main(String[] args) throws Exception {\r\n \r\n // dir is input from environment in which the app is running\r\n String dir = System.getProperty(\\\"dir\\\");\r\n Runtime rt = Runtime.getRuntime();\r\n \r\n // input from environment is directly concatenated and fed to Runtime.exec\r\n // Subject to command line injection\r\n Process proc = rt.exec(\\\"bash -c ls \\\" + dir);\r\n \r\n int result = proc.waitFor();\r\n if (result != 0) {\r\n System.out.println(\\\"process error: \\\" + result);\r\n }\r\n // continue processing\r\n // ...\r\n }\r\n}\r\n"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A1"
        ],
        "cwe": [
          "78",
          "917"
        ],
        "p3c-sec": [
          "4"
        ]
      },
      "csv_string": [
        "I07J1",
        "I07J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 96,
      "category": "VUL",
      "language": "Java",
      "code": "IDS15-J",
      "name": "Sensitive data (both input and output) should be sanitized/normalized",
      "desc": "Sensitive data should be kept secure including input and output data.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, sensitive data ${si.var} in function ${si.func} is leaked outside a trust boundary.",
      "severity": "M",
      "likelihood": "L",
      "cost": "H",
      "details": "#### Abstract\r\nSensitive data should be kept secure, including input and output data.\r\n\r\n#### Explanation\r\nSensitive information should not be allowed to leak across trusted boundaries. This is to keep integrity and security of different subsystems within a complex system. \r\n",
      "examples": {
        "good": {},
        "bad": {
          "java": [
            "import javax.servlet.http.HttpServletRequest;\r\n\r\npublic class j_ids15_0\r\n{\r\n public void setSession(HttpServletRequest request, String attrName, String attrValue) {\r\n request.getSession().setAttribute(attrName, attrValue);\r\n }\r\n\r\n public void configSession(HttpServletRequest request) {\r\n String value = request.getParameter(\\\"Config\\\");\r\n String data = System.getenv(\\\"APP_DATA\\\");\r\n if(value.startsWith(\\\"APP_DATA\\\")) {\r\n setSession(request, \\\"APP_DATA\\\", data); // sensitive data\r\n } else if(value.startsWith(\\\"SAFE_DATA\\\")) {\r\n String safeData = Encryption(data);\r\n setSession(request, \\\"SAFE_DATA\\\", safeData); // data sanitized\r\n } else {\r\n setSession(request, \\\"attr\\\", \\\"value\\\");\r\n }\r\n }\r\n\r\n public String Encryption(String data) {\r\n // encrypt the input data\r\n // ...\r\n String safeData = data.replace(\\\"a\\\", \\\"z\\\");\r\n return safeData;\r\n }\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A2",
          "A5"
        ],
        "cwe": [
          "523",
          "200",
          "284"
        ],
        "p3c-sec": [
          "1",
          "7"
        ]
      },
      "csv_string": [
        "I15J2",
        "I15J1",
        "I15J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 97,
      "category": "VUL",
      "language": "Java",
      "code": "MSC03-J",
      "name": "Do not hard code sensitive information in program",
      "desc": "The program has hard coded sensitive information.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, ${si.var} in function ${si.func} has hard coded data and may contain sensitive information.",
      "severity": "H",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has hard coded sensitive information.\r\n\r\n#### Explanation\r\nSecurity and privacy related sensitive information should be retrieved at execution time from a secured file. Java executables are in the form of byte code and could be easily reverted back to source code form with the information in plain text.\r\n",
      "examples": {
        "good": {
          "java": [
            "import java.net.InetAddress;\r\nimport java.net.UnknownHostException;\r\nimport java.sql.Connection;\r\nimport java.sql.DriverManager;\r\nimport java.sql.SQLException;\r\n\r\npublic class msc03_0 {\r\n public final Connection getConnection() throws SQLException, UnknownHostException {\r\n \r\n // IP address class to fill in at runtime. The address should be cleared immediately after use\r\n class IPAddress {\r\n // IP address in string\r\n char[] ipAddress = new char[128];\r\n try {\r\n // read in from some secure channel or file\r\n ...\r\n }\r\n finally {\r\n // clear after use\r\n Arrys.fill(ipAddress, (byte)0);\r\n // close file or channel\r\n ...\r\n }\r\n \r\n }\r\n if (InetAddress.getByName(ipAddress).isAnyLocalAddress()){\r\n // hard coded username and password\r\n String username, password;\r\n // Username and password should be read from a secure config file/channel at rungime\r\n return DriverManager.getConnection(\\\"dbhost:mysql://localhost/mydb\\\", username, password);\r\n }\r\n return DriverManager.getConnection(\\\"dbhost:mysql://localhost/dbName\\\", \\\"username\\\", \\\"password\\\");\r\n }\r\n}\r\n"
          ]
        },
        "bad": {
          "java": [
            "import java.net.InetAddress;\r\nimport java.net.UnknownHostException;\r\nimport java.sql.Connection;\r\nimport java.sql.DriverManager;\r\nimport java.sql.SQLException;\r\n\r\npublic class msc03_0 {\r\n public final Connection getConnection() throws SQLException, UnknownHostException {\r\n \r\n // hard coded IP address in String\r\n String ipAddress = new String(\\\"184.15.254.1\\\");\r\n if (InetAddress.getByName(ipAddress).isAnyLocalAddress()){\r\n // hard coded username and password\r\n return DriverManager.getConnection(\\\"dbhost:mysql://localhost/mydb\\\", \\\"7f4j9vj\\\", \\\"xsi9j2nn8\\\");\r\n }\r\n return DriverManager.getConnection(\\\"dbhost:mysql://localhost/dbName\\\", \\\"username\\\", \\\"password\\\");\r\n }\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A3"
        ],
        "cwe": [
          "798"
        ]
      },
      "csv_string": [
        "M03J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 98,
      "category": "VUL",
      "language": "Java",
      "code": "OBJ07-J",
      "name": "Classes with sensitive data should be protected against being copied or cloned",
      "desc": "Classes with sensitive data should be protected against being copied or cloned.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, the method ${si.var} can be copied or cloned.",
      "severity": "M",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nClasses with sensitive data should be protected against being copied or cloned. \r\n\r\n#### Explanation\r\nClasses with sensitive data, when cloned or copied maliciously, may be exposed to thread-safety issues that violates invariants of critical data. \r\n",
      "examples": {
        "good": {
          "java": [
            "public class j_obj07_fp_1 \r\n{\r\n private String userName;\r\n private char[] passwd;\r\n\r\n public j_obj07_fp_1(String name, String pass) {\r\n userName = name;\r\n passwd = pass.toCharArray();\r\n }\r\n\r\n // [certj pages]\r\n // sensitive class define clone() and throws CloneNotSupportedException\r\n // and clone() method marked finalclone\r\n // Well behaved clone that prevents subclasses from being made cloneable by defining a final clone that always fails\r\n public final j_obj07_fp_1 clone() throws CloneNotSupportedException {\r\n throw new CloneNotSupportedException();\r\n }\r\n\r\n void resetPasswd() {\r\n for(int i = 0; i < passwd.length; i++) {\r\n passwd[i] = 'a';\r\n } \r\n }\r\n\r\n void display() {\r\n System.out.println(\\\"UserName addr:\\\" + System.identityHashCode(userName));\r\n System.out.println(\\\"Passwd addr:\\\" + System.identityHashCode(passwd));\r\n System.out.print(\\\"User:\\\" + userName + \\\" passwd:\\\");\r\n System.out.println(passwd);\r\n }\r\n\r\n public static void main(String[] args) {\r\n j_obj07_fp_1 obj1= new j_obj07_fp_1(\\\"user1\\\", \\\"abcdef\\\");\r\n try {\r\n j_obj07_fp_1 obj2 = (j_obj07_fp_1)obj1.clone();\r\n obj2.resetPasswd();\r\n obj1.display();\r\n obj2.display();\r\n } catch (CloneNotSupportedException e) {\r\n System.out.println(\\\"Error: clone is not allowed for sensitive class\\\");\r\n }\r\n }\r\n}\r\n"
          ]
        },
        "bad": {
          "java": [
            "public class j_obj07_sensitive\r\n{\r\n private String userName;\r\n private char[] passwd;\r\n\r\n public j_obj07_sensitive(String name, char[] pass) { // OBJ07-J: class not provide clone throw exception and mark final\r\n userName = name;\r\n passwd = pass;\r\n } \r\n\r\n public String getUserName() {\r\n return userName;\r\n }\r\n\r\n public char[] getPasswd() {\r\n return passwd;\r\n }\r\n\r\n protected void resetPasswd() {\r\n for(int i = 0; i < passwd.length; i++) {\r\n passwd[i] = 'a';\r\n }\r\n }\r\n\r\n void display() {\r\n System.out.println(\\\"UserName addr:\\\" + System.identityHashCode(userName));\r\n System.out.println(\\\"Passwd addr:\\\" + System.identityHashCode(passwd));\r\n System.out.print(\\\"User:\\\" + userName + \\\" passwd:\\\");\r\n System.out.println(passwd);\r\n }\r\n\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A3",
          "A5"
        ],
        "cwe": [
          "498"
        ]
      },
      "csv_string": [
        "O07J1",
        "O07J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 99,
      "category": "VUL",
      "language": "Java",
      "code": "SEC01-J",
      "name": "Untrusted data is not allowed in privileged blocks",
      "desc": "The program has untrusted data in the privileged blocks.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, sensitive information may be leaked through ${si.var} inside a trusted block ${si.func}.",
      "severity": "H",
      "likelihood": "L",
      "cost": "L",
      "details": "#### Abstract\r\nThe program has untrusted data in privileged blocks.\r\n\r\n#### Explanation\r\nUntrusted data may contain special characters that eventually form tainted paths or file names. Attackers can take advantage of tainted data that get into privileged blocks for malicious intent.\r\n",
      "examples": {
        "good": {
          "java": [
            "import java.io.FileInputStream;\r\nimport java.io.FileNotFoundException;\r\nimport java.security.AccessController;\r\nimport java.security.PrivilegedActionException;\r\nimport java.security.PrivilegedExceptionAction;\r\n\r\npublic class sec01_0 { // edited from CERT-J example\r\n // input file name gone through sanitization and normalization before \r\n // enter the doPrivileged() block\r\n }\r\n private void privilegedMethod(final String filename)\r\n throws FileNotFoundException {\r\n \r\n final String sanitizeFilename;\r\n try {\r\n sanitizeFilename = sanitizeFilename(filename);\r\n } catch {\r\n // call handler appropriately \r\n ...\r\n }\r\n \r\n try {\r\n FileInputStream fis =\r\n (FileInputStream) AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () -> {\r\n return new FileInputStream(filename);\r\n });\r\n // Do something with the file and then close it\r\n } catch (PrivilegedActionException e) {\r\n // Forward to handler\r\n }\r\n }\r\n}"
          ]
        },
        "bad": {
          "java": [
            "import java.io.FileInputStream;\r\nimport java.io.FileNotFoundException;\r\nimport java.security.AccessController;\r\nimport java.security.PrivilegedActionException;\r\nimport java.security.PrivilegedExceptionAction;\r\n\r\npublic class sec01_0 { // edited from CERT-J example\r\n // input file name may be tainted since origin is unknown\r\n // should have gone through sanitization and normalization before \r\n // enter the doPrivileged() block\r\n private void privilegedMethod(final String filename)\r\n throws FileNotFoundException {\r\n try {\r\n FileInputStream fis =\r\n (FileInputStream) AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () -> {\r\n return new FileInputStream(filename);\r\n });\r\n // Do something with the file and then close it\r\n } catch (PrivilegedActionException e) {\r\n // Forward to handler\r\n }\r\n }\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A2",
          "A5",
          "A3"
        ],
        "cwe": [
          "732",
          "266",
          "272"
        ]
      },
      "csv_string": [
        "C01J2",
        "C01J1",
        "C01J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 100,
      "category": "VUL",
      "language": "c++",
      "code": "DCL55-CPP",
      "name": "Information leakage when transferring class objects across trusted boundaries",
      "desc": "The program has classes that have padding bits in the object that may have sensitive data but failed to clear them after use.",
      "msg_templ": "",
      "severity": "LOW",
      "likelihood": "UNLIKELY",
      "cost": "LOW",
      "details": "",
      "examples": {
        "good": {},
        "bad": {}
      }
    },
    {
      "master_id": 101,
      "category": "VUL",
      "language": "Java",
      "code": "ENV01-J",
      "name": "Security sensitive code should be signed and sealed in a single JAR",
      "desc": "The program is code signed to authenticate the origin of the code. Such codes should contain some code that performs privileged operations.",
      "msg_templ": "",
      "severity": "H",
      "likelihood": "P",
      "cost": "M",
      "details": "#### Abstract\r\nThe program is code signed to authenticate the origin of the code. Such code should contain some code that performs privileged operations.\r\n\r\n#### Explanation\r\nCode signing is usually taken as trusted and safe to execute code. Many systems are configured to be \\\"Always trust\\\". The implied permission can easily be exploited.\r\n\r\n",
      "examples": {
        "good": {},
        "bad": {}
      },
      "standards": {
        "owasp": [
          "A2"
        ],
        "cwe": [
          "349"
        ]
      },
      "csv_string": [
        "N01J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 102,
      "category": "VUL",
      "language": "c,c++",
      "code": "FIO21-C",
      "name": "Temporary files should not be stored in shared directories",
      "desc": "The program has created temporary files in shared directories but has no removal or access procedure to prevent user attacks into the shared directory.",
      "msg_templ": "",
      "severity": "HIGH",
      "likelihood": "LIKELY",
      "cost": "MEDIUM",
      "details": "#### Abstract\r\nThe program has created temporary files in shared directories but has no removal or access procedures to prevent user attacks into the shared directory.\r\n\r\n#### Explanation\r\nProcess of creating temporary files is often used as a practice to transmit data from one process to another when it cannot reside in memory. If there is no clean up procedure for these files, or if the file name of these files is predictable, then it allows attackers to easily hijack this file. It can be fatal if the file holds sensitive information.\r\n",
      "examples": {
        "good": {},
        "bad": {
          "c": [
            "void func(const char * file_name) {\r\nFILE *fp=fopen(file_name),\"wb+\";\r\nif(fp == NULL){\r\nreturn\r\n}\r\n// write to file ...\r\nfclose(fp)\r\n}"
          ]
        }
      }
    },
    {
      "master_id": 103,
      "category": "VUL",
      "language": "c++",
      "code": "DCL56-CPP",
      "name": "Initialization of static objects should not have a circular dependency",
      "desc": "The program makes a recursion call when initializing a static object. Program also might have an unordered initialization such that recursion may cause unexpected behaviors.",
      "msg_templ": "",
      "severity": "LOW",
      "likelihood": "UNLIKELY",
      "cost": "MEDIUM",
      "details": "",
      "examples": {
        "good": {},
        "bad": {}
      }
    },
    {
      "master_id": 104,
      "category": "VUL",
      "language": "c++",
      "code": "FIO51-CPP",
      "name": "Always close files before a program terminates",
      "desc": "The program fails to close a file that was previously opened before program termination.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} fails to close an open file before program termination.",
      "severity": "MEDIUM",
      "likelihood": "UNLIKELY",
      "cost": "MEDIUM",
      "details": "",
      "examples": {
        "good": {},
        "bad": {}
      }
    },
    {
      "master_id": 105,
      "category": "VUL",
      "language": "c++",
      "code": "MEM52-CPP",
      "name": "Failures in memory allocation should be properly handled",
      "desc": "Default allocators do not check results of allocation if it produces an exception. Any error has to be caught and handled.",
      "msg_templ": "",
      "severity": "HIGH",
      "likelihood": "LIKELY",
      "cost": "MEDIUM",
      "details": "#### Abstract\r\nDefault allocators do not check results of allocation if it produces an exception. Any error has to be caught and handled.\r\n\r\n#### Explanation\r\nOne of the most common memory alocation operators used in C++ is ::operator new(std::size_t) which may throw a std::bad_alloc when allocation fails. New operator is also overloaded with the non-throwing version which is ::operator new(std::size_t, const std::nothrow_t&) which instead of throwing exceptions will give a nullptr instead. Whichever new operator is used, there should be a check for either the corresponding error. Exceptions must be handled with catch, while nullptr should be checked accordingly, to avoid the abrupt termination of a program.\r\n",
      "examples": {
        "good": {},
        "bad": {
          "cpp": [
            "#include <cstring>\r\n#include <new>\r\n\r\n void f(std::size_t size) noexcept {\r\nint *var = new int[size];\r\nvar[0]=5;\r\ndelete[] var;\r\n}"
          ]
        }
      }
    },
    {
      "master_id": 106,
      "category": "VUL",
      "language": "c++",
      "code": "MSC50-CPP",
      "name": "Use a stronger pseudorandom generator than std::rand()",
      "desc": "The program has used std::rand(), which is not a good candidate for random number sequences.",
      "msg_templ": "",
      "severity": "MEDIUM",
      "likelihood": "UNLIKELY",
      "cost": "LOW",
      "details": "#### Abstract\r\nThe program has used std::rand(), which is not a good candidate for random number sequences.\r\n\r\n#### Explanation\r\nPseudorandom number generator like rand() uses mathematical algorithms which makes numbers not completely random. Numbers generated by std::rand() doesn't give a good enough quality for random number sequences due to its comparatively short cycle. Hence, using rand() is not advised.\r\n",
      "examples": {
        "good": {},
        "bad": {
          "cpp": [
            "#include <iostream>\r\n#include<string>\r\n\r\nvoid func(void){\r\nstd::string id{\\\"id\\\"};\r\nid += std::to_string(std::rand()%1000);\r\n}"
          ]
        }
      }
    },
    {
      "master_id": 107,
      "category": "VUL",
      "language": "c++",
      "code": "MSC52-CPP",
      "name": "Any value returning function must ensure all exit paths return a value",
      "desc": "The program has a function with non-void return, but that function has an execution path that will reach the exit without encountering a \"return\" statement.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} has non-void return but it will reach the exit without a return statement.",
      "severity": "MEDIUM",
      "likelihood": "PROBABLE",
      "cost": "MEDIUM",
      "details": "#### Abstract\r\nThe program has a function with non-void return, but that function has an execution path that will reach the exit without encountering a \\\"return\\\" statement.\r\n\r\n#### Explanation\r\nA value is expected to be returned upon calling this function, however, not all code paths return a value and may result in an undefined behavior.\r\n",
      "examples": {
        "good": {},
        "bad": {
          "cpp": [
            "int get_number(int x){\r\nif(x>=1 && x<=10) return x;\r\n}"
          ]
        }
      }
    },
    {
      "master_id": 108,
      "category": "VUL",
      "language": "Java",
      "code": "OBJ05-J",
      "name": "References to mutable class members that are private should not be returned and exposed",
      "desc": "The program is returning references to mutable class members that are declared as private.",
      "msg_templ": "",
      "severity": "HIGH",
      "likelihood": "PROBABLE",
      "cost": "MEDIUM",
      "details": "#### Abstract\r\nThe program is returning references to mutable class members that are declared private.\r\n\r\n#### Explanation\r\nReturning reference to a private mutable class member is breaking the encapsulation and also makes a private object available that can be manipulated by an untrusted calling method.\r\n",
      "examples": {
        "good": {
          "java": [
            "import java.util.Date;\r\n\r\npublic class obj05_0 {\r\n private Data private_d;\r\n\r\n // this class is mutable\r\n public obj05_0() {\r\n private_d = new Data();\r\n }\r\n\r\n // a copy is returned, hence, no leakage using this method\r\n public Data getDataSafe() {\r\n return (Data)d.clone();\r\n }\r\n}\r\n"
          ]
        },
        "bad": {
          "java": [
            "import java.util.Date;\r\n\r\npublic class obj05_0 {\r\n    private Data private_d;\r\n\r\n    // this class is mutable\r\n    public obj05_0() {\r\n        // private_d is declared private, and is being returned \r\n        // thus exposes the internal mutable component to untrustable caller\r\n        private_d = new Data();\r\n}\r\n\r\npublic Data getData() {\r\n    return private_d;\r\n}\r\n\r\n}\r\n"
          ]
        }
      }
    },
    {
      "master_id": 109,
      "category": "VUL",
      "language": "Java",
      "code": "ENV02-J",
      "name": "Environment variables are to be treated as untrusted",
      "desc": "The program's use of environment variables may be a loophole for attackers.",
      "msg_templ": "",
      "severity": "LOW",
      "likelihood": "LIKELY",
      "cost": "LOW",
      "details": "",
      "examples": {
        "good": {},
        "bad": {}
      }
    },
    {
      "master_id": 110,
      "category": "VUL",
      "language": "Java",
      "code": "ENV04-J",
      "name": "Bytecode verification should not be disabled",
      "desc": "Java class files with no verification may come from untrusted sources.",
      "msg_templ": "",
      "severity": "HIGH",
      "likelihood": "LIKELY",
      "cost": "LOW",
      "details": "",
      "examples": {
        "good": {},
        "bad": {}
      }
    },
    {
      "master_id": 111,
      "category": "VUL",
      "language": "Java",
      "code": "ENV05-J",
      "name": "Remotely monitored applications should not be deployed in the product",
      "desc": "Program fails to disable remote monitoring.",
      "msg_templ": "",
      "severity": "HIGH",
      "likelihood": "PROBABLE",
      "cost": "LOW",
      "details": "",
      "examples": {
        "good": {},
        "bad": {}
      }
    },
    {
      "master_id": 112,
      "category": "VUL",
      "language": "Java",
      "code": "JNI01-J",
      "name": "Invoke standard APIs safely",
      "desc": "The program has invoked a standard API on behalf of untrusted code through loadLibrary methods.",
      "msg_templ": "",
      "severity": "H",
      "likelihood": "L",
      "cost": "L",
      "details": "",
      "examples": {
        "good": {},
        "bad": {}
      },
      "csv_string": [
        "J01J0"
      ],
      "standards": {},
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 113,
      "category": "VUL",
      "language": "Java",
      "code": "OBJ01-J",
      "name": "Field accessibility of an object must be managed properly",
      "desc": "The program might expose sensitive fields through using a public modifier.",
      "msg_templ": "",
      "severity": "M",
      "likelihood": "L",
      "cost": "M",
      "details": "#### Abstract\r\nThe program might expose sensitive fields through using a public modifier.\r\n",
      "examples": {
        "good": {
          "java": [
            "import java.util.List;\r\n\r\npublic class j_obj01_0 {\r\n\r\n  private static final String[] items = {\"abc\", \"def\", \"ghj\"/* ... */};\r\n\r\n  public static final List<String> itemsList =\r\n    Collections.unmodifiableList(Arrays.asList(items));\r\n\r\n  public static final String[] getItems() {\r\n    return items.clone();\r\n  }\r\n  public static final String getItem(int index) {\r\n    return items[index];\r\n  }\r\n\r\n  public static final int getItemCount() {\r\n    return items.length;\r\n  }\r\n\r\n  private static final HashMap<Integer, String> hm = new HashMap<Integer, String>();\r\n\r\n  public static String getElement(int key) {\r\n    return hm.get(key);\r\n  }\r\n\r\n  private int total; // Declared private\r\n\r\n  public int getTotal () {\r\n    return total;\r\n  }\r\n\r\n}"
          ]
        },
        "bad": {
          "java": [
            "import java.util.List;\r\n\r\npublic class j_obj01_0 {\r\n\r\n  private static final String[] items = {\"abc\", \"def\", \"ghj\"/* ... */};\r\n\r\n  public static final List<String> itemsList =\r\n    Collections.unmodifiableList(Arrays.asList(items));\r\n\r\n  public static final String[] getItems() {\r\n    return items.clone();\r\n  }\r\n  public static final String getItem(int index) {\r\n    return items[index];\r\n  }\r\n\r\n  public static final int getItemCount() {\r\n    return items.length;\r\n  }\r\n\r\n  private static final HashMap<Integer, String> hm = new HashMap<Integer, String>();\r\n\r\n  public static String getElement(int key) {\r\n    return hm.get(key);\r\n  }\r\n\r\n  public int total; // Unprotected\r\n\r\n  public int getTotal () {\r\n    return total;\r\n  }\r\n\r\n}"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A5"
        ],
        "cwe": [
          "766"
        ]
      },
      "csv_string": [
        "O01J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 114,
      "category": "VUL",
      "language": "Java",
      "code": "OBJ13-J",
      "name": "References to mutable objects should not be shown to client",
      "desc": "The program is exposing reference mutable objects to the user side where they may be modified freely.",
      "msg_templ": "",
      "severity": "M",
      "likelihood": "L",
      "cost": "L",
      "details": "",
      "examples": {
        "good": {},
        "bad": {}
      },
      "standards": {
        "owasp": [
          "A2",
          "A3"
        ]
      },
      "csv_string": [
        "O13J1",
        "O13J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 115,
      "category": "VUL",
      "language": "Java",
      "code": "SEC03-J",
      "name": "Trusted class must be loaded by the trusted class loader",
      "desc": "The program may allow a class loader from an untrusted source to load trusted classes.",
      "msg_templ": "",
      "severity": "H",
      "likelihood": "P",
      "cost": "M",
      "details": "",
      "examples": {
        "good": {},
        "bad": {}
      },
      "standards": {
        "owasp": [
          "A5",
          "A2"
        ],
        "cwe": [
          "269",
          "284"
        ]
      },
      "csv_string": [
        "C03J1",
        "C03J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 116,
      "category": "VUL",
      "language": "Java",
      "code": "SEC04-J",
      "name": "Sensitive operations should be protected with a proper security manager check",
      "desc": "The program is allowing sensitive method calls that bypass security manager checks.",
      "msg_templ": "",
      "severity": "H",
      "likelihood": "P",
      "cost": "M",
      "details": "",
      "examples": {
        "good": {},
        "bad": {}
      },
      "standards": {
        "owasp": [
          "A5",
          "A3",
          "A6"
        ],
        "cwe": [
          "284",
          "285"
        ]
      },
      "csv_string": [
        "C04J2",
        "C04J1",
        "C04J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 117,
      "category": "VUL",
      "language": "Java",
      "code": "SEC05-J",
      "name": "Do not use reflection to modify accessibility of classes, methods or fields",
      "desc": "The program is using Java reflection APIs that alters accessibility of certain fields.",
      "msg_templ": "",
      "severity": "H",
      "likelihood": "P",
      "cost": "M",
      "details": "",
      "examples": {
        "good": {},
        "bad": {}
      },
      "standards": {
        "cwe": [
          "269"
        ]
      },
      "csv_string": [
        "C05J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 118,
      "category": "VUL",
      "language": "Java",
      "code": "SER01-J",
      "name": "Follow the proper signatures when making custom serialization methods",
      "desc": "The program is not using signatures of serialization methods properly.",
      "msg_templ": "",
      "severity": "H",
      "likelihood": "L",
      "cost": "L",
      "details": "",
      "examples": {
        "good": {},
        "bad": {}
      },
      "standards": {
        "owasp": [
          "A8"
        ],
        "cwe": [
          "502"
        ]
      },
      "csv_string": [
        "R01J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 119,
      "category": "VUL",
      "language": "Java",
      "code": "SER04-J",
      "name": "Serialization and deserialization should always pass the security manager",
      "desc": "The program is doing a serialization without security checks that may allow untrusted code to modify internal state of class.",
      "msg_templ": "",
      "severity": "HIGH",
      "likelihood": "PROBABLE",
      "cost": "HIGH",
      "details": "",
      "examples": {
        "good": {},
        "bad": {}
      }
    },
    {
      "master_id": 120,
      "category": "VUL",
      "language": "Java",
      "code": "SER05-J",
      "name": "Avoid serialization of inner classes",
      "desc": "The program contains inner class(es) that implement a serializable interface.",
      "msg_templ": "",
      "severity": "M",
      "likelihood": "L",
      "cost": "M",
      "details": "",
      "examples": {
        "good": {},
        "bad": {}
      },
      "csv_string": [
        "R05J0"
      ],
      "standards": {},
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 121,
      "category": "VUL",
      "language": "Java",
      "code": "SER08-J",
      "name": "If deserializing requires privileges, strip permissions to the minimum of intended usage",
      "desc": "The program is doing deserialization within a privileged context.",
      "msg_templ": "",
      "severity": "HIGH",
      "likelihood": "LIKELY",
      "cost": "MEDIUM",
      "details": "",
      "examples": {
        "good": {},
        "bad": {}
      }
    },
    {
      "master_id": 122,
      "category": "VUL",
      "language": "Java",
      "code": "IDS53-J",
      "name": "Prevent XPath Injection",
      "desc": "String input to retrieve data from XML document must be properly sanitized before the query.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, ${si.func}, ${si.var} is not properly sanitized before being used to retrieve data from XML document .",
      "severity": "H",
      "likelihood": "P",
      "cost": "L",
      "details": "#### Abstract\r\nThe program is using String input to retrieve data from an XML document. It must be properly sanitized before the query.\r\n\r\n#### Explanation\r\nThe program is using String input to retrieve data from an XML document without adequate input sanitization and validation. This could result in malicious users formulating an SQL or XML query that results in a tautology and allow attackers access to restricted information.",
      "examples": {
        "good": {
          "java": [
            "import javax.xml.xpath.*;\r\nimport org.xml.sax.SAXException;\r\nimport java.io.IOException;\r\nimport java.io.FileInputStream;\r\nimport javax.xml.parsers.DocumentBuilder;\r\nimport org.w3c.dom.Document;\r\nimport org.w3c.dom.NodeList;\r\npublic class j_ids53_0 {\r\n  private final String accountFile = \"account.xml\";\r\n  private DocumentBuilder docBuilder;\r\n  private XPath xpath;\r\n\r\n  // the code below trying to query account Info with given id\r\n  public String queryAccountInfo(String id) throws XPathExpressionException, SAXException, IOException {\r\n    Document accountDoc = docBuilder.parse(accountFile);\r\n    Map queryVars = new HashMap();\r\n\r\n    // validate input \"id\" using StringEscapeUtils\r\n    String filteredId = StringEscaptUtils.escapeXml(id);\r\n    String compileStr = \"/Accounts/account[@id='\" + filteredId + \"']\";\r\n    String res = xpath.evaluate(compileStr, accountDoc); \r\n    return res;\r\n  }\r\n}\r\n\r\n"
          ]
        },
        "bad": {
          "java": [
            "package io.xc5.cert;\r\n\r\nimport javax.xml.xpath.*;\r\nimport org.xml.sax.SAXException;\r\nimport java.io.IOException;\r\nimport java.io.FileInputStream;\r\nimport javax.xml.parsers.DocumentBuilder;\r\nimport org.w3c.dom.Document;\r\nimport org.w3c.dom.NodeList;\r\n\r\npublic class example_bad {\r\n  private final String accountFile = \"account.xml\";\r\n  private DocumentBuilder docBuilder;\r\n  private XPath xpath;\r\n\r\n  // the code below trying to query account Info with given id\r\n  public String queryAccountInfo(String id) throws XPathExpressionException, SAXException, IOException {\r\n    Document accountDoc = docBuilder.parse(accountFile);\r\n\r\n    // attacker can inject by provide id with '1'='1 causing evaluate to return \"true\"\r\n    String compileStr = \"/Accounts/account[@id='\" + id + \"']\"; \r\n    String res = xpath.evaluate(compileStr, accountDoc); // IDS53-J\r\n    return res;\r\n  }\r\n}\r\n"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A1"
        ],
        "cwe": [
          "91",
          "943"
        ]
      },
      "csv_string": [
        "I53J1",
        "I53J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 123,
      "category": "VUL",
      "language": "Java",
      "code": "IDS54-J",
      "name": "Prevent LDAP injection",
      "desc": "String input to perform remote directory access must be properly sanitized and validated.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, ${si.func}, ${si.var} is not properly sanitized and validated before being used to perform remote directory access.",
      "severity": "H",
      "likelihood": "P",
      "cost": "L",
      "details": "#### Abstract\r\nThe program is using LDAP for remote operations with inadequate input sanitization and validation.\r\n\r\n#### Explanation\r\nThe program is using Lightweight Directory Access Protocol to perform remote operations without adequate input sanitization and validation. This could result in giving malicious users access to restricted information.",
      "examples": {
        "good": {
          "java": [
            "import javax.naming.NamingEnumeration;\r\nimport javax.naming.NamingException;\r\nimport javax.naming.directory.InitialDirContext;\r\nimport javax.naming.directory.SearchControls;\r\nimport javax.naming.directory.SearchResult;\r\n\r\npublic class example_good\r\n{\r\n  public NamingEnumeration<SearchResult> queryUserInfo(InitialDirContext ctx, String id) throws NamingException {\r\n    SearchControls sc = new SearchControls();\r\n    sc.setReturningAttributes(new String[]{\"balance\", \"phone\"});\r\n    sc.setSearchScope(SearchControls.SUBTREE_SCOPE);\r\n\r\n    String searchBase = \"dc=Users,dc=com\";\r\n\r\n    // check against special characters \r\n    if (!id.matches(\"[\\\\w\\\\s]*\") || !id.matches(\"[\\\\w]*\")) {\r\n      throw new IllegalArgumentException(\"Invalid input\");\r\n    }\r\n    \r\n    String filter = \"(id=\" + id + \")\"; // attacker can inject by provide id with \"*\"\r\n    return ctx.search(searchBase, filter, sc); // IDS54-J, query user info with id \r\n  }\r\n}\r\n"
          ]
        },
        "bad": {
          "java": [
            "import javax.naming.NamingEnumeration;\r\nimport javax.naming.NamingException;\r\nimport javax.naming.directory.InitialDirContext;\r\nimport javax.naming.directory.SearchControls;\r\nimport javax.naming.directory.SearchResult;\r\n\r\npublic class example_bad\r\n{\r\n  public NamingEnumeration<SearchResult> queryUserInfo(InitialDirContext ctx, String id) throws NamingException {\r\n    SearchControls sc = new SearchControls();\r\n    sc.setReturningAttributes(new String[]{\"balance\", \"phone\"});\r\n    sc.setSearchScope(SearchControls.SUBTREE_SCOPE);\r\n\r\n    String searchBase = \"dc=Users,dc=com\";\r\n    String filter = \"(id=\" + id + \")\"; // attacker can inject by provide id with \"*\"\r\n    return ctx.search(searchBase, filter, sc); // IDS54-J, query user info with id \r\n  }\r\n}\r\n"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A1"
        ],
        "cwe": [
          "90",
          "943"
        ]
      },
      "csv_string": [
        "I54J1",
        "I54J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 124,
      "category": "VUL",
      "language": "Java",
      "code": "IDS06-J",
      "name": "Exclude unsanitized user input from format strings",
      "desc": "Format string should not contain input that is not properly sanitized and validated.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, ${si.func}, ${si.var} contains input that is not properly santizied and validated.",
      "severity": "M",
      "likelihood": "U",
      "cost": "M",
      "details": "#### Abstract\r\nThe program has format strings that includes unsanitized user input.\r\n\r\n#### Explanation\r\nUnsanitized input from an untrusted source should not be incorporated into format strings. This could result in information leakage or allow denial of service attacks.",
      "examples": {
        "good": {
          "java": [
            "\r\nimport java.util.Calendar;\r\nimport java.util.GregorianCalendar;\r\n\r\n// this example is taken from CERT-J site Dashboard\r\n// \r\npublic class example_bad {\r\n  static Calendar c = new GregorianCalendar(1995, GregorianCalendar.MAY, 23);\r\n  public static void main(String[] args) {\r\n    // simply compare input with c\r\n    System.out.format(\r\n      \"%s did not match! HINT: It was issued on %terd of some month\", args[0], c\r\n    );\r\n  }\r\n}\r\n"
          ]
        },
        "bad": {
          "java": [
            "\r\nimport java.util.Calendar;\r\nimport java.util.GregorianCalendar;\r\n\r\n// this example is taken from CERT-J site Dashboard\r\n// \r\npublic class example_bad {\r\n  static Calendar c = new GregorianCalendar(1995, GregorianCalendar.MAY, 23);\r\n  public static void main(String[] args) {\r\n    // Untrusted data is incorporated into the format string below.\r\n    // Attacker can expose the date against which input is compared against\r\n    // with some special input string, resulting in infomation leakage.\r\n    System.out.format(\r\n      args[0] + \"did not match! HINT: It was issued on %1$terd of some month\", c\r\n    );\r\n  }\r\n}\r\n"
          ]
        }
      },
      "standards": {
        "cwe": [
          "134"
        ]
      },
      "csv_string": [
        "I06J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 125,
      "category": "BAD_PRACTICE",
      "language": "c/c++",
      "code": "MSC30-C",
      "name": "Do not use the rand() function for generating pseudorandom numbers",
      "desc": "The program is using a pseudorandom number generator  that can produce a predictable sequence of numbers.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} is using a pseudorandom number generator that might produce a predictable sequence of numbers.",
      "severity": "M",
      "likelihood": "U",
      "cost": "L",
      "details": "#### Abstract\r\nThe program is using a pseudorandom number generator that can produce a predictable sequence of numbers.\r\n\r\n#### Explanation\r\nThe rand() function produces numbers that are not truly random and may have a short cycle. An attacker can guess the next value that will be generated. Programmers should use a better random function that is properly seeded.",
      "examples": {
        "good": {
          "c": [
            "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\r\n\r\nvoid use_rand(void) {\r\n  int r;\r\n  int i;\r\n  time_t t;\r\n\r\n  // seeds the rand()\r\n  srand((unsigned) time(&t));\r\n  \r\n  // random is a better pseudorandom number generator\r\n  for (i = 0; i < 10; i++) {\r\n    r = random();\r\n    printf(\"Random %d is %d\\n\", i, r);\r\n  }\r\n  \r\n}\r\n"
          ]
        },
        "bad": {
          "c": [
            "#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nvoid use_rand(void) {\r\n  int r;\r\n  int i;\r\n\r\n  // the same sequence will be printed every time this function is called\r\n  for (i = 0; i < 10; i++) {\r\n    r = rand();\r\n    printf(\"Random %d is %d\\n\", i, r);\r\n  }\r\n  \r\n}\r\n"
          ]
        }
      },
      "standards": {
        "owasp": [
          "A3"
        ],
        "cwe": [
          "338",
          "327",
          "330"
        ]
      },
      "csv_string": [
        "M30C2",
        "M30C1",
        "M30C0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 126,
      "category": "VUL",
      "language": "c/c++",
      "code": "INT32-C",
      "name": "Make sure that operations on signed integers do not wraparound or overflow",
      "desc": "The program has operations in expressions with signed integers that may cause integer overflow or wraparound",
      "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} has operations in expressions with signed integers.",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "details": "",
      "examples": {
        "good": {},
        "bad": {}
      },
      "standards": {
        "cwe": [
          "190",
          "191",
          "680"
        ]
      },
      "csv_string": [
        "N322",
        "N321",
        "N320"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 127,
      "category": "VUL",
      "language": "Java",
      "code": "IDS04-J",
      "name": "Safely extract files from ZipInputStream",
      "desc": "The program is extracting file entries from a zip file using java.util.zip.ZipInputStream without any sanitization or resource guard measures.",
      "msg_templ": "In file ${si.filename}, line ${si.line}, function ${si.func} is extracting file entries from a zip file without any sanitization or resource guard measures.",
      "severity": "L",
      "likelihood": "P",
      "cost": "H",
      "details": "#### Abstract\r\nThe program is extracting file entries from a zip file using java.util.zip.ZipInputStream without sanitization or resource guard measures.\r\n\r\n#### Explanation\r\nWhen using the java.util.zip package to extract file entries from a zip file then file names may contain path information. These file names must be canonicalized and validated to prevent path injection attacks. Resource usage must also be tracked to ensure resources will not be exhausted that could result in a denial of service.\r\n\r\n",
      "examples": {
        "good": {
          "java": [
            "import java.util.zip.*;\r\nimport java.io.*;\r\n\r\n\r\npublic class IDS04J_good {\r\n    public static void main(String[] args) throws IOException, IllegalStateException {\r\n        String zipPath = args[0];\r\n        String destPath = args[1];\r\n        \r\n        // Fix vulnerability by canonicalizing path\r\n        File checkZip = new File(zipPath);\r\n        File checkDest = new File(destPath);\r\n        String canonicalZip =  checkZip.getCanonicalPath();\r\n        String canonicalDest =  checkDest.getCanonicalPath();\r\n\r\n        // Check result of canonicalization\r\n        if (!canonicalZip.startsWith(canonicalDest)) {\r\n            throw new IllegalStateException(\"Accesing Out of Bounds Area, set a correct path\");\r\n        }\r\n    \r\n        byte[] buffer = new byte[1024];\r\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(zipPath));\r\n        ZipEntry zipEntry = zis.getNextEntry();\r\n        File destDirectory = new File(destPath);\r\n\r\n        long sizeLimit = 0x6400000; \r\n        int fileLimit = 2000; \r\n        long currentSize =  0; \r\n        int entry = 0; \r\n\r\n        try {\r\n            // Limit size to avoid DoS attack through resource exhaustion      \r\n            while (zipEntry != null) {\r\n                // Limit number of files\r\n                if (entry > fileLimit){\r\n                    throw new IllegalStateException(\"Unzipped file exceed the allowed limit\");\r\n                } \r\n                // Limit size of file\r\n                if (currentSize > sizeLimit) {\r\n                    throw new IllegalStateException(\"Unzipped file exceed the allowed size\");\r\n                }\r\n\r\n                System.out.println(\"File being extracted: \" + zipEntry);\r\n                FileOutputStream fos = new FileOutputStream(destDirectory + \"/\" + zipEntry.getName());\r\n                \r\n                int len;\r\n                while ((len = zis.read(buffer)) > 0) {\r\n                    fos.write(buffer, 0, len);\r\n                    currentSize += len;\r\n                }\r\n                fos.close();\r\n                zipEntry = zis.getNextEntry();\r\n                entry++;\r\n            }\r\n        } \r\n        finally {\r\n        \tzis.close(); \t\r\n        }\r\n    }\r\n}\r\n\r\n\r\n"
          ]
        },
        "bad": {
          "java": [
            "import java.util.zip.*;\r\nimport java.io.*;\r\n\r\n\r\npublic class IDS04J_bad {\r\n    public static void main(String[] args) throws IOException {\r\n        // Path may be manipulated to access areas outside of intended directory\r\n        String zipPath = args[0];\r\n        String destPath = args[1];\r\n\r\n        byte[] buffer = new byte[1024];\r\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(zipPath));\r\n        ZipEntry zipEntry = zis.getNextEntry();\r\n        File destDirectory = new File(destPath);\r\n\r\n        try {          \r\n            // Exhaustion of resource without limit to the size of zip files in while loop\r\n            while (zipEntry != null) {\r\n                System.out.println(\"File being extracted: \" + zipEntry);\r\n                FileOutputStream fos = new FileOutputStream(destDirectory + \"/\" + zipEntry.getName());\r\n\r\n                int len;\r\n                while ((len = zis.read(buffer)) > 0) {\r\n                    fos.write(buffer, 0, len);\r\n                }\r\n\r\n                fos.close();\r\n                zipEntry = zis.getNextEntry();\r\n            }\r\n        } \r\n        finally {\r\n        \tzis.close(); \t\r\n        }\r\n    }\r\n}\r\n\r\n\r\n"
          ]
        }
      },
      "standards": {
        "cwe": [
          "409"
        ]
      },
      "csv_string": [
        "I04J0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 128,
      "category": "VUL",
      "language": "c,c++,java",
      "code": "IDS03-J",
      "name": "Unsanitized user information should not be exposed",
      "desc": "Sensitive data leakage arises When unsanitized user input are logged or put out in standard output (stdout) device.",
      "msg_templ": "",
      "severity": "H",
      "likelihood": "P",
      "cost": "L",
      "details": "#### Abstract\nSensitive data leakage arises When unsanitized user input are logged or put out in standard output (stdout) device.\n\n#### Explanation\nLogging unsanitized user input can result in sensitive data leakage across a trusted boundary. A log injection attack may arise leading to further information leakage. This vulnerability is not limited to Java programs. C/C++ programs can subject to the same attack as show in the C example.",
      "examples": {
        "good": {
          "c": [
            "\nusing namespace mychain;\nusing namespace MyContract::Sample;\n\nclass demoBranch:public Contract {\npublic:\n    TransferPtr m_ptransfer;\n\n    demoBranch() {\n        m_ptransfer = GetTransferM();\n    }\n    INTERFACE void Init() {\n        InitRoot();\n    }\n    \n    INTERFACE void LeakToLog(const std::string& sAccountName ) {\n        if(!m_ptransfer) {\n            Revert(\"error\");\n        }\n\n\t// get account, balance etc\n        AccountMMapPtr pAccountMap = m_ptransfer->get_accounts();\n        if (!pAccountMap) {\n            Revert(\"AcountMMapPtr Error.\");\n        }\n\n        // obtain user account number and name\n\t// ...\n\n\t//\n        int32_t iBalanceRmb = pBalance->get_rmb();\n        std::string sBalanceTopic = std::to_string(iBalanceRmb);\n        std::vector<std::string> leak_msg;\n        leak_msg.push_back(sAccountName);\n        leak_msg.push_back(sBalanceTopic);\n\n        if (iBalanceRmb < 1) {\n\t  // Sanitize and clean up message before logging\n          Log(std::string(\"acc_bal\"), SanitizeUser(leak_msg));\n        }\n    }\n};\nINTERFACE_EXPORT(demoBranch, (Init) (LeakToLog))\n"
          ],
          "java": [
            "locationClient = new LocationClient(this, this, this);\nlocationClient.connect();\ncurrentUser.setLocation(locationClient.getLastLocation());\n... \n\ncatch (Exception e) {\n    AlertDialog.Builder builder = new AlertDialog.Builder(this);\n    builder.setMessage(\"Application Error.\");\n    AlertDialog alert = builder.create();\n    alert.show();\n\n    // user location is \"sanitized\" being written to log\n    Log.e(\"Example\", \"Caught exception: \" + e + \" User:\" + sanitizeUser(User.toString()));\n}\n"
          ]
        },
        "bad": {
          "c": [
            "\nusing namespace mychain;\nusing namespace MyContract::Sample;\n\nclass demoBranch:public Contract {\npublic:\n    TransferPtr m_ptransfer;\n\n    demoBranch() {\n        m_ptransfer = GetTransferM();\n    }\n    INTERFACE void Init() {\n        InitRoot();\n    }\n    \n    INTERFACE void LeakToLog(const std::string& sAccountName ) {\n        if(!m_ptransfer) {\n            Revert(\"error\");\n        }\n\n\t// get account, balance etc\n        AccountMMapPtr pAccountMap = m_ptransfer->get_accounts();\n        if (!pAccountMap) {\n            Revert(\"AcountMMapPtr Error.\");\n        }\n\n        // obtain user account number and name\n\t// ...\n\n\t//\n        int32_t iBalanceRmb = pBalance->get_rmb();\n        std::string sBalanceTopic = std::to_string(iBalanceRmb);\n        std::vector<std::string> leak_msg;\n        leak_msg.push_back(sAccountName);\n        leak_msg.push_back(sBalanceTopic);\n\t\n        if (iBalanceRmb < 1) {\n          Log(std::string(\"acc_bal\"), leak_msg);\n        }\n    }\n};\nINTERFACE_EXPORT(demoBranch, (Init) (LeakToLog))\n"
          ],
          "java": [
            "locationClient = new LocationClient(this, this, this);\nlocationClient.connect();\ncurrentUser.setLocation(locationClient.getLastLocation());\n... \n\ncatch (Exception e) {\n    AlertDialog.Builder builder = new AlertDialog.Builder(this);\n    builder.setMessage(\"Application Error.\");\n    AlertDialog alert = builder.create();\n    alert.show();\n\n    // user location is written to log\n    Log.e(\"Example\", \"Caught exception: \" + e + \" User:\" + User.toString());\n}\n"
          ]
        }
      },
      "csv_string": [
        "SIL0"
      ],
      "standards": {},
      "alias": {},
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 129,
      "category": "",
      "language": "c/c++",
      "code": "FIO39-C",
      "name": "Do not alternately input and output from a stream without an intervening flush or positioning call",
      "details": "",
      "examples": {
        "good": {},
        "bad": {}
      },
      "csv_string": [
        "F39C0"
      ],
      "severity": "L",
      "likelihood": "L",
      "cost": "M",
      "standards": {},
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 130,
      "category": "",
      "language": "c/c++",
      "code": "POS39-C",
      "name": "Remark: Only work for self-created example because ntolh() ... is replaced by a custom user written function. See TG-137",
      "details": "",
      "examples": {
        "good": {},
        "bad": {}
      },
      "csv_string": [
        "P39C0"
      ],
      "severity": "M",
      "likelihood": "L",
      "cost": "L",
      "standards": {},
      "alias": {},
      "ruleSet": {
        "id": "S",
        "code": "CERT",
        "displayName": "CERT"
      }
    },
    {
      "master_id": 132,
      "category": "VUL",
      "language": "c/c++",
      "code": "MLU",
      "name": "Missing lock or unlock",
      "desc": "The paired lock and unlock mutex program idiom is broken, missing one or the other counterpart",
      "msg_templ": "",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "details": "#### Abstract\nThe paired lock and unlock mutex program idiom is broken, missing one or the other counterpart\n\n#### Explanation\nA thread must enter or leave a mutex region through proper invokation of the corresponding lock or unlock functions. Failure to doing so will cause starvation for other threads.",
      "examples": {
        "good": {
          "c": [
            "void hc1_good (int ret) {\n  int i;\n  for (i = 0; i < 100; i++){\n    pthread_mutex_lock(&g_struct[i].mutex);\n    if (ret > 0) {\n      if (ret < 100) {\n        printf(\"ret < 100\\n\");\n        pthread_mutex_unlock(&g_struct[i].mutex);\n        break;\n      }\n      else {\n\t// unlock before break \n        if (ret > 1000) {\n          printf(\"ret > 1000\\n\");\n          pthread_mutex_unlock(&g_struct[i].mutex);\n          break;\n        }\n      }\n    }\n    pthread_mutex_unlock(&g_struct[i].mutex);\n  }\n}\n \n"
          ]
        },
        "bad": {
          "c": [
            "#include <pthread.h>\n#include <stdio.h>\n \ntypedef struct sMutex_Lock {\n  int index;\n  pthread_mutex_t mutex;\n} Mutex_Lock_Type;\n \nMutex_Lock_Type g_struct[100];\n \nvoid hc1_bad (int ret) {\n  int i;\n  for (i = 0; i < 100; i++){\n    pthread_mutex_lock(&g_struct[i].mutex);\n    if (ret > 0) {\n      if (ret < 100) {\n        printf(\"ret < 100\\n\");\n        pthread_mutex_unlock(&g_struct[i].mutex);\n        break;\n      }\n      else {\n\t// break statement exits the loop prematurely without calling unlock \n        if (ret > 1000) {\n          printf(\"ret > 1000\\n\");\n          break;\n        }\n      }\n    }\n    pthread_mutex_unlock(&g_struct[i].mutex);\n  }\n}\n"
          ]
        }
      },
      "standards": {
        "cwe": [
          "832"
        ]
      },
      "csv_string": [
        "MLU0"
      ],
      "alias": {},
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 133,
      "category": "VUL",
      "language": "c/c++",
      "code": "DBLI",
      "name": "Do not spin-lock initialization more than once",
      "desc": "Thread spin_lock has been initialized more than once before deinitialized.",
      "msg_templ": "",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "details": "#### Abstract\nThread spin_lock has been initialized more than once before deinitialized.\n\n#### Explanation\nAfter initializing a thread, it should be de-initialized before initialization is called again. Failure to doing so will cause starvation for other threads.",
      "examples": {
        "good": {
          "c": [
            " \n#include <linux/spinlock.h>\n \nstruct sbuf_mgr {\n  int         sbuf_inited;\n  spinlock_t  sbuf_lock;\n  char       *sbuf;\n};\n \nint is_sbuf_inited(struct sbuf_mgr *p_sbuf_mgr);\nvoid sbuf_mgr_reset(struct sbuf_mgr *p_sbuf_mgr);\nvoid write_data(struct sbuf_mgr *p_sbuf_mgr);\n \n// thread 1\nint *worker1(void *args)\n{\n  struct sbuf_mgr * p_sbuf_mgr = args;\n  if (is_sbuf_inited(p_sbuf_mgr)) {\n     write_data(p_sbuf_mgr);\n  }\n  return 0;\n}\n \nint is_sbuf_inited( struct sbuf_mgr *p_sbuf_mgr )\n{\n    int tmp_inited;\n    unsigned long irq_flags;\n    spin_lock_irqsave( &p_sbuf_mgr->sbuf_lock, irq_flags );\n    tmp_inited = p_sbuf_mgr->sbuf_inited;\n    spin_unlock_irqrestore( &p_sbuf_mgr->sbuf_lock, irq_flags );\n    return tmp_inited;\n}\n \n// thread 2\nint *worker2(void *args)\n{\n  struct sbuf_mgr * p_sbuf_mgr = args;\n\n  // spin_lock_init called in thread2 with this call\n  sbuf_mgr_reset(p_sbuf_mgr);\n  return 0;\n}\n \nvoid sbuf_mgr_reset( struct sbuf_mgr *p_sbuf_mgr )\n{\n    int i;\n    unsigned long irq_flags;\n    \n    spin_lock_init(&(p_sbuf_mgr->sbuf_lock));  \n    spin_lock_irqsave(&p_sbuf_mgr->sbuf_lock, irq_flags);\n    // .. do the work \n}\n \nint test_init_in_thread(void)\n{\n  struct sbuf_mgr buf_mgr;\n  struct task_struct *worker1_task, *worker2_task;\n \n  worker1_task = kthread_create(worker1, (void*)&buf_mgr, \"thread1\");\n \n  worker2_task = kthread_create(worker2, (void*)&buf_mgr, \"thread2\");\n  // ,,, \n  \n  // start tasks\n  wake_up_process(worker1_task);\n  wake_up_process(worker2_task);\n  return 0;\n}\n \nvoid init(struct sbuf_mgr *buf_mgr)\n{\n  spin_lock_init(&(buf_mgr->sbuf_lock));\n}\n  \nint test_double_init(bool is_double_init)\n{\n  struct sbuf_mgr buf_mgr;\n\n  // initialization only if boolean is false\n  if (!is_double_init)\n    init(&buf_mgr);\n  \n  return;  \n}\n"
          ]
        },
        "bad": {
          "c": [
            "#include <linux/spinlock.h>\n \nstruct sbuf_mgr {\n  int         sbuf_inited;\n  spinlock_t  sbuf_lock;\n  char       *sbuf;\n};\n \nint is_sbuf_inited(struct sbuf_mgr *p_sbuf_mgr);\nvoid sbuf_mgr_reset(struct sbuf_mgr *p_sbuf_mgr);\nvoid write_data(struct sbuf_mgr *p_sbuf_mgr);\n \n// thread 1\nint *worker1(void *args)\n{\n  struct sbuf_mgr * p_sbuf_mgr = args;\n  if (is_sbuf_inited(p_sbuf_mgr)) {\n     write_data(p_sbuf_mgr);\n  }\n  return 0;\n}\n \nint is_sbuf_inited( struct sbuf_mgr *p_sbuf_mgr )\n{\n    int tmp_inited;\n    unsigned long irq_flags;\n    spin_lock_irqsave( &p_sbuf_mgr->sbuf_lock, irq_flags );\n    tmp_inited = p_sbuf_mgr->sbuf_inited;\n    spin_unlock_irqrestore( &p_sbuf_mgr->sbuf_lock, irq_flags );\n    return tmp_inited;\n}\n \n// thread 2\nint *worker2(void *args)\n{\n  struct sbuf_mgr * p_sbuf_mgr = args;\n\n  // spin_lock_init called in thread2 with this call\n  sbuf_mgr_reset(p_sbuf_mgr);\n  return 0;\n}\n \nvoid sbuf_mgr_reset( struct sbuf_mgr *p_sbuf_mgr )\n{\n    int i;\n    unsigned long irq_flags;\n    \n    spin_lock_init(&(p_sbuf_mgr->sbuf_lock));  \n    spin_lock_irqsave(&p_sbuf_mgr->sbuf_lock, irq_flags);\n    // .. do the work \n}\n \nint test_init_in_thread(void)\n{\n  struct sbuf_mgr buf_mgr;\n  struct task_struct *worker1_task, *worker2_task;\n \n  worker1_task = kthread_create(worker1, (void*)&buf_mgr, \"thread1\");\n \n  worker2_task = kthread_create(worker2, (void*)&buf_mgr, \"thread2\");\n  // ,,, \n  \n  // start tasks\n  wake_up_process(worker1_task);\n  wake_up_process(worker2_task);\n  return 0;\n}\n \nvoid init(struct sbuf_mgr *buf_mgr)\n{\n  spin_lock_init(&(buf_mgr->sbuf_lock));\n}\n  \nint test_double_init(bool is_double_init)\n{\n  struct sbuf_mgr buf_mgr;\n\n  // first initialization \n  init(&buf_mgr);\n  \n  if (is_double_init) {\n    // if true, call init, causing double init\n    init(&buf_mgr);\n  }\n}\n"
          ]
        }
      },
      "standards": {
        "cwe": [
          "609"
        ]
      },
      "csv_string": [
        "DBLI0"
      ],
      "alias": {
        "cert": [
          "CON35-C"
        ]
      },
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 134,
      "category": "VUL",
      "language": "c/c++",
      "code": "LIIT",
      "name": "Do no call spinlock initialization in a thread",
      "desc": "Calling spinlock initialization in a thread may result the thread being initialized multiple times.",
      "msg_templ": "",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "details": "#### Abstract\nCalling spinlock initialization in a thread may result the thread being initialized multiple times.\n\n#### Explanation\nA thread should not be initialized multiple times, directly or indirectly. Doing so will cause starvation for other threads.",
      "examples": {
        "good": {},
        "bad": {
          "c": [
            "#include <linux/spinlock.h>\n \nstruct sbuf_mgr {\n  int         sbuf_inited;\n  spinlock_t  sbuf_lock;\n  char       *sbuf;\n};\n \nint is_sbuf_inited(struct sbuf_mgr *p_sbuf_mgr);\nvoid sbuf_mgr_reset(struct sbuf_mgr *p_sbuf_mgr);\nvoid write_data(struct sbuf_mgr *p_sbuf_mgr);\n \n// thread 1\nint *worker1(void *args)\n{\n  struct sbuf_mgr * p_sbuf_mgr = args;\n  if (is_sbuf_inited(p_sbuf_mgr)) {\n     write_data(p_sbuf_mgr);\n  }\n  return 0;\n}\n \nint is_sbuf_inited( struct sbuf_mgr *p_sbuf_mgr )\n{\n    int tmp_inited;\n    unsigned long irq_flags;\n    spin_lock_irqsave( &p_sbuf_mgr->sbuf_lock, irq_flags );\n    tmp_inited = p_sbuf_mgr->sbuf_inited;\n    spin_unlock_irqrestore( &p_sbuf_mgr->sbuf_lock, irq_flags );\n    return tmp_inited;\n}\n \n// thread 2\nint *worker2(void *args)\n{\n  struct sbuf_mgr * p_sbuf_mgr = args;\n\n  // spin_lock_init called with this call, can result in double init\n  sbuf_mgr_reset(p_sbuf_mgr);\n  return 0;\n}\n \nvoid sbuf_mgr_reset( struct sbuf_mgr *p_sbuf_mgr )\n{\n    int i;\n    unsigned long irq_flags;\n    \n    spin_lock_init(&(p_sbuf_mgr->sbuf_lock));  \n    spin_lock_irqsave(&p_sbuf_mgr->sbuf_lock, irq_flags);\n    // .. do the work \n}\n \nint test_init_in_thread(void)\n{\n  struct sbuf_mgr buf_mgr;\n  struct task_struct *worker1_task, *worker2_task;\n \n  worker1_task = kthread_create(worker1, (void*)&buf_mgr, \"thread1\");\n \n  worker2_task = kthread_create(worker2, (void*)&buf_mgr, \"thread2\");\n  // ,,, \n  \n  // start tasks\n  wake_up_process(worker1_task);\n  wake_up_process(worker2_task);\n  return 0;\n}\n \nvoid init(struct sbuf_mgr *buf_mgr)\n{\n  spin_lock_init(&(buf_mgr->sbuf_lock));\n}\n  \nint test_double_init(bool is_double_init)\n{\n  struct sbuf_mgr buf_mgr;\n\n  // first initialization \n  init(&buf_mgr);\n  \n  if (is_double_init) {\n    // if true, call init, causing double init\n    init(&buf_mgr);\n  }\n}\n"
          ]
        }
      },
      "csv_string": [
        "LIIT0"
      ],
      "standards": {},
      "alias": {},
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 135,
      "category": "VUL",
      "language": "c/c++",
      "code": "SLAE",
      "name": "SpinLock variable address escaped",
      "desc": "Address of a spinlock variable has escaped and may cause deadlock situation",
      "msg_templ": "",
      "severity": "L",
      "likelihood": "U",
      "cost": "M",
      "details": "#### Abstract\nAddress of a spinlock variable has escaped and may cause deadlock situation\n\n#### Explanation\nWhen the address of a spinlock variable is exposed to outside of a thread, the thread may not be properly unlock resulting in possible deadlock situation.",
      "examples": {
        "good": {},
        "bad": {
          "c": [
            "#include <linux/spinlock.h>\nvoid bad(int irq, spinlock_t lock)\n{\n  // \n  spin_lock(&lock);\n}\n \nvoid bad2(int irq, spinlock_t lock, spinlock_t lock2)\n{\n  spin_lock(&lock);\n}\n"
          ]
        }
      },
      "standards": {
        "cwe": [
          "412"
        ]
      },
      "csv_string": [
        "SLAE0"
      ],
      "alias": {
        "cert": [
          "CON38-C"
        ]
      },
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 136,
      "category": "VUL",
      "language": "c/c++",
      "code": "LNR",
      "name": "",
      "desc": "",
      "msg_templ": "",
      "severity": "M",
      "likelihood": "P",
      "cost": "H",
      "standards": {
        "cwe": [
          "833"
        ]
      },
      "csv_string": [
        "LNR0"
      ],
      "alias": {
        "cert": [
          "CON30-C"
        ]
      },
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 137,
      "category": "VUL",
      "language": "c/c++",
      "code": "SAC",
      "name": "Sleep in atomic-context or locked region",
      "desc": "The program has entered an atomic region/context, within that region, there is operation that may cause the program to pause, delay due to interrupt or sleep.",
      "details": "#### Abstract\nThe program has entered an atomic region/context, within that region, there is operation that may cause the program to pause, delay due to interrupt or sleep. \n\n\n#### Explanation\nWhen a program is inside an atomic context or locked region, any operation that may pause due to sleep, interrupt or wait etc may cause dead lock.",
      "examples": {
        "good": {
          "c": [
            "#include <linux/spinlock.h>\nvoid test_isr1(int irq, spinlock_t *lock)\n{\n  // this guarantees interrupt state is saved and that\n  // the critical section will not be preempted by the kernel\n  spin_lock_irqsave(lock);  \n}\n \n \n// cross function check\nnoinline\nvoid call_spin(spinlock_t *lock)\n{\n  spin_lock(lock);\n}\n",
            "#include <stdio.h>\r\n#include <pthread.h>\r\n\r\nint num = 8; // global variable\r\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; // initialise a mutex\r\n\r\nint main() {\r\n    pthread_mutex_lock(&lock); // enter mutex locked region\r\n    switch (num) {\r\n    case 0:\r\n            num = 0;\r\n            break;\r\n    case 1:\r\n            num++;\r\n            break;\r\n    case 2:\r\n            num--;\r\n            break;\r\n    default:\r\n            pthread_mutex_unlock(&lock); // exit mutex lock region\r\n            return 0;\r\n    }\r\n    pthread_mutex_unlock(&lock); // exit mutex lock region\r\n    return 0;\r\n}\r\n",
            "#include <stdio.h>\r\n#include <pthread.h>\r\n#include <unistd.h>\r\n\r\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; // initialise a mutex\r\nint num; // global variable\r\n\r\nint main () {\r\n    pthread_mutex_lock(&lock); // enter mutex lock region\r\n    num++;\r\n    pthread_mutex_unlock(&lock); // exit mutex lock region\r\n    return 0;\r\n}\r\n"
          ]
        },
        "bad": {
          "c": [
            "#include <linux/spinlock.h>\nvoid test_isr1(int irq, spinlock_t *lock)\n{\n  spin_lock(lock);  // VUL: should use spin_lock_irqsave\n}\n \n// cross function check\nnoinline\nvoid call_spin(spinlock_t *lock)\n{\n  spin_lock(lock);\n}\n\n\n",
            "#include <stdio.h>\r\n#include <pthread.h>\r\n\r\nint num = 8; // global variable\r\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; // initialise a mutex\r\n\r\nint main() {\r\n    pthread_mutex_lock(&lock); // enter mutex locked region\r\n    switch (num) {\r\n    case 0:\r\n            num = 0;\r\n            break;\r\n    case 1:\r\n            num++;\r\n            break;\r\n    case 2:\r\n            num--;\r\n            break;\r\n    default:\r\n            // does not exit mutex lock region before return\r\n            // can cause a deadlock because lock is never released\r\n            return 0;\r\n    }\r\n    pthread_mutex_unlock(&lock); // exit mutex lock region\r\n    return 0;\r\n}\r\n",
            "\r\n#include <stdio.h>\r\n#include <pthread.h>\r\n#include <unistd.h>\r\n\r\npthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; // initialise a mutex\r\nint num; // global variable\r\n\r\nint main () {\r\n    pthread_mutex_lock(&lock); // enter mutex lock region\r\n    num++;\r\n    sleep(1); // thread goes to sleep within lock region, never want to do this\r\n    pthread_mutex_unlock(&lock); // exit mutex lock region\r\n    return 0;\r\n}\r\n"
          ]
        }
      },
      "csv_string": [
        "SAC0"
      ],
      "severity": "L",
      "likelihood": "L",
      "cost": "H",
      "standards": {},
      "alias": {},
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 138,
      "category": "VUL",
      "language": "c/c++",
      "code": "LLAT",
      "name": "Thread local live after thread is terminated",
      "desc": "When a thread local's address has been saved, it can be called by its holder even after the thread has been terminated.",
      "msg_templ": "",
      "severity": "M",
      "likelihood": "P",
      "cost": "H",
      "details": "#### Abstract\nWhen a thread local's address has been saved, it can be called by its holder even after the thread has been terminated.\n\n#### Explanation\nExposing address of a thread local variable can lead to unintended calls to illegal locks, or functions that are no longer valid. This results in non-deterministic behavior.",
      "examples": {
        "good": {},
        "bad": {
          "c": [
            " \nstruct completion {\n  int done;\n};\n \nstruct usb_request {\n  struct completion *context;\n  void (*complete)(struct usb_request *req);\n};\n \nvoid complete(struct completion *x)\n{\n  printf(\"%d\\n\", x->done);\n}\n \nvoid ffs_epfile_io_complete(struct usb_request *req)\n{\n  complete(req->context);\n}\n \nvoid usb_ep_queue(struct usb_request *req)\n{\n  req->complete(req);\n}\n \nvoid ffs_epfile_io(struct usb_request *req)\n{\n  struct completion done;\n  req->context = &done;\n  req->complete = ffs_epfile_io_complete;\n  usb_ep_queue(req);\n}\n \n"
          ]
        }
      },
      "standards": {
        "cwe": [
          "412"
        ]
      },
      "csv_string": [
        "LLAT0"
      ],
      "alias": {
        "cert": [
          "CON30-C"
        ]
      },
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 139,
      "category": "VUL",
      "language": "c/c++",
      "code": "UIL",
      "name": "Uninitialized lock",
      "desc": "The lock has not been initialized when spin_lock was called.",
      "msg_templ": "",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "details": "#### Abstract\nThe lock has not been initialized when spin_lock was called.\n\n#### Explanation\nResource alloation is required to use a spin lock, it also needed to be initialized to an unlock state. Failure to do so will lead to non-determinstic system behavior",
      "examples": {
        "good": {},
        "bad": {
          "c": [
            "#include <stddef.h>\n#include <pthread.h>\n \nvoid mutex_initialise(pthread_mutex_t *lock) {\n  pthread_mutex_init(lock, NULL);\n}\n \nvoid mutex_lock(pthread_mutex_t *lock) {\n  pthread_mutex_lock(lock);\n}\n \nvoid mutex_unlock(pthread_mutex_t *lock) {\n  pthread_mutex_unlock(lock);\n}\n \nint main(void) {\n    pthread_mutex_t mlock;\n    \n    // mutex_initialize, nor pthread_mutex_init has been invoked\n    mutex_lock(&mlock);\n    mutex_unlock(&mlock);\n    return 0;\n}\n"
          ]
        }
      },
      "standards": {
        "cwe": [
          "667"
        ]
      },
      "csv_string": [
        "UIL0"
      ],
      "alias": {
        "cert": [
          "CON35-C"
        ]
      },
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "master_id": 140,
      "category": "VUL",
      "language": "c/c++",
      "code": "TASR",
      "name": "Race condition from test-and-set",
      "desc": "Test-and-set without proper locking may cause race condition",
      "msg_templ": "",
      "severity": "M",
      "likelihood": "P",
      "cost": "H",
      "details": "#### Abstract\nTest-and-set without proper locking may cause race condition\n\n#### Explanation\nModifying the variables that are decided in the test-and-set operation in a thread may cause a race condition if such an operation is not protected by the lock.",
      "examples": {
        "good": {},
        "bad": {
          "c": [
            "extern int printf(const char*, ...);\nextern int get_int();\n \nvoid cmp_set_race_bad() {\n  int flag = get_int();\n  if (flag == 0) {\n    flag = 1;\n  }\n  else {\n    printf(\"\\n\");\n  }\n  printf(\"1st: get %d\\n\", flag);\n  flag = get_int();\n  if (flag != 0) {\n    printf(\"2nd: get %d\\n\", flag);\n  }\n  else {\n    flag = 1;\n  }\n  printf(\"final: %d\\n\", flag);\n}\n"
          ]
        }
      },
      "csv_string": [
        "TASR0"
      ],
      "standards": {},
      "alias": {
        "cert": [
          "CON43-C"
        ]
      },
      "ruleSet": {
        "id": "X",
        "code": "BUILTIN",
        "displayName": "XCALIBYTE"
      }
    },
    {
      "category": "Advisory",
      "language": "c",
      "code": "MSR_2_3",
      "master_id": 2001,
      "name": "A project should not include undefined data types",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\ntypedef int used; // type is declared here\n\nint main()\n{\n    used a = 1; // type is used here\n    printf(\"%d\",a);\n    return 0;\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\ntypedef int used; // type is declared but not used\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func} includes undefined data types.",
      "desc": "A project should not include undefined data types",
      "details": "#### Abstract\nA project should not include undefined data types\n\n#### Explanation\nAn undefined data type will cause a waste of resources. When reviewing the code, it will also be difficult to determine whether the data type is not used due to an error in the programming process or if it is just extra code. ",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_2_3"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "Advisory",
      "language": "c",
      "code": "MSR_2_6",
      "master_id": 2002,
      "name": "Unused label in function not allowed",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int i = 5;\n    goto lab1; // label used\n    if (i != 5) i = 5;\nlab1: // label declared\n    return i;\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int i = 5;\n    if (i != 5) i = 5;\nlab1: // unused label declared\n    return i;\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, unused tags are declared in ${so.func}.",
      "desc": "Unused tags cannot be declared in the function",
      "details": "#### Abstract\nUnused tags cannot be declared in the function\n\n#### Explanation\nThe reviewer of the code cannot judge whether the unused tag is redundant or is not used due to negligence, so the unused label cannot be declared. ",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_2_6"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "Advisory",
      "language": "c",
      "code": "MSR_2_7",
      "master_id": 2003,
      "name": "All declared parameters must be used",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nint Addtion(int a,int b,int c);\n\nint main()\n{\n    printf(\"%d\",Addtion(1,2,3));\n    return 0;\n}\nint Addtion(int a,int b,int c)\n{\n    return a+b+c; // every parameter is used\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nint Addtion(int a,int b,int c);\n\nint main()\n{\n    printf(\"%d\",Addtion(1,2,3));\n    return 0;\n}\n // three parameters are defined\nint Addtion(int a,int b,int c)\n{\n    return a+b; // only two of them are used\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, unused parameters appear in ${so.func}.",
      "desc": "Unused parameters should not appear in the function",
      "details": "#### Abstract\nUnused parameters should not appear in the function\n\n#### Explanation\nThe function should use all its parameters. If the function does not use all its parameters, the implementation will not match the declaration of the function. ",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_2_7"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "Required",
      "language": "c",
      "code": "MSR_5_1",
      "master_id": 2004,
      "name": "All external identifiers must be unique up to 31 characters",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nint main()\n{\n    // the first 31 characters are distinct\n    int a_non_compliant_example_a = 1;\n    int a_non_compliant_example_b = 2; \n    int a;\n    a = a_non_compliant_example_a + a_non_compliant_example_b;\n    printf(\"%d\\n\",a);\n    return 0;\n} "
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nint main()\n{\n    // the first 31 characters are not distinct\n    int this_is_a_non_compliant_example_a = 1;\n    int this_is_a_non_compliant_example_b = 2; \n    int a;\n    a = this_is_a_non_compliant_example_a + this_is_a_non_compliant_example_b;\n    printf(\"%d\\n\",a);\n    return 0;\n} "
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, external identifiers are not unique.",
      "desc": "The external identifier must be distinguishable",
      "details": "#### Abstract\nThe external identifier must be distinguishable\n\n#### Explanation\nIn the C99 standard, external identifiers should be distinguished by at least the first 31 characters. The external identifiers must be distinct with respect to the first 31 characters, so they are deemed unique by the compiler. ",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_5_1"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "Required",
      "language": "c",
      "code": "MSR_5_2",
      "master_id": 2005,
      "name": "Identifiers of same scope and name space must be unique",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\n// this example have two identifiers, first 31 characters are the same\nextern int this_is_a_non_compliant_example_a = 1; // first identifier, global scope\n\nint main()\n{\n    int a;\n    int this_is_a_non_compliant_example_b = 2; // two identifiers are defined in local scope\n    a = 1 + this_is_a_non_compliant_example_b;\n    printf (\"%d\\n\",a);\n    return 0;\n} "
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\n// this example have two identifiers, first 31 characters are the same\nextern int a_non_compliant_example_a = 1;\nextern int a_non_compliant_example_b = 2; // two indistinct identifiers are defined in the same scope\n\nint main()\n{\n    int a;\n    a = 1 + a_non_compliant_example_b;\n    printf(\"%d\\n\",a);\n    return 0;\n} "
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, identifiers are not distinguishable.",
      "desc": "Identifiers declared in the same scope and name space should be distinguishable",
      "details": "#### Abstract\nIdentifiers declared in the same scope and name space should be distinguishable\n\n#### Explanation\nIn the same scope, the first 31 characters of different identifiers should not be exactly the same to ensure they are distinguishable.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_5_2"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "Required",
      "language": "c",
      "code": "MSR_5_3",
      "master_id": 2006,
      "name": "Identifiers in inner and outer scope must be distinct",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nint a = 3; // identifier defined, outer scope\n\nint main()\n{\n    int b; // identifier defined, inner scope, different form the outer one\n    b = 4;\n    printf(\"%d\",b);\n    return 0;\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nint a = 3; // identifier defined, outer scope\n\nint main()\n{\n    int a; // identifier defined, inner scope, covering the outer one\n    a = 4;\n    printf(\"%d\",a);\n    return 0;\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, identifiers are not distinct.",
      "desc": "The identifier of the internal scope should be different from the identifier of the external scope",
      "details": "#### Abstract\nThe identifier of the internal scope should be different from the identifier of the external scope\n\n#### Explanation\nWhen defining variables in the internal scope, you should avoid having the same name as the external scope to prevent creating ambiguity.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_5_3"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "Required",
      "language": "c",
      "code": "MSR_5_6",
      "master_id": 2007,
      "name": "typedef name should be a unique identifier",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\ntypedef int my_name; // unique typedef declared\n\nint main()\n{\n    int my_name_2 = 1; // unique variable declared \n    printf(\"%d\",my_name_2);\n    return 0;\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\ntypedef int my_name; // typedef declared\n\nint main()\n{\n    int my_name = 1; // variable declared, same identifier\n    printf(\"%d\",my_name);\n    return 0;\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the typedef identifier is not unique.",
      "desc": "A typedef identifier must be unique",
      "details": "#### Abstract\nA typedef identifier must be unique\n\n#### Explanation\nUnless the alias is defined in the header file, and the header file is included, the alias defined by the typedef used must be unique in all namespaces.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_5_6"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_5_7",
      "master_id": 2008,
      "name": "Tag names should be a unique identifier",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nstruct my_name // unique tag declared\n{\n    int a;\n    int b;\n};\n\nint main()\n{\n    int my_name_2 = 1; // unique variable declared\n    printf(\"%d\",my_name_2);\n    return 0;\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nstruct my_name // tag declared\n{\n    int a;\n    int b;\n};\n\nint main()\n{\n    int my_name = 1; // variable declared, same identifier\n    printf(\"%d\",my_name);\n    return 0;\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, tag names are not unique identifiers.",
      "desc": "A tag must be unique",
      "details": "#### Abstract\nA tag must be unique\n\n#### Explanation\nUnless the tag is defined in the header file, and the header file is included, the tag used must be unique in all namespaces.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_5_7"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_6_1",
      "master_id": 2009,
      "name": "Bit field types must not be builtin types",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nstruct str\n{\n    signed int a:2;   // signed int permitted\n    unsigned int b:2; // unsigned int permitted\n};\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nstruct str\n{\n    int a:2;   // plain int not permitted\n    float b:2; // float is inappropriate \n};\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, bit fields are not appropriate data types.",
      "desc": "Bit fields must be declared as appropriate data types",
      "details": "#### Abstract\nBit fields must be declared as appropriate data types\n\n#### Explanation\nWhen declaring a bit field, it must be declared as one of the specified data types either signed or unsigned. It cannot be omitted in the declaration.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_6_1"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_6_2",
      "master_id": 2010,
      "name": "Single-bit named field must be unsigned",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nstruct str\n{\n    unsigned int a:1;   // single-bit bit field declared unsigned\n};\n\nint main()\n{\n    printf (\"finished\") ;\n    return 0;\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nstruct str\n{\n    signed int a:1;   // single-bit bit field declared signed\n};\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the single-bit named field is signed data.",
      "desc": "A bit field that only occupies one bit cannot be signed data",
      "details": "#### Abstract\nA bit field that only occupies one bit cannot be signed data\n\n#### Explanation\nSince signed data requires the first sign bit, a bit field that only occupies one bit is not allowed to be defined as a signed data type.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_6_2"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_7_4",
      "master_id": 2011,
      "name": "String literal must only be assigned to a const char pointer",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nextern int foo (const char *a);\nextern int foo2 (const char *b);\n\nint func()\n{\n    const char *str = \"string\"; // str is not const-qualified\n    foo ( \"string\" );\n    foo2 ( \"string\" ); // string can not be modified\n    return 0;\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nextern int foo (char *a);\nextern int foo2 (char *b);\n\nint func()\n{\n    char *str = \"string\"; // str is not const-qualified\n    foo ( \"string\" );\n    foo2 ( \"string\" ); // may be modified by foo\n    return 0;\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, a string literal is not assigned to char type.",
      "desc": "Always assign a string literal through a const qualified pointer to char type",
      "details": "#### Abstract\nAlways assign a string literal through a const qualified pointer to char type\n\n#### Explanation\nSince the constant string is stored in the static storage area, the modification operation will cause an error. Only the constant string can be copied to the pointer to the constant string to prevent its modification operation.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_7_4"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_8_4",
      "master_id": 2012,
      "name": "External object, when defined must be the same as a visble declaration.",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nextern int func(int a); // extern function declared\n\nint func(int a) // extern compatible funtion defined\n{\n    return 0;\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nextern int func(int a); // extern function declared\n\nint func(int a, int b) // parameters different\n{\n    return 0;\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the external object is not compatible with its declaration.",
      "desc": "Defining objects that have external linkage should be compatible with their declarations",
      "details": "#### Abstract\nDefining objects that have external linkage should be compatible with their declarations\n\n#### Explanation\nWhen defining an object or function with external linkage, the data type, number of parameters, etc. of the object or function must be compatible with the external declaration.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_8_4"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_8_8",
      "master_id": 2013,
      "name": "Objects with internal linkage should be declared static ",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nstatic int func (int a); // function with internal linkage declared\n\nstatic int func (int a) // function defined with \"static\"\n{\n    return a;\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nstatic int func (int a); // function with internal linkage declared\n\nint func (int a) // function defined without \"static\"\n{\n    return a;\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the object with internal linkage is not declared static.",
      "desc": "The static specifier should be added to the object that has internal linkage",
      "details": "#### Abstract\nThe static specifier should be added to the object that has internal linkage\n\n#### Explanation\nWhen declaring an object or function with internal linkage, a static specifier must be added to ensure the declaration is correct. ",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_8_8"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_8_9",
      "master_id": 2014,
      "name": "The object should only be defined in the scope in which it appears",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nextern int foo (int *a);\nextern void foo2 ( void );\n\nint count ( void )\n{\n    static int num = 0; // object declared at block scope\n    num++; // object appears only in this function\n    return num;\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nextern int foo(int *a);\nextern void foo2( void );\nstatic int num = 0; // object declared, global scope\n\nint count( void )\n{\n    num++; // object appears only in this function\n    return num;\n}\n\nextern void foo2( void )\n{\n    foo(&num); // object may be modified at outer scope\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the object is not defined in the scope in which it appears.",
      "desc": "The object should only be defined in the scope in which it appears",
      "details": "#### Abstract\nThe object should only be defined in the scope in which it appears\n\n#### Explanation\nWhen an object only functions in a certain scope, it should be defined in that scope to prevent other scopes from changing its value.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_8_9"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_8_10",
      "master_id": 2015,
      "name": "Inline function should have a static declaration",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nstatic inline int func( void ); // inline function declared with internal linkage\nint func2( void );\n\nint func2( void )\n{\n    func();\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nextern inline int func( void ); // inline function declared with external linkage\nint func2( void );\n\nint func2( void )\n{\n    func();\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, inline function ${so.func} does not have static declaration.",
      "desc": "A static storage class should be used to declare inline functions",
      "details": "#### Abstract\nA static storage class should be used to declare inline functions\n\n#### Explanation\nReferencing an inline function of an external linkage may affect the execution time, so the inline function should be declared with a static storage class.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_8_10"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_8_11",
      "master_id": 2016,
      "name": "The size of the array of external linkage must be explicitly specified",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nextern int array[20]; // declare array with external linkage and its size\nint foo ( void ) ;\n\nint foo ( void )\n{\n    return array[10];\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nextern int array[]; // declare array with external linkage but without size\nint foo( void );\n\nint foo ( void )\n{\n    return array[10]; // 10 may be bigger than actual array size\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the size of the array of external linkage is not explicitly specified.",
      "desc": "The size of the array of external linkage must be explicitly specified",
      "details": "#### Abstract\nThe size of the array of external linkage must be explicitly specified\n\n#### Explanation\nIn order to ensure consistency and determine the boundaries of the storage area, the size of the array must be determined when declaring an externally linked array.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_8_11"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_8_12",
      "master_id": 2017,
      "name": "An implicitly specified enum constant list should be unique",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\n// all implicitly-specified enmueration constants is unique\ntypedef enum weekday {thu = 4, fri, sat = 6, sun = 6};"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\n// implicitly-specified enmueration sat is not unique\ntypedef enum weekday {thu = 4, fri, sat, sun = 6};"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the implicitly specified enum constant list is not unique.",
      "desc": "The value of the enumeration member assigned by default must be unique",
      "details": "#### Abstract\nThe value of the enumeration member assigned by default must be unique\n\n#### Explanation\nIn order to avoid the incorrect repetition of the value of the enumeration member, the value of the enumeration member should be ",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_8_12"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_8_13",
      "master_id": 2018,
      "name": "Try to declare pointers with const qualifier",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func (const char *ptr);\n\nvoid func (const char *ptr) // pointer declared const-qualified\n{\n    // ptr pointed to is not modified\n    printf (\"%c\", *ptr);\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func (char *ptr);\n\nvoid func (char *ptr) // pointer declared is not const-qualified\n{\n    // ptr pointed to is not modified, it should be const-qualified\n    printf (\"%c\", *ptr);\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the pointer is not declared with const qualifier.",
      "desc": "Try to declare pointers with const qualifier",
      "details": "#### Abstract\nTry to declare pointers with const qualifier\n\n#### Explanation\nA pointer should always point to the same underlying qualified type. Mixed type assignments should be always explicitly casted.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_8_13"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_8_14",
      "master_id": 2019,
      "name": "Restrict qualifier should not be used",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\n// restrict type qualifier removed\nextern void func (int * ptr1, int * ptr2);\nvoid func2 (void);\n\nvoid func2(void)\n{\n    int i;\n    int *a,*b;\n    a = b = &i;\n    func (a, b);\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\n// restrict-qualified parameters declared\nextern void func (int * restrict ptr1, int * restrict ptr2);\nvoid func2 (void);\n\nvoid func2(void)\n{\n    int i;\n    int *a,*b;\n    a = b = &i;\n    // overlap memory areas\n    func (a, b);\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the restrict type qualifier is used",
      "desc": "Try to avoid using the restrict type qualifier",
      "details": "#### Abstract\nTry to avoid using the restrict type qualifier\n\n#### Explanation\nIn order to prevent problems such as overlapping of the areas pointed to by the pointer, the restrict type qualifier should be avoided as much as possible.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_8_14"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_9_3",
      "master_id": 2020,
      "name": "Arrays should not be partially initialized",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nint func( void );\n\nint func ( void )\n{\n    int a[10] = {0}; // array totally initialized\n    return a[9]; // a[9] is "
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nint func( void );\n\nint func ( void )\n{\n    int a[10] = {0, 0, 0}; // array only initialized three elements\n    return a[9]; // a[9] is still unknown value\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, arrays are partially initialized",
      "desc": "Arrays must not be partially initialized",
      "details": "#### Abstract\nArrays must not be partially initialized\n\n#### Explanation\nIn order to ensure that there are no unprocessed values in the array after explicitly initializing the array, all elements in the array must also be explicitly initialized.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_9_3"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_9_4",
      "master_id": 2021,
      "name": "Multiple initialization of elements in an object is not allowed",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func( void )\n{\n    // all elements initialized once\n    int arr[3] = { [ 0 ] = 3, [ 1 ] = 2, [ 2 ] = 1};\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func( void )\n{\n    // a[0] initialized twice\n    int arr[3] = { [ 0 ] = 3, [ 1 ] = 2, [ 2 ] = 1, [ 0 ] = 4};\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the elements in the object have been initialized more than once",
      "desc": "The elements in the object can only be initialized once",
      "details": "#### Abstract\nThe elements in the object can only be initialized once\n\n#### Explanation\nWhen initializing arrays and structures that are not in the default order, you must not initialize the same element(s) repeatedly.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_9_4"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_9_5",
      "master_id": 2022,
      "name": "If initializers are used in an array, its size must be known",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nint func ( void );\n\nint func( void )\n{\n    // arr have designated initializer with size specified explicitly\n    int arr[10] = { [ 5 ] = 1};\n    return arr[ 9 ];\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nint func ( void );\n\nint func( void )\n{\n    // flexible array declared using designated initializer\n    int arr[] = { [ 5 ] = 1};\n    // array may not have the element arr[9]\n    return arr[ 9 ];\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the size of the array that uses explicit initializer is not declared",
      "desc": "The size of the array must be declared if an explicit initializer is used on the array",
      "details": "#### Abstract\nThe size of the array must be declared if an explicit initializer is used on the array\n\n#### Explanation\nIn order to determine the maximum number of elements in the array, when this array is explicitly initialized, the array size must be specified.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_9_5"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_10_3",
      "master_id": 2023,
      "name": "Down casting of an expression is not allowed",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    short short_a;\n    int b;       // b declared as int for illustration\n    b = short_a; // short_a assigned to wider essential type object\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    short short_a;\n    long int b;\n    short_a = b; // c assigned to narrower essential type\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func} includes down casting of an expression",
      "desc": "You cannot assign values to objects with different essential types",
      "details": "#### Abstract\nYou cannot assign values to objects with different essential types\n\n#### Explanation\nIt is erroneous to assign the value of an expression to an object with an inappropriate type or is not large enough to represent the data type of the value.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_10_3"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_10_4",
      "master_id": 2024,
      "name": "operands and type conversion",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int int_var;\n    char char_var;\n    // int 1 added to char char_var, permitted\n    char_var += 1;\n    // int 1 added to int int_var, same type\n    int_var += 1;\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int int_var;\n    char char_var;\n    // float 1.0f added to char char_var, not permitted\n    char_var += 1.0f;\n    // float 1.0f added to int int_var, differnt type\n    int_var += 1.0f;\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the two operands of the same operator are not of the same essential type category",
      "desc": "The two operands of the same operator must be of the same essential type category",
      "details": "#### Abstract\nThe two operands of the same operator must be of the same essential type category\n\n#### Explanation\nUsing binary or ternary operands for two different types of operands may cause some information of the resulting value to be lost. Therefore, in general, the two operands of the uniform operator should be of the same type.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_10_4"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_10_5",
      "master_id": 2025,
      "name": "Same essential type within an expression ",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    char char_var;\n    bool bool_var;\n    // int can be cast to char\n    char_var = ( char ) 1;\n    // int 1 can be cast to bool by exception\n    bool_var = ( bool ) 1;\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    char char_var;\n    bool bool_var;\n    // expression 1.0f cast to an narrower type char\n    char_var = ( char ) 1.0f;\n    // char_var cast to narrower type bool\n    bool_var = ( bool ) char_var;\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the value of the expression is converted to an inappropriate essential type",
      "desc": "The value of the expression cannot be converted to an inappropriate essential type",
      "details": "#### Abstract\nThe value of the expression cannot be converted to an inappropriate essential type\n\n#### Explanation\nCast conversion between two inappropriate types may result in the loss or change of data, so the value of the expression cannot be cast to an inappropriate type.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_10_5"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_10_6",
      "master_id": 2026,
      "name": "Assignment from a composite expression should remain the same size ",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    long long_var;\n    short short_a, short_b;\n    short_a = 1\n    short_b = 1;\n    long_var = ( long )short_a + short_b; // explicitly converted to long\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    long int long_var;\n    short int short_a, short_b;\n    short_a = short_b = 1;\n    long_var = short_a + short_b; // implicitly converted to long\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the use of composite expressions to assign values to objects of larger data types does not use explicit conversions",
      "desc": "The use of composite expressions to assign values to objects of larger data types should use explicit conversions",
      "details": "#### Abstract\nThe use of composite expressions to assign values to objects of larger data types should use explicit conversions\n\n#### Explanation\nExplicit conversion must be used when converting the value of a composite expression to a data type with more storage space and assigning it to an object.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_10_6"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_10_7",
      "master_id": 2027,
      "name": "For composite expressions, any up casting on either side is not allowed",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    short int short_a, short_b;\n    long int long_a, long_b;\n    long_a = 1;\n    short_a = short_b = 2;\n    long_b = ( ( long ) short_a * short_b ) * long_a; // explicitly converted to long\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    short int short_a, short_b;\n    long int long_a, long_b;\n    long_a = 1;\n    short_a = short_b = 2;\n    long_b = (short_a * short_b) * long_a; // implicitly converted to long\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, an explicit conversion is not used when a composite expression is converted to a larger data type as an operand",
      "desc": "An explicit conversion is used when a composite expression is converted to a larger data type as an operand",
      "details": "#### Abstract\nAn explicit conversion is used when a composite expression is converted to a larger data type as an operand\n\n#### Explanation\nWhen a composite expression is used as one of the operands of an operator and needs to be converted to a larger data type, explicit conversion must be used.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_10_7"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_10_8",
      "master_id": 2028,
      "name": "Composite expression cannot be up casted",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    float float_a, float_b;\n    int int_var;\n    float_a = float_b = 1.0f;\n    int_var = ( int ) float_a + ( int ) float_b; // float_a and float_b casted to type int\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    float float_a, float_b;\n    int int_var;\n    float_a = float_b = 1.0f;\n    int_var = ( int ) ( float_a + float_b ); // casted to inappropriate type int\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the value of a composite expression is cast to an inappropriate data type",
      "desc": "The value of a composite expression cannot be cast to an inappropriate data type",
      "details": "#### Abstract\nThe value of a composite expression cannot be cast to an inappropriate data type\n\n#### Explanation\nThe data type cast conversion may cause the loss or change of data.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_10_8"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_11_2",
      "master_id": 2029,
      "name": "No conversion of pointer to incomplete type convert to any other type",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nunion uni\n{\n    int i;\n    char c;\n}; // union declared\nvoid func ( void );\n\nvoid func ( void )\n{\n    union uni union_var;\n    union_var.i =1;\n    int *ptr_int;\n    // ptr_int point to union_var.i\n    ptr_int = &union_var.i;\n    ptr_int = ( void * )ptr_union; // also allowed by exception\n\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nunion uni; // incomplete type declared\nvoid func ( void );\n\nvoid func ( void )\n{\n    union uni *ptr_union;\n    int *ptr_int; \n    // ptr_int converted to pointer to incomplete type\n    ptr_union = ( union uni * ) ptr_int;\n    // ptr_union (incomplete type) converted to int pointer\n    ptr_int = ( int * )ptr_union;\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, pointers to incomplete types are converted to pointers of other types",
      "desc": "Pointers to incomplete types cannot be converted to pointers of other types and vice versa ",
      "details": "#### Abstract\nPointers to incomplete types cannot be converted to pointers of other types and vice versa \n\n#### Explanation\nType conversion operations between pointers to incomplete types may destroy the encapsulation of incomplete types, so pointers of incomplete types cannot be converted to pointers of other types.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_11_2"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_11_3",
      "master_id": 2030,
      "name": "No casting between pointers of different types",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *ptr_int;    // pointer to int declared\n    char *ptr_char;  // pointer to char declared\n    *ptr_char = NULL;\n    *ptr_int = NULL; // pointers point to null\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *ptr_int;                 // pointer to int declared\n    char *ptr_char;               // pointer to char declared\n    ptr_int = ( int * ) ptr_char; // convert to int type pointer\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, pointers are cast to pointers of other types",
      "desc": "Pointers cannot be cast to pointers of other types",
      "details": "#### Abstract\nPointers cannot be cast to pointers of other types\n\n#### Explanation\nCasting one type of pointer to another type of pointer may be incorrectly aligned causing undefined behavior, so you cannot convert pointers to other types of pointers.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_11_3"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_11_4",
      "master_id": 2031,
      "name": "No conversion of int type to pointer",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *ptr_int;\n    int int_a, int_b;\n    int_a = 1;\n    ptr_int = &int_a; // ptr_int point to int_a\n    int_b = *ptr_int; // *ptr_int assigned to int_b\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *ptr_int;\n    int int_a, int_b;\n    int_a = 1;\n    ptr_int = ( int * ) int_a; // convert int to pointer\n    int_b = ( int ) ptr_int;   // convert pointer to type int\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, there is conversion between pointers and integers",
      "desc": "Avoid the conversion between pointers and integers",
      "details": "#### Abstract\nAvoid the conversion between pointers and integers\n\n#### Explanation\nImplementing the conversion between pointers and integers may result in data overflow of the integers or mis-alignment of the pointers. Avoid conversion between pointers and integers as much as possible.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_11_4"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_11_5",
      "master_id": 2032,
      "name": "No conversion from pointers to void into pointer to object",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    void *ptr_void; // void pointer declared\n    int *ptr_int;   // int pointer declared\n    int int_var;\n    ptr_int = &int_var;\n    // convert int pointer into void pointer\n    ptr_void = ( void * ) ptr_int;\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    void *ptr_void; // void pointer declared\n    int *ptr_int;   // int pointer declared\n    int int_var;\n    ptr_void = &int_var;\n    // convert void pointer into int pointer\n    ptr_int = ( int * ) ptr_void;\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, null pointers are coverted to pointers to objects",
      "desc": "Avoid converting null pointers to pointers to objects",
      "details": "#### Abstract\nAvoid converting null pointers to pointers to objects\n\n#### Explanation\nIn order to avoid pointer errors that may occur during type conversion, you should avoid converting null type pointers to pointers to objects. This can result in an undefined behavior. ",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_11_5"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_11_6",
      "master_id": 2033,
      "name": "No casting between a void pointer and an arithmatic type",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\n#define ZERO 0\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    void *ptr_void;\n    int int_var;\n    // ptr_void point to the address of int_var\n    ptr_void = &int_var;\n    ptr_void = (void *)ZERO;\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    void *ptr_void;\n    int int_var;\n    // convert int_var to void pointer\n    ptr_void = ( void * ) int_var;\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, there is null type pointer and arithmetic type conversion",
      "desc": "Cannot perform a null type pointer and arithmetic type conversion",
      "details": "#### Abstract\nCannot perform a null type pointer and arithmetic type conversion\n\n#### Explanation\nDuring data conversion, data type conversion between null pointers and arithmetic types may cause unalignment with undefined behavior during data conversion.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_11_6"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_11_7",
      "master_id": 2034,
      "name": "No casting between void pointer and a non-int arithmatic type",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    char char_a, char_b;\n    char *ptr_char;\n    char_a = "
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    char char_a, char_b;\n    char *ptr_char;\n    char_a = "
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, there is casting between pointers to objects and non-integer arithmetic types",
      "desc": "Cannot cast pointers to objects and non-integer arithmetic types",
      "details": "#### Abstract\nCannot cast pointers to objects and non-integer arithmetic types\n\n#### Explanation\nIn order to prevent undefined behavior during the type conversion process, the data type conversion between the pointer to the object and the non-integer arithmetic is not allowed. ",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_11_7"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_11_8",
      "master_id": 2035,
      "name": "Const or volatile pointers to pointed should not be cast away ",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n#include <malloc.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    // const pointer declared\n    int * const ptr_const = ( int *) malloc ( sizeof ( int ) );\n    int *ptr_int;\n    // ptr_int point to the address of ptr_const\n    ptr_int = ptr_const;\n    // more code that may change ptr_const\n    // ...\n    \n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n#include <malloc.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    volatile int *p_volatile;\n    // pointer to const declared\n    const int * ptr_const = ( int *) malloc ( sizeof ( int ) );\n    int *ptr_int;\n    // const qualifier removed in a cast\n    ptr_int = ( int * ) ptr_const;\n    ptr_int = (int *) p_volatile;\n    // more code that may change ptr_const\n    // ...\n    \n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, pointer data type cast removes const or volatile qualifiers",
      "desc": "Pointer data type cast cannot remove const or volatile qualifiers",
      "details": "#### Abstract\nPointer data type cast cannot remove const or volatile qualifiers\n\n#### Explanation\nThe const and volatile qualifiers in the definition cannot be removed when the pointer data type is converted. This may cause errors in the reading and writing process of the pointer.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_11_8"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_11_9",
      "master_id": 2036,
      "name": "int null pointer const must be the NULL macro",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *int_ptr = NULL; // ptr_int point to NULL\n    // NULL appear as an operand with the other operand a pointer\n    if ( int_ptr != (int *)NULL )\n    {\n        *int_ptr = NULL;\n    }\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *int_ptr = 0; // 0 assigned to ptr_int\n    // 0 appear as an operand with the other operand a pointer\n    if ( int_ptr != 0 )\n    {\n        *int_ptr = NULL;\n    }\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, a null integer pointer not only points to the macro NULL",
      "desc": "A null integer pointer can only point to the macro NULL",
      "details": "#### Abstract\nA null integer pointer can only point to the macro NULL\n\n#### Explanation\nAn integer constant expression with the value 0 should be derived from expansion of the macro NULL if it appears as the value being assigned to a pointer or an operand of equal/not-equal, or operand of a trigraph.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_11_9"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_12_2",
      "master_id": 2037,
      "name": "Shift amount of shift operator must be smaller than the bit size of operand",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdint.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    uint16_t uint16_var = 2;\n    uint32_t uint32_var;\n    // 17 is in the range 0 to the size of uint16_var\n    uint32_var = uint32_var << 17;\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdint.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    uint16_t uint16_var = 2;\n    // 17 is bigger than the size of uint16_var\n    uint16_var = uint16_var << 17;\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the right operand of the shift operator is not taken from zero to one less than the number of bits in the left operand",
      "desc": "The right operand of the shift operator should be taken from zero to one less than the number of bits in the left operand",
      "details": "#### Abstract\nThe right operand of the shift operator should be taken from zero to one less than the number of bits in the left operand\n\n#### Explanation\nThe right operand of the shift operator should be a positive integer, the value range is from zero to one less than the number of digits in the left operand. Any value beyond this range will cause undefined behavior.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_12_2"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_12_3",
      "master_id": 2038,
      "name": "Comma operator not allowed",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdint.h>\n\nstatic char a[ 10 ];\nvoid func ( void );\n\nvoid func ( void )\n{\n    int i;\n    char *p;\n    // same effect achieved by other mean\n    p = &a[ 0 ];\n    for ( i = 0; i < 10 ; ++i)\n    {\n        *p++ = i;\n    }\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdint.h>\n\nstatic char a[ 10 ];\nvoid func ( void );\n\nvoid func ( void )\n{\n    int i;\n    char *p;\n    // comma operator hard the readability of code\n    for ( i = 0, p = &a[ 0 ]; i < 10 ; ++i, *p++ = i);\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the comma operator is used",
      "desc": "Try not to use the comma operator",
      "details": "#### Abstract\nTry not to use the comma operator\n\n#### Explanation\nSince using the comma operator will reduce the readability of the code, try to avoid using the comma operator.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_12_3"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_12_4",
      "master_id": 2039,
      "name": "Const expression should not cause unsigned wrap-around",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\n#define MAXIMUM 0xffffffffu // maximum value of unsigned int\n\nconst unsigned int const_int = 1;\nvoid func( void );\n\nvoid func( void )\n{\n    unsigned int uint_var;\n    // 0xffffffff assigned to long_long_var\n    uint_var = MAXIMUM;\n    // uint_var + 1 and uint_var + const_int is not a constant expression\n    uint_var = uint_var + 1;\n    uint_var = uint_var + const_int;\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\n#define MAXIMUM 0xffffffffu // value of unsigned int (assume int is 32 bits)\n#define ONE     0x1u\nvoid func( void );\n\nvoid func( void )\n{\n    unsigned int uint_var;\n    // the value of MAXIMUM + 1 lead to wrap-around\n    uint_var = MAXIMUM + ONE;\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, a constant expression causes an unsigned integer wrap-around",
      "desc": "A constant expression should not cause an unsigned integer wrap-around",
      "details": "#### Abstract\nA constant expression should not cause an unsigned integer wrap-around\n\n#### Explanation\nTo prevent wrap-around, the value range of the unsigned integer constant expression should be in the range of zero to the maximum value that the unsigned integer can represent.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_12_4"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_13_1",
      "master_id": 2040,
      "name": "The initialization list should not have side effects",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func( void );\n\nvoid func( void )\n{\n    int x = 0;\n    // array initialized with no side effect\n    int arr[2] = { 1, 2 };\n    // more code may call x\n    // ...\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func( void );\n\nvoid func( void )\n{\n    int x = 0;\n    // object x modified due to side effect\n    int arr[2] = { ++x, ++x };\n    // more code may call x\n    // ...\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the initialization list has side effects",
      "desc": "The initialization list should not have side effects",
      "details": "#### Abstract\nThe initialization list should not have side effects\n\n#### Explanation\nIn order to avoid causing errors in the initialization content and side effects affecting the operation of the program, operations that produce side effects such as assigning other parameters to other parameters, should not be performed in the initialization list.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_13_1"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_13_2",
      "master_id": 2041,
      "name": "Persistent side effect expressions should be the same",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int a = 6;\n    // the value will sure to be -60\n    a -= a*a;\n    a += a;\n    return a;\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int a = 6;\n\n    a += a -= a*a;\n    return a;\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, the value of ${so.func} is not deterministic in all possible execution orders.",
      "desc": "The values and side effects of all expressions in the execution order must be the same",
      "details": "#### Abstract\nThe values and side effects of all expressions in the execution order must be the same\n\n#### Explanation\nSince the expression may have multiple execution orders, the design expression should ensure that the value of the expression and its side effects are the same in all possible execution orders.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_13_2"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_13_3",
      "master_id": 2042,
      "name": "Side effect free expr (except ++, --)",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int int_a, int_b, int_c;\n    int_a = int_b = 1;\n    // make the code more readable by this mean\n    ++int_a;\n    int_c = int_a * int_b;\n    int_b--;\n    return int_c;\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    int int_a, int_b, int_c;\n    int_a = int_b = 1;\n    // theÂ complexÂ expressionÂ impairsÂ theÂ readability\n    int_c = ++int_a * int_b--;\n    return int_c;\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the increment (++) or decrement (--) operators have additional side effects",
      "desc": "The increment (++) or decrement (--) operators cannot have additional side effects",
      "details": "#### Abstract\nThe increment (++) or decrement (--) operators cannot have additional side effects\n\n#### Explanation\nAvoid mixing increment or decrement operators with other operators in expressions, including function calls, as this will cause an undefined behavior. Doing so will impair readability of the code.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_13_3"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_13_4",
      "master_id": 2043,
      "name": "Assign operators inside an expression ",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func( void );\n\nvoid func( void )\n{\n    bool bool_var;\n    bool_var = true;\n    // == is not an assignment operator\n    while (bool_var == true)\n    {\n        // some code that change bool_var\n        // ...\n    }\n    \n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func( void );\n\nvoid func( void )\n{\n    bool bool_var;\n    bool_var = true;\n    // the value of assignment opreator used as condition\n    while (bool_var = true)\n    {\n        // some code that change bool_var\n        // ...\n    }\n    \n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the result of the assignment operator is used",
      "desc": "The result of the assignment operator cannot be used",
      "details": "#### Abstract\nThe result of the assignment operator cannot be used\n\n#### Explanation\nThe result of the assignment operator should not be used since it introduces additional side-effects. Doing so also impairs readability of the code.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_13_4"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_13_5",
      "master_id": 2044,
      "name": "The right operand of the && and || operators cannot have side effects",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nstatic int int_a;\nvoid func( void );\nint func2( void );\nbool return_true( void );\n\nvoid func( void )\n{\n    int int_b;\n    \n    // right operand do not have side effect\n    if( return_true() || int_b == func2() );\n    // more code that may read int_a\n    // ...\n}\n\nint func2( void )\n{\n    return int_a + 1; // do not have side effect\n}\n\nbool return_true( void )\n{\n    return true;\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nstatic int int_a;\nvoid func( void );\nint func2( void );\nbool return_true( void );\n\nvoid func( void )\n{\n    int int_b;\n    \n    // int_a is not modified as intended\n    if( return_true() || int_b == func2() );\n    // more code that may read int_a\n    // ...\n}\n\nint func2( void )\n{\n    int_a++; // side effect: int_a is modified\n    return int_a;\n}\n\nbool return_true( void )\n{\n    return true;\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the right operand of the && and || operators have side effects",
      "desc": "The right operand of the && and || operators cannot have side effects",
      "details": "#### Abstract\nThe right operand of the && and || operators cannot have side effects\n\n#### Explanation\nThe evaluation of the right hand operand of the && and || operators is conditional on the value of the left-hand operand. The right hand operand",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_13_5"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_13_6",
      "master_id": 2045,
      "name": "The operand of sizeof operator cannot have persistent side effects",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func( void );\n\nvoid func( void )\n{\n    int int_a, int_b;\n\n    // the operand do not have side effect\n    int_a = sizeof( int_b );\n    int_b++; // int_b modified as intended\n    // some code that may read int_b\n    // ...\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid func( void );\n\nvoid func( void )\n{\n    int int_a, int_b;\n    \n    // int_b is not modified as intended\n    int_a = sizeof( int_b++ );\n    // some code that may read int_b\n    // ...\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the operand of sizeof operator has persistent side effects",
      "desc": "The operand of sizeof operator cannot have persistent side effects",
      "details": "#### Abstract\nThe operand of sizeof operator cannot have persistent side effects\n\n#### Explanation\nSince sizeof operator does not necessarily execute the expression in its operand, the operand of sizeof must not produce side effects.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_13_6"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "Advisory",
      "language": "c",
      "code": "MSR_18_4",
      "master_id": 2047,
      "name": "Pointer arithmatic should not be used, except for ++ and --",
      "severity": "L",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nint func(int *pint)\n{\n  if (pint != NULL)\n    return 0;\n\n  // +, -, +=, -= not allowed for expression of pointer type\n  printf(\"*(pint+5) valie is %d.\", *(pint +5));\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, pointer arithmatic is used, except for ++ and --",
      "desc": "Pointer arithmatic should not be used, except for ++ and --",
      "details": "#### Abstract\nPointer arithmatic should not be used, except for ++ and --\n\n#### Explanation\nPointer arithmetic is confusing to the novice programmers. The expression ptr+1 may be mistakenly interpreted as adding one byte to the address held in ptr.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_18_4"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "Required",
      "language": "c",
      "code": "MSR_18_8",
      "master_id": 2048,
      "name": "Variable length array types should not be used",
      "severity": "L",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdlib.h>\n#include <string.h>\n\n#define NAME_LEN 31  // null included\n\nstruct FixedlenArray {\n  int  id;\n  int  name_len;\n  char name[NAME_LEN];\n  int  struct_sz;\n};\n\n\nstruct FixedlenArray *foo(int len, int id, char *pchar)\n{\n  struct FixedlenArray *s;\n  int sz = sizeof(struct FixedlenArray);\n  s = (FixedlenArray *)malloc(sizeof(sz));\n\n  if (s == 0) {\n    return NULL;\n  }\n\n  s->id = id;\n  s->name_len = len;\n  strncpy(s->name, pchar, NAME_LEN);\n\n  s->struct_sz = sz;\n  return s;  \n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdlib.h>\n#include <string.h>\n\nstruct VarlenArray {\n  int  id;\n  int  name_len;\n  char name[0];\n  int  struct_sz;\n};\n\n\nstruct VarlenArray *foo(int len, int id, char *pchar)\n{\n  struct VarlenArray *s;\n  int sz = sizeof(*s) + strlen(pchar) + 1;\n  s = (VarlenArray *)malloc(sizeof(*s) + strlen(pchar) + 1);\n\n  if (s == 0) {\n    return NULL;\n  }\n\n  s->id = id;\n  s->name_len = len;\n  strcpy(s->name, pchar);\n\n  s->struct_sz = sz;\n  return s;  \n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, variable length array types are used",
      "desc": "Variable length array types should not be used",
      "details": "#### Abstract\nVariable length array types should not be used\n\n#### Explanation\nThe use of variable-length array types would make it impossible to determine statically the amount of memory that must be reserved for a stack",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_18_8"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "Advisory",
      "language": "c",
      "code": "MSR_19_2",
      "master_id": 2049,
      "name": "Union should not be used",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\ntypedef union UnionT\n{\n  int    i;\n  char   c;\n  double d;\n} UNIONT;\n\ntypedef struct MyData\n{\n  int     tag;\n  UNIONT  u;\n} MYDATA;\n\n\nint foo(char ch_param)\n{\n   MYDATA md;\n\n   md.tag = 0;  // say, 0 for int, 1 for char, 2 for double\n   md.u.c = ch_param;\n\n   return md.u.i; // return is undefined\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, union is used",
      "desc": "Union should not be used",
      "details": "#### Abstract\nUnion should not be used\n\n#### Explanation\nIf the union member read is wider than the member written then the value is unspecified. Since it is possible to access bytes with unspecified values, unions should not be used.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_19_2"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "Required",
      "language": "c",
      "code": "MSR_21_3",
      "master_id": 2050,
      "name": "Memory allocation related functions in stdlib.h should not be used",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <string.h>\n\ntypedef struct MyData\n{\n  int     tag;\n  int     data[100];\n} MYDATA;\n\nvoid func ( void );\n\nvoid func (int sz)\n{\n  MYDATA *p_calloc;\n  \n  const MYDATA * p_mydata = new MYDATA;;\n\n  if (p_mydata != 0) {\n    p_calloc = new MYDATA;\n    memset((void *)p_calloc, 0, sizeof(MYDATA));\n  }\n\n  // ...\n  delete p_mydata;\n  delete p_calloc;\n  return;\n}"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdlib.h>\n\nvoid func ( void );\n\n\n#include <stdlib.h>\n\ntypedef struct MyData\n{\n  int     tag;\n  int     data[100];\n} MYDATA;\n\nvoid func ( void );\n\nvoid func (int sz)\n{\n  MYDATA *p_calloc;\n  \n  // use of malloc\n  const MYDATA * ptr_mydata = (MYDATA *) malloc ( sizeof(MYDATA) );\n\n  if (ptr_mydata != 0) {\n    p_calloc = (MYDATA *)calloc(sz, sizeof(MYDATA));\n  }\n\n  // ...\n    \n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, memory allocation related function ${so.func} in stdlib.h is used",
      "desc": "Memory allocation related functions in stdlib.h should not be used",
      "details": "#### Abstract\nMemory allocation related functions in stdlib.h should not be used\n\n#### Explanation\nThe use of memory allocation related functions in stdlib.h can lead to an undefined behaviour. For example:  memory that was dynamically allocated may not be freed subsequently.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_21_3"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "Required",
      "language": "c",
      "code": "MSR_21_4",
      "master_id": 2051,
      "name": "setjmp.h should not be used",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <setjmp.h>\n#include <stdlib.h>\n\nvoid foo()\n{\n  jmp_buf env;\n  int i;\n\n  i = setjmp(env);   // standard call to setjmp with environment info\n  if (i) {\n    // ...\n    exit(i);\n  }\n\n  // ...\n  longjmp(env, 100); // longjmp with second argument\n  return;\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, setjmp.h is used",
      "desc": "setjmp.h should not be used",
      "details": "#### Abstract\nsetjmp.h should not be used\n\n#### Explanation\nSetjmp allows the normal function call/return mechanisms to be bypassed. The use of that can lead to undefined and unspecified behavior.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_21_4"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "Required",
      "language": "c",
      "code": "MSR_21_5",
      "master_id": 2052,
      "name": "signal.h should not be used",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <signal.h>\n\nvoid handler(int signum)\n{\n  if (signal(signum, handler) == SIG_ERR) {\n    // handle error\n  }\n\n  // ...\n}\n\nvoid func(void)\n{\n  struct sigaction act;\n  act.sa_handler = handler;\n  act.sa_flags = 0;\n\n  if (sigemptyset(&act.sa_mask) != 0) {\n    // ...\n  }\n  \n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, signal.h is used",
      "desc": "signal.h should not be used",
      "details": "#### Abstract\nsignal.h should not be used\n\n#### Explanation\nSince signal handling contains an implementation-defined and undefined behaviour, signal.h should not be used for C90 and C99 modes.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_21_5"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "Required",
      "language": "c",
      "code": "MSR_21_6",
      "master_id": 2053,
      "name": "I/O functions in stdio.h should not be used",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nvoid bar_c(void* ptr)\n{\n    int* dest = (int*)ptr;\n    int data = (*dest);\n    int i;\n    int Buffer[10] = { 0 };\n    if(data >= 0)\n      {\n         Buffer[data] = 1;\n         for(i=0; i<10; i++)\n         {\n             printf(\"%d\", Buffer[i]);\n         }\n     }\n }\n\n void foo_v()\n {\n     int data;\n     data = -1;\n     fscanf(stdin, \"%d\", &data); // this can easily cause array out of bound\n     bar_c(&data);\n } "
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, I/O functions in stdio.h is used",
      "desc": "I/O functions in stdio.h should not be used",
      "details": "#### Abstract\nI/O functions in stdio.h should not be used\n\n#### Explanation\nSince I/O have unspecified, undefined and implementation-defined behavioursï¼ŒI/O functions and their wide char equivalents in stdio.h should not be used for C90 and C99 modes.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_21_6"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "Required",
      "language": "c",
      "code": "MSR_21_7",
      "master_id": 2054,
      "name": "ascii conversion functions in stdlib.h should not be used",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <iostream>\n#include <cstdlib>\n\nint foo()\n{\n  char s[] = \"98\";\n  long num;\n\n  num = atol(s);\n\n  std::cout << \"number in long = \" << num << std::endl;\n    \n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, ascii conversion functions in stdlib.h is used",
      "desc": "ascii conversion functions in stdlib.h should not be used",
      "details": "#### Abstract\nascii conversion functions in stdlib.h should not be used\n\n#### Explanation\nSince atof, atol and atoll functions have undefined behaviors associated with them when the string cannot be converted, they should not be used for C90 and C99 modes.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_21_7"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "Required",
      "language": "c",
      "code": "MSR_21_8",
      "master_id": 2055,
      "name": "getenv, getenv and exit functions should not be used",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void)\n{\n  char* ptr_h;\n  char h[64];\n\n  ptr_h = getenv(\"HOME\");  // value of HOME could be > 64, need size guard\n  if (ptr_h != NULL) {\n    // ...\n  }\n  return 0;\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, getenv, getenv and exit functions are used",
      "desc": "getenv, getenv and exit functions should not be used",
      "details": "#### Abstract\ngetenv, getenv and exit functions should not be used\n\n#### Explanation\nSince getenv, getenv and exit functions have undefined and implementation-defined behaviors, they should not be used for C90 and C99 modes.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_21_8"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "Required",
      "language": "c",
      "code": "MSR_21_9",
      "master_id": 2056,
      "name": "bsearch and qsort should not be used",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n#include <stdlib.h>\n\n#define VALTAB_SZ 5\n\nint value[] = { 10, 90, 4, -10, 25 };\n\nextern int cmp(const void *a, const void *b);\n\nint foo(void)\n{\n  int n;\n\n  // use qsort\n  qsort((void *)value, (size_t)VALTAB_SZ, sizeof(int), cmp);\n\n  return value[0];\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, bsearch and qsort is used",
      "desc": "bsearch and qsort should not be used",
      "details": "#### Abstract\nbsearch and qsort should not be used\n\n#### Explanation\nIf bsearch and qsort function do not behave consistently when comparing elements, or they modify any of the elements, the behavior is undefined. So they should not be used for C90 and C99 modes.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_21_9"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "Required",
      "language": "c",
      "code": "MSR_21_10",
      "master_id": 2057,
      "name": "Time and date functions in stdlib.h should not be used",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <time.h>\n\nint foo(void)\n{\n  time_t timer;\n  struct tm date_time  = { 0 };\n  double seconds;\n\n  time(&timer); // get current time\n\n  // ...\n\n  return 0;\n    \n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, time and date functions in stdlib.h are used",
      "desc": "Time and date functions in stdlib.h should not be used",
      "details": "#### Abstract\nTime and date functions in stdlib.h should not be used\n\n#### Explanation\nSince the time and date functions have unspecified, undefined and implementation-defined behaviors, they should not be used for C90 and C99 modes.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_21_10"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c++",
      "code": "MSR_5_0_1",
      "master_id": 2058,
      "name": "For an evaluation of any expression and its side effects, the value must be the same under any evaluation order permitted by the language standard",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            "\n#define LEN 1024\n\nint array_int[LEN];\n\nint foo(int i, int j)\n{\n  if (j > 0) {\n    return i+1;\n  }\n  else\n    return i;\n}\n\nint bar(unsigned int parm_b)\n{\n  if (parm_b < LEN) {\n    unsigned int temp = parm_b++;\n    array_int[temp] = parm_b ;  // behavior is deterministic\n  \n  return parm_b;\n}\n\nint call_foo(int i)\n{\n  int j = i++;\n  return foo(j, i);  // return value non-ambiguous\n}"
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            "\n#define LEN 1024\n\nint array_int[LEN];\n\nint foo(int i, int j)\n{\n  if (j > 0) {\n    return i+1;\n  }\n  else\n    return i;\n}\n\n\nint bar(unsigned int parm_b)\n{\n  if (parm_b < LEN)\n    array_int[parm_b++] = parm_b ;  // behavior is undefined\n  \n  return parm_b;\n}\n\n\nint call_foo(int i)\n{\n  return foo(i++, i);  // return value is implementation defined\n}\n"
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, the value of ${so.func} is not the same under any evaluation order permitted by the language standard",
      "desc": "For an evaluation of any expression and its side effects, the value must be the same under any evaluation order permitted by the language standard",
      "details": "#### Abstract\nFor an evaluation of any expression and its side effects, the value must be the same under any evaluation order permitted by the language standard\n\n#### Explanation\nSince the expression may have multiple execution orders, the design for any expression, should ensure that the value of the expression and its side effects are the same in all possible execution orders as prescribed by the lexical rule for the expression.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_5_0_1"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c++",
      "code": "MSR_5_0_8",
      "master_id": 2059,
      "name": "The value of an expression cannot be cast to sizes larger than the underlying type of the expression",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            "\nvoid func_5_0_8(int si, short sh_j, float flt_k)\n{\n  short  local_sh = 0x1234;\n  int    local_int1, local_int2;\n  float  local_flt = 1.0;\n  double local_dbl, local_dbl2;\n\n  local_int1 = static_cast< int > (int)local_sh + sh_j;  // compliant\n  local_int2 = static_cast< int > (local_sh) + sh_j;     // compliant\n\n  local_dbl2 = static_cast<double> ((double)flt_k) + local_flt;  // compliant\n  \n}"
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            "\nvoid func_5_0_8(int si, short sh_j, float flt_k)\n{\n  short  local_sh = 0x1234;\n  int    local_int1, local_int2;\n  float  local_flt = 1.0;\n  double local_dbl, local_dbl2;\n\n  local_int1 = static_cast< int > (local_sh + sh_j);  // non-compliant\n\n  local_dbl2 = static_cast<double> (flt_k + local_flt);  // non-compliant\n  \n}"
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, the value of ${so.func} is cast to sizes larger than the underlying type of the expression",
      "desc": "The value of an expression cannot be cast to sizes larger than the underlying type of the expression",
      "details": "#### Abstract\nThe value of an expression cannot be cast to sizes larger than the underlying type of the expression\n\n#### Explanation\nWhen the value of an expression is cast to a size larger than its underlying type, there may be information loss such as signedness of the value.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_5_0_8"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_5_0_19",
      "master_id": 2060,
      "name": "More than 2 indirections",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            "\nint array[10][20];\n\n// this example is equivalent to the \"avoid\" example\n// \nint mlk_three_indirect(int val)\n{\n  int j = val;\n  int *p = &j;\n  int **p_2, **r_2;\n  int *p_2_array = &array[*p][0];\n  int p3;\n  \n  array[val][0] = val;\n  p3 = array[val][0];\n  return p3;\n\n}"
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            "\nint array[10][20];\n\nint mlk_three_indirect(int val)\n{\n  int j = val;\n  int *p = &j;\n  int **p_2, **r_2;\n  int *p_2_array = &array[*p][0];\n  int ***p3;\n\n  // ... \n  p_2 = &p;\n  \n  // ...\n  array[val][0] = **p_2;\n  \n  //...\n  r_2 = &p_2_array;\n  \n  // ...\n  p3 = &r_2;\n  \n  // ... \n  return ***p3;\n\n}"
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, declaration of objects contains more than two levels of pointer indirection",
      "desc": "Declaration of objects cannot contain more than two levels of pointer indirection",
      "details": "#### Abstract\nDeclaration of objects cannot contain more than two levels of pointer indirection\n\n#### Explanation\nHaving more than two levels of indirection, which gives, at least three levels of dereferencing an object, means it can be very hard to understand the intended behavior of the program.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_5_0_19"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c++",
      "code": "MSR_8_5_3",
      "master_id": 2061,
      "name": "Bad enum initialization",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            "\ntypedef enum color { red=3 } GoodEnum;   // compliant\n\n// compliant (but assignment not in sequence )\ntypedef enum bad_enum_color { white=0,\n         blue=1,         // 2 is not used \n         yellow=3 } BadEnum;  \n\ntypedef enum no_assign { NO_ONE, NO_TWO, NO_THREE } GoodEnum_NoAssign;\n\nextern void bar( color c, bad_enum_color b, no_assign n);\n\nvoid func_use(void)\n{\n  color var_color = red;\n  bad_enum_color var_bad_color = blue;\n  no_assign var_no_assign = NO_TWO;\n\n  bar(var_color, var_bad_color, var_no_assign);\n  return;\n}"
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            "\ntypedef enum color { red=3 } GoodEnum;   // compliant\n\ntypedef enum bad_enum_color { white=0,\n\t\t\t      blue=1,\n\t\t\t      yellow } BadEnum;  // non-compliant\n\ntypedef enum no_assign { NO_ONE, NO_TWO, NO_THREE } GoodEnum_NoAssign;\n\nextern void bar( color c, bad_enum_color b, no_assign n);\n\nvoid func_use(void)\n{\n  color var_color = red;\n  bad_enum_color var_bad_color = blue;\n  no_assign var_no_assign = NO_TWO;\n\n  bar(var_color, var_bad_color, var_no_assign);\n  return;\n}"
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the enum initialization is incorrect",
      "desc": "The only explicit initialization of an enum with the â€œ=â€ construct is such that all, none or the first one, are initialized",
      "details": "#### Abstract\nThe only explicit initialization of an enum with the â€œ=â€ construct is such that all, none or the first one, are initialized\n\n#### Explanation\nExplicit and uniform initialization of an enum list prevents mixing of automatic and manual assignment, which is error-prone. The compiler can also detect possible out of range errors for the enum.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_8_5_3"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c++",
      "code": "MSR_10_1_3",
      "master_id": 2062,
      "name": "Base class has virtual and non-virtual",
      "severity": "H",
      "likelihood": "L",
      "cost": "H",
      "examples": {
        "good": {
          "cpp": [
            "\nclass Expr {\n  int i;\npublic:\n  Expr(); // def constructor\n  Expr(const Expr&); // copy constructor\n\n  virtual Expr* newExpr() { i+=2; return new Expr(); }\n  virtual Expr* clone()   { i++; return new Expr(*this); }\n};\n\n\nclass B1 : public virtual Expr {};\nclass B2 : public virtual Expr {};\nclass B3 : public         Expr {};\n\nclass C  : public B1, B2 {};  // both B1 and B2 are virtual\n\nclass D  : public B3, B1 {};  // B3 and B1 are different base classes"
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            "\nclass Expr {\n  int i;\npublic:\n  Expr(); // def constructor\n  Expr(const Expr&); // copy constructor\n\n  virtual Expr* newExpr() { i+=2; return new Expr(); }\n  virtual Expr* clone()   { i++; return new Expr(*this); }\n};\n\n\nclass B1 : public virtual Expr {};\nclass B2 : public virtual Expr {};\nclass B3 : public         Expr {};\n\n// B2 and B3 are virtual and non-virtual in a multiple inheritance hierarchy\nclass C  : public B1, B2, B3 {}; "
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, a base class is virtual and non-virtual in a multiple inheritance hierarchy",
      "desc": "A base class should not be both, virtual and non-virtual in a multiple inheritance hierarchy",
      "details": "#### Abstract\nA base class should not be both, virtual and non-virtual in a multiple inheritance hierarchy\n\n#### Explanation\nIf the base class is both virtual and non-virtual in a multiple inheritance hierarchy, then there will be multiple copies of the base class sub-object in the derived object. This is likely a declaration error.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_10_1_3"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_12_1_1",
      "master_id": 2063,
      "name": "Dynamic type in ctor or dtor",
      "examples": {
        "good": {
          "cpp": [
            "\nclass Expr {\n  int i;\n  \npublic:\n  Expr(const Expr&); // copy constructor\n  virtual ~Expr ();\n\n  virtual Expr* newExpr() { i+=2; return new Expr(); }\n  virtual Expr* clone()   { i++; return new Expr(*this); }\n  Expr() {\n    Expr::clone();                // not a virtual call, hence compliant\n    clone();                      // a virtual call\n    // the following line must be removed from this constructor declaration\n    // commented out in the example to be clear\n    // dynamic_cast<Expr*> (this);  \n  }\n};\n"
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            "\nclass Expr {\n  int i;\n  \npublic:\n  Expr(const Expr&); // copy constructor\n  virtual ~Expr ();\n\n  virtual Expr* newExpr() { i+=2; return new Expr(); }\n  virtual Expr* clone()   { i++; return new Expr(*this); }\n  Expr() {\n    Expr::clone();                // not a virtual call, hence compliant\n    clone();                      // a virtual call\n    dynamic_cast<Expr*> (this);   // non-compliant\n  }\n};\n"
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, an objectâ€™s dynamic type is used from the body of its constructor or destructor",
      "desc": "An objectâ€™s dynamic type cannot be used from the body of its constructor or destructor",
      "details": "#### Abstract\nAn objectâ€™s dynamic type cannot be used from the body of its constructor or destructor\n\n#### Explanation\nA non-static member of an object can have an initialization with the declaration of the member in its body (NSDMI). To avoid confusion, any member initialized this way (NSDMI) or with a constructor should be the same.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_12_1_1"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c++",
      "code": "MSR_12_1_2",
      "master_id": 2064,
      "name": "ctor must explicitly call ctor for all its immediate base classes",
      "examples": {
        "good": {
          "cpp": [
            "\nclass Base {\npublic:\n  Base() {}\n  Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {}\n  Derived1(int) : Base(0) {}\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  Derived2(int) : Base(1) {}\n}; \n\n\nclass Hier : public Derived1, public Derived2 {\n  //  Hier()    {}\n  Hier(int) {} // constructor used is ambiguous w.r.t. Derived1 or Derived2\n\n};"
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            "\nclass Base {\npublic:\n  Base() {}\n  Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {}\n  Derived1(int) : Base(0) {}\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  Derived2(int) : Base(1) {}\n}; \n\n\nclass Hier : public Derived1, public Derived2 {\n  //  Hier()    {}\n  Hier(int) {} // constructor used is ambiguous w.r.t. Derived1 or Derived2\n\n};"
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, ctor does not explicitly call ctor for all its immediate base classes",
      "desc": "ctor must explicitly call ctor for all its immediate base classes",
      "details": "#### Abstract\nctor must explicitly call ctor for all its immediate base classes\n\n#### Explanation\n",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_12_1_2"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c++",
      "code": "MSR_12_1_3",
      "master_id": 2065,
      "name": "ctor with single parameter of basic type should be explicit",
      "examples": {
        "good": {
          "cpp": [
            "\nclass Base {\npublic:\n  Base() {}\n  explicit Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {} \n  explicit Derived1(int) : Base(0) {}    // make explicit\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  explicit Derived2(int) : Base(1) {}    // make explicit\n}; \n\n\nclass Hier : public Derived1, public Derived2 {\n  explicit Hier(int) : Derived1(2), Derived2(), Base() {}  // make explicit\n\n};"
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            "\n\nclass Base {\npublic:\n  Base(void) {}\n  Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {}\n  Derived1(int) : Base(0) {}\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  Derived2(int) : Base(1) {}\n}; \n\nclass Hier : public Derived1, public Derived2 {\n  Hier(int)    {}\n};"
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, ctor with single parameter of basic type is not explicit",
      "desc": "ctor with single parameter of basic type should be explicit",
      "details": "#### Abstract\nctor with single parameter of basic type should be explicit\n\n#### Explanation\n",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_12_1_3"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c++",
      "code": "MSR_11_0_1",
      "master_id": 2066,
      "name": "Non-POD member in a class must be private",
      "examples": {
        "good": {
          "cpp": [
            "\ntypedef char    Letter;  \ntypedef Letter* pLetter;\n  \nclass Class_Without_POD    \n{\npublic:\n  Letter  c;  \n  pLetter p;\n};\n\nclass Class_with_POD\n{\nprivate:\n  char    c;         // will need interfaces to access and modify\n  char*   pc;  \n};"
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            "\n#include <stdint.h>\n\ntypedef char    Letter;  \ntypedef Letter* pLetter;\n  \nclass Class_Without_POD    \n{\npublic:\n  Letter  c;  \n  pLetter p;\n};\n\nclass Class_with_POD\n{\npublic:\n  int8_t   c;         // POD has no default constructor\n  char*   pc;  \n};"
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, non-POD member in a class is not private",
      "desc": "Non-POD member in a class must be private",
      "details": "#### Abstract\nNon-POD member in a class must be private\n\n#### Explanation\n",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_11_0_1"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_10_2_1",
      "master_id": 2067,
      "name": "All visible names within an inheritance hierarchy must be unique",
      "examples": {
        "good": {
          "cpp": [
            "\n\nclass Base {\npublic:\n  void func_char(char) {};\n};\n\nclass Derived : public Base {\npublic:\n  void func_int(int) {};\n};\n\n\nint foo(void)\n{\n  int   i;\n  char ch;\n  Derived example;\n\n  example.func_int(i);\n\n  example.func_char(ch);  // func(char) in Base is not visible \n  \n}"
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            "\n\nclass Base {\npublic:\n  void func(char) {};\n};\n\nclass Derived : public Base {\npublic:\n  void func(int) {};\n};\n\n\nint foo(void)\n{\n  int   i;\n  char ch;\n  Derived example;\n\n  example.func(i);\n  example.func(ch);  // func(char) in Base is not visible \n  \n}"
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, the visiable names within a inheritance hierarchy are not unique",
      "desc": "All visible names within an inheritance hierarchy must be unique",
      "details": "#### Abstract\nAll visible names within an inheritance hierarchy must be unique\n\n#### Explanation\n",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_10_2_1"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_17_7",
      "master_id": 2068,
      "name": "Value returned by a function should be used",
      "examples": {
        "good": {
          "cpp": [
            "\nextern int func_ret_int(int, int);\n\n\nvoid bar(int n, int m)\n{\n  if (n > 0) {\n    n += func_ret_int(n, m);\n  }\n  else {\n    (void)func_ret_int(m, m); // func return value ignored\n  }\n}\n"
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            "\nextern int func_ret_int(int, int);\n\n\nvoid bar(int n, int m)\n{\n  if (n > 0) {\n    n += func_ret_int(n);\n  }\n  else {\n    func_ret_int(m); // func return value ignored\n  }\n}"
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, value returned by ${so.func} is not used",
      "desc": "The value returned by a function which has non-void return type should be used",
      "details": "#### Abstract\nThe value returned by a function which has non-void return type should be used\n\n#### Explanation\nCalling a function without using the return value may be an error for a C90 and a C99 mode. Return value of a function should be cast to the void type if it is intended not to be used explicitly.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_17_7"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_17_8",
      "master_id": 2069,
      "name": "A function parameter should not be modified",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            "\nextern int func_ret_int(int, int);\n\nint global_int;\n\nvoid bar(int n, int m)\n{\n  if (n > 0) {\n    n += func_ret_int(n, m);  // parameter n modified\n  }\n  else {\n    n = global_int;  // value of n modified by global\n  }\n  \n  // ...\n}"
          ],
          "java": [
            ""
          ],
          "c": [
            ""
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, ${so.func}, a function parameter is modified",
      "desc": "The parameter of a function should not be modified",
      "details": "#### Abstract\nThe parameter of a function should not be modified\n\n#### Explanation\nModifying the parameter of a function can be confusing and in conflict with programmer expectations for C90 and C99 modes. So the The parameter of a function should not be modified.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_17_8"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    },
    {
      "category": "",
      "language": "c",
      "code": "MSR_10_2",
      "master_id": 2046,
      "name": "char not allowed in arithmatic expression",
      "examples": {
        "good": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    // essentially character type declared\n  char char_var;   \n  char numb;\n  char_var = '9';\n  // convert numa to digit value 9\n  numb = char_var - '0';\n  return numb\n\n}\n"
          ],
          "general": [
            ""
          ]
        },
        "bad": {
          "cpp": [
            ""
          ],
          "java": [
            ""
          ],
          "c": [
            "\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    // essentially character type declared\n    char char_var;\n    int numb;\n    char_var = '9';\n    // the result of char_var + '>' do not make sense\n    numb = char_var + '>';\n    return numb;\n\n}"
          ],
          "general": [
            ""
          ]
        }
      },
      "msg_templ": "In file ${so.filename}, line ${so.line}, char is used in arithmatic expression ${so.func}",
      "desc": "Use basic character variables appropriately for addition and subtraction",
      "details": "#### Abstract\nUse basic character variables appropriately for addition and subtraction\n\n#### Explanation\nSince the data in the basic character variable does not represent a numeric value, the basic character variable should be used appropriately in the addition and subtraction expressions.",
      "alias": {},
      "standards": {},
      "csv_string": [
        "MSR_10_2"
      ],
      "ruleSet": {
        "id": "M",
        "code": "M",
        "displayName": "MISRA"
      }
    }
  ],
  "csvCodeMap": {
    "CSL0": 0,
    "CSS0": 1,
    "DBF0": 2,
    "FMT2": 3,
    "FMT1": 3,
    "FMT0": 3,
    "MSF2": 4,
    "MSF1": 4,
    "MSF0": 4,
    "RAL1": 5,
    "RAL0": 5,
    "RXS0": 6,
    "UAF3": 7,
    "UAF2": 7,
    "UAF1": 7,
    "UAF0": 7,
    "UDR5": 8,
    "UDR4": 8,
    "UDR3": 8,
    "UDR2": 8,
    "UDR1": 8,
    "UDR0": 8,
    "WRF0": 9,
    "AOB4": 10,
    "AOB3": 10,
    "AOB2": 10,
    "AOB1": 10,
    "AOB0": 10,
    "CRF0": 11,
    "DBZ2": 12,
    "DBZ1": 12,
    "DBZ0": 12,
    "DDC1": 13,
    "DDC0": 13,
    "DDV0": 14,
    "FAM2": 15,
    "FAM1": 15,
    "FAM0": 15,
    "NPD0": 16,
    "RCD0": 17,
    "SCB0": 18,
    "SSE0": 19,
    "UIC0": 20,
    "UIV1": 21,
    "UIV0": 21,
    "ECB1": 22,
    "ECB0": 22,
    "F37C1": 23,
    "F37C0": 23,
    "M32C1": 24,
    "M32C0": 24,
    "N32C0": 25,
    "N33C3": 26,
    "N33C2": 26,
    "N33C1": 26,
    "N33C0": 26,
    "E33C0": 27,
    "F34C0": 28,
    "F42C2": 29,
    "F42C1": 29,
    "F42C0": 29,
    "F45C0": 30,
    "m35C1": 31,
    "m35C0": 31,
    "M33C0": 33,
    "M37C0": 34,
    "P30C1": 35,
    "P30C0": 35,
    "P34C2": 36,
    "P34C1": 36,
    "P34C0": 36,
    "P35C0": 37,
    "P37C2": 38,
    "P37C1": 38,
    "P37C0": 38,
    "P54C0": 39,
    "G30C0": 40,
    "G31C1": 41,
    "G31C0": 41,
    "S02C2": 42,
    "S02C1": 42,
    "S0200": 42,
    "S31C4": 43,
    "S31C3": 43,
    "S31C2": 43,
    "S31C1": 43,
    "S31C0": 43,
    "S32C4": 44,
    "S32C3": 44,
    "S32C2": 44,
    "S32C1": 44,
    "S32C0": 44,
    "S38C0": 45,
    "S50P0": 46,
    "m55P0": 48,
    "M51P0": 49,
    "M54P0": 50,
    "I16J1": 51,
    "I16J0": 51,
    "M02J1": 52,
    "M02J0": 52,
    "C07J0": 53,
    "D00J0": 54,
    "N03J2": 55,
    "N03J1": 55,
    "N03J0": 55,
    "N06J2": 56,
    "N06J1": 56,
    "N06J0": 56,
    "E08J0": 57,
    "X02J0": 58,
    "F02J0": 59,
    "F05J1": 60,
    "F05J0": 60,
    "F14J0": 61,
    "F16J2": 62,
    "F16J1": 62,
    "I00J3": 63,
    "I00J2": 63,
    "I00J1": 63,
    "I00J0": 63,
    "I01J2": 64,
    "I01J1": 64,
    "I01J0": 64,
    "I11J2": 65,
    "I11J1": 65,
    "I11J0": 65,
    "I17J2": 66,
    "I17J1": 66,
    "I17J0": 66,
    "T06J1": 67,
    "T06J0": 67,
    "M61J1": 68,
    "M61J0": 68,
    "O09J": 69,
    "O11J0": 70,
    "C02J1": 71,
    "C02J0": 71,
    "C06J3": 72,
    "C06J2": 72,
    "C06J1": 72,
    "C06J0": 72,
    "F02C6": 73,
    "F02C5": 73,
    "F02C4": 73,
    "F02C3": 73,
    "F02C2": 73,
    "F02C1": 73,
    "F02C0": 73,
    "M62J1": 77,
    "M62J0": 77,
    "I03J2": 78,
    "I03J1": 78,
    "I03J0": 78,
    "A38C2": 79,
    "A38C1": 79,
    "A38C0": 79,
    "m51P0": 84,
    "E00J0": 87,
    "F08J0": 88,
    "F30C1": 89,
    "F30C0": 89,
    "M41C2": 90,
    "M41C1": 90,
    "M41C0": 90,
    "F52J2": 91,
    "F52J1": 91,
    "F52J0": 91,
    "I07J1": 92,
    "I07J0": 92,
    "I15J2": 93,
    "I15J1": 93,
    "I15J0": 93,
    "M03J0": 94,
    "O07J1": 95,
    "O07J0": 95,
    "C01J2": 96,
    "C01J1": 96,
    "C01J0": 96,
    "N01J0": 98,
    "J01J0": 109,
    "O01J0": 110,
    "O13J1": 111,
    "O13J0": 111,
    "C03J1": 112,
    "C03J0": 112,
    "C04J2": 113,
    "C04J1": 113,
    "C04J0": 113,
    "C05J0": 114,
    "R01J0": 115,
    "R05J0": 117,
    "I53J1": 119,
    "I53J0": 119,
    "I54J1": 120,
    "I54J0": 120,
    "I06J0": 121,
    "M30C2": 122,
    "M30C1": 122,
    "M30C0": 122,
    "N322": 123,
    "N321": 123,
    "N320": 123,
    "I04J0": 124,
    "SIL0": 125,
    "F39C0": 126,
    "P39C0": 127,
    "MLU0": 128,
    "DBLI0": 129,
    "LIIT0": 130,
    "SLAE0": 131,
    "LNR0": 132,
    "SAC0": 133,
    "LLAT0": 134,
    "UIL0": 135,
    "TASR0": 136,
    "MSR_2_3": 137,
    "MSR_2_6": 138,
    "MSR_2_7": 139,
    "MSR_5_1": 140,
    "MSR_5_2": 141,
    "MSR_5_3": 142,
    "MSR_5_6": 143,
    "MSR_5_7": 144,
    "MSR_6_1": 145,
    "MSR_6_2": 146,
    "MSR_7_4": 147,
    "MSR_8_4": 148,
    "MSR_8_8": 149,
    "MSR_8_9": 150,
    "MSR_8_10": 151,
    "MSR_8_11": 152,
    "MSR_8_12": 153,
    "MSR_8_13": 154,
    "MSR_8_14": 155,
    "MSR_9_3": 156,
    "MSR_9_4": 157,
    "MSR_9_5": 158,
    "MSR_10_3": 159,
    "MSR_10_4": 160,
    "MSR_10_5": 161,
    "MSR_10_6": 162,
    "MSR_10_7": 163,
    "MSR_10_8": 164,
    "MSR_11_2": 165,
    "MSR_11_3": 166,
    "MSR_11_4": 167,
    "MSR_11_5": 168,
    "MSR_11_6": 169,
    "MSR_11_7": 170,
    "MSR_11_8": 171,
    "MSR_11_9": 172,
    "MSR_12_2": 173,
    "MSR_12_3": 174,
    "MSR_12_4": 175,
    "MSR_13_1": 176,
    "MSR_13_2": 177,
    "MSR_13_3": 178,
    "MSR_13_4": 179,
    "MSR_13_5": 180,
    "MSR_13_6": 181,
    "MSR_18_4": 182,
    "MSR_18_8": 183,
    "MSR_19_2": 184,
    "MSR_21_3": 185,
    "MSR_21_4": 186,
    "MSR_21_5": 187,
    "MSR_21_6": 188,
    "MSR_21_7": 189,
    "MSR_21_8": 190,
    "MSR_21_9": 191,
    "MSR_21_10": 192,
    "MSR_5_0_1": 193,
    "MSR_5_0_8": 194,
    "MSR_5_0_19": 195,
    "MSR_8_5_3": 196,
    "MSR_10_1_3": 197,
    "MSR_12_1_1": 198,
    "MSR_12_1_2": 199,
    "MSR_12_1_3": 200,
    "MSR_11_0_1": 201,
    "MSR_10_2_1": 202,
    "MSR_17_7": 203,
    "MSR_17_8": 204,
    "MSR_10_2": 205
  }
}