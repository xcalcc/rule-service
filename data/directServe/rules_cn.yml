- alias: {}
  category: BAD_PRACTICE
  code: CSL
  cost: M
  csv_string:
    - CSL0
  desc: 该程序调用序列太深, 超出用户设置的上限。
  details: >+
    #### 概要

    该程序调用序列太深，超出用户设置的上限。


    #### 解释

    当函数A调用另外一个函数B时，B同时也有可能正在调用C函数。这类调用链可以无限进行下去。在嵌入式系统中，调用链太深可能会引起意外的结果，如内存不足、执行时间不足等。

  examples:
    bad:
      c:
        - |
          int __attribute__((__noinline__)) f1() {
            return 1;
          }
          int __attribute__((__noinline__)) f2() {
            return 2 + f1();
          }
          int __attribute__((__noinline__)) f3() {
            return 3 + f2();
          }
          int __attribute__((__noinline__)) f4() {
            return 4 + f3();
          }
          int __attribute__((__noinline__)) f5() {
            return 5 + f4();
          }
          int __attribute__((__noinline__)) f6() {
            return 6 + f5();
          }
          int __attribute__((__noinline__)) f7() {
            return 7 + f6();
          }
          int __attribute__((__noinline__)) f8() {
            return 8 + f7();
          }
          int __attribute__((__noinline__)) f9() {
            return 9 + f8();
          }
          int __attribute__((__noinline__)) f10() {
            return 10 + f9();
          }
          int __attribute__((__noinline__)) f11() {
            return 11 + f10();
          }
          int __attribute__((__noinline__)) f12() {
            return 12 + f11();
          }
          int __attribute__((__noinline__)) f13() {
            return 13 + f12();
          }
          int __attribute__((__noinline__)) f14() {
            return 14 + f13();
          }
          int __attribute__((__noinline__)) f15() {
            return 15 + f14();
          }
          int __attribute__((__noinline__)) f16() {
            return 16 + f15();
          }
          int __attribute__((__noinline__)) f17() {
            return 17 + f16();
          }
          int __attribute__((__noinline__)) f18() {
            return 18 + f17();
          }
          int __attribute__((__noinline__)) f19() {
            return 19 + f18();
          }
          int __attribute__((__noinline__)) f20() {
            return 20 + f19();
          }
          int __attribute__((__noinline__)) f21() {
            return 21 + f20();
          }
          int __attribute__((__noinline__)) f22() {
            return 22 + f21();
          }
          int __attribute__((__noinline__)) f23() {
            return 23 + f22();
          }
          int __attribute__((__noinline__)) f24() {
            return 24 + f23();
          }
          int __attribute__((__noinline__)) f25() {
            return 25 + f24();
          }
          int __attribute__((__noinline__)) f26() {
            return 26 + f25();
          }
          int __attribute__((__noinline__)) f27() {
            return 27 + f26();
          }
          int __attribute__((__noinline__)) f28() {
            return 28 + f27();
          }
          int __attribute__((__noinline__)) f29() {
            return 29 + f28();
          }
          int __attribute__((__noinline__)) f30() {
            return 30 + f29();
          }
          int __attribute__((__noinline__)) f31() {
            return 31 + f30();
          }
          int __attribute__((__noinline__)) f32() {
            return 32 + f31();
          }
          int __attribute__((__noinline__)) f33() {
            return 33 + f32();
          }
          int __attribute__((__noinline__)) f34() {
            return 34 + f33();
          }
          int __attribute__((__noinline__)) f35() {
            return 35 + f34();
          }
          int __attribute__((__noinline__)) f36() {
            return 36 + f35();
          }
          int __attribute__((__noinline__)) f37() {
            return 37 + f36();
          }
          int __attribute__((__noinline__)) f38() {
            return 38 + f37();
          }
          int __attribute__((__noinline__)) f39() {
            return 39 + f38();
          }
          int __attribute__((__noinline__)) f40() {
            return 40 + f39();
          }
          int __attribute__((__noinline__)) f41() {
            return 41 + f40();
          }
          int __attribute__((__noinline__)) f42() {
            return 42 + f41();
          }
          int __attribute__((__noinline__)) f43() {
            return 43 + f42();
          }
          int __attribute__((__noinline__)) f44() {
            return 44 + f43();
          }
          int __attribute__((__noinline__)) f45() {
            return 45 + f44();
          }
          int __attribute__((__noinline__)) f46() {
            return 46 + f45();
          }
          int __attribute__((__noinline__)) f47() {
            return 47 + f46();
          }
          int __attribute__((__noinline__)) f48() {
            return 48 + f47();
          }
          int __attribute__((__noinline__)) f49() {
            return 49 + f48();
          }
          int __attribute__((__noinline__)) f50() {
            return 50 + f49();
          }
      general:
        - >-
          // This case does not need an example.

          // The complete call level from function A to Z, i.e. A() ==> B() ==>
          .... ==> Z(), is too deep.
    good: {}
  language: c,c++
  likelihood: L
  master_id: 1
  msg_templ: 在${si.filename}，${si.line}行上，函数 ${si.func}有一个调用序列，该调用序列超过了在扫描配置设置时设置的上限。
  name: 调用栈的深度超於设置上限
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: M
  standards:
    cwe:
      - '121'
- alias: {}
  category: BAD_PRACTICE
  code: CSS
  cost: M
  csv_string:
    - CSS0
  desc: 该程序有调用序列, 会致使运行时栈內存超出设置的上限。
  details: |
    #### 概要
    该程序有调用序列，会致使运行时栈內存超出设置的上限。

    #### 解释
    当函数A调用另外一个函数B时，传递给被调用函数的参数和被调用函数给调用函数的返回值将被放置在执行栈上。局部变量也会被放置在执行栈上。
  examples:
    bad:
      c:
        - |+
          extern void init_buf(char *buf, int sz);
          int f1() {
            char buf[8192];
            init_buf(buf, sizeof(buf));
            return buf[1];
          }

          int f2() {
            char buf[8192];
            init_buf(buf, sizeof(buf));
            return buf[2] + f1();
          }

          int f3() {
            char buf[8192];
            init_buf(buf, sizeof(buf));
            return buf[3] + f2();
          }

          int f4() {
            char buf[8192];
            init_buf(buf, sizeof(buf));
            return buf[4] + f3();
          }

      general:
        - >-
          // Assuming that stack size is 8 bytes for parameter, 4 bytes for
          return value (assume) 32 bit ABI

          int func_callee(int* a, int i)

          {
           return a[i];
          }


          // stack size is 0 byte (no parameter), 12 byte for local variable, 4
          bytes for return value

          int func_caller() {
           int a[3] = {0, 1}, b;
           b = assign(a, 1); /* callee stack size if 12 bytes
           return 0;
          }


          // total stack size for the call sequence func_caller -> func_callee
          is 28 bytes

          // (assume ABI specifies all parameters uses stack and not register)
    good:
      c:
        - >-
          // Assume that stack size is 8 bytes for parameter, 4 bytes for return
          value (assume) 32 bit ABI

          // Assume we limit the size of stack to that of 32 bytes


          int func_callee(int *a, int i)

          {
              return a[i];
          }


          // stack size is 0 byte (no parameter), 12 byte for local variable, 4
          bytes for return value

          int func_caller()

          {
              int a[3] = {0, 1}, b;
              b = func_callee(a, 1);
              // callee stack size if 12 bytes
              return 0;
          }


          // total stack size for the call sequence func_caller -> func_callee
          is 28 bytes

          // (assume ABI specifies all parameters uses stack and not register)
  language: c,c++
  likelihood: L
  master_id: 2
  msg_templ: >-
    在${si.filename}，${si.line}行上，函数
    ${si.func}有一个调用序列，该调用序列会致使运行时栈內存超过了在扫描配置设置时设置的上限。
  name: 调用栈的內存超於设置上限
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: M
  standards:
    cwe:
      - '787'
- alias:
    cert:
      - MEM51-CPP
  category: VUL
  code: DBF
  cost: M
  csv_string:
    - DBF0
  desc: 该程序已多次释放了某些资源（例如，堆内存、I/O流对象等）。
  details: >+
    #### 概要

    该程序已多次释放了某些资源（例如，堆内存、I/O流对象等）。


    ### 解释

    该程序已多次调用了诸如free()、close()这样的函数来释放同一个资源对象。这会导致系统不一致，例如系统的堆管理数据结构或I/O流子类等的损坏，从而可能允许恶意用户访问任意内存或造成IOException。

  examples:
    bad:
      general:
        - |-
          int func_1(void *p) {
           if (p != NULL) {
           free(p); // free p
           }
          }

          int func_2(void *p) {
           if (p != NULL) {
           free(p); // free p
           }
          }

          int main() {
           int i, *p, *q;
           p = malloc(10 * sizeof(int));
           if (p == NULL)
           return 1;
           for (i=0; i < 10; ++i)
           p[i] = i;
           q = p;
           func_1(p); // free p the first time
           func_2(q); // free p the second time due to value of p copied into q
           return 0;
          }
    good:
      general:
        - |-
          int func_1(void *p) {
           if (p != NULL) {
           free(p); // free p
           }
          }

          int func_2(void *p) {
           if (p != NULL) {
           free(p); // free p
           }
          }

          int main() {
           int i, *p, *q;
           p = malloc(10 * sizeof(int));
           if (p == NULL)
           return 1;
           for (i=0; i < 10; ++i)
           p[i] = i;
           q = p;
           func_1(p); // free p the first time and only time
           return 0;
          }
  language: c,c++
  likelihood: L
  master_id: 3
  msg_templ: >-
    在${si.filename}，第${si.line}行，${si.func}的资源变量${si.var}已被多次释放。该资源变量${si.var}在${so.filename}第${so.line}行被首次释放。
  name: 资源被多次释放
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    cwe:
      - '415'
- alias: {}
  category: VUL
  code: FMT
  cost: L
  csv_string:
    - FMT2
    - FMT1
    - FMT0
  desc: 该程序正调用printf函数族中的一个，其使用的参数个数（或类型）与格式字符串声明的不同。
  details: |+
    #### 概要
    该程序正调用printf函数族中的一个，其使用的参数个数（或类型）与格式字符串声明的不同。

    #### 解释
    在printf（或此类系统调用的家族）里，实际使用的参数个数或类型与格式化字符串说明的不同。当传递的实际参数不同时，实际打印出的内容将不可预测。

  examples:
    bad:
      c:
        - |+
          foo(int a, int guard)
          {
            int x = 0;
            int int_result = 0;
            if (guard != 0) int_result = a * x;
            
            // The format string specified two values to be printed,
            // only one actual parameter is passed. The second output is unpredictable
            printf("result %d is %x truncated", int_result); 
            return 0;
          }

    good:
      c:
        - |+

          foo(int a, int guard)
          {  int x = 0;
            int int_result = 0;
            if (guard != 0) int_result = a * x;

            // number of actuals match that with format statement
            printf("result %d is %x truncated", int_result, int_result); 
            return 0;
          }

  language: c,c++
  likelihood: U
  master_id: 4
  msg_templ: 在${si.filename}，第${si.line}行${si.func}中参数${si.var}的格式与格式字符串声明有些不同。
  name: 格式字符串溢出
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    cwe:
      - '787'
      - '88'
      - '119'
    owasp:
      - A3
      - A1
      - A6
- alias: {}
  category: ROBUSTNESS
  code: MSF
  cost: M
  csv_string:
    - MSF2
    - MSF1
    - MSF0
  desc: 该程序已分配了堆内存，但未能释放那块内存。
  details: >
    #### 概要

    该程序已分配了堆内存，但未能释放那块内存。


    #### 解释

    分配了堆内存并且分配的内存地址存储在引用（指针）类型的变量里。该堆内存在其生命周期结束后从未被释放，其对应的引用仍然指向该内存空间。这可能会导致敏感数据泄漏或意外程序行为（例如拒绝服务）。
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>

          struct S
          {
              int *p;
          };

          int main()
          {
              int *p;
              struct S *s;
              p = malloc(10 * sizeof(int)); // heap memory allocated and pointed to by p
              if (p == NULL)
              {
                  return 1;
              }
              s = (struct S *)malloc(sizeof(struct S)); // heap memory allocated and pointed to by s
              if (s == NULL)
              {
                  free(p);
                  return 1;
              }
              s->p = p;
              free(s); // only s is freed
              // s->p, which is copied from p is not freed
              return 0;
          }
      general:
        - |-
          struct S {
           int *p;
          };

          int main() {
           int *p;
           struct S *s;
           p = malloc(10 * sizeof(int)); // heap memory allocated and pointed to by p
           if (p == NULL)
           return 1;
           s = (struct S*)malloc(sizeof(struct S)); // heap memory allocated and pointed to by s
           if (s == NULL) {
           free(p);
           return 1;
           }
           s->p = p;
           free(s); // only s is freed
           // s->p, which is copied from p is not freed
           return 0;
          }
    good:
      c:
        - |-
          #include <stdio.h>

          struct S
          {
              int *p;
          };

          int main()
          {
              int *p;
              struct S *s;
              p = malloc(10 * sizeof(int)); // heap memory allocated and pointed to by p
              if (p == NULL)
              {
                  return 1;
              }
              s = (struct S *)malloc(sizeof(struct S)); // heap memory allocated and pointed to by s
              if (s == NULL)
              {
                  free(p);
                  return 1;
              }
              s->p = p;
              // both s and p are freed
              free(s); 
              free(p); 
              return 0;
          }
  language: c,c++
  likelihood: L
  master_id: 5
  msg_templ: >-
    在${si.filename}，第${si.line}行，${si.func}里的变量${si.var}未被释放。${si.var}是在${so.filename}，第${so.line}行获得首个堆内存的分配。
  name: 没有释放
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    owasp:
      - A3
- alias:
    cert:
      - EXP54-CPP
      - DCL30-C
  category: VUL
  code: RAL
  cost: L
  csv_string:
    - RAL1
    - RAL0
  desc: 该函数返回了栈变量的地址，这会导致意外程序行为。
  details: |
    #### 概要
    该函数返回了栈变量的地址，这会导致意外程序行为。

    #### 解释
    由于局部变量分配在栈上，当函数返回至调用者时，被调用者的栈地址不再有效。随后的函数调用很可能重用这个相同的栈地址，并覆盖先前的调用的返回值。
  examples:
    bad:
      c:
        - |
          extern void bar(int);

          int *foo()
          {
              int c = 0;
              bar(c);
              return &c; //return a local address to caller
          }
      general:
        - |-
          int foo()
          {
           int *c;
           return &c; //return a local address to caller
          }
    good:
      c:
        - |-
          int foo()
          {
              int *c;
              return *c; // item *c is pointing to returned
          }
  language: c,c++
  likelihood: L
  master_id: 6
  msg_templ: 在${si.filename}，第${si.line}行，局部变量${si.var}的地址已返回给了调用者。
  name: 局部变量的返回地址
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    autosar:
      - M7-5-1
- alias: {}
  category: VUL
  code: RXS
  cost: L
  csv_string:
    - RXS0
  desc: 该程序可能已从包含不受信任数据的外部接口中读取。
  details: |
    #### 概要
    该程序可能已从包含不受信任数据的外部接口中读取。

    #### 解释
    外部接口会允许程序同外部世界产生相互作用，因此确保外部接口不接收安全敏感型或者不受信任的输入是非常重要的。
  examples:
    bad:
      c:
        - |-
          #include <sys/socket.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <unistd.h>

          #define BUF_SZ 256

          int foo(void)
          {
              int n;
              char buffer[BUF_SZ];
              int sockfd = socket(AF_INET, SOCK_STREAM, 0);

              if (sockfd < 0)
              {
                  perror("ERROR opening socket");
                  exit(1);
              }

              n = read(sockfd, buffer, 255);

              // use buffer
              // if buffer is used as argument to system() or to setenv()
              // the buffer may contain untrusted commands or characters leading to unpredictable program behavior
              // ...
          }
      general:
        - |
          #include <sys/socket.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <unistd.h>

          #define BUF_SZ 256

          int foo(void)
          {
           int n;
           char buffer[BUF_SZ];
           sockfd = socket(AF_INET, SOCK_STREAM, 0);

           if (sockfd < 0) {
           perror(\"ERROR opening socket\");
           exit(1);
           }

           n = read(sockfd,buffer,255);

           // use buffer
           // if buffer is used as argument to system() or to setenv()
           // the buffer may contain untrusted commands or characters leading to unpredictable program behavior
           // ...
          }
    good:
      c:
        - |-
          #include <sys/socket.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <unistd.h>

          #define BUF_SZ 256

          int foo(void)
          {
              int n;
              char buffer[BUF_SZ];
              char *cp = buffer; 
              int sockfd = socket(AF_INET, SOCK_STREAM, 0);

              if (sockfd < 0)
              {
                  perror("ERROR opening socket");
                  exit(1);
              }

              // filter out untrusted data and characters
              static char approved[] = "abcdefghijklmnopqrstuvwxyz"
                                       "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                                       "1234567890_-.@";
              const char *end = buffer + strlen(buffer);
              for (cp += strspn(cp, approved); cp != end; cp += strspn(cp, approved))
              {
                  *cp = '_';
              }

              n = read(sockfd, buffer, 255);

              // use buffer
              // if buffer is used as argument to system() or to setenv()
              // the buffer may contain untrusted commands or characters leading to unpredictable program behavior
              // ...
          }
  language: c,c++
  likelihood: L
  master_id: 7
  msg_templ: >-
    在${si.filename}，第${si.line}行，${si.func}从外部接口接收了不受信任的数据，此外部接口是在${si.filename}的第${si.line}行被建立的。
  name: 从外部套接字读取
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: M
  standards:
    cwe:
      - '577'
- alias:
    cert:
      - MEM50-CPP
      - MEM01-C
      - MEM30-C
      - MEM00-C
  category: VUL
  code: UAF
  cost: M
  csv_string:
    - UAF3
    - UAF2
    - UAF1
    - UAF0
  desc: 该程序在已释放了内存后引用了该内存。这可能导致程序崩溃或不可预测的程序行为。
  details: >
    #### 概要

    该程序在已释放了内存后引用了该内存。这可能导致程序崩溃或不可预测的程序行为。


    #### 解释

    释放后重用是悬空指针引用的一种形式。它通常发生在指针所指向的内存对象已被释放而指针未被更新时。该指针将指向不正确的内存，这在使用指针时会引起未经授权的访问。
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>

          int g = 2;

          void my_free(void *p)
          {
              if (p != NULL) 
              {
                  free(p); // free p
              }
          }

          int main()
          {
              int i, j, *p, *q;
              p = malloc(10 * sizeof(int));
              if (p == NULL)
              {
                  return 1;
              }
              for (i = 0; i < 10; ++i) 
              {
                  p[i] = i;
              }
              q = p;
              my_free(p); // p is freed
              j = 0;
              for (i = 0; i < 10; ++i)
              {
                  j += q[i]; // Use after free here (note the statement q = p), read of q[i] is illegal
              }
              return j;
          }
      general:
        - |-
          #include <stdio.h>

          int g = 2;

          void my_free(void *p) {
           if (p != NULL)
           free(p); // free p
          }

          int main() {
           int i, j, *p, *q;
           p = malloc(10 * sizeof(int));
           if (p == NULL)
           return 1;
           for (i=0; i < 10; ++i)
           p[i] = i;
           q = p;
           my_free(p); // p is freed
           j = 0;
           for (i=0; i < 10; ++i)
           j += q[i]; // Use after free here (note the statement q = p), read of q[i] is illegal
           return j;
          }
    good:
      c:
        - |-
          #include <stdio.h>

          int g = 2;

          void my_free(void *p)
          {
              if (p != NULL) 
              {
                  free(p); // free p
              }
                  
          }

          int main()
          {
              int i, j, *p, *q;
              p = malloc(10 * sizeof(int));
              if (p == NULL)
              {
                  return 1;
              }
              for (i = 0; i < 10; ++i) 
              {
                  p[i] = i;
              }    
              q = p;
              my_free(p); // p is freed
              j = 0;

              // checks if q is illegal before running the for loop
              if (q == 0 || q == NULL)
              {
                  exit(1);
              }
              
              for (i = 0; i < 10; ++i)
              {
                  // Use after free here (note the statement q = p), read of q[i] is illegal
                  j += q[i]; 
              }
                  
              return j;
          }
  language: c,c++
  likelihood: L
  master_id: 8
  msg_templ: >-
    在${so.filename}，第${so.line}行，${so.func}里使用了变量${so.var}。然而，此变量在${so.filename}第${so.line}行已被释放。
  name: 释放后重用
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    cwe:
      - '416'
      - '672'
    owasp:
      - A1
      - A3
- alias: {}
  category: VUL
  code: UDR
  cost: H
  csv_string:
    - UDR5
    - UDR4
    - UDR3
    - UDR2
    - UDR1
    - UDR0
  desc: 已使用了悬空指针来引用无效的内存资源。
  details: |
    #### 概要
    已使用了悬空指针来引用无效的内存资源。

    #### 解释
    悬空指针是引用无效或不正确的内存资源的指针。引用这些内存资源可能会造成内存损坏，从而导致不可预测的程序行为或系统不稳定。
  examples:
    bad:
      c:
        - |-
          int *assign()
          {
              int *c;
              c = 1;
              return &c;
          }

          int foo()
          {
              int *a;
              a = assign(); // return a stack address and assign to a
              printf("assigned value: %d", a); // use dangling pointer
              return 0;
          }
        - |-
          #include <alloca.h>
          #include <stdlib.h>

          void extern fill(char *data, int num);
          void dangling_ptr_func(int sz, char *data_buf)
          {
            data_buf = alloca(sz);
            fill(data_buf, sz);  // fill data buffer
            // more manipulation of data buffer ...


            // free does not really free data_buf
            // data_buf points to memory that is out of scope after
            free(data_buf);
            return;
          }
      general:
        - |-
          int *assign()
          {
           int *c;
           c = 1;
           return &c;
          }

          int foo()
          {
           int *a;
           a = assign(); // return a stack address and assign to a
           printf(\"assigned value: %d\", a); // use dangling pointer
           return 0;
          }
    good:
      c:
        - |+
          void assign(int *c)
          {
              *c = 1;
              return;
          }

          int foo()
          {
              int a;
              assign(&a); 
              printf("assigned value: %d", a); // pointer is not dangling
              return 0;
          }

  language: c,c++
  likelihood: L
  master_id: 9
  msg_templ: >-
    在${so.filename}，第${so.line}行，使用了${so.func}里的内存引用变量${so.var}。该变量首次被赋值为内存引用，这在${so.filename}的第${so.line}行可能无效。
  name: 使用悬空指针
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    cwe:
      - '590'
    owasp:
      - A1
      - A2
      - A3
- alias: {}
  category: VUL
  code: WRF
  cost: M
  csv_string:
    - WRF0
  desc: 该程序正对只读文件执行写操作。
  details: |
    #### 概要
    该程序正对只读文件执行写操作。

    #### 解释
    当打开文件进行读取并随后写入时，fwrite会报告错误。如果不检查fwrite的结果，则该程序会继续进行，而文件可能不会按预期得到更新。
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>
          #include <unistd.h>
          #include <sys/stat.h>
          #include <fcntl.h>

          int file_operation()
          {
              struct stat statBefore, statAfter;

              lstat("/tmp/x", &statBefore);

              // file open for read
              FILE *fp_open_readonly = fopen("/tmp/x", "r");
              lstat("/tmp/x", &statAfter);

              if (statAfter.st_ino == statBefore.st_ino)
              {
                  if (fp_open_readonly != NULL)
                  {
                      // writing to the file
                      fwrite("HELLO!", 1, 5, fp_open_readonly);
                  }
              }

              fclose(fp_open_readonly);
              return 0;
          }
      general:
        - |-
          int file_operation(two_level *p, two_level *q)
          {
           struct stat statBefore, statAfter;

           lstat(\"/tmp/x\", &statBefore);

           // file open for read
           FILE *fp_open_readonly = fopen(\"/tmp/x\", \"r\");
           lstat(\"/tmp/x\", &statAfter);

           if (statAfter.st_ino == statBefore.st_ino) {
           if (fp_open_readonly != NULL) {
           // writing to the file
           fwrite(\"HELLO!\", 1, 5, fp_open_readonly);
           }
           }

           fclose(fp_open_readonly);
           return 0;
          }
    good:
      c:
        - |-
          #include <stdio.h>
          #include <unistd.h>
          #include <sys/stat.h>
          #include <fcntl.h>

          int file_operation()
          {
              struct stat statBefore, statAfter;

              lstat("/tmp/x", &statBefore);

              // file open for read
              FILE *fp_open_readonly = fopen("/tmp/x", "w");
              lstat("/tmp/x", &statAfter);

              if (statAfter.st_ino == statBefore.st_ino)
              {
                  if (fp_open_readonly != NULL)
                  {
                      // writing to the file
                      fwrite("HELLO!", 1, 5, fp_open_readonly);
                  }
              }

              fclose(fp_open_readonly);
              return 0;
          }
  language: c,c++
  likelihood: L
  master_id: 10
  msg_templ: 在${si.filename}，第${si.line}行，函数${si.func}对只读文件执行写操作。
  name: 写入只读文件
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    cwe:
      - '275'
    owasp:
      - A5
- alias:
    cert:
      - ARR38-C
      - ARR30-C
  category: VUL
  code: AOB
  cost: H
  csv_string:
    - AOB4
    - AOB3
    - AOB2
    - AOB1
    - AOB0
  desc: 该程序正在预期缓存定义的界限外（界限之前或之后）访问数据。
  details: >+
    #### 概要

    该程序正在预期缓存声明的界限外（界限前后）访问数据。

    #### 解释

    通常情况下，这可能会引起程序在执行期间受到攻击而导致程序崩溃。当代码从其他内存位置读取敏感数据或可疑数据量并假定存在前哨来阻止读操作时（例如字符串里的空值），可能会发生崩溃。预期的前哨可能不位于越界内存里，致使读取过量数据，从而导致段错误或缓存溢出。软件可能修改引用在缓存界限之外的内存位置的索引或执行指针运算。随后的读运算便会产生未定义或意外结果。

  examples:
    bad:
      c:
        - |-
          int assign(int* a, int i)
          {
           return a[i]; /* called by main
           a only has 2 elements but i is 2 */
          }

          int main() {
           int a[2] = {0, 1}, b;
           b = assign(a, 2); // call assign with a and i
           // a has two elements and i is 2
           // a[2] is out-of-bound and also uninitialized
           printf("value of b = %d\\", b);
           return 0;
          }
      general:
        - |-
          int assign(int* a, int i)
          {
           return a[i]; /* called by main
           a only has 2 elements but i is 2 */
          }

          int main() {
           int a[2] = {0, 1}, b;
           b = assign(a, 2); // call assign with a and i
           // a has two elements and i is 2
           // a[2] is out-of-bound and also uninitialized
           printf("value of b = %d\\", b);
           return 0;
          }
    good:
      c:
        - |-
          int assign(int* a, int i)
          {
              return a[i];    /* called by main
              a only has 2 elements but i is 2 */
          }

          #define ARR_SZ 2
          int main()
          {
              int a[ARR_SZ] = {0, 1}, b;
              b = assign(a, (ARR_SZ-1)); // call assign with a and i
              // a has two elements and i is 2
              // a[2] is out-of-bound and also uninitialized
              printf("value of b = %d\\", b);
              return 0;
          }
      general:
        - |-
          int assign(int* a, int i)
          {
           return a[i]; /* called by main
           a only has 2 elements but i is 2 */
          }

          #define ARR_SZ 2
          int main() {
           int a[ARR_SZ] = {0, 1}, b;
           if ()
           b = assign(a, (ARR_SZ-1)); // call assign with a and i
           // a has two elements and i is 2
           // a[2] is out-of-bound and also uninitialized
           printf("value of b = %d\\", b);
           return 0;
          }
  language: c,c++,java
  likelihood: L
  master_id: 11
  msg_templ: 在${si.filename}，第${si.line}行，已经检测到 ${si.func} 里的变量${si.var}有数组越界。
  name: 数组越界
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    cwe:
      - '787'
      - '125'
      - '121'
      - '122'
      - '126'
    owasp:
      - A1
      - A2
      - A3
      - A5
- alias: {}
  category: BAD_PRACTICE
  code: CRF
  cost: M
  csv_string:
    - CRF0
  desc: 该程序有调用序列，它在运行时造成了递归。
  details: >
    #### 概要

    该程序有调用序列，它在运行时造成了递归


    #### 解释

    当一个函数(假定是A)调用另外一个函数而调用序列最终再次调用A时，会发生递归。其最简单的形式是函数在执行期间就调用自身，这可能会导致无限循环，还可能会造成对栈空间的过分使用，并可能导致内存不足或栈空间问题。
  examples:
    bad:
      c:
        - |-
          // Most simple forms of recursion.
          // if first call to func_recurse is: func_recurse(p_glbl, 6)
          // this code segment will recurse and get into an infinite loop

          int global = 5;
          static *p_glbl = &global;
          int func_recurse(int *p, int i)
          {
              if ((p != 0) && (*p != i))
              {
                  return func_recurse(p, 2); // calls itself directly
              }
              return 0;
          }
      general:
        - |-
          // Most simple forms of recursion.
          // if first call to func_recurse is: func_recurse(p_glbl, 6)
          // this code segment will recurse and get into an infinite loop

          int global = 5;
          static *p_glbl = &global;
          int func_recurse(int* p, int i)
          {
           if ((p != 0) && (*p != i))
           return func_recurse(p, 2); // calls itself directly
           return 0;
          }
        - |-
          // Indirect recursion.
          // if first call to func_recurse is: func_recurse(p_glbl, 6)
          // this code segment will call func_recurse inside func_b

          int global = 5;
          static *p_glbl = &global;

          int func_b(int *q, int j)
          {
           if (q != 0) {
           return func_recurse(q, 5);
           }
           else
           return 5;
          }

          int func_recurse(int *p, int i)
          {
           if ((p != 0) && (*p != i))
           return func_b(p, i); // calls func_recurse indirectly
           return 0;
          }
    good:
      c:
        - "// suppose first call to func_recurse is (p_glbl, 6)\n\nconst int MAXIMUM_LIMIT = 100;\nint global = 5;\nstatic *p_glbl = &global;\nint func_recurse(int *p, int i)\n{\n    if (i > MAXIMUM_LIMIT) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tif (i != 0) {\n        // recursion bottoms out when second argument tends to 0\n        return func_recurse(p_glbl, i - 1);                                           \n    }\n    return 0;\n}"
  language: c,c++,java
  likelihood: L
  master_id: 12
  msg_templ: 在${si.filename}，${si.line}行上，函数 ${si.func}在调用自身。
  name: 使用了递归函数
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: M
  standards:
    cwe:
      - '674'
- alias:
    cert:
      - FLP03-C
      - INT33-C
      - NUM02-J
  category: CORRECTNESS
  code: DBZ
  cost: H
  csv_string:
    - DBZ2
    - DBZ1
    - DBZ0
  desc: 该程序正试图将值除以零。
  details: |+
    #### 概要
    该程序正试图将值除以零。

    #### 解释
    当把意外的常数零赋值给除数，或者发生了未适当检测到的错误（例如函数调用的返回值）时，将值除以零的情况就可能会发生。

  examples:
    bad:
      c:
        - |-
          int divide(int num, int denom)
          {
              // denom could be of value 0, and dividing 
              // by 0 results in undefined behavior
              return num / denom;
          }

          int func(void)
          {
              return divide(3, 0); // non-compliant
          }
      general:
        - |-
          int foo(int a, int guard)
          {
           int x = 0;
           int result = 0;
           if (guard != 0)
           result = a / x; // did not check for zero
           printf(\"result is %d\", result);
           return 0;
          }
    good:
      c:
        - |-
          int divide(int num, int denom) {

              // checks if denom is 0, and always throws an
              // error when trying to divide by 0
              if (denom == 0) 
              {
                  printf("Cannot divide a number by 0");
                  exit(133);
              }

              return num/denom;
          }
  language: c,c++,java
  likelihood: P
  master_id: 13
  msg_templ: 在${so.filename}，第${so.line}行，${so.func} 里的变量 ${so.var}，已检测到了被除以零。该变量的值是零。
  name: 被零除
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: L
  standards:
    cwe:
      - '369'
- alias:
    cert:
      - MSC07-C
      - MSC12-C
  category: BAD_PRACTICE
  code: DDC
  cost: M
  csv_string:
    - DDC1
    - DDC0
  desc: 跳转语句后有无法访问的代码。
  details: |
    #### 概要
    跳转语句后有无法访问的代码。

    #### 解释
    跳转语句后面的代码不会被执行， 无返回值的函数之后的代码也不会被执行。这可能是由于意外编辑导致。这是代码质量问题。
  examples:
    bad:
      c:
        - |
          void abort();
          void exit();
          int foo();

          int f1()
          {
              abort();
              foo(); // unreachable
          }
          int f2()
          {
              exit();
              foo(); // unreachable
          }

          int f3()
          {
              foo();
              goto L;
              foo(); // unreachable
          L:
              foo();
          }

          int f4(int x)
          {
              foo();
              goto L;
              if (x > 5)
              { // unreachable
              L:
                  foo();
              }
          }
      general:
        - |
          void abort();
          void exit();
          int foo();

          int f1() {
           abort();
           foo(); // unreachable
          }
          int f2() {
           exit();
           foo(); // unreachable
          }

          int f3() {
           foo();
           goto L;
           foo(); // unreachable
          L:
           foo();
          }

          int f4(int x) {
           foo();
           goto L;
           if (x>5) { // unreachable
          L:
           foo();
           }
          }
    good:
      c:
        - |
          void abort();
          void exit();
          int foo();

          int f1()
          {
              foo(); // reachable
          }
          int f2()
          {
              foo(); // reachable
          }

          int f3()
          {
              foo();
              goto L;
              L:
                  foo();  // reachable
          }
  language: c,c++,java
  likelihood: U
  master_id: 14
  msg_templ: 在${si.filename}，函数${si.func}，第${si.line}行，在执行期间存在无法访问的代码。
  name: 跳转语句后有无法访问的代码
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: L
  standards: {}
- alias:
    cert:
      - MSC12-C
  category: PFM
  code: DDV
  cost: M
  csv_string:
    - DDV0
  desc: 这个语句之后的另一个语句将使此语句的执行无效，或这个语句的结果不会被使用。
  details: |
    #### 概要
    这个语句之后的另一个语句将使此语句的执行无效，或这个语句的结果不会被使用。

    #### 解释
    此类错误通常由输入错误引起，抑或是由于一些被删除了的语句导致。
  examples:
    bad:
      c:
        - |-
          void assign(int input)
          {
              int a = 0; // dead code
              a = input; // result of \"a = 0\" will be nullified by this statement
              printf("a value: %d", a);
          }
      general:
        - |-
          void assign(int input)
          {
           int a = 0; // dead code
           a = input; // result of \"a = 0\" will be nullified by this statement
           printf(\"a value: %d\", a);
          }
    good:
      c:
        - |-
          void assign(int input)
          {
              int a = input; // a is only used once and does not get nullified
              printf("a value: %d", a);
          }
  language: c,c++,java
  likelihood: U
  master_id: 15
  msg_templ: 在${si.filename}，第${si.line}行，检测到${si.func}里的变量${si.var}是闲置赋值。
  name: 闲置变量
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: L
  standards: {}
- alias: {}
  category: VUL
  code: FAM
  cost: H
  csv_string:
    - FAM2
    - FAM1
    - FAM0
  desc: 该程序正调用函数，其使用的参数个数与原型声明的参数个数不同。
  details: >
    #### 概要

    该程序正调用函数，其使用的参数个数与原型声明的参数个数不同。


    #### 解释

    在调用点里，传递的实际参数个数与函数声明里的参数个数不同。如果传递的实际参数比声明的要少，缺失的实际参数最终会变成\"wild\"，并可能发生不可预测的行为后果。
  examples:
    bad:
      c:
        - |-
          int foo(int a, int guard)
          {
              a++;
              guard++;
              return 0;
          }

          int func(void)
          {
              int t = 1;
              /* 
              missing one parameter, and \"guard\" will have 
              random value during execution at this point;
              compilation error would be raised here
              */
              foo(t);
              return 1;
          }
      general:
        - |-
          int foo(int a, int guard)
          {
           int x = 0;
           int result = 0;
           if (guard != 0)
           result = a * x;
           foo(result); // missing one parameter, and \"guard\" will have random value during execution at this point
           return 0;
          }
    good:
      c:
        - |-
          int foo(int a, int guard)
          {
              int x = 0;
              int result = 0;
              if (guard != 0)
              {
                  result = a * x;
              }
              foo(result, guard); // no parameters missing
              return 0;
          }
  language: c,c++,java
  likelihood: P
  master_id: 16
  msg_templ: >-
    在${si.filename}，第${si.line}行，${si.func}的参数与文件${si.filename}，第${si.line}行里的函数声明不匹配。
  name: 形式和实际参数不匹配
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    owasp:
      - A3
      - A6
- alias:
    cert:
      - EXP34-C
  category: ROBUSTNESS
  code: NPD
  cost: M
  csv_string:
    - NPD0
  desc: 该程序正通过有空值的指针访问内存。这可能会导致段错误或不可预测的程序行为。该漏洞与EXP34-C等同。
  details: >
    #### 概要

    该程序正通过有空值的指针访问内存。这可能会导致段错误或不可预测的程序行为。该漏洞与EXP34-C等同。


    #### 解释

    在有内存保护的系统里（例如Linux），解引用空指针会导致段错误。
    对于嵌入系统来说，它会造成不可预测的程序行为。在Java里，空指针解除引用会触发空指针异常。
  examples:
    bad:
      c:
        - |-
          extern int bar(int);

          int assign(int* a)
          {
           int i = bar(*a) // dereference a
           return i;
          }

          int foo(void)
          {
           int *p = 0; // p as a pointer has been initialized to 0 (null)
           assign(p);
          }
      java:
        - |-
          class User {
           public String getName() {
           return null;
           }
          }

          class Bar {
           private User findUser(String uid) {
           if (user.containsKey(uid)) {
           return user.get(uid);
           }
           else
           return null;
           }
           public void Npd(String uid) {
           // program continues
           // ...
           User user = findUser(uid); // Throws NPE if \"user\" has not been properly initialized
           String getName() {
           return null;
           }
           }
          }
    good:
      c:
        - |-
          extern int bar(int);

          int assign(int* a)
          {
           int i;
           if (a != 0)
           i = bar(*a); // dereference a
           else {
           // handle error and exit gracefully (such exit program)
           exit(1);
           }
           return i;
          }

          int foo(void)
          {
           int *p = 0; // p as a pointer has been initialized to 0 (null)
           assign(p);
          }
      java:
        - |-
          class User {
           public String getName() {
           return null;
           }
          }

          class Bar {
           private User findUser(String uid) {
           if (user.containsKey(uid)) {
           return user.get(uid);
           }
           else
           return null;
           }
           public void Npd(String uid) {
           // program continues
           // ...
           User user = findUser(uid); 
           if (user == null) {
           throw new RuntimeException(\"Null String\");
           }
           String getName() {
           return null;
           }
           }
          }
  language: c,c++,java
  likelihood: L
  master_id: 17
  msg_templ: 在${so.filename}，第${so.line}行，${so.func} 里对变量${so.var}检测到了NPD缺陷。该变量的值是零。
  name: 空指针解除引用
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    cwe:
      - '476'
- alias:
    cert:
      - MSC12-C
  category: BAD_PRACTICE
  code: RCD
  cost: M
  csv_string:
    - RCD0
  desc: 冗余的控制语句。
  details: >
    #### 概要

    冗余的控制语句。


    #### 解释

    当两个条件语句在执行流中有依赖时，一个条件可以在逻辑上包含另一个条件语句。在这种情况下，另一个条件是多余和不必要的，这种情况可能是编辑错误造成的，这是一个代码质量问题。
  examples:
    bad:
      c:
        - |-
          int foo();
          int bar();

          int f1(int x)
          {
              if (x > 15 && x > 16) // x>16 will subsume x>15
                  foo();
          }

          int f2(int x)
          {
              if (x > 16 && x > 15) // x>16 implies x>15, hence x>15 is redundant
                  foo();
          }

          int f3(int x)
          {
              if (x > 16)
              {
                  foo();
                  if (x > 15) // x>16 implies x>15, hence this check is unnecessary
                      bar();
              }
          }

          int f4(int x)
          {
              if (x > 15)
              {
                  foo();
                  if (x > 16) // x>15 does not imply x>16, this check is not redundant
                      bar();
              }
          }
      general:
        - |-
          int foo();
          int bar();

          int f1(int x) {
           if (x>15 && x>16) // x>16 will subsume x>15
           foo();
          }

          int f2(int x) {
           if (x>16 && x>15) // x>16 implies x>15, hence x>15 is redundant
           foo();
          }

          int f3(int x) {
           if (x>16) {
           foo();
           if (x>15) // x>16 implies x>15, hence this check is unnecessary
           bar();
           }
          }

          int f4(int x) {
           if (x>15) {
           foo();
           if (x>16) // x>15 does not imply x>16, this check is not redundant
           bar();
           }
          }
    good:
      c:
        - |-
          int foo();
          int bar();

          int f1(int x)
          {
              if (x > 16) // removed x>15 since unnecessary
                  foo();
          }

          int f2(int x)
          {
              if (x > 16) // removed x>15 since unnecessary
                  foo();
          }

          int f3(int x)
          {
              if (x > 16)
              {
                  foo();
                  bar(); // bar will always run anyways so no need an if statement
              }
          }

          int f4(int x)
          {
              if (x > 15)
              {
                  foo();
                  if (x > 16) 
                  {
                      bar();
                  }
              }
          }
  language: c,c++,java
  likelihood: U
  master_id: 18
  msg_templ: 在${si.filename}，函数 ${si.func}，第${si.line}行的语句是多余的。
  name: 冗余的控制语句
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: L
  standards: {}
- alias:
    cert:
      - MSC12-C
  category: BAD_PRACTICE
  code: SCB
  cost: M
  csv_string:
    - SCB0
  desc: 一个条件语句中相同的代码块。
  details: |
    #### 概要
    一个条件语句中相同的代码块。

    #### 解释
    条件语句中的两个代码块是相同的。这可能是由于编辑错误造成的。这是一个代码质量问题。
  examples:
    bad:
      c:
        - |
          int foo();
          int a, b;

          int f1(int x)
          {
              if (a) 
              {
                  foo();
              } 
              else 
              {
                  foo();
              }
          }

          int f2(int x)
          {
              return x ? foo() : foo();  // equivalent to above
          }

          int f3(int x)
          {
              if (x);  // both then and else blocks are empty
          }
      general:
        - |
          int foo();
          int a, b;

          int f1(int x) {
           if (x) // in this condition (if-then-else, block 1 and block 2 are the same. Effectively making the conditional statement useless)
           foo(); // block 1
           else
           foo(); // block 2
          }

          int f2(int x) {
           return x ? foo() : foo(); // similar code written differently
          }

          int f3(int x) {
            if (x);  // both then and else blocks are empty
          }
    good:
      c:
        - |
          int foo();
          int a, b;

          int f1(int x)
          {
              foo(); // no dead code
          }

          int f2(int x)
          {
              return foo();
          }
  language: c,c++,java
  likelihood: U
  master_id: 19
  msg_templ: 在${si.filename}，函数${si.func}，第${si.line}行的条件语句，其两边后面的代码块是相同的。
  name: 相同的代码块
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: L
  standards:
    cwe:
      - '223'
- alias:
    cert:
      - MSC07-C
  category: BAD_PRACTICE
  code: SSE
  cost: M
  csv_string:
    - SSE0
  desc: 程序有相同的子表达式。
  details: |
    #### 概要
    程序有相同的子表达式。

    #### 解释
    在语句中有相同的表达式，其中表达式中变量的值也没有更改。 这可能是由于程序中的拼写错误。 这是一个代码质量问题。
  examples:
    bad:
      c:
        - |-
          int foo();
          int a, b;

          int f3(int x, int *p)
          {
              if (*p && x) // both expressions are not the same 
              {
                  foo();
              }  
          }

          int f4(int x, int y)
          {
              if ((x + y++) && (y + x)) 
              {
                  foo();
              }
                  
          }
      general:
        - |-
          int foo();
          int a, b;


          int f3(int x, int *p) {
           if (*p && *p) // same sub-expression
           foo();
          }

          int f4(int x, int y) {
           if ((x+y++) && (y+x)) // not same sub-expression due to y++
           foo();
          }
    good:
      c:
        - |-
          int foo();
          int a, b;

          int f3(int x, int *p)
          {
              if (*p && *p) // same sub-expression
                  foo();
          }

          int f4(int x, int y)
          {
              if ((x + y++) && (y + x)) // not same sub-expression due to y++
                  foo();
          }
  language: c,c++,java
  likelihood: U
  master_id: 20
  msg_templ: 在${si.filename}，函数${si.func}，第${si.line}行，条件语句中有相同的子表达式。
  name: 相同的子表达式
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: L
  standards: {}
- alias: {}
  category: BAD_PRACTICE
  code: UIC
  cost: L
  csv_string:
    - UIC0
  desc: 构造函数中有未初始化字段。
  details: |
    #### 概要
    构造函数中有未初始化字段 

    #### 解释
    类的构造函数通常包括类内字段的初始化。如果字段没有初始化，很可能是由于编辑错误，这是一个代码质量问题。
  examples:
    bad:
      cpp:
        - |
          #include <stdio.h>

          class Construct_Init
          {
          private:
              int a;
              int b;

          public:
              // all variables in all constructors are
              // initialized
              Construct_Init();
              Construct_Init(int i);
              Construct_Init(int i, int j);

              void CI_Run() { printf("%d:%d", a, b); }
          };

          Construct_Init::Construct_Init()
          {
          }

          Construct_Init::Construct_Init(int i)
          {
              a = i;
          }

          Construct_Init::Construct_Init(int i, int j)
          {
              a = i;
              b = j;
          }

          int main(int argc, char **argv)
          {
              Construct_Init ci;
              ci.CI_Run();
              Construct_Init ci1(1);
              ci1.CI_Run();
              Construct_Init ci2(1, 2);
              ci2.CI_Run();
          }
      general:
        - |
          #include <stdio.h>

          class Construct_Init{
          private:
           int a;
           int b;
          public:
           Construct_Init();
           Construct_Init(int i): a(i) {}; // did not initialize b
           Construct_Init(int i, int j) { a = i; b = j; }

           void CI_Run() { printf(\"%d:%d\
          \", a, b); }
          };

          int main(int argc, char**argv)
          {
           Construct_Init ci;
           ci.CI_Run();
           Construct_Init ci1(1);
           ci1.CI_Run();
           Construct_Init ci2(1,2);
           ci2.CI_Run();
          }
    good:
      cpp:
        - |-
          #include <stdio.h>

          class Construct_Init
          {
          private:
              int a;
              int b;

          public:
              // all variables in all constructors are
              // initialized
              Construct_Init()
              {
                  a = 0;
                  b = 0;
              };
              Construct_Init(int i)
              {
                  a = i;
                  b = 0;
              }
              Construct_Init(int i, int j)
              {
                  a = i;
                  b = j;
              }

              void CI_Run() { printf("%d:%d", a, b); }
          };

          int main(int argc, char **argv)
          {
              Construct_Init ci;
              ci.CI_Run();
              Construct_Init ci1(1);
              ci1.CI_Run();
              Construct_Init ci2(1, 2);
              ci2.CI_Run();
          }
  language: c,c++,java
  likelihood: L
  master_id: 21
  msg_templ: 在${si.filename}，函数${si.func}，第${si.line}行，有一个字段${si.var}尚未初始化。
  name: 构造函数中有未初始化字段
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: L
  standards:
    cwe:
      - '909'
- alias:
    cert:
      - EXP33-C
      - EXP53-CPP
  category: CORRECTNESS
  code: UIV
  cost: M
  csv_string:
    - UIV1
    - UIV0
  desc: 该程序正在使用未初始化的变量。
  details: |
    #### 概要
    该程序在变量初始化前使用该变量。

    #### 解释
    C和C++里的栈变量默认为非初始化，并且非静态全局变量不默认为零。它们的初始值取决于调用函数时它们在内存中的位置里恰好有的值。这么做会导致意外程序行为。
  examples:
    bad:
      c:
        - |-
          int assign(int *a)
          {
              return *a; // dereference a
          }

          int main()
          {
              int a, b;
              b = assign(&a); // call assign with a uninitialized variable
              printf("value of b = %d", b);
              return 0;
          }
      general:
        - |-
          int assign(int* a)
          {
           return *a; // dereference a
          }

          int main() {
           int a, b;
           b = assign(&a); // call assign with a uninitialized
           printf(\"value of b = %d\
          \", b);
           return 0;
          }
    good:
      c:
        - |-
          int assign(int *a)
          {
              return *a; // dereference a
          }

          int main()
          {
              int a = 100; // a is assigned as 100
              int b;
              b = assign(&a); 
              printf("value of b = %d", b);
              return 0;
          }
  language: c,c++,java
  likelihood: P
  master_id: 22
  msg_templ: 在${so.filename}，第${so.line}行，已经使用了${so.func}里的变量${so.var}但从未对其赋值。
  name: 未初始化的变量
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards: {}
- alias:
    cert:
      - ERR00-J
  category: BAD_PRACTICE
  code: ECB
  cost: M
  csv_string:
    - ECB1
    - ECB0
  desc: 该程序有带空catch块的异常构造。
  details: |+
    #### 概要
    该程序有带空catch块的异常构造。

    #### 解释
    空的catch块会导致另一个try块无法正确处理异常。 “未被抓取到”的异常可能会导致程序出现异常。

  examples:
    bad:
      cpp:
        - |-
          #include <iostream>

          int integer_divide(int a, int b) 
          {
              if (b == 0) 
              {
                  throw "division by zero error";
              }
              else return (a/b);
          }

          int foo(int x, int y) {
              try {
                  int z = integer_divide(x, y);
                  std::cout << z << std::endl;
              }
              catch (const char* msg) {
              // empty catch body, zero as divisor notice suppressed
              }
              return 0;
          }
      general:
        - |-
          #include <iostream>

          int integer_divide(int a, int b) {
           if (b == 0) {
           throw \"division by zero error\";
           }
           else return (a/b);
          }

          int foo(int x, int y) {
           try {
           int z = integer_divide(x, y);
           std::cout << z << std::endl;
           }
           catch (const char* msg) {
           // empty catch body, zero as divisor notice suppressed
           }
           return 0;
          }
    good:
      cpp:
        - |-
          #include <iostream>

          int integer_divide(int a, int b) {
              if (b == 0) {
                  throw "division by zero error";
              }
              else return (a/b);
          }

          int foo(int x, int y) {
              try {
                  int z = integer_divide(x, y);
                  std::cout << z << std::endl;
              }
              catch (const char* msg) {
              // non-empty catch body and return error
                  std::cout << "division exception" << std::endl;
                  return 1;
              }
              return 0;
          }
      general:
        - |-
          #include <iostream>

          int integer_divide(int a, int b) {
           if (b == 0) {
           throw \"division by zero error\";
           }
           else return (a/b);
          }

          int foo(int x, int y) {
           try {
           int z = integer_divide(x, y);
           std::cout << z << std::endl;
           }
           catch (const char* msg) {
           // non-empty catch body and return error
           std::cout << \"division exception\" << std::endl;
           return 1;
           }
           return 0;
          }
  language: c++,java
  likelihood: P
  master_id: 23
  msg_templ: 在${si.filename}，${si.func}里第${si.line}行的catch块是空的。
  name: 空的异常catch块
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: L
  standards:
    cwe:
      - '223'
    owasp:
      - A3
      - A5
- alias: {}
  category: VUL
  code: FIO37-C
  cost: M
  csv_string:
    - F37C1
    - F37C0
  desc: 该程序正调用fgets()或fgetws()，并假定返回的字符串为非空字符串。
  details: |
    #### 概要
    该程序正调用fgets()或fgetws()，并假定返回的字符串为非空字符串。

    #### 解释
    fgets()和fgetws()这两个函数可能返回空字符串（例如，文件可能为二进制文件）。
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>

          #define BUF_SZ 1024

          void read_string(void)
          {
           char buf[BUF_SZ];
           FILE *fp = fopen("/myfile", "+r");
           // check fp valid
           // ...

           if (fgets(buf, BUF_SZ, fp) != 0) {
           // if the first character of buf is '\\0', a random meaningless large number will be printed
           printf("Size of string read = %d", strlen(buf)-1);
           }

          }
    good:
      c:
        - |-
          #include <stdio.h>

          #define BUF_SZ 1024

          void read_string(void)
          {
           char buf[BUF_SZ];
           FILE *fp = fopen("/myfile", "+r");
           // check fp valid
           // ...

           if (fgets(buf, BUF_SZ, fp) != 0) {
           // replace newline character if it is there
           char *pchar = strchr(buf, '');
           if (pchar) *pchar = '\\0';

           printf("Size of string read = %d", strlen(buf)-1);
           }

          }
  language: c,c++
  likelihood: P
  master_id: 24
  msg_templ: 在${si.filename}，第${si.line}行的函数${si.func}可能会返回空字符串。
  name: fgets()和fgetws()可能返回空字符串
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '119'
      - '241'
- alias: {}
  category: VUL
  code: MSC32-C
  cost: L
  csv_string:
    - M32C1
    - M32C0
  desc: 该程序正使用有播种（初始状态）的伪随机数生成器，这会产生确定性的数字序列。
  details: >
    #### 概要

    该程序正使用有播种（初始状态）的伪随机数生成器，这会产生确定的数字序列。


    #### 解释

    适当生成种子的PRNG在每次运行时都会生成不同的数字序列（例如，在调用random函数前调用srandom()），这能阻止潜在的攻击者预测生成的数字序列攻击。或者也可以使用不能生成种子的随机数生成器来阻止潜在的攻击。
  examples:
    bad:
      c:
        - |+
          #include <stdio.h>
          #include <stdlib.h>

          // this function calls random() without proper seeding it
          // output of this function will be the same each time it is called
          void print_rand(void)
          {
              for (int i = 0; i < 20; i++)
              {
                  printf("%lx \n", random());
              }
          }



    good:
      c:
        - |
          #include <stdio.h>
          #include <stdlib.h>

          // function calls random() with proper seeding
          void print_rand(void)
          {
              srandom(time(NULL));
              for (int i = 0; i < 20; i++)
              {
                  printf("%lx \n", random());
              }
          }
  language: c,c++
  likelihood: L
  master_id: 25
  msg_templ: 在${si.filename}，第${si.line}行的函数${si.func}里，正在调用变量${si.var}。该产生器会生成确定性的序列。
  name: 请在使用伪随机数生成器前为其生成种子
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '522'
      - '327'
    owasp:
      - A2
      - A3
- alias: {}
  category: VUL
  code: ENV32-C
  cost: M
  csv_string:
    - N32C0
  desc: 该程序正使用某个未正常返回的退出处理程序。
  details: >
    #### 概要

    该程序正使用某个未正常返回的退出处理程序。


    #### 解释

    以下三个函数_Exit()、exit()、quick_exit()是C的标准退出函数。exit()和quick_exit()会因为清理目的分别调用退出处理程序atexit()和at_quick_exit()，_Exit()则不会。用户可以定义其自有的处理程序并在系统提供的处理程序注册。这些退出处理程序必须正常返回，这样才能适当地执行所有退出处理程序（从而执行所有清理任务）。此外，所有退出处理程序均不应调用exit()。
  examples:
    bad:
      c:
        - |-
          #include <stdlib.h>
          #include <stdio.h>

          extern int file_opened;

          int my_exit1(void)
          {
           // some clean up code for opened file
           fprintf(stderr, "abnormal exit from my_exit1() with file closed\\");
           exit(0); // this exit handler does not return normally. exit() is called the second time when value of file_opened is 1.
          }

          int my_exit2(void)
          {
           if (file_opened == 1) {
           my_exit1();
           }
           fprintf(stderr, "abnormal exit with errno %d", errno());
           // other cleanup code
           // if file_opened is 1, the clean up code here will not be executed
           // ...
           return 1;

          }

          int main() {
           // ...
           if (atexit(my_exit2) != 0) {
           // handle error
           }
          }
           return 0;
          }
    good:
      c:
        - |-
          #include <stdlib.h>
          #include <stdio.h>

          static int file_opened;

          void my_exit1(void)
          {
           // some clean up code for opened file
           fprintf(stderr, "abnormal exit from my_exit1() with file closed\\");
           exit(0); // this exit handler does not return normally. exit() is called the second time when value of file_opened is 1.
          }

          void my_exit2(void)
          {
           if (file_opened == 1) {
           my_exit1();
           }
           fprintf(stderr, "abnormal exit with errno %d", errno());
           // other cleanup code
           // if file_opened is 1, the clean up code here will not be executed
           // ...
           return;

          }

          int main() {
           // ...
           file_opened = 1;
           if (atexit(my_exit2) != 0) {
           // handle error
           }
          }
           return 0;
          }
  language: c,c++
  likelihood: L
  master_id: 26
  msg_templ: 在${si.filename}，第${si.line}行的函数${si.func}被注册为退出处理程序。该程序会退出，且不会正常返回。
  name: 退出处理程序必须正常返回
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards: {}
- alias: {}
  category: VUL
  code: ENV33-C
  cost: M
  csv_string:
    - N33C3
    - N33C2
    - N33C1
    - N33C0
  desc: 该程序正调用C标准system()函数。如果保护不当，可能会导致多种攻击。
  details: >+
    #### 概要

    该程序正调用C标准system()函数。如果保护不当，可能会导致多种攻击。


    #### 解释

    该程序正调用有字符串参数的system()函数。必须适当地保护此类字符串，例如清理过的字符串、规范化的路径等等。未能这么做将导致程序的任意执行、权限提升或其它不可预测行为。

  examples:
    bad:
      c:
        - |-
          void func_call_sys(const char *in)
          {
           // system() is called with a string \"in\" passed from outside of this function
           // There is no evidence that \"in\" has been sanitized
           // for example, if \"in\" is the string \"rm *\"
           // executing the system() call could be devastating
           system(in);
          }
    good:
      c:
        - |-
          void func_call_sys(const char *in)
          {
           // system() is called with a string \"in\" passed from outside of this function
           // There is no evidence that \"in\" has been sanitized
           // Sanitize input to system()
           // use full path name for directory for example
           sanitise(in); // e.g. for file or directory name, do not include \"../\" substring
           system(in);
          }
  language: c,c++
  likelihood: P
  master_id: 27
  msg_templ: 在${si.filename}，函数${si.func}里的第${si.line}行，system()有未经清理的输入参数。
  name: 请注意对system()的直接调用
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '88'
      - '77'
      - '78'
      - '917'
- alias: {}
  category: VUL
  code: ERR33-C
  cost: M
  csv_string:
    - E33C0
  desc: 该程序正调用标准库函数，但未能检查并处理函数的错误返回。
  details: >
    #### 概要

    该程序正调用标准库函数，但未能检查并处理函数的错误返回。


    #### 解释

    该程序正调用标准库函数。这些函数通常返回一个有效值，或某种形式的值以表示有错误发生。未能检查调用是成功还是失败可能造成意外或未定义行为。请参考语言或系统规范，以获得对标准接口的完整描述。请注意有一些系统函数，不需要对其返回值进行检查。您也可以在系统或语言规范里找到这些函数的列表，一些经常被使用的函数是printf、vprintf、memcpy、memmove、strcpy、strcat、memset（以及其宽字符版本）。
  examples:
    bad:
      c:
        - |-
          #include <stdlib.h>
          #include <string.h>

          typedef struct {
           int len;
           int *data;
          } vec_rec, *vec_rec_ptr;

          enum { VEC_SZ = 32 };

          vec_rec vr[VEC_SZ] = { 0 }; // initialize table content
          vec_rec_ptr func_call_stdlib(int len, vec_rec_ptr in_vec)
          {
           vec_rec_ptr vrp = (vec_rec_ptr)(malloc(sizeof(vec_rec) * len));
           // vrp may be NULL if malloc failed
           // this code did not check that vrp may be invalid

           // this memcpy may enable an attacker to access memory causing remote code execution
           memcpy(vrp, in_vec, len);

          }
    good:
      c:
        - |
          #include <stdlib.h>
          #include <string.h>

          typedef struct {
           int len;
           int *data;
          } vec_rec, *vec_rec_ptr;

          enum { VEC_SZ = 32 };

          vec_rec vr[VEC_SZ] = { 0 }; // initialize table content
          vec_rec_ptr func_call_stdlib(int len, vec_rec_ptr in_vec)
          {
           vec_rec_ptr vrp = (vec_rec_ptr)(malloc(sizeof(vec_rec) * len));

           // Checks if vrp is NULL, such as when malloc failed
           if (vrp == NULL) 
           {
            printf("Malloc has failed, the program will terminate.");
            return NULL;
           }

           // this memcpy may enable an attacker to access memory causing remote code execution
           memcpy(vrp, in_vec, len);

          }
  language: c,c++
  likelihood: L
  master_id: 28
  msg_templ: 在${si.filename}，第${si.line}行的${si.func}里，未检查系统库调用${si.var}的返回值。
  name: 请检查并处理标准库返回错误
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- alias: {}
  category: VUL
  code: FIO34-C
  cost: M
  csv_string:
    - F34C0
  desc: 该程序正使用文件读（例如getchar()、getc()、getwc()......）的返回值来核实EOF/WEOF为文件读操作的末尾。
  details: |
    #### 概要
    该程序正使用文件读（例如getchar()、getc()、getwc()......）的返回值来核实EOF/WEOF为文件读操作的末尾。

    #### 解释
    从文件中读取字符的函数会返回int类型。把读取的字符直接和EOF/WEOF比较可能导致意外结果，因为EOF和WEOF是以实现为准的。
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>

          void read_char(void)
          {
           FILE *fp = fopen("/tmp/myfile", "+r");
           // check fp valid
           // ...

           int c = getc(fp);
           while (c != EOF) // this check does not guarantee read has reached end of file
           {
           putchar(c); // echo what is read in
           c = getc(fp);
           }
          }
    good:
      c:
        - "#include <stdio.h>\n\nvoid read_char(void)\n{\n\tFILE *fp = fopen(\"/tmp/myfile\", \"+r\");\n\t// check fp valid\n\t// ...\n\t\n\tint c = getc(fp);\n\t\n\t// make sure it is really an EOF character and that the EOF is due to end-of-file\n\t\n\twhile (c != EOF || (feof(stdin) && !ferror(stdin)) \n\t{\n\tputchar(c); // echo what is read in\n\tc = getc(fp);\n\t}\n}"
  language: c,c++
  likelihood: P
  master_id: 29
  msg_templ: 在${si.filename}第${si.line}行上的函数${si.func}正使用文件读的返回值来核实EOF。
  name: 作为"char"大小对象的EOF和WEOF与从文件里读取的字符不一
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '197'
    owasp:
      - A1
- alias: {}
  category: VUL
  code: FIO42-C
  cost: M
  csv_string:
    - F42C2
    - F42C1
    - F42C0
  desc: 该程序打开了文件但未能在使用完文件后或程序终止前关闭该文件。
  details: |
    #### 概要
    该程序打开了文件但未能在使用完文件后或程序终止前关闭该文件。

    #### 解释
    当不再需要文件时就关闭它是很重要的。未能这么做可能会把与文件相关的资源（例如缓存数据）暴露给攻击者。
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>

          int open_file(const char *fname)
          {
           FILE *fp = fopen(fname, "+r");
           if (fp == NULL) return -1;

           // program continues
           return 0; // file is not properly closed on return

          }
    good:
      c:
        - |-
          #include <stdio.h>

          int open_file(const char *fname)
          {
           FILE *fp = fopen(fname, "+r");
           if (fp == NULL) return -1;

           // program continues

           if (fclose(fp) == EOF) {
           // handle error
           ...
           }
           return 0; // file is properly closed on return

          }
  language: c,c++
  likelihood: U
  master_id: 30
  msg_templ: 在${si.filename}第${si.line}行上的函数${si.func}，文件${si.var}未经关闭。
  name: 请关闭使用完的文件
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '459'
      - '772'
      - '404'
    owasp:
      - A3
- alias: {}
  category: VUL
  code: FIO45-C
  cost: H
  csv_string:
    - F45C0
  desc: 竞态条件在访问文件（time of check，time of use）时可能发生，並需要避免。
  details: >
    #### 概要

    在访问文件（time of check，time of use）时竞态条件可能发生，这应该要避免。


    #### 解释

    在共享文件系统里，两个或多个进程可能访问同一个文件，从而导致竞态条件。攻击者可以在不同进程的两次访问之间更改文件，或用不同的文件代替该文件（符号或硬链接）。
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>
          #include <unistd.h>
          #include <sys/stat.h>
          #include <fcntl.h>

          // This example is modified from example in 
          // CERT-C FIO45 site
          int file_s1(char *p, char *q)
          {
              struct stat statBefore, statAfter;

              lstat("/tmp/x", &statBefore);
              // previous contents of file gets destroyed 
              // with "w" mode
              FILE *f = fopen("/tmp/x", "w");
              lstat("/tmp/x", &statAfter);
              if (statAfter.st_ino == statBefore.st_ino)
              {
                  if (f != NULL)
                      fwrite("HELLO!", 1, 5, f);
              }

              fclose(f);
              return 0;
          }
    good:
      c:
        - |-
          #include <stdio.h>
          #include <unistd.h>
          #include <sys/stat.h>
          #include <fcntl.h>

          int file_s1(char *p, char *q)
          {
              struct stat statBefore, statAfter;

              lstat("/tmp/x", &statBefore);
              
              // "x" mode will cause fopen() to fail
              // if the file exists.  
              // NOTE: Only works for C11 and above or
              // systems that support this feature
              FILE *f = fopen("/tmp/x", "wx");
              if (statAfter.st_ino == statBefore.st_ino)
              {
                  if (f != NULL)
                      fwrite("HELLO!", 1, 5, f);
              }

              fclose(f);
              return 0;
          }
  language: c,c++
  likelihood: P
  master_id: 31
  msg_templ: 在${si.filename}第${si.line}行的函数 ${si.func}，文件${si.var}有TOCTOU的漏洞。
  name: 文件访问可能有竞态条件，应该要避免
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    owasp:
      - A3
- alias: {}
  category: VUL
  code: MEM35-C
  cost: H
  csv_string:
    - m35C1
    - m35C0
  desc: 该程序使用了malloc函数家族来分配内存，该内存比程序所需的内存要小。
  details: |
    #### 概要
    该程序使用了malloc函数家族来分配内存，该内存比程序所需的内存要小。

    #### 解释
    对应malloc函数的大小参数的参数应有足够的范围来表示要存储的对象的大小。未能这么做将造成缓存溢出，从而导致意外程序行为。
  examples:
    bad:
      c:
        - |-
          #include <stdlib.h>

          typedef struct
          {
              size_t len;
              int *data;
          } vect_record, *vect_ptr;

          vect_record *vector_new(size_t len)
          {
              vect_record *vect;
              // size of pointer used to determine size of pointed-to object
              vect_ptr result = (vect_ptr)malloc(sizeof(vect));
              if (result == NULL)
              {
                  // handle error and return
                  return NULL;
              }

              // initialize vector
              result[0].len = 1;
              result[1].len = 2;
              // ...
              return result;
          }
    good:
      c:
        - |-
          #include <stdlib.h>

          typedef struct
          {
              size_t len;
              int *data;
          } vect_record, *vect_ptr;

          vect_record *vector_new(size_t len)
          {
              vect_record *vect;
              // dereferenced pointer type means correct amount 
              // of memory is allocated for the struct tm object
              vect_ptr result = (vect_ptr)malloc(sizeof(*vect));
              if (result == NULL)
              {
                  // handle error and return
                  return NULL;
              }

              // initialize vector
              result[0].len = 1;
              result[1].len = 2;
              // ...
              return result;
          }
  language: c,c++
  likelihood: P
  master_id: 32
  msg_templ: 在${si.filename}，第${si.line}行的${si.func}函数里，正访问位于分配的范围之外的内存。
  name: 请确保分配了足够的内存给对象
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    owasp:
      - A3
      - A1
- category: VUL
  code: MEM36-C
  cost: HIGH
  desc: 该程序使用了realloc()，它导致指针的对齐比内存重新分配前的对齐限制要小。
  details: >
    #### 概要

    该程序使用了realloc()，它导致指针的对齐比内存重新分配前的对齐限制要小。


    #### 解释

    realloc()会分配新内存并把之前分配的内存指针指向新的分配区域。如果之前分配的内存有更多对齐上的限制（例如，16byte），新指向的内存将不会满足这一限制，从而导致意外程序行为。
  examples:
    bad:
      c:
        - |-
          #include <stdlib.h>

          int *vector_calc(size_t vec_sz, int elements)
          {
           size_t align_vec = 1 << vec_sz;
           int *ptr_align;

           if ((ptr_align = (int *)aligned_alloc(align_vec, sizeof(int)*elements)) == NULL) {
           // handle error and return;
           // ...
           }

           // program continues
           // ...
           if ((ptr1 = (int *) realloc(ptr_align, sizeof(int)*elements * 2)) == NULL) {
           // handle error and return
           //...
           }

           // program continues
           // but ptr1 is not guaranteed to properly aligned with the vector objects previous allocated

           return ptr1;

          }
    good: {}
  language: c,c++
  likelihood: PROBABLE
  master_id: 33
  msg_templ: 在${si.filename}，第${si.line}行，函数${si.func}使用了realloc()。
  name: 调用realloc()可能会使得之前对齐的对象再次不一致
  severity: LOW
- alias: {}
  category: VUL
  code: MSC33-C
  cost: L
  csv_string:
    - M33C0
  desc: 该程序正调用asctime()函数，然而该函数的输入参数来自不受信任来源。
  details: |
    #### 概要
    该程序正调用asctime()函数，然而该函数的输入参数来自不受信任来源。

    #### 解释
    函数asctime()不验证其输入参数的值或范围。在试图打印到字符串时，对该函数返回结果的继续使用可能造成缓存溢出及其它安全违规。
  examples:
    bad:
      c:
        - |-
          #include <time.h>
          #include <stdio.h>

          void read_time(struct tm *time_info)
          {
              // does not check for invalid or potentially
              // unsanitised data
              char *time = asctime(time_info);
              printf("time is %s", time);
          }
    good:
      c:
        - |+
          #define __STDC_WANT_LIB_EXT1__ 1
          #include <time.h>
          #include <stdio.h>

          enum
          {
              max = 50
          };

          void read_time(struct tm *time_info)
          {   
              // checks for invalid data below and handles 
              // error if exists
              char buffer[max];
              if (asctime_s(buffer, max, &time_info))
              {
                  /* Handle error */
              }

              char *time = asctime(time_info);
              printf("time is %s", time);
          }
              


  language: c,c++
  likelihood: L
  master_id: 34
  msg_templ: >-
    在${si.filename}，第${si.line}行，函数asctime被调用并以变量${si.var}为参数。该变量${si.var}可能尚未经过清理。
  name: asctime()函数的使用必须传递所需的、有着有效范围的参数
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- alias: {}
  category: VUL
  code: MSC37-C
  cost: L
  csv_string:
    - M37C0
  desc: 该程序有一个执行路径，它可能不通过"return"语句就到达非void函数的退出点。
  details: >
    #### 概要

    该程序有一个执行路径，它可能不通过返回语句就到达非void函数的退出点。


    #### 解释

    当该程序在没有返回语句的执行路径上退出此函数时，返回值会是不确定的，从而导致意外程序行为。如果此函数恰好是\"main\"，或者如果它被标为有\"no-return\"属性，那么就没有问题。
  examples:
    bad:
      c:
        - |-
          #include <string.h>

          #define BUF_SZ 1024

          int has_char(const char *s)
          {
              if (s != NULL)
              {
                  int l = strlen(s);
                  int i;
                  for (i = 0; i < l; i++)
                  {
                      if (s[i] == 'c')
                          return i;
                  }
              }
              // missing return here, return value will be undefined
          }
    good:
      c:
        - |
          #include <string.h>
          #define BUF_SZ 1024
          int has_char(const char *s)
          {
              if (s != NULL)
              {
                  int l = strlen(s);
                  int i;
                  for (i = 0; i < l; i++)
                  {
                      if (s[i] == 'c')
                          return i;
                  }
              }
              // return statement ensures control never reaches end of
              // the function, returns -1 if no letter 'c'
              return -1;
          }
  language: c,c++
  likelihood: U
  master_id: 35
  msg_templ: 在${si.filename}第${si.line}行，声明了函数${si.func}的返回非void，但在没有返回语句的情况下已达到了函数末尾。
  name: 非void函数应始终通过返回语句退出该函数
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- alias: {}
  category: VUL
  code: POS30-C
  cost: M
  csv_string:
    - P30C1
    - P30C0
  desc: 该程序调用了readlink()函数，而写在缓存（第二个参数）上的字符数不足够容纳有效字符串。
  details: |
    #### 概要
    该程序调用了readlink()函数，而写在缓存（第二个参数）上的字符数不足够容纳有效字符串。

    #### 解释
    由readlink()写入的字符数可能会溢出第二个参数里指定的缓存。另外我们需要确保字符串末尾为空终止。
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>

          #define BUF_SZ 1024

          int func(char *env_str)
          {
              char buf[BUF_SZ];

              // if len is >= sizeof(buf), up till the last byte of buf is non-null
              ssize_t len = readlink("/usr/somedir/symlinkfile", buf, sizeof(buf));

              // len is outside of buf size range (i may be -1 or i >= sizeof(buf))
              buf[len] = '\0'; 
              return;
          }
    good:
      c:
        - |-
          #include <stdio.h>

          #define BUF_SZ 1024

          int func(char *env_str)
          {
              char buf[BUF_SZ];

              // if len is >= sizeof(buf), up till the last byte of buf is non-null
              ssize_t len = readlink("/usr/somedir/symlinkfile", buf, sizeof(buf)); 

              // case handled when len is an invalid value
              if (len >= sizeof(buf) || len == -1) {
                  // Handle Exception 
                  return;
              }

              buf[len] = '\0'; // len is always within buf size range
              return;
          }
  language: c,c++
  likelihood: P
  master_id: 36
  msg_templ: 在${si.filename}第${si.line}行，调用了函数readlink()并把其赋值给变量${si.var}。字符串读不一定是空终止。
  name: readlink()函数只会填满第二个参数里的缓存，但不包括空终止符
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '170'
    owasp:
      - A1
      - A7
- alias: {}
  category: VUL
  code: POS34-C
  cost: M
  csv_string:
    - P34C2
    - P34C1
    - P34C0
  desc: 该程序调用了putenv()，它有指向本地对象的参数。
  details: >
    #### 概要

    该程序调用了putenv()，它有指向本地对象的参数。


    #### 解释

    系统调用putenv()会保存参数（为指向预期字符串的指针）到环境数组。当该函数返回到调用者时，可能会重写带有环境字符串的本地对象。这会造成不可预测的程序行为。
  examples:
    bad:
      c:
        - |-
          #include <string.h>

          #define BUF_SZ 1024

          // TEST environment variable may take on unintended value

          int func(char *env_str)
          {
              char buf[BUF_SZ];
              // ...
              if (strlen(env_str) < BUF_SZ)
              {
                  strcpy(buf, env_str);
                  return putenv(buf);
              }
              else
              {
                  // handle error
                  // ...
              }
              return 0;
          }
    good:
      c:
        - |-
          #include <string.h>

          #define BUF_SZ 1024

          int func(char *env_str)
          {
              // use a static array so that call to putenv() is 
              // only necessary the first time func() is called
              static char buf[BUF_SZ];
              // ...
              if (strlen(env_str) < BUF_SZ)
              {
                  strcpy(buf, env_str);
                  return putenv(buf);
              }
              else
              {
                  // handle error
                  // ...
              }
              return 0;
          }
  language: c,c++
  likelihood: U
  master_id: 37
  msg_templ: 在${si.filename}，第${si.line}行的函数${si.func}正用变量${si.var}作为参数调用系统函数putenv()。
  name: putenv()调用的指针参数不应指向本地对象
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '252'
      - '253'
      - '391'
    owasp:
      - A2
      - A3
      - A5
- alias: {}
  category: VUL
  code: POS35-C
  cost: M
  csv_string:
    - P35C0
  desc: 该程序调用了函数lstat()来检查命名文件是否为符号链接。之后若再此访问该文件，之前检查的结果可能无效。
  details: >
    #### 概要

    该程序调用了函数lstat()来检查命名文件是否为符号链接。之后若再此访问该文件，之前检查的结果可能无效。


    #### 解释

    检查文件是符号链接会遇到time of call、time of
    use（TOCTOU）问题。换句话说，当最终打开文件访问时，为符号链接状态的该文件可能已经不再有效。
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>
          #include <stdlib.h>
          #include <sys/stat.h>

          #define BUF_SZ 1024

          struct stat link_info;
          int val;

          int func(char *fname)
          {
              FILE *fp;
              if (lstat(fname, &link_info) == -1)
              {
                  // handle error
                  // ...
                  printf("lstat return error");
                  return 0;
              }
              else if (S_ISLNK(link_info.st_mode))
              {

                  // both fopen and lstat operate on a file name
                  // the name can be manipulated asynchronously such that
                  // lstat and fopen referred to different files in reality
                  fp = fopen(fname, "O_RDWR"); 
                  if (fp == 0)
                  {
                      // handle error
                      return 0;
                  }

                  size_t i = fread(&val, sizeof(int), 1, fp);
                  // ...
              }
              return 1;
          }
    good:
      c:
        - |-
          #include <stdio.h>
          #include <stdlib.h>
          #include <sys/stat.h>

          #define BUF_SZ 1024

          struct stat link_info;
          int val;

          int func(char *fname)
          {
              FILE *fp;
              // Race condition eliminated by using O_NOFOLLOW 
              // to cause open() to fail if passed a symbolic link
              int fd = open(fp, "O_RDWR"|"O_NOFOLLOW");
              if (fd == -1)
              {
                  /* Handle error */
                  return 0;
              }

              return 1;
          }
  language: c,c++
  likelihood: L
  master_id: 38
  msg_templ: 在${si.filename}，第${si.line}行的函数${si.func}调用了函数lstat()来检查命名文件是否为符号链接。
  name: 在检查符号链接的有效性时，可能会出现竞态条件，它可能会使经过检查的结果无效
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '363'
    owasp:
      - A3
- alias: {}
  category: VUL
  code: POS37-C
  cost: M
  csv_string:
    - P37C2
    - P37C1
    - P37C0
  desc: 该程序有一组get/set uid/euid函数，它对用户ID权限进行操作。调用此类函数的结果并未受到检查，这将导致该程序的权限处于意外状态。
  details: |
    #### 概要
    该程序有一组get/set uid/euid函数，它对用户id权限进行操作。调用此类函数的结果并未受到检查，这将导致该程序的权限处于意外状态。

    #### 解释
    权限能力是以实现为准的。要确保按预期设置及撤回权限，检查返回时的错误条件是很重要的。未能这么做可能导致用根权限运行该程序。
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>
          #include <unistd.h>

          void func()
          {
              // Permanently drop privileges
              if (setuid(getuid()) != 0) {
                  // Handle error
              }
              
              // Check for failure of privilege relinquishmnet has to be done here
              // Else, attacker can regain elevated privileges    
          }
    good:
      c:
        - |2-
           // ...

           // the following check alone is not sufficient. need to make sure privilege can be restored
           if (setuid(getuid()) != 0) {
           // Handle error
           }

           // check for failure to set uid when the caller is UID 0
           // failure to do this will result in a serious security risk
           if (setuid(0) != -1) {
           // privilege can be restored. Handle error
           }
  language: c,c++
  likelihood: L
  master_id: 39
  msg_templ: 在${si.filename}，第${si.line}行的函数${si.func}，尚未适当地恢复权限。
  name: 在通过set/set uid/euid函数操控系统权限时，请确保权限已成功撤回
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '273'
      - '299'
      - '200'
    owasp:
      - A2
- alias: {}
  category: VUL
  code: POS54-C
  cost: L
  csv_string:
    - P54C0
  desc: 该程序调用了某些POSIX库函数，但未能检查及处理返回错误条件。
  details: |
    #### 概要
    该程序调用了某些POSIX库函数，但未能检查及处理返回错误条件。

    #### 解释
    每一个POSIX库都有明确定义的错误返回。未能检查返回值以获得错误条件的标示并合理地处理错误将造成意外程序行为。
  examples:
    bad:
      c:
        - |-
          #include <sys/types.h>
          #include <sys/mman.h>
          #include <err.h>
          #include <fcntl.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <unistd.h>

          int main(void)
          {
              const char str1[] = "string 1";
              int fd = -1;
              void *rwrite;

              if ((fd = open("/usr/somefile", O_RDWR, 0)) == -1)
              {
                  err(1, "open");
              }

              rwrite = (char *)mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

              // rwrite may not be valid pointer since mmap may have failed
              strcpy(rwrite, str1);

              // ... continue
          }
    good:
      c:
        - |-
          #include <sys/types.h>
          #include <sys/mman.h>
          #include <err.h>
          #include <fcntl.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <unistd.h>

          int main(void)
          {
              const char str1[] = "string 1";
              int fd = -1;
              void *rwrite;

              if ((fd = open("/usr/somefile", O_RDWR, 0)) == -1)
              {
                  err(1, "open");
              }

              rwrite = (char *)mmap(NULL, 4096, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

              // checks if rwrite fails and handles error so that
              // strcpy() works properly below
              if (rwrite == NULL) 
              {
                  // Handle error
              }

              strcpy(rwrite, str1);

              // ... continue
          }
  language: c,c++
  likelihood: L
  master_id: 40
  msg_templ: 在${si.filename}，第${si.line}行的函数${si.func}调用了POSIX函数，调用结果被使用前并未检查该返回值是否有效。
  name: 当使用POSIX库时，请确保检测并恰当地处理函数返回的错误
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- alias: {}
  category: VUL
  code: SIG30-C
  cost: M
  csv_string:
    - G30C0
  desc: 该程序的信号处理函数正在调用非异步安全函数。
  details: >
    #### 概要

    该程序的信号处理函数正在调用非异步安全函数。


    #### 解释

    异步安全函数表是可以被信号处理函数安全调用而不会产生副作用的函数。非可重入函数通常是不安全的。用户可以检查您的系统用户手册以获得一份可以使用的所有安全函数的完整列表。
  examples:
    bad:
      c:
        - |
          #include <signal.h>
          #include <stdio.h>
          #include <stdlib.h>

          char *messg = NULL;
          int errflag;

          #define BUF_SZ 1024

          void put_messg(void)
          {
              fputs(messg, stderr);
          }

          void handler(int signum)
          {
              put_messg(); // this is not asynchronous safe
              free(messg); // this is not asynchronous safe
              errflag = 1;
          }

          int main(void)
          {
              if (signal(SIGINT, handler) == SIG_ERR)
              {
                  // handle error
              }
              messg = (char *)malloc(BUF_SZ);
              if (messg == 0)
              {
                  // handle error
              }

              if (!errflag)
              {
                  put_messg();
                  // ...
              }
              return 0;
          }
    good:
      c:
        - |
          #include <signal.h>
          #include <stdio.h>
          #include <stdlib.h>

          char *messg = NULL;
          // sets flag of type volatile
          volatile sig_atomic_t eflag = 0;
          int errflag;

          #define BUF_SZ 1024

          void put_messg(void)
          {
              fputs(messg, stderr);
          }

          void handler(int signum)
          {
              errflag = 1;
          }

          int main(void)
          {
              if (signal(SIGINT, handler) == SIG_ERR)
              {
                  // handle error
              }
              messg = (char *)malloc(BUF_SZ);
              if (messg == 0)
              {
                  // handle error
              }

              while (!errflag)
              {
                  put_messg();
                  // ...
              }

              // put_messg() and free() are directly called from main()
              put_messg();
              free(messg);
              messg = NULL;

              return 0;
          }
  language: c,c++
  likelihood: L
  master_id: 41
  msg_templ: >-
    在${si.filename}，第${si.line}行的函数${si.func}调用了signal程序。它的处理信号函数为${si.var}。此处理信号会调用非异步安全函数。
  name: 信号处理函数只能调用异步安全函数
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '479'
    owasp:
      - A1
- alias: {}
  category: VUL
  code: SIG31-C
  cost: H
  csv_string:
    - G31C1
    - G31C0
  desc: 该程序正在信号处理函数里访问共享变量或对象。
  details: |
    #### 概要
    该程序正在信号处理函数里访问共享变量或对象。

    #### 解释
    除了类型为\"volatile sig_atomic_t\"的变量外，在信号处理函数里访问任何其它类型的对象都可能导致竞态条件，从而造成未定义行为。
  examples:
    bad:
      c:
        - >-
          #include <signal.h>

          #include <stdlib.h>

          #include <sys/socket.h>


          char *messg = NULL;

          #define BUF_SZ 1024

          int sockfd; // as a simple example, we assume sockfd has been properly
          initialized and connected


          volatile sig_atomic_t errflag = 0;


          ssize_t put_messg(void)

          {
              ssize_t err = send(sockfd, (const void *)messg, BUF_SZ, MSG_DONTWAIT);
              return err;
          }


          void handler(int signum)

          {
              errflag = 1; // access shared variable inside handler
          }


          int main(void)

          {
              messg = (char *)malloc(1024);
              if (messg == 0)
              {
                  // handle error
              }

              if (signal(SIGINT, handler) == SIG_ERR)
              {
                  // handle error
              }

              if (!errflag)
              {
                  if (put_messg() >= 0)
                  {
                      // messg sent
                      // ...
                  }
                  else
                  {
                      // ...
                  }
              }
              return 0;
          }
    good:
      c:
        - >-
          #include <signal.h>

          #include <stdlib.h>

          #include <sys/socket.h>


          char *messg = NULL;

          #define BUF_SZ 1024

          int sockfd; // as a simple example, we assume sockfd has been properly
          initialized and connected


          int errflag; // this is a shared variable


          ssize_t put_messg(void)

          {
              ssize_t err = send(sockfd, (const void *)messg, BUF_SZ, MSG_DONTWAIT);
              return err;
          }


          void handler(int signum)

          {
              errflag = 1; // access shared variable inside handler
          }


          int main(void)

          {
              messg = (char *)malloc(1024);
              if (messg == 0)
              {
                  // handle error
              }

              if (signal(SIGINT, handler) == SIG_ERR)
              {
                  // handle error
              }

              if (!errflag)
              {
                  if (put_messg() >= 0)
                  {
                      // messg sent
                      // ...
                  }
                  else
                  {
                      // ...
                  }
              }
              return 0;
          }
  language: c,c++
  likelihood: L
  master_id: 42
  msg_templ: >-
    在${si.filename}，第${si.line}行的函数${si.func}，用处理函数${si.var}对信号进行了调用。该处理函数最终会访问可共享的内存对象。
  name: 访问共享变量或对象的信号处理函数可能会导致竞态条件
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '662'
      - '828'
- alias: {}
  category: VUL
  code: STR02-C
  cost: M
  csv_string:
    - S02C2
    - S02C1
    - S0200
  desc: 该程序正传递字符串数据给外部包或子系统，这些作为字符串的数据需进行安全清理
  details: |
    #### 概要
    该程序正传递字符串数据给外部包或子系统，这些作为字符串的数据需进行安全清理。

    #### 解释
    当传递包含敏感数据的数据给系统调用、数据库或其它外部第三方组件时，确保只传递产生者和使用者双方都认可的数据是很重要的。
  examples:
    bad:
      c:
        - |-
          #include <stdlib.h>
          #include <stdio.h>

          char *messg = NULL;
          #define BUF_SZ 1024

          void foo(char *argv)
          {
              int len;
              char buf[BUF_SZ];

              if (*argv != 0)
                  len = snprintf(buf, BUF_SZ, "%s", *argv); // buf will be fed into system call later. \"argv\" needs to be sanitized
              if (len < 0)
              {
                  // report error
                  return;
              }
              else
              {
                  if (system(buf) == -1)
                  {
                      // report error
                      return;
                  }
              }
          }
    good:
      c:
        - |
          #include <stdlib.h>
          #include <stdio.h>

          char *messg = NULL;
          #define BUF_SZ 1024

          void foo(char *argv)
          {
              int len;
              char buf[BUF_SZ];


              // filter out invalid data and characters
              static char approved[] = "abcdefghijklmnopqrstuvwxyz"
                                       "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                                       "1234567890_-.@";
              const char *end = *argv + strlen(*argv);
              for (argv += strspn(argv, approved); argv != end; argv += strspn(argv, approved))
              {
                  *argv = '_';
              }

              if (*argv != 0)
                  len = snprintf(buf, BUF_SZ, "%s", *argv); 
              if (len < 0)
              {
                  // report error
                  return;
              }
              else
              {
                  if (system(buf) == -1)
                  {
                      // report error
                      return;
                  }
              }
          }
  language: c,c++
  likelihood: L
  master_id: 43
  msg_templ: >-
    在${si.filename}，第${si.line)行的函数${si.func}，传递了${si.var}给系统调用。该变量已被声明，在程序流里被认为没有经过清理。
  name: 传递给外部包或子系统的数据应该先安全化清理
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '88'
      - '78'
      - '917'
    owasp:
      - A3
      - A1
- alias: {}
  category: VUL
  code: STR31-C
  cost: M
  csv_string:
    - S31C4
    - S31C3
    - S31C2
    - S31C1
    - S31C0
  desc: 请确保字符串的目的地存储空间足够大，能包括空终止。
  details: |
    #### 概要
    请确保字符串的目的地存储空间足够大，能包括空终止。

    #### 解释
    字符串由空字符终止，它应该是字符串大小/长度的一部分。如果字符串的存储空间不够大，这将造成缓存溢出或其它伪错误。
  examples:
    bad:
      c:
        - |-
          #include <stdlib.h>
          #include <string.h>
          #include <stdio.h>

          void get_passwd(void)
          {
              char buf[256];
              char *passwd = getenv("PASSWORD");
              if (passwd == NULL)
              {
                  printf("Error getting password");
                  exit(1);
              }
              //
              // copy environmental string to a fixed-length can cause buffer overflow
              //
              strcpy(buf, passwd);
          }
    good:
      c:
        - |+
          #include <stdlib.h>
          #include <string.h>
          #include <stdio.h>

          void get_passwd(void)
          {
              // length is not fixed, so no buffer overflow
              
              char *buf;
              char *passwd = getenv("PASSWORD");
              if (passwd == NULL)
              {
                  printf("Error getting password");
                  exit(1);
              }

              size_t length = strlen(passwd) + 1;
              buf = (char *)malloc(length);
              if (buf == NULL)
              {
                  // handle error
              }

              memcpy(buf, passwd, length);
              free(buf);
          }

  language: c,c++
  likelihood: L
  master_id: 44
  msg_templ: >-
    在${si.filename}，第${si.line}行的函数${si.func}，指向字符的指针${si.var}用来填充另一个字符数组/指针。指针${si.var}
    的大小不足以存储包含空终止在内的所有数据，可能会导致内存访问错误
  name: 字符串应有足够的存储空间以便能放下包括空终止符在内的所有字符
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '122'
      - '767'
      - '787'
      - '125'
      - '119'
    owasp:
      - A3
      - A1
- alias: {}
  category: VUL
  code: STR32-C
  cost: M
  csv_string:
    - S32C4
    - S32C3
    - S32C2
    - S32C1
    - S32C0
  desc: 该程序正调用有字符串参数的库函数。该字符串可能没有被适当地终止。
  details: |
    #### 概要
    该程序正调用有字符串参数的库函数。该字符串可能没有被适当地终止。

    #### 解释
    在非空终止的字符串上操作的库函数会造成访问在字符串对象界限之外的内存。这进而会造成意外程序行为。
  examples:
    bad:
      c:
        - |-
          #include <stdlib.h>
          #include <stdio.h>

          char *messg = NULL;
          #define BUF_SZ 3

          void foo(void)
          {
              char buf[BUF_SZ] = "123";

              printf("string is %s", buf); // buf may not be null terminated since the array is a local array

              // ...
          }
    good:
      c:
        - |-
          #include <stdlib.h>
          #include <stdio.h>

          char *messg = NULL;
          #define BUF_SZ 3

          void foo(void)
          {
              char buf[] = "123";

              printf("string is %s", buf); 

              // ...
          }
  language: c,c++
  likelihood: P
  master_id: 45
  msg_templ: 在${si.filename}，第${si.line}行的函数${si.func}，传递了变量${si.var}给库函数。该变量不是空终止。
  name: 应合理终止库函数的字符串参数
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '119'
      - '125'
      - '123'
      - '170'
      - '787'
    owasp:
      - A3
      - A1
- alias: {}
  category: VUL
  code: STR38-C
  cost: L
  csv_string:
    - S38C0
  desc: 该程序正在使用函数，并在使用字符大小或类型不匹配的参数来表示字符串的字符大小。
  details: |
    #### 概要
    该程序正在使用函数，并在使用字符大小或类型不匹配的参数来表示字符串的字符大小。

    #### 解释
    该程序正传递指向对象的指针和大小参数给库函数。当这两个参数组合在一起时，会造成库函数在该对象的有效范围之外访问它，从而导致未定义行为。
  examples:
    bad:
      c:
        - |-
          #include <stddef.h>
          #include <stdlib.h>
          #include <wchar.h>

          #define ARRAY_SZ 2
          int mismatch_char_type()
          {
              char char_array[] = "0123456789";
              wchar_t wchar_array[] = "0123456789";

              // size of char_array is smaller than wchar_array due to different char type
              memcpy(&char_array[0], &wchar_array[0], sizeof(wchar_array));
              return 0;
          }
    good:
      c:
        - |-
          #include <stddef.h>
          #include <stdlib.h>
          #include <wchar.h>

          #define ARRAY_SZ 2
          int mismatch_char_type()
          {
              char char_array[] = "0123456789";
              char char_array_2[] = "0123456789";

              // char type is the same, so comparing is acceptable
              strncpy(&char_array[0], &char_array[2], sizeof(char_array));
              return 0;
          }
  language: c,c++
  likelihood: L
  master_id: 46
  msg_templ: 在${si.filename}的第${si.line}行，变量${si.var}错误地被函数${si.func}使用。
  name: 窄和宽字符串以及函数应有合适的空终止符和长度的类型
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- alias: {}
  category: VUL
  code: STR50-CPP
  cost: M
  csv_string:
    - S50P0
  desc: 程序使用了不适当的字符串方法来处理字符，这可能导致绕过验证检查或内存泄漏。
  details: >
    #### 概要

    该程序正在使用不正确的字符串方法来处理字符，这有可能会导致绕过验证或者内存泄漏。


    #### 解释

    在C或者C++中创建字符串时，必须定义字符串的最大长度。在进行变量输入时（例如通过控制台输入），如果输入的字符长度超过了变量允许的范围，这会引发缓冲区溢出，导致程式受到攻击的风险。
  examples:
    bad:
      cpp:
        - |-
          #include <string>
          #include <iostream>
          void f(){
          char x[5];
          std::cin>>x;
          }
    good:
      cpp:
        - |-
          void f(){
          std:;string x;
          std::cin >> x;
          }
  language: c++
  likelihood: L
  master_id: 47
  msg_templ: 在${si.filename}的第${si.line}行，直接将数据复制到内存可能会引发缓冲区溢出。
  name: 确保字符串存储足以储存内容
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- category: VUL
  code: ERR54-CPP
  cost: LOW
  desc: 在try语句之后，程序无法按正确的顺序处理异常捕获处理程序。当前顺序是从最小派生（更一般）到最大派生（更具体），因此最大派生的捕获处理程序将不会被执行。
  details: |
    #### 概要
    在try语句之后，程序无法按正确的顺序管理异常捕获处理程序。 当前顺序是从最小派生（更一般）到最大派生（更具体）。
     
    #### 解释
    捕获处理程序按照try语句后的声明顺序进行。正确的顺序应该是从最大派生到最小派生，从最具体到不具体。
    如果捕获是从最小派生开始，而它可能从最大派生处中捕获到的问题。这样，最大派生的捕获处理程序将不会被执行，这种行为是不可取的。
  examples:
    bad:
      cpp:
        - |-
          // Classes used for exception handling
          #include <iostream>
           
          class Base {};
           
          class Derived1 : public Base {};
          class Derived2 : public Derived1 {};
           
          void foo();
          void bar();
           
          void foo()
          {
           std::cout << "foo" << std::endl;
          }
          void bar()
          {
           std::cout << "bar" << std::endl;
          }
           
          void f()
          {
           try {
           foo();
           bar();
           // ...
           }
           catch (Base &) {
           // ...
           }
           catch (Derived1 &) { // violation here in Line 19
           // ...
           }
           try {
           foo();
           bar();
           // ...
           }
           catch (Base &) {
           // ...
           }
           catch (Derived2 &) // violation here in Line 31
           {
           // ...
           }
           
           try {
           foo();
           bar();
           // ...
           }
           catch (Base *) {
           // ...
           }
           catch (Derived1 *) { // violation here in Line 44
           // ...
           }
          }
           
          int main() {
           f();
          }
    good:
      cpp:
        - |-
          // Classes used for exception handling
          #include <iostream>
           
          class Base {};
           
          class Derived1 : public Base {};
          class Derived2 : public Derived1 {};
           
          void foo();
          void bar();
           
          void foo()
          {
           std::cout << "foo" << std::endl;
          }
          void bar() {
           std::cout << "bar" << std::endl;
          }
           
          void f()
          {
           try {
           foo();
           bar();
           // ...
           }
           catch (Derived1 &) {
           // ...
           }
           catch (Base &)
           {
           // ...
           }
           try {
           foo();
           bar();
           // ...
           }
           catch (Derived2 &) {
           // ...
           }
           catch (Base &) //
           {
           // ...
           }
           
           try {
           foo();
           bar();
           // ...
           }
           catch (Derived1 *) {
           // ...
           }
           catch (Base *) { //
           // ...
           }
          }
           
          int main() {
           f();
          }
  language: c++
  likelihood: LIKELY
  master_id: 48
  msg_templ: 在${si.filename}，第${si.line}行，${si.func} 里，异常捕获程序的顺序不正确。
  name: catch处理程序的顺序应为从最具体到最不具体
  severity: MEDIUM
- alias: {}
  category: VUL
  code: MEM55-CPP
  cost: M
  csv_string:
    - m55P0
  desc: 该程序替换使用了不符合C++标准语义规范的动态内存分配或释放函数。
  details: >
    #### 概要

    该程序替换使用了不符合C++标准语义规范的动态内存分配或释放函数。


    #### 解释

    内存分配的替换函数包含一个外部声明，该声明可能返回nullptr。 函数 \"new \" 将返回nullptr，而不是本该返回的 \"std ::
    bad_alloc \"。
  examples:
    bad:
      cpp:
        - |-
          #include <cstdio>
          #include <cstdlib>
          #include <new>
          #include <iostream>

          extern void* cust_allocator(std::size_t);

          class Person {
           int age; 
           std::string name;
           
          public:
           Person(){}
           void* operator new(size_t s)
           {
           return cust_allocator(s);
           }
          };
    good:
      cpp:
        - |-
          #include <cstdio>
          #include <cstdlib>
          #include <new>
          #include <iostream>

          extern void* cust_allocator(std::size_t);

          class Person {
           int age; 
           std::string name;
           
          public:
           Person(){}
           void* operator new(size_t s)
           {
           if (((void*) ret = cust_allocator) == 0)
           return ret;
           return cust_allocator(s);
           }
          };
  language: c++
  likelihood: L
  master_id: 49
  msg_templ: 在${si.filename}，第${si.line}行，${si.func} 里，动态内存分配/释放的替代函数违反了C++标准的语义规范。
  name: 用户定义的动态存储管理应遵循语言要求
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- alias: {}
  category: VUL
  code: MSC51-CPP
  cost: L
  csv_string:
    - M51P0
  desc: 程序没有正确地为伪随机数生成器设定种子。它使用了一个常量种子，或可预测的非常量种子（如时间）。
  details: |+
    #### 概要
    程序没有正确地为伪随机数生成器设定种子。它使用了一个常量种子，或可预测的种子, 使用后会反复产生相同的数字序列。

    #### 解释
    当调用具有相同初始状态的伪随机数生成器（PRNG）时，例如使用相同的种子，它将生成完全相同的数字序列。攻击者可以很容易地预测数字序列并引发安全问题。


  examples:
    bad:
      cpp:
        - |-
          #include <stdlib.h>
          #include <iostream>
          #include <vector>

          #define MAX_VALUE 100
          #define VECTOR_SIZE 10
          int main()
          { 
           std::vector<int> vec;
           
           for(int i = 0 ; i < VECTOR_SIZE; ++i) {
           vec.push_back(rand()%MAX_VALUE); // using the same initial seed 
           }

           // printing
           for(int j=0 ; j < vec.size() ; ++j ) {
           std::cout << vec[j] << \" \";
           }
           std::cout << '\
          ';
          }
    good:
      cpp:
        - |-
          #include <stdlib.h>
          #include <iostream>
          #include <vector>

          #define MAX_VALUE 100
          #define VECTOR_SIZE 10

          int main() 
          {
           std::vector<int> vec;
           std::random_device rd;

           srand(rd()); // seed is randomized again for every execution
           for(int i = 0 ; i < VECTOR_SIZE; ++i) {
           vec.push_back(rand()%MAX_VALUE); // no repeated sequence 
           }

           for(int j=0 ; j < vec.size() ; ++j ) {
           std::cout << vec[j] << \" \";
           }
           std::cout << '\
          ';
          }
  language: c++
  likelihood: L
  master_id: 50
  msg_templ: >-
    在${si.filename}，第${si.line}行，${si.func}
    里，使用了未正确设定种子的伪随机数发生器，该种子是常量或者可预测的非常量。
  name: 应正确设置随机数生成器的种子
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards: {}
- alias: {}
  category: VUL
  code: MSC54-CPP
  cost: H
  csv_string:
    - M54P0
  desc: 程序中的信号处理函数不是一个普通的传统函数(POF)。这个特定的信号处理函数使用无C链接的纯C++链接。
  details: >+
    #### 概要

    程序中的信号处理程序函数不是普通的传统函数。 特定的信号处理函数使用纯C++ 链接，而没有与C的链接。


    #### 解释

    POF或“普通的传统函数”是在C和C
    ++语言公共子集上使用功能的函数。在C++源代码中声明的所有信号处理程序都必须具有C链接，否则可能导致未定义的行为。

  examples:
    bad:
      cpp:
        - |-
          #include <iostream>
          #include <csignal>
          using namespace std;



          void handle_signal(int signum) 
          {
           cout << \"Signal to interrupt \" << signum << endl;
           exit(signum);
          }

          int main() 
          {
           signal(SIGINT, handle_signal);
           // ....

          }
    good:
      cpp:
        - |-
          #include <iostream>
          #include <csignal>
          using namespace std;

          // use C signature
          extern \"C\" void handle_signal(int signum)
          {
           cout << \"Signal to interrupt \" << signum << endl;
           exit(signum);
          }

          int main() 
          {
           signal(SIGINT, handle_signal);
           // ....

          }
  language: c++
  likelihood: P
  master_id: 51
  msg_templ: 在${si.filename}，第${si.line}行，${si.func}，它不是一个POF（普通的传统函数），尽管它展现出信号处理的行为。
  name: 确保信号处理程序是普通的传统函数
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- alias: {}
  category: VUL
  code: IDS16-J
  cost: M
  csv_string:
    - I16J1
    - I16J0
  desc: 该程序正在没有验证字符串的情况下操作用于XML处理的XMLStrings。
  details: |
    #### 概要
    该程序正在没有验证字符串的情况下操作用于XML处理的XMLString对象。

    #### 解释
    当XMLString对象没有经过清理时，可能会恶意注入XML字符串并将其错认为有效的XML，从而导致XML注入攻击。
  examples:
    bad:
      java:
        - |
          import java.io.BufferedOutputStream;
          import java.io.ByteArrayOutputStream;
          import java.io.IOException;
           
          public class j_ids16_1 {
           public static void createXMLStreamBad(final BufferedOutputStream outStream,
           final String number) throws IOException {
           String xmlString = \"<item>\
          <description>Widget</description>\
          \"
           + \"<level>500</>\
          \";

           if (number != null) {
           // the string xmlString should be validated
           // to prevent XML injection
          \t xmlString = xmlString + \"<number>\" + number
           + \"</number></item>\";
           }
           outStream.write(xmlString.getBytes());
           outStream.flush();
           }
          }
    good:
      java:
        - |-
          import java.io.BufferedOutputStream;
          import java.io.ByteArrayOutputStream;
          import java.io.IOException;
           
          public class j_ids16_1 {
           public static void createXMLStreamBad(final BufferedOutputStream outStream,
           final String number) throws IOException {
           String xmlString = \"<item>\
          <description>Widget</description>\
          \"
           + \"<level>500</>\
          \";

           if (number != null) {
           int sanitizedNumber = Integer.parseUnsignedInt(number);
           // the string xmlString should be validated
           // to prevent XML injection
          \t xmlString = xmlString + \"<number>\" + sanitizedNumber
           + \"</number></item>\";
           }
           outStream.write(xmlString.getBytes());
           outStream.flush();
           }
          }
  language: Java
  likelihood: P
  master_id: 52
  msg_templ: 在${si.filename}，第${si.line}行，函数${si.func}的字符串${si.var}未被清理就被传递到XML查询。
  name: 用于XML处理的XMLStrings必须在处理之前通过验证
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '79'
      - '776'
    owasp:
      - A4
      - A1
    p3c-sec:
      - '4'
- alias: {}
  category: VUL
  code: MSC02-J
  cost: M
  csv_string:
    - M02J1
    - M02J0
  desc: 该程序使用了安全性不强的随机数生成器（PRNG）。
  details: >
    #### 概要

    该程序使用了安全性不强的随机数生成器（PRNG）。


    #### 解释

    Java
    API在java.util.Random类里提供PRNG，当使用了相同种子时它会生成相同的序列。对于安全敏感型程序，应该使用像java.security.SecureRandom类这样的更安全的PRNG。
  examples:
    bad:
      java:
        - |-
          // The Random() generates identical sequences in all three cases
          import java.util.Random;
          import java.lang.Math;

          public class msc02_0 {

           public void foo0() {
           Random number = new Random(123L);
           for (int i = 0; i < 20; i++) {
           int n = number.nextInt();
           System.out.println(n);
           }
           }

           public void foo1() {
           Random number = new Random();
           System.out.println(number.nextLong());
           }

          }
    good:
      java:
        - |-
          // The Random() generates identical sequences in the following cases
          import java.util.Random;
          import java.lang.Math;

          public class msc02_0 {

           public void foo0() {
           Random number = new SecureRandom(); // use SecureRandom class 
           for (int i = 0; i < 20; i++) {
           int n = number.nextInt();
           System.out.println(n);
           }
           }

           public void foo1() {
           Random number = new SecureRandom.getInstanceStrong(); // use strong algorithm 
           System.out.println(number.nextLong());
           }

          }
  language: Java
  likelihood: P
  master_id: 53
  msg_templ: 在${si.filename}，第${si.line}行，函数${si.func}中的${si.var}不会产生强随机数。
  name: 使用安全性强的随机数生成器
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '327'
    owasp:
      - A3
      - A5
- alias: {}
  category: VUL
  code: SEC07-J
  cost: L
  csv_string:
    - C07J0
  desc: 该程序有自定义类加载器，并未能调用super.getPermission()方法。
  details: >
    #### 概要

    该程序有自定义类加载器，并未能调用super.getPermission()方法。


    #### 解释

    该程序有自定义加载器来重写getPermission()方法。该实现应调用超类别的getPermission()以获得默认系统方案，然后再赋予程序自定义权限。这样一来，系统全局的安全方案也能得到应用。
  examples:
    bad:
      java:
        - |-
          import java.net.URL;
          import java.net.URLClassLoader;
          import java.security.CodeSource;
          import java.security.PermissionCollection;
          import java.security.Permissions;

          public class j_sec07_0 extends URLClassLoader { 

           public j_sec07_0(URL[] urls) {
           super(urls);
           }

           protected PermissionCollection getPermissions(CodeSource cs) {
           PermissionCollection pc = new Permissions();
           // Allow exit from the VM anytime
           pc.add(new RuntimePermission(\"exitVM\"));
           return pc;
           }

           public static boolean checkRtPermission(URL[] urls, String tag) {
           j_sec07_0 loader = new j_sec07_0(urls);
           PermissionCollection pc = loader.getPermissions(null);
           RuntimePermission rp = new RuntimePermission(tag);
           if(pc.implies(rp)) {
           System.out.println(\"Able to exit vm\");
           return true;
           } else {
           System.out.println(\"Not Able to exit VM\");
           return false;
           }
           }

           public static void main(String[] args) {
           URL[] urls = new URL[0];
           checkRtPermission(urls, \"exitVM\");
           checkRtPermission(urls, \"stopVM\");
           }

          }
    good:
      java:
        - |
          import java.net.URL;
          import java.net.URLClassLoader;
          import java.security.CodeSource;
          import java.security.PermissionCollection;
          import java.security.Permissions;

          public class j_sec07_0 extends URLClassLoader { 

           public j_sec07_0(URL[] urls) {
           super(urls);
           }

           protected PermissionCollection getPermissions(CodeSource cs) {
           // apply default system wide security policy
           PermissionCollection pc = superPermissions(cs);
           // Allow exit from the VM anytime
           pc.add(new RuntimePermission(\"exitVM\"));
           return pc;
           }

           public static boolean checkRtPermission(URL[] urls, String tag) {
           j_sec07_0 loader = new j_sec07_0(urls);
           PermissionCollection pc = loader.getPermissions(null);
           RuntimePermission rp = new RuntimePermission(tag);
           if(pc.implies(rp)) {
           System.out.println(\"Able to exit vm\");
           return true;
           } else {
           System.out.println(\"Not Able to exit VM\");
           return false;
           }
           }

           public static void main(String[] args) {
           URL[] urls = new URL[0];
           checkRtPermission(urls, \"exitVM\");
           checkRtPermission(urls, \"stopVM\");
           }

          }
  language: Java
  likelihood: P
  master_id: 54
  msg_templ: >-
    在${si.filename}，第${si.line}行，在函数${si.func}里，${si.var}自定义加载器覆盖getPermission()，而未调用超类别的权限。
  name: 请调用超类别的getPermissions()方法实现自定义类加载器
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    owasp:
      - A9
- alias: {}
  category: VUL
  code: DCL00-J
  cost: M
  csv_string:
    - D00J0
  desc: 程序具有类的初始化会构成循环。
  details: |
    #### 概要
    程序具有类的初始化会构成循环。

    #### 解释
    静态字段会触发类的初始化。当静态字段依赖于另一个类的初始化时，将构成一个循环。
  examples:
    bad:
      java:
        - |-
          import java.util.Calendar;
          public class j_dcl00_0 {
           private int elapse;
           private static final j_dcl00_0 obj = new j_dcl00_0(); // self cycle (call constructor)
           private static final int curr_year = Calendar.getInstance().get(Calendar.YEAR);
           
           public j_dcl00_0() {
           if(200 > Calendar.getInstance().get(Calendar.YEAR))
           elapse = curr_year - 2000; // curr_year not initialized yet, due to constructor is called before curr_year assignment in line 73. 
           // ( Remediate suggestion: swap lines 72 and line 73 will ensure initialized)
           }

           public static void main(String[] args) {
           System.out.println(\"It was \" + obj.elapse + \" years since 2000\");
           }
           
          }
    good:
      java:
        - |-
          import java.util.Calendar;
          public class j_dcl00_0 {
           private int elapse;
           private static final int curr_year = Calendar.getInstance().get(Calendar.YEAR);
           private static final j_dcl00_0 obj = new j_dcl00_0(); // curr_year is initialized before used in constructor
           
           public j_dcl00_0() {
           if(200 > Calendar.getInstance().get(Calendar.YEAR))
           elapse = curr_year - 2000; 
           }

           public static void main(String[] args) {
           System.out.println(\"It was \" + obj.elapse + \" years since 2000\");
           }
           
          }
  language: Java
  likelihood: U
  master_id: 55
  msg_templ: 在${si.filename}，第${si.line}行，${si.func}中的${si.var}类会构成初始化循环。
  name: 程序不应具有类初始化循环
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: L
  standards: {}
- alias: {}
  category: VUL
  code: ENV03-J
  cost: L
  csv_string:
    - N03J2
    - N03J1
    - N03J0
  desc: 程序用授予权限或者权限组合给代码。
  details: >
    #### 概要

    程序授予权限或者权限组合给代码，而这类操作可能存在风险。


    #### 解释

    权限组合授予代码可能是危险的。例如，当应用RunitimePermission到createClassLoader时，它会创建自定义类加载器并分配任意权限。ReflextPermission和suppressAccessChecks一起将阻止所有标准检查。
  examples:
    bad:
      java:
        - |-
          import java.net.URL;
          import java.net.URLClassLoader;
          import java.net.MalformedURLException;
          import java.security.cert.Certificate;
          import java.security.CodeSource;
          import java.security.PermissionCollection;
          import java.security.Permissions;
          import java.lang.reflect.*;

          public class env03_0 extends URLClassLoader {

           public env03_0(URL[] urls) {
           super(urls);
           }

           protected PermissionCollection getPermissions(CodeSource cs) {
           PermissionCollection pc = super.getPermissions(cs); 
           pc.add(new ReflectPermission("suppressAccessChecks")); // add permission to create a class loader
           // includes granting "suppressAccessChecks"
           // ...
           // other permissions
           return pc;
           }

           public static boolean checkRtPermission(URL[] urls, String tag) throws MalformedURLException{
           env03_0 loader = new env03_0(urls);
           Certificate[] cert = null;
           CodeSource cs = new CodeSource(new URL("http://abc"), cert);
           PermissionCollection pc = loader.getPermissions(cs);
           ReflectPermission rp = new ReflectPermission(tag);
           if(pc.implies(rp)) {
           System.out.println("Able to get suppressAccessChecks");
           return true;
           } else {
           System.out.println("Not Able to get suppressAccessChecks");
           return false;
           }
           }

           public static void main(String[] args) throws MalformedURLException{
           URL[] urls = new URL[0];
           checkRtPermission(urls, "suppressAccessChecks");
           }

          }
    good:
      java:
        - |
          import java.net.URL;
          import java.net.URLClassLoader;
          import java.net.MalformedURLException;
          import java.security.cert.Certificate;
          import java.security.CodeSource;
          import java.security.PermissionCollection;
          import java.security.Permissions;
          import java.lang.reflect.*;

          public class env03_0 extends URLClassLoader {

           public env03_0(URL[] urls) {
           super(urls);
           }

           protected PermissionCollection getPermissions(CodeSource cs) {
           PermissionCollection pc = super.getPermissions(cs);
           // ...
           // other permissions
           return pc;
           }

           public static boolean checkRtPermission(URL[] urls, String tag) throws MalformedURLException{
           env03_0 loader = new env03_0(urls);
           Certificate[] cert = null;
           CodeSource cs = new CodeSource(new URL("http://abc"), cert);
           PermissionCollection pc = loader.getPermissions(cs);
           ReflectPermission rp = new ReflectPermission(tag);
           if(pc.implies(rp)) {
           System.out.println("Able to get suppressAccessChecks");
           return true;
           } else {
           System.out.println("Not Able to get suppressAccessChecks");
           return false;
           }
           }

           public static void main(String[] args) throws MalformedURLException{
           URL[] urls = new URL[0];
           checkRtPermission(urls, "suppressAccessChecks");
           }

          }
  language: Java
  likelihood: L
  master_id: 56
  msg_templ: 在${si.filename}，第${si.line}行，${si.func}里的方法${si.var}有危险的权限组合，可以导致越权操作。
  name: 应明确并审慎地授予权限
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '287'
      - '732'
      - '862'
    owasp:
      - A2
      - A5
      - A6
- alias: {}
  category: VUL
  code: ENV06-J
  cost: L
  csv_string:
    - N06J2
    - N06J1
    - N06J0
  desc: 该程序应删除所有用于调试的且不计划随应用程序一起提供或部署的代码。
  details: |
    #### 概要
    该程序应删除所有用于调试的且不计划随应用程序一起提供或部署的代码。

    #### 解释
    包含“main”开发虽然是一个认可的做法，但将它遗留在上线代码里会给攻击者留下后门入口点。应从上线应用程序里删除包含“main”的方法。
  examples:
    bad:
      java:
        - |-
          public class my_code {
           // DEBUG is set to false, but \"main\" is left behind
           private static final boolean DEBUG = false;
           public static void main(String[] args) {
           my_code f = new my_code();
           }
          }
    good:
      java:
        - |-
          public class my_code {
           // DEBUG is set to false, but \"main\" is left behind
           private static final boolean DEBUG = false;
           // remove the following statement if DEBUG is set to FALSE
           // public static void main(String[] args) {
           // my_code f = new my_code();
           // }
          }
  language: Java
  likelihood: P
  master_id: 57
  msg_templ: 在${si.filename}，${si.func} 里第${si.line}行，有疑似调试入口\"main\"。
  name: 调试入口点不应保留在产品代码中
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '200'
    owasp:
      - A2
      - A9
      - A3
- alias: {}
  category: VUL
  code: ERR08-J
  cost: M
  csv_string:
    - E08J0
  desc: 该程序正捕捉NullPointerException。
  details: >
    #### 概要

    该程序正捕捉NullPointerException。


    #### 解释

    运行时抛出的NullPointerException表明有底层缺陷，必须在应用程序代码里修复它。捕捉此异常（或者其它像RuntimeException、Exception或Throwable这样的异常）会增加运行时的性能消耗。此外，当发生这种情况时，程序很可能处于未知状态，而继续执行可能导致意外结果。
  examples:
    bad:
      java:
        - |-
          public class err08_0 {
           boolean isName(String s) {
           try {
           String names = s.concat("abc");
           if (names.length() != 5) {
           return false;
           }
           return true;
           } catch (NullPointerException e) {
           // catch Null pointer exception 
           return false;
           }
           
           }

           boolean foo1() {
           try {
           throw new RuntimeException("xyz");
           } catch (RuntimeException e) {
           // this catch RuntimeException is ancestor of the NullPointerException
           return false;
           }
           }
          }
    good:
      java:
        - |-
          public class err08_0 {
           boolean isName(String s) {
           try {
           String names = s.concat("abc");
           if (names.length() != 5) {
           return false;
           }
           return true;
           } 
           }

           boolean foo1() {
           try {
           throw new RuntimeException("xyz");
           } catch (RuntimeException e) {
           // this catch RuntimeException is ancestor of the NullPointerException
           return false;
           }
           }
          }
  language: Java
  likelihood: L
  master_id: 58
  msg_templ: 在${si.filename}，第${si.line}行，有NullPointerException的异常在${si.func}函数的try块捕获到。
  name: 不应捕捉NullPointerException或其父类
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '476'
    owasp:
      - A10
- alias: {}
  category: VUL
  code: EXP02-J
  cost: L
  csv_string:
    - X02J0
  desc: 该程序正使用Object.equals()方法比较两个数组。
  details: |
    #### 概要
    该程序正使用Object.equals()方法比较两个数组。

    #### 解释
    如果两个数组包含相同的元素并且它们有相同的顺序，则这两个数组是等同的。在数组上使用Object.equals()只比较数组引用，而不是其内容。
  examples:
    bad:
      java:
        - |-
          // this example is modified from CERT-J site
          import java.util.Arrays;

          public class exp02_example {

           public static void println(int[] ar1, int[] ar2) {
           System.out.println(ar1.equals(ar2)); // prints false
           }
           
           public static void main(String[] args) {
           int[] arr1 = new int[20]; // Initialized to 0
           int[] arr2 = new int[20]; // Initialized to 0
           println(arr1, arr2); 
           }
          }
    good:
      java:
        - |-
          // this example is modified from CERT-J site
          import java.util.Arrays;

          public class exp02_example {

           public static void println(int[] ar1, int[] ar2) {
           System.out.println(Arrays.equals(arr1, arr2)); // prints true
           }
           
           public static void main(String[] args) {
           int[] arr1 = new int[20]; // Initialized to 0
           int[] arr2 = new int[20]; // Initialized to 0
           println(arr1, arr2); 
           }
          }
  language: Java
  likelihood: L
  master_id: 59
  msg_templ: 在${si.filename}，${si.func} 里第${si.line}行，Object.equals() 被用来比较${si.var}。
  name: Object.equal() 不应用于比较两个数组
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: L
  standards: {}
- alias: {}
  category: VUL
  code: FIO02-J
  cost: M
  csv_string:
    - F02J0
  desc: 该程序正试图操控一个文件，但未能检查该方法返回值的有效性。
  details: |
    #### 概要
    该程序正试图操控一个文件，但未能检查该方法返回值的有效性。

    #### 解释
    Java里的文件I/O操作必须检查执行文件I/O方法的返回值。例如，如果不经过检查，File.delete()会悄无声息地失败。
  examples:
    bad:
      java:
        - |-
          import java.io.File;
          import java.io.IOException;

          public class j_fio02_0 {
           void foo(boolean b) {
           try {
           File f = new File("file");
           if (b) {
           if (f.delete()) {
           System.out.println("Deletion error");
           }
           }
           else {
           f.delete(); // failed to check return value of delete()
           }
           }
           catch(Exception e) {
           System.out.println("Exception");
           }
           }
          }
    good:
      java:
        - |
          import java.io.File;
          import java.io.IOException;

          public class j_fio02_0 {
           void foo(boolean b) {
           try {
           File f = new File("file");
           if (b) {
           if (f.delete()) {
           System.out.println("Deletion error");
           }
           }
           else {
           if (f.delete()) {
           System.out.println("Deletion error");
           }
           
           }
           }
           catch(Exception e) {
           System.out.println("Exception");
           }
           }
          }
  language: Java
  likelihood: P
  master_id: 60
  msg_templ: >-
    在${si.filename}，${si.func}里第${si.line}行，请求打开新文件对象${si.var}。其后在第${si.line}对此对象进行调用时，未能检查文件操作是否成功。
  name: 应该检查并处理和文件有关的错误
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '252'
- alias: {}
  category: VUL
  code: FIO05-J
  cost: L
  csv_string:
    - F05J1
    - F05J0
  desc: 该程序正使用java.nio包里的buffer类的wrap()或duplicate()方法。这些缓存暴露给了程序里不受信任的代码。
  details: >
    #### 概要

    该程序正使用java.nio包里的buffer类里的wrap()或duplicate()方法。这些缓存暴露给了程序里不受信任的代码。


    #### 解释

    此方法会创建从给定输入数组生成的新Buffer对象。而新的Buffer对象可能被恶意修改。使用只读Buffer或确保原本的buffer不被修改是很重要的。
  examples:
    bad:
      java:
        - |-
          // this example is modified from CERT-J example
          import java.nio.CharBuffer;

          public class j_fio05_0 {
           private char[] dataArray;
           private CharBuffer cb;

           public j_fio05_0() {
           dataArray = new char[10];
           }

           public CharBuffer getBufferCopy() {
           return CharBuffer.wrap(dataArray); // dataArray (private) is exposed through this wrap
           }
          }
        - |-
          import java.nio.CharBuffer;

          public class j_fio05_0 {
           private char[] dataArray;
           private CharBuffer cb;

           public j_fio05_0() {
           dataArray = new char[10];
           }

           public CharBuffer getBufferCopy() {
           return CharBuffer.wrap(dataArray); // dataArray (private) is exposed through this wrap
           }

           private void storeBuffer() {
           cb = CharBuffer.wrap(dataArray); // dataArray (private) is exposed, see comment in return statement below
           }

           public CharBuffer getBufferCopy2() {
           storeBuffer();
           return cb; // dataArray is exposed through cb which is assigned in storeBuffer()
           }
          }
    good:
      java:
        - |-
          // this example is modified from CERT-J example
          import java.nio.CharBuffer;

          public class j_fio05_0 {
           private char[] dataArray;
           private CharBuffer cb;

           public j_fio05_0() {
           dataArray = new char[10];
           }

           public CharBuffer getBufferCopy() {
           return CharBuffer.wrap(dataArray).asReadOnlyBuffer(); // attemp to modify will result in exception
           }
          }
        - |-
          import java.nio.CharBuffer;

          public class j_fio05_0 {
           private char[] dataArray;
           private CharBuffer cb;

           public j_fio05_0() {
           dataArray = new char[10];
           }

           public CharBuffer getBufferCopy() {
           return CharBuffer.wrap(dataArray).asReadOnlyBuffer();; // attempt to modify will result in exception
           }

           private void storeBuffer() {
           cb = CharBuffer.wrap(dataArray).asReadOnlyBuffer();; // attempt to modify will result in exception
           }

           public CharBuffer getBufferCopy2() {
           storeBuffer();
           return cb; 
           }
          }
  language: Java
  likelihood: L
  master_id: 61
  msg_templ: >-
    在${si.filename}里第${si.line}行，buffer类中的${si.var}后备数组有可能通过函数${si.func}暴露给不可信任的代码。
  name: 不应把用wrap()或duplicate()创建的缓存暴露给不受信任的代码
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '522'
    owasp:
      - A3
      - A2
- alias: {}
  category: VUL
  code: FIO14-J
  cost: M
  csv_string:
    - F14J0
  desc: 在程序终止时，未有进行适当的清理。
  details: |
    #### 概要
    在程序终止时，未有进行适当的清理。

    #### 解释
    当检测到不可恢复的错误时，通常会快速关闭系统并允许操作员在确定的状态下重新启动。这应该包括涉及外部资源的清理。否则，可能会在系统中留下重要或敏感数据。
  examples:
    bad:
      java:
        - |
          import java.io.*;

          public class fio14_example {
           public static void reg_hook(PrintStream out) {
           // shut down hook will be called when Runtime.exit(),
           // make sure in call hierarchy,
           // there is an path from Runtime.exit() to Runtime.addShutdownHook
           Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
           public void run() {
           System.out.println("exit without closing file, need out.close()");
           out.close(); // report double close
           }
           }
           ));
           }

           public static void close2() throws FileNotFoundException {
           final PrintStream out =
           new PrintStream(new BufferedOutputStream(
           new FileOutputStream("foo.txt")));
           reg_hook(out);
           out.println("register hook");
           Runtime.getRuntime().exit(1);
           }
           public static void main(String[] args) throws FileNotFoundException{
           close2();
           }
          }
    good:
      java:
        - |-
          import java.io.*;

          public class fio14_example {
           public static void reg_hook(PrintStream out) {
           // shut down hook will be called when Runtime.exit(),
           // make sure in call hierarchy,
           // there is an edge from Runtime.exit() to Runtime.addShutdownHook
           Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
           public void run() {
           System.out.println("exit without closing file, need out.close()");
           out.close(); // report double close
           }
           }
           ));
           }

           public static void close2() throws FileNotFoundException {
           final PrintStream out =
           new PrintStream(new BufferedOutputStream(
           new FileOutputStream("foo.txt")));
           reg_hook(out);
           out.println("hello");
           Runtime.getRuntime().exit(1);
           }
           public static void main(String[] args) throws FileNotFoundException{
           close2();
           }
          }
  language: Java
  likelihood: L
  master_id: 62
  msg_templ: 在${si.filename}，第${si.line}行，程序已经终止，但是与${si.var}关联的资源将无法被正确清理。
  name: 在程序终止时，应通过Runtime.exit()执行适当的清理
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '705'
    owasp:
      - A3
- alias: {}
  category: VUL
  code: FIO16-J
  cost: M
  csv_string:
    - F16J2
    - F16J1
  desc: 该程序在没有首先规范化路径名的情况下对其进行验证。
  details: >
    #### 概要

    该程序在没有规范化路径名的情况下对其进行验证。


    #### 解释

    路径名可能包含特殊字符，这让验证变得困难。而且，路径名可能其实是软连接、影子等等，攻击者能利用这些绕过安全检查。在验证前完全解析/规范化路径名是很重要的。
  examples:
    bad:
      java:
        - |-
          import javax.servlet.http.HttpServletRequest;
          import javax.servlet.http.HttpServletResponse;
          import java.io.*;

          public class fio16_example
          {

           public void bad_1(HttpServletRequest request, HttpServletResponse response) throws IOException
           {
           String fname = request.getParameter("FileName");
           String info = request.getParameter("Info");
           File fp = new File(fname);
           
           if(fp.exists() && is_safe(fname)) { // fp validated but before calling getCanonicalPath,
           // hacker can bypass the validateion
           String uniqPath = fp.getCanonicalPath();
           FileOutputStream writer = new FileOutputStream(uniqPath);
           writer.write(info.getBytes());
           writer.close(); // info may be written to unkown location
           }
           }
           
           private Boolean is_safe(String path)
           {
           // do path validation
           if(path.startsWith("/share/user")) {
           return true;
           } else {
           return false;
           }
           }
          }
    good:
      java:
        - |-
          import javax.servlet.http.HttpServletRequest;
          import javax.servlet.http.HttpServletResponse;
          import java.io.*;

          public class fio16_example
          {

           public void bad_1(HttpServletRequest request, HttpServletResponse response) throws IOException
           {
           String fname = request.getParameter("FileName");
           String info = request.getParameter("Info");
           File fp = new File(fname);
           
           { 
           String uniqPath = fp.getCanonicalPath();
           // va;odate after calling getCanonicalPath
           if (fp.exists() && is_safe(uniqPath) { 
           FileOutputStream writer = new FileOutputStream(uniqPath);
           writer.write(info.getBytes());
           writer.close(); // info is written to validated location
           }
           }
           }
           
           private Boolean is_safe(String path)
           {
           // do path validation
           if(path.startsWith("/share/user")) {
           return true;
           } else {
           return false;
           }
           }
          }
  language: Java
  likelihood: U
  master_id: 63
  msg_templ: 在${si.filename}，${si.func} 里第${si.line}行，文件名的字符串 ${si.var} 在文件打开之前未被规范化。
  name: 请在验证路径名之前将其规范化
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '22'
      - '647'
    owasp:
      - A2
      - A5
- alias: {}
  category: VUL
  code: IDS00-J
  cost: M
  csv_string:
    - I00J3
    - I00J2
    - I00J1
    - I00J0
  desc: 在查询前必须清理所有SQL查询的字符串输入。
  details: |
    #### 概要
    在查询前必须清理所有SQL查询的字符串输入。

    #### 解释
    来自于不受信任来源的字符串必须经过清理及验证流程，以避免被当作SQL数据库的恶意输入。没有字符串清理及验证可能造成数据泄漏和违反隐私。
  examples:
    bad:
      java:
        - |
          import java.sql.DriverManager;
          import java.sql.PreparedStatement;
          import java.sql.ResultSet;
          import java.sql.SQLException;
          import java.sql.Statement;

          public class j_ids00_2 {

           public Connection getConnection() throws SQLException {
           String dbConnection = System.getProperty(\"db.connection\");
           return DriverManager.getConnection(dbConnection);
           }

           String hashPwd(char[] pwd) {
           // Create hash of password
           return new String(pwd);
           }

           public void doPrivilegedAction(
           String username, char[] password // username is unsanitized 
           ) throws SQLException, SecurityException {
           Connection connection = getConnection();
           if (connection == null) {
           // Handle error
           }
           try {
           String pwd = hashPwd(password);
           // the string query is composed with unsanitized string (username) input
           String query = \"SELECT * from where product username =\" +
           username + \" and password =\" + pwd;
           
           PreparedStatement stmt = connection.prepareStatement(query);

           ResultSet result = stmt.executeQuery();
           if (!result.next()) {
           throw new SecurityException(\"User name/password incorrect\");
           }

           // Authenticated
           } finally {
           try {
           connection.close();
           } catch (SQLException x) {
           // Forward to handler
           }
           }
           }
          }
    good:
      java:
        - |-
          import java.sql.DriverManager;
          import java.sql.PreparedStatement;
          import java.sql.ResultSet;
          import java.sql.SQLException;
          import java.sql.Statement;

          public class j_ids00_2 {

           public Connection getConnection() throws SQLException {
           String dbConnection = System.getProperty(\"db.connection\");
           return DriverManager.getConnection(dbConnection);
           }

           String hashPwd(char[] pwd) {
           // Create hash of password
           return new String(pwd);
           }

           public void doPrivilegedAction(
           String username, char[] password // username is unsanitized 
           ) throws SQLException, SecurityException {
           Connection connection = getConnection();
           if (connection == null) {
           // Handle error
           }
           try {
           String pwd = hashPwd(password);
           // the string query is composed with sanitized string (username) input
           PreparedStatement stmt = connection.prepareStatement(\"SELECT * FROM db_user WHERE username = ? AND passwd = ?\");
           
           // use set*() to enforce strong type checking
           stmt.setString(1, username); // to be sure, username may still be considered \"tainted\"
           stmt.setString(2, pwd); // to be sure, pwd ma still be considered \"tainted\" 

           ResultSet result = stmt.executeQuery();
           if (!result.next()) {
           throw new SecurityException(\"User name/password incorrect\");
           }

           // Authenticated
           } finally {
           try {
           connection.close();
           } catch (SQLException x) {
           // Forward to handler
           }
           }
           }
          }
  language: Java
  likelihood: P
  master_id: 64
  msg_templ: 在${si.filename}，函数${si.func}的字符串${si.var}在${si.line}行的SQL查询之前未有被清理。
  name: 在查询前必须清理所有SQL查询的字符串输入
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '116'
      - '943'
      - '564'
      - '89'
    owasp:
      - A1
      - A5
      - A2
    p3c-sec:
      - '3'
      - '5'
      - '4'
- alias: {}
  category: VUL
  code: IDS01-J
  cost: M
  csv_string:
    - I01J2
    - I01J1
    - I01J0
  desc: 该程序正在验证尚未被规范化的字符串。
  details: >
    #### 概要

    该程序正在验证尚未被规范化的字符串。


    #### 解释

    字符串有多种表现形式，例如“char”、“unicode”等等。许多过滤或验证机制是基于字符串的字符数据。未能在验证前过滤或规范化字符串可能最终致使绕过验证机制，从而造成代码的任意执行
  examples:
    bad:
      java:
        - |-
          import java.text.Normalizer;
          import java.text.Normalizer.Form;
          import java.util.regex.Matcher;
          import java.util.regex.Pattern;
           
          public class j_ids01_0 { // inspired by CERT-J example
           public static String filterString(String str) {
           
           // Non-compliant - Validate before the string is normalized
           Pattern pattern = Pattern.compile(\"<script>\");
           Matcher matcher = pattern.matcher(str);
           if (matcher.find()) {
           throw new IllegalArgumentException(\"Invalid input\");
           }
           // Normalization form for validate String is NFKC
           String s = Normalizer.normalize(str, Form.NFKC); 
           return s;
           }
           
           public static void main(String[] args) {
           // \"\\ \" is a noncharacter code point
           String maliciousInput = \"<scr\" + \"\\ \" + \"ipt>\";
           String sb = filterString(maliciousInput);
           // sb = \"<script>\"
           }
          }
    good:
      java:
        - |
          import java.text.Normalizer;
          import java.text.Normalizer.Form;
          import java.util.regex.Matcher;
          import java.util.regex.Pattern;
           
          public class j_ids01_0 { // inspired by CERT-J example
           public static String filterString(String str) {
           
           // Normalization form for validate String is NFKC
           String s = Normalizer.normalize(str, Form.NFKC); 
           // compliant - Validate after the string is normalized
           Pattern pattern = Pattern.compile(\"<script>\");
           Matcher matcher = pattern.matcher(str);
           if (matcher.find()) {
           throw new IllegalArgumentException(\"Invalid input\");
           }
           return s;
           }
           
           public static void main(String[] args) {
           // \"\\ \" is a noncharacter code point
           String maliciousInput = \"<scr\" + \"\\ \" + \"ipt>\";
           String sb = filterString(maliciousInput);
           // sb = \"<script>\"
           }
          }
  language: Java
  likelihood: P
  master_id: 65
  msg_templ: >-
    在${si.filename}，第${si.line}行已验证了字符串。并在函数${si.var}被规范化。可是之后在${si.filename}，第${si.line}行才规范化。
  name: 请勿验证尚未被规范化的字符串
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '180'
      - '289'
      - '79'
    owasp:
      - A7
      - A5
      - A2
    p3c-sec:
      - '4'
- alias: {}
  category: VUL
  code: IDS11-J
  cost: M
  csv_string:
    - I11J2
    - I11J1
    - I11J0
  desc: 该程序修改了一个已经过验证的字符串。
  details: |
    #### 概要
    该程序修改了一个已经过验证的字符串。

    #### 解释
    字符串在经过处理验证后又经过了修改，如此该字符串可能又会变成不受信任的字符串，使之前的验证无效。
  examples:
    bad:
      java:
        - |-
          import java.text.Normalizer;
          import java.text.Normalizer.Form;
          import java.util.regex.Matcher;
          import java.util.regex.Pattern;
           
          public class j_ids11_0 {
           public static String filterString(String s) {
           // Normalize input string
           String str = Normalizer.normalize(s, Form.NFKC);
           
           // Validate input after normalization
           Pattern pattern = Pattern.compile(\"<script>\");
           Matcher matcher = pattern.matcher(str);
           if (matcher.find()) {
           throw new IllegalArgumentException(\"Invalid input\");
           }
           
           // Delete noncharacter code
           // input string may have noncharacter code
           // however, the new string formed should go through normalize and validation again
           str = str.replaceAll(\"[\\\\p{Cn}]\", \"\");
           return str;
           }
           // ... more code 
          }
    good:
      java:
        - |-
          import java.text.Normalizer;
          import java.text.Normalizer.Form;
          import java.util.regex.Matcher;
          import java.util.regex.Pattern;
           
          public class j_ids11_0 {
           public static String filterString(String s) {
           // Normalize input string
           String str = Normalizer.normalize(s, Form.NFKC);
           
           // Delete noncharacter code
           // input string may have noncharacter code
           // however, the new string formed should go through normalize and validation again
           str = str.replaceAll(\"[\\\\p{Cn}]\", \"\");
           
           // Validate input after normalization
           Pattern pattern = Pattern.compile(\"<script>\");
           Matcher matcher = pattern.matcher(str);
           if (matcher.find()) {
           throw new IllegalArgumentException(\"Invalid input\");
           }
           
           return str;
           }
           // ... more code 
          }
  language: Java
  likelihood: P
  master_id: 66
  msg_templ: 在${si.filename}，第${si.line}行，程序修改了已经被规范化并验证了的字符串${si.var}，导致字符串再次变成不可信仼。
  name: 请勿修改已经过验证的字符串
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '182'
    owasp:
      - A7
      - A2
      - A3
    p3c-sec:
      - '4'
- alias: {}
  category: VUL
  code: IDS17-J
  cost: M
  csv_string:
    - I17J2
    - I17J1
    - I17J0
  desc: 应该适当地过滤定义了外部实体（通常由URI指定）的外部声明。
  details: |
    #### 概要
    应该适当过滤定义外部实体（通常由URI指定）的外部声明。

    #### 解释
    应该过滤外部实体，或是通过白名单或预注册，这样能控制XML攻击。未能这么做可能导致拒绝服务或数据泄漏。
  examples:
    bad:
      java:
        - |-
          import java.io.IOException;
          import org.xml.sax.EntityResolver;
          import org.xml.sax.InputSource;
          import org.xml.sax.SAXException;
          import java.io.FileInputStream;
          import java.io.InputStream;

          import javax.xml.parsers.ParserConfigurationException;
          import javax.xml.parsers.SAXParser;
          import javax.xml.parsers.SAXParserFactory;
          import org.xml.sax.XMLReader;
          import org.xml.sax.helpers.DefaultHandler;

          class ids17_CustomResolver implements EntityResolver {
           public InputSource resolveEntity(String publicId, String systemId)
           throws SAXException, IOException {
           // Check by whitelist good entity
           ....
           }
          }
           
          public class ids17_example{
           private static void bad_receiveXMLStream(InputStream inStream,
           DefaultHandler defaultHandler)
           throws ParserConfigurationException, SAXException, IOException {
           SAXParserFactory factory = SAXParserFactory.newInstance();
           SAXParser saxParser = factory.newSAXParser();
           saxParser.parse(inStream, defaultHandler); // IDS17-J
           }

           private static void bad_receiveXMLStream2(InputStream inStream,
           DefaultHandler defaultHandler,
           Boolean do_sanitize) 
           throws ParserConfigurationException, SAXException, IOException {
           try {
           SAXParserFactory factory = SAXParserFactory.newInstance();
           SAXParser saxParser = factory.newSAXParser();

           XMLReader reader = saxParser.getXMLReader();
           reader.setContentHandler(defaultHandler);
           if(do_sanitize) {
           reader.setEntityResolver(new ids17_CustomResolver()); // sanitized
           }
           InputSource is = new InputSource(inStream);
           reader.parse(is); // IDS17-J, not setEntityResolver if !do_sanitize
           } catch (java.net.MalformedURLException mue) {
           System.err.println(\"Malformed URL Exception: \" + mue);
           }
           }

           
           public static void main(String[] args) throws ParserConfigurationException,
           SAXException, IOException {
           // invokes bad_receiveXMLStream and bad_receiveXMLStream2
           // ...
           }
          }
    good:
      java:
        - |-
          import java.io.IOException;
          import org.xml.sax.EntityResolver;
          import org.xml.sax.InputSource;
          import org.xml.sax.SAXException;
          import java.io.FileInputStream;
          import java.io.InputStream;

          import javax.xml.parsers.ParserConfigurationException;
          import javax.xml.parsers.SAXParser;
          import javax.xml.parsers.SAXParserFactory;
          import org.xml.sax.XMLReader;
          import org.xml.sax.helpers.DefaultHandler;

          class ids17_CustomResolver implements EntityResolver {
           public InputSource resolveEntity(String publicId, String systemId)
           throws SAXException, IOException {
           // Check by whitelist good entity
           ....
           }
          }
           
          public class ids17_example{
           private static void bad_receiveXMLStream(InputStream inStream,
           DefaultHandler defaultHandler)
           throws ParserConfigurationException, SAXException, IOException {
           SAXParserFactory factory = SAXParserFactory.newInstance();
           SAXParser saxParser = factory.newSAXParser();
           saxParser.parse(inStream, defaultHandler); // IDS17-J
           }

           private static void bad_receiveXMLStream2(InputStream inStream,
           DefaultHandler defaultHandler,
           Boolean do_sanitize) 
           throws ParserConfigurationException, SAXException, IOException {
           try {
           SAXParserFactory factory = SAXParserFactory.newInstance();
           SAXParser saxParser = factory.newSAXParser();

           XMLReader reader = saxParser.getXMLReader();
           reader.setContentHandler(defaultHandler);
           // always sanitize
           reader.setEntityResolver(new ids17_CustomResolver()); // sanitized
           
           InputSource is = new InputSource(inStream);
           reader.parse(is); // no IDS17 complaince issue 
           } catch (java.net.MalformedURLException mue) {
           System.err.println(\"Malformed URL Exception: \" + mue);
           }
           }

           
           public static void main(String[] args) throws ParserConfigurationException,
           SAXException, IOException {
           // invokes bad_receiveXMLStream and bad_receiveXMLStream2
           // ...
           }
          }
  language: Java
  likelihood: P
  master_id: 67
  msg_templ: 在${si.filename}，第${si.line}行，外部声明未被适当过滤。
  name: 在XML输入里引用外部软件实体可能会导致XML攻击
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '611'
      - '116'
      - '776'
    owasp:
      - A4
      - A1
- alias: {}
  category: VUL
  code: MET06-J
  cost: L
  csv_string:
    - T06J1
    - T06J0
  desc: 该程序在clone()里调用了可覆盖的方法。
  details: |
    #### 概要
    该程序在clone()里调用了可覆盖的方法。

    #### 解释
    恶意的子类可能会覆盖clone()里的方法，造成不安全或不可预测的行为。另外，受信任的子类可以修改处于构造过程的被复制的对象，造成被复制的对象的不一致。
  examples:
    bad:
      java:
        - |
          // this example is extended from CERT site
          import java.net.HttpCookie;
          import java.util.ArrayList;
          import java.util.List;

          class j_met06 implements Cloneable {
           HttpCookie[] cookies;

           j_met06(HttpCookie[] c) {
           cookies = c;
           }

           public Object clone() throws CloneNotSupportedException {
           // get shallow copy of object
           final j_met06 clone = (j_met06) super.clone();
           clone.doSomething(); // Can invoke overridable method

           // the class has mutable object, need to deep copy those field
           clone.cookies = clone.deepCopy();
           return clone;
           }

           void doSomething() { // Overridable method
           for (int i = 0; i < cookies.length; i++) {
           cookies[i].setValue(\"\" + i);
           }
           }

           HttpCookie[] deepCopy() {
           if (cookies == null) {
           throw new NullPointerException();
           }

           // implements deep copy
           List<HttpCookie> cloned_cookie = new ArrayList<>();
           // ...
           return (HttpCookie[]) cloned_cookie;
           }
          }

          class j_met06_ext extends j_met06 {
           j_met06_ext(HttpCookie[] c) {
           super(c);
           }

           public Object clone() throws CloneNotSupportedException {
           final j_met06_ext clone = (j_met06_ext) super.clone();
           clone.doSomething();
           return clone;
           }

           void doSomething() { // Erroneously executed
           for (int i = 0;i < cookies.length; i++) {
           cookies[i].setDomain(i + \".xxx.com\");
           }
           }

           public static void main(String[] args)
           throws CloneNotSupportedException {
           HttpCookie[] hc = new HttpCookie[20];
           for (int i = 0 ; i < hc.length; i++){
           hc[i] = new HttpCookie(\"cookie\" + i,\"\" + i);
           }
           // shallow copy was invoked, the original object can be modified
           j_met06 badcookie = new j_met06_ext(hc);
           badcookie.clone();
           }
          }
    good:
      java:
        - |
          import java.net.HttpCookie;
          import java.util.ArrayList;
          import java.util.List;

          class j_met06 implements Cloneable {
           HttpCookie[] cookies;

           j_met06(HttpCookie[] c) {
           cookies = c;
           }

           public Object clone() throws CloneNotSupportedException {
           // get shallow copy of object
           final j_met06 clone = (j_met06) super.clone();
           clone.doSomething(); // Can invoke overridable method

           // the class has mutable object, need to deep copy those field
           clone.cookies = clone.deepCopy();
           return clone;
           }

           final void doSomething() { // not overridable method
           for (int i = 0; i < cookies.length; i++) {
           cookies[i].setValue(\"\" + i);
           }
           }

           final HttpCookie[] deepCopy() { // not overridable method
           if (cookies == null) {
           throw new NullPointerException();
           }

           // implements deep copy
           List<HttpCookie> cloned_cookie = new ArrayList<>();
           // ...
           return (HttpCookie[]) cloned_cookie;
           }
          }

          class j_met06_ext extends j_met06 {
           j_met06_ext(HttpCookie[] c) {
           super(c);
           }

           public Object clone() throws CloneNotSupportedException {
           final j_met06_ext clone = (j_met06_ext) super.clone();
           clone.doSomething();
           return clone;
           }

           void doSomething() { // will not be called
           for (int i = 0;i < cookies.length; i++) {
           cookies[i].setDomain(i + \".xxx.com\");
           }
           }

           public static void main(String[] args)
           throws CloneNotSupportedException {
           HttpCookie[] hc = new HttpCookie[20];
           for (int i = 0 ; i < hc.length; i++){
           hc[i] = new HttpCookie(\"cookie\" + i,\"\" + i);
           }
           // deep copy was invoked, the original object cannot be modified
           j_met06 badcookie = new j_met06_ext(hc);
           badcookie.clone();
           }
          }
  language: Java
  likelihood: P
  master_id: 68
  msg_templ: 在${si.filename}，第${si.line}行，可覆盖的方法${si.var}会被clone()覆盖。
  name: 不要在clone()中调用可覆盖的方法
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    owasp:
      - A5
      - A2
- alias: {}
  category: VUL
  code: MSC61-J
  cost: H
  csv_string:
    - M61J1
    - M61J0
  desc: 该程序正为安全敏感型代码使用弱加密算法。
  details: |
    #### 概要
    该程序正为安全敏感型代码使用弱加密算法。

    #### 解释
    安全和隐私敏感型信息应使用安全性强的加密算法，包括有Galois/Counter模式（GCM）的AES和有加密块链模式的AES。
  examples:
    bad:
      java:
        - |-
          import javax.crypto.*;
          import java.io.UnsupportedEncodingException;
          import java.security.InvalidKeyException;
          import java.security.NoSuchAlgorithmException;

          public class j_msc61_0 {
           public static byteArray[] encryption(String strToBeEncrypted) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, UnsupportedEncodingException, BadPaddingException, IllegalBlockSizeException {
           
           // DES is a weak encryption algorithm
           // AES is also weak, however, if AES is to be used
           // GCM (Galois/Counter Mode) will do the encryption
           SecretKey key = KeyGenerator.getInstance(\"DES\").generateKey();
           Cipher cipher = Cipher.getInstance(\"DES\");
           cipher.init(Cipher.ENCRYPT_MODE, key);

           // Encode bytes as UTF8; strToBeEncrypted contains
           // the input string that is to be encrypted
           byteArray[] encoded = strToBeEncrypted.getBytes(\"UTF8\");

           // Perform encryption
           byteArray[] encrypted = cipher.doFinal(encoded);
           return encrypted;
           }
          }
    good:
      java:
        - |-
          import javax.crypto.*;
          import java.io.UnsupportedEncodingException;
          import java.security.InvalidKeyException;
          import java.security.NoSuchAlgorithmException;

          public class j_msc61_0 {
           
           public static SecretKey genKey() {
           // DES is a weak encryption algorithm
           // AES is also weak, however, if AES is to be used
           // GCM (Galois/Counter Mode) will do the encryption
           try {
           KeyGenerator keygen = KeyGenerator.getInstance(\"AES\");
           keygen.init(128);
           return keygen.generateKey();
           } catch (NoSuchAlgorithmException e) {
           // handle exception
           ...
           }
           }
           
           public static byteArray[] encryption(String strToBeEncrypted, SecretKey seckey) throws NoSuchAlgorithmException, NoSuchPaddingException, InvalidKeyException, UnsupportedEncodingException, BadPaddingException, IllegalBlockSizeException {
           Cipher cipher = Cipher.getInstance(\"AES/GCM/NoPadding\");
           // please consult example in CERT-J site for MSC61-J
           ...
           }
          }
  language: Java
  likelihood: P
  master_id: 69
  msg_templ: 在${si.filename}，第${si.line}行，函数${si.func}用${si.var}加密算法是比较弱和不安全的。
  name: 安全关键型代码必须避免使用不安全或弱加密算法
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '325'
      - '326'
    owasp:
      - A3
- alias: {}
  category: VUL
  code: OBJ09-J
  cost: L
  csv_string:
    - O09J
  desc: 比较类名称可能会导致混合搭配攻击。
  details: >+
    #### 概要

    比较类名称可能会导致混合搭配攻击。


    #### 解释

    只有当两个类具有相同的限定名称时，它们才是同一类。 具有相同名称的类可能具有不同的包名称。
    同样由于不同的类加载器（或类加载器的不同实例），具有相同限定名称类也可能成为不同的类。

  examples:
    bad:
      java:
        - |-
          import java.lang.String;
          public class j_obj09_1 {
           void callComp(Boolean v) {
           Class cls1 = getClass();
           Class cls2 = String.class;
           if(v) {
           badComp1(cls1.getName()); 
           } else {
           badComp2(cls1.getName(), cls2.getName());
           }
           }
           Boolean badComp1(String clsName) {
           if(clsName.equals(\"j_obj09_0\")) {
           return true;
           }
           else {
           return false;
           }
           } 

           Boolean badComp2(String name1, String name2)
           {
           if(name1.equals(name2)) {
           return true;
           }
           else {
           return false;
           }
           }
          }
    good: {}
  language: Java
  likelihood: U
  master_id: 70
  msg_templ: 在${si.filename}，第${si.line}行，函数${si.func}使用了名称来比较类。
  name: 比较类名称可能导致混搭攻击
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- alias: {}
  category: VUL
  code: OBJ11-J
  cost: M
  csv_string:
    - O11J0
  desc: 抛出异常的构造函数可能会使对象处于部分初始状态。
  details: |+
    #### 概要
    抛出异常的构造函数可能会使对象处于部分初始状态。

    #### 解释
    在对象构造过程中，该对象处于部分初始状态。在构造过程中抛出异常会使对象处于不稳定状态。

  examples:
    bad:
      java:
        - |-
          import java.io.IOException;

          public class obj11_0 {
           public obj11_0()
           {
           // by throwing an exception in constructor
           // attacker can capture a reference to the partially initialized object of the obj11_0 class since
           // the object reference remains in the garbge collector
           if (!performVerification()) {
           throw new SecurityException(\"Access Denied!\");
           }
           }

           private boolean performVerification() {
           return false; // Returns true if data entered is valid, else false
           // Assume that the attacker always enters an invalid value
           }

           public void greeting() {
           System.out.println(\"Welcome user!\");
           }
          }
    good: {}
  language: Java
  likelihood: P
  master_id: 71
  msg_templ: 构造函数${si.func}会在${si.filename}，第${si.line}行抛出异常${si.var}。
  name: 构造函数不应抛出异常
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- alias: {}
  category: VUL
  code: SEC02-J
  cost: M
  csv_string:
    - C02J1
    - C02J0
  desc: 此程序中安全检查代码的来源可能基于不受信任的来源。
  details: >
    #### 概要

    此程序中安全检查代码的来源可能基于不受信任的来源。


    #### 解释

    不受信任代码可能有许多不同的来源。安全检查可能通过代码重写被绕过。经过安全检查的对象在检查后也能被重写。即使通过安全检查后保存的该对象，也有可能存在复制方法不足够的问题（例如浅复制这类不够完全彻底的复制方法）。
  examples:
    bad:
      java:
        - |-
          import java.io.FileNotFoundException;
          import java.io.RandomAccessFile;
          import java.security.AccessController;
          import java.security.PrivilegedAction;
          import java.io.IOException;

          public class sec02_0 {
           public static RandomAccessFile openFile(final java.io.File f) {
           // getPath() can be extended, thus security check can pass the first time, 
           // but getPath() changed the second time, bypass the good check
           if (f.getPath().contains(\"passwd\")){
           return null;
           };
           // ...
           return (RandomAccessFile) AccessController.doPrivileged(new PrivilegedAction<Object>() {
           public Object run() {
           try {
           return new RandomAccessFile(f, \"r\");
           } catch (FileNotFoundException e) {
           e.printStackTrace();
           }
           return null;
           }
           });
           }
          }
    good:
      java:
        - |-
          import java.io.FileNotFoundException;
          import java.io.RandomAccessFile;
          import java.security.AccessController;
          import java.security.PrivilegedAction;
          import java.io.IOException;

          public class sec02_0 {
           public static RandomAccessFile openFile(final java.io.File f) {
           // get a copy through getPath(), but not a clone
           final java.io.File copy = new java.io.File(f.getPath());
           // use copy of path later on
           if (copy.getPath().contains(\"passwd\")){
           return null;
           };
           // ...
           return (RandomAccessFile) AccessController.doPrivileged(new PrivilegedAction<Object>() {
           public Object run() {
           try {
           return new RandomAccessFile(copy.getPath(), \"r\");
           } catch (FileNotFoundException e) {
           e.printStackTrace();
           }
           return null;
           }
           });
           }
          }
  language: Java
  likelihood: P
  master_id: 72
  msg_templ: 在${si.filename}，第${si.line}行，函数${si.func}返回来源不可信任的安全检查给${si.var}。
  name: 安全检查代码不应基于不受信任来源
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '269'
      - '862'
    owasp:
      - A2
      - A6
- alias: {}
  category: VUL
  code: SEC06-J
  cost: M
  csv_string:
    - C06J3
    - C06J2
    - C06J1
    - C06J0
  desc: 该程序正使用URLClassLoader和java.util.jar提供的默认自动签名检验器。
  details: >
    #### 概要

    该程序正使用URLClassLoader和java.util.jar提供的默认自动签名检验器。


    #### 解释

    当签名用于权限提升目的时，把这些包当作默认自动签名检验来使用是不够的。它只会执行完整性检查。并且它只使用公钥来对加载的类进行认证，此公钥可能已被恶意修改。
  examples:
    bad:
      java:
        - |-
          package io.xc5.cert;
          import java.io.IOException;
          import java.lang.reflect.InvocationTargetException;
          import java.lang.reflect.Method;
          import java.lang.reflect.Modifier;
          import java.net.JarURLConnection;
          import java.net.URL;
          import java.net.URLClassLoader;
          import java.util.jar.Attributes;
          import java.security.GeneralSecurityException;
          import java.security.KeyStore;
          import java.security.cert.Certificate;
          import java.io.FileInputStream;

          public class j_sec06_1 extends URLClassLoader {
           private URL url;
           public j_sec06_1(URL url) {
           super(new URL[] { url });
           this.url = url;
           }

           public void invokeClass(String name, String[] args)
           throws ClassNotFoundException, NoSuchMethodException,
           InvocationTargetException , GeneralSecurityException, IOException {
           Class c = loadClass(name);
           Method m = c.getMethod(\"getValue\", new Class[] { args.getClass() });
           m.setAccessible(true);
           try {
           m.invoke(null, new Object[] { args });
           } catch (IllegalAccessException e) {
           System.out.println(\"Access denied\");
           }
           }
          }
    good:
      java:
        - |-
          package io.xc5.cert;
          import java.io.IOException;
          import java.lang.reflect.InvocationTargetException;
          import java.lang.reflect.Method;
          import java.lang.reflect.Modifier;
          import java.net.JarURLConnection;
          import java.net.URL;
          import java.net.URLClassLoader;
          import java.util.jar.Attributes;
          import java.security.GeneralSecurityException;
          import java.security.KeyStore;
          import java.security.cert.Certificate;
          import java.io.FileInputStream;

          public class j_sec06_fp_1 extends URLClassLoader {
           private URL url;
           public j_sec06_fp_1(URL url) {
           super(new URL[] { url });
           this.url = url;
           }

           Boolean verifyClass(Class c) throws ClassNotFoundException, NoSuchMethodException,
           InvocationTargetException, GeneralSecurityException,
           IOException {
           Certificate[] certs = c.getProtectionDomain().getCodeSource().getCertificates();
           if (certs == null) {
           return false;
           }
           else { 
           KeyStore ks = KeyStore.getInstance(\"JKS\");
           ks.load(new FileInputStream(\"sec06.jks\"), \"loadkeystorepassword\".toCharArray());
           Certificate pubCert = ks.getCertificate(\"sec06\");
           // Check with the trusted public key, else throws exception
           certs[0].verify(pubCert.getPublicKey());
           return true;
           }
           }

           public void invokeClass(String name, String[] args)
           throws ClassNotFoundException, NoSuchMethodException,
           InvocationTargetException , GeneralSecurityException, IOException {
           Class c = loadClass(name);
           Method m = c.getMethod(\"getValue\", new Class[] { args.getClass() });
           m.setAccessible(true);
           
           // use customized, non-default verification method declared above
           if(verifyClass(c)) {
           try {
           m.invoke(null, new Object[] { args });
           } catch (IllegalAccessException e) {
           System.out.println(\"Access denied\");
           }
           }
           }
          }
  language: Java
  likelihood: P
  master_id: 73
  msg_templ: >-
    在${si.filename}，第${si.line}行，在函数${si.func}里，
    ${si.var}使用URLClassLoader默认自动签名验证器。
  name: 不应使用URLClassLoader和java.util.jar提供的默认自动签名检验器
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '256'
      - '295'
      - '285'
      - '862'
    owasp:
      - A2
      - A3
- alias: {}
  category: VUL
  code: FIO02-C
  cost: M
  csv_string:
    - F02C6
    - F02C5
    - F02C4
    - F02C3
    - F02C2
    - F02C1
    - F02C0
  desc: >-
    路径名，目录名和文件名可能包含使验证变得困难且不准确的字符。 此外，任何路径名组件都可以是符号链接，从而进一步掩盖了文件的实际位置或标识。
    为了简化文件名验证，建议将名称转换为规范形式。
    通过对名称进行规范化，可以比较名称，从而更轻松地验证路径，目录或文件名。由于规范形式在操作系统和文件系统之间可能会有所不同，因此最好使用特定于操作系统的机制进行规范化。
  details: >
    #### 概要

    来源不受信任的路径名和目录名应该被规范化并验证。


    #### 解释

    路径名、目录名和文件名可能包含使验证变得困难且不准确的字符。 此外，任何路径名组件都可以是符号链接，从而进一步掩盖了文件的实际位置或标识。
    为了简化文件名验证，建议将名称转换为规范形式。
    通过对名称进行规范化，可以比较名称，从而更轻松地验证路径，目录或文件名。由于规范形式在操作系统和文件系统之间可能会有所不同，因此最好使用特定于操作系统的机制进行规范化。
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>
          #include <stdlib.h>

          FILE* f_open(char* fname, FILE *fptr)
          {
              fptr = fopen(fname, "r");
              return fptr;
          }

          int main(int argc, char **argv[])
          {
            FILE *fptr;
            
            if (!verify_file(*argv[1])) {
              printf("error
          ");
              exit(1);
            }
            else {
              fptr = f_open(*argv[1], fptr);
            }
            printf("File opened %x
          ", fptr);
            // ...
            exit(0);
          }
    good:
      c:
        - |-
          #include <stdio.h>
          #include <stdlib.h>

          FILE* f_open(char* fname, FILE *fptr)
          {
              fptr = fopen(fname, "r");
              return fptr;
          }

          char *sanitize(char *fname);


          int main(int argc, char **argv[])
          {
            FILE *fptr;
            
            if (!verify_file(sanitize(*argv[1]))) {  // sanitize file name first
              printf("error
          ");
              exit(1);
            }
            else {
              fptr = f_open(*argv[1], fptr);
            }
            printf("File opened %x
          ", fptr);
            // ...
            exit(0);
          }
  language: c,c++
  likelihood: P
  master_id: 74
  msg_templ: 在${si.filename}行${si.line}行，函数${si.func}正在打开文件而不规范其名称，该名称可能来自受污染的源。
  name: 规范化来自污染源的路径名
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '22'
      - '23'
      - '28'
      - '40'
      - '41'
      - '59'
      - '73'
- category: VUL
  code: STR07-C
  cost: MEDIUM
  desc: ''
  details: ''
  examples:
    bad: {}
    good: {}
  language: c,c++
  likelihood: PROBABLE
  master_id: 75
  msg_templ: ''
  name: 使用边界检查接口进行字符串操作
  severity: HIGH
- category: BAD_PRACTICE
  code: POS02-C
  cost: HIGH
  desc: ''
  details: ''
  examples:
    bad: {}
    good: {}
  language: c,c++
  likelihood: LIKELY
  master_id: 76
  msg_templ: ''
  name: 遵循最小特权原则
  severity: HIGH
- category: VUL
  code: POS36-C
  cost: MEDIUM
  desc: ''
  details: ''
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>
          #include <unistd.h>

          void func(){
              int uid_stat = setuid(getuid());
              int gid_stat = setgid(getfid());

              // Possible to regain group privileges because of incorrect order
              // Vulnerability allowing execution of arbitrary code
          }
    good:
      c:
        - |-
          #include <stdio.h>
          #include <unistd.h>

          void func() {
              int gid_stat = setgid(getgid());
              int uid_stat = setuid(getuid());
              
              // Correct order of privilege relinquishment
          }
  language: c,c++
  likelihood: PROBABLE
  master_id: 77
  msg_templ: ''
  name: 放弃特权时遵守正确的撤销顺序
  severity: HIGH
- alias: {}
  category: VUL
  code: MSC62-J
  cost: L
  csv_string:
    - M62J1
    - M62J0
  desc: 将密码用明文存储可能导致这些密码以各种方式暴露。建议使用计算上可行而其解码在计算上不可行的哈希函数加密，用户可以使用哈希值测试密码是否相等。
  details: |-
    #### 概要
    将密码用明文存储可能导致这些密码以各种方式暴露。建议使用计算上可行而其解码在计算上不可行的哈希函数加密，用户可以使用哈希值测试密码是否相等。

    #### 解释
    密码不应以明文存储。为防止密码泄露，通常使用哈希函数来进行密码存储，这种加密方法成本不高昂且允许直接比较。
  examples:
    bad:
      java:
        - |-
          import java.security.MessageDigest;
          import java.security.NoSuchAlgorithmException;
          import java.security.SecureRandom;

          public class j_msc62_ex {
            private void regUser1(String userName, byte[] passwd, String regType) {
              try {
                String salt = genSalt();
                String combPasswd = salt + passwd;
                byte[] secureHash = secureHash(combPasswd.getBytes());
                byte[] noSaltPasswd = secureHash(passwd);
                byte[] unsecureHash = unSecureHash(combPasswd.getBytes());
                if(regType.equals("NO_SALT_HASH")) {
                  saveUser(userName, passwd);             // MSC62-J, no salt, no hash
                } else if(regType.equals("NO_SALT")) {
                  saveUser(userName, noSaltPasswd);       // MSC62-J no salt
                } else if(regType.equals("UNSECURE_HASH")){
                  saveUser(userName, unsecureHash);       // MSC62-J unsecure hash
                } else {
                  saveUser(userName, secureHash);         // 
                }
              } catch (NoSuchAlgorithmException e) {
                e.printStackTrace();
              }
            } 
            private byte[] unSecureHash(byte [] passwd) throws NoSuchAlgorithmException{
              MessageDigest msgDigest = MessageDigest.getInstance("MD5");  // not secure hash algorithm
              return msgDigest.digest(passwd);
            }
            // .. other code
            private byte[] secureHash(byte [] passwd) throws NoSuchAlgorithmException{
              MessageDigest msgDigest = MessageDigest.getInstance("SHA256");  // secure hash algorithm
              return msgDigest.digest(passwd);
            }

            private void testRegUser(String userName, String passwd, String regType) {
              regUser1(userName, passwd.getBytes(), regType);
              regUser2(userName, passwd);  // MSC62-J passwd is String type
            }

          } 
    good:
      java:
        - |-
          import java.security.MessageDigest;
          import java.security.NoSuchAlgorithmException;
          import java.security.SecureRandom;

          public class j_msc62_ex {
            private void regUser1(String userName, byte[] passwd, String regType) {
              try {
                String salt = genSalt();
                String combPasswd = salt + passwd;
                byte[] secureHash = secureHash(combPasswd.getBytes());
                byte[] noSaltPasswd = secureHash(passwd);
                byte[] unsecureHash = unSecureHash(combPasswd.getBytes());
                if(regType.equals("NO_SALT_HASH")) {
                  handleError("NO_SALT_HASH");;             // MSC62-J, no salt, no hash
                } else if(regType.equals("NO_SALT")) {
                  handleError("NO_SALT_HASH");        // MSC62-J no salt
                } else if(regType.equals("UNSECURE_HASH")){
                  handleError("UNSECURE_HASH");       // MSC62-J unsecure hash
                } else {
                  saveUser(userName, secureHash);         
                }
              } catch (NoSuchAlgorithmException e) {
                e.printStackTrace();
              }
            } 
            private byte[] unSecureHash(byte [] passwd) throws NoSuchAlgorithmException{
              MessageDigest msgDigest = MessageDigest.getInstance("MD5");  // not secure hash algorithm
              return msgDigest.digest(passwd);
            }
            
            private byte[] secureHash(byte [] passwd) throws NoSuchAlgorithmException{
              MessageDigest msgDigest = MessageDigest.getInstance("SHA256");  // secure hash algorithm
              return msgDigest.digest(passwd);
            }

            private void testRegUser(String userName, String passwd, String regType) {
              regUser1(userName, passwd.getBytes(), regType);
              regUser2(userName, passwd);  // MSC62-J passwd is String type
            }

          } 
  language: java
  likelihood: P
  master_id: 80
  msg_templ: 在${si.filename}行${si.line}行，函数${si.func}正在使用不安全的哈希值存储密码。
  name: 密码应使用安全的哈希值存储，以防止暴露给恶意用户。
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '522'
- alias: {}
  category: VUL
  code: IDS03-J
  cost: M
  csv_string:
    - I03J2
    - I03J1
    - I03J0
  desc: 包含未经清理的用户输入的日志条目可能导致日志注入攻击并导致跨信任边界的数据泄露。
  details: |-
    #### 名称
    未经过清理的用户信息不应该被暴露

    #### 概要
    当未经过清理的用户输入被记录或者以stdout输出时，可能造成敏感信息泄漏

    #### 解释
    记录未经过清理的用户输入可能导致敏感信息在信任边界外泄漏。Log注入攻击会进一步引起信息泄漏。Java和C/C++程序都可能遭到类似的攻击（见示例）。
  examples:
    bad:
      c:
        - "\nusing namespace mychain;\nusing namespace MyContract::Sample;\n\nclass demoBranch:public Contract {\npublic:\n    TransferPtr m_ptransfer;\n\n    demoBranch() {\n        m_ptransfer = GetTransferM();\n    }\n    INTERFACE void Init() {\n        InitRoot();\n    }\n    \n    INTERFACE void LeakToLog(const std::string& sAccountName ) {\n        if(!m_ptransfer) {\n            Revert(\"error\");\n        }\n\n\t// get account, balance etc\n        AccountMMapPtr pAccountMap = m_ptransfer->get_accounts();\n        if (!pAccountMap) {\n            Revert(\"AcountMMapPtr Error.\");\n        }\n\n        // obtain user account number and name\n\t// ...\n\n\t//\n        int32_t iBalanceRmb = pBalance->get_rmb();\n        std::string sBalanceTopic = std::to_string(iBalanceRmb);\n        std::vector<std::string> leak_msg;\n        leak_msg.push_back(sAccountName);\n        leak_msg.push_back(sBalanceTopic);\n\t\n        if (iBalanceRmb < 1) {\n          Log(std::string(\"acc_bal\"), leak_msg);\n        }\n    }\n};\nINTERFACE_EXPORT(demoBranch, (Init) (LeakToLog))\n"
      java:
        - |
          locationClient = new LocationClient(this, this, this);
          locationClient.connect();
          currentUser.setLocation(locationClient.getLastLocation());
          ... 

          catch (Exception e) {
              AlertDialog.Builder builder = new AlertDialog.Builder(this);
              builder.setMessage("Application Error.");
              AlertDialog alert = builder.create();
              alert.show();

              // user location is written to log
              Log.e("Example", "Caught exception: " + e + " User:" + User.toString());
          }
    good:
      c:
        - "\nusing namespace mychain;\nusing namespace MyContract::Sample;\n\nclass demoBranch:public Contract {\npublic:\n    TransferPtr m_ptransfer;\n\n    demoBranch() {\n        m_ptransfer = GetTransferM();\n    }\n    INTERFACE void Init() {\n        InitRoot();\n    }\n    \n    INTERFACE void LeakToLog(const std::string& sAccountName ) {\n        if(!m_ptransfer) {\n            Revert(\"error\");\n        }\n\n\t// get account, balance etc\n        AccountMMapPtr pAccountMap = m_ptransfer->get_accounts();\n        if (!pAccountMap) {\n            Revert(\"AcountMMapPtr Error.\");\n        }\n\n        // obtain user account number and name\n\t// ...\n\n\t//\n        int32_t iBalanceRmb = pBalance->get_rmb();\n        std::string sBalanceTopic = std::to_string(iBalanceRmb);\n        std::vector<std::string> leak_msg;\n        leak_msg.push_back(sAccountName);\n        leak_msg.push_back(sBalanceTopic);\n\n        if (iBalanceRmb < 1) {\n\t  // Sanitize and clean up message before logging\n          Log(std::string(\"acc_bal\"), SanitizeUser(leak_msg));\n        }\n    }\n};\nINTERFACE_EXPORT(demoBranch, (Init) (LeakToLog))\n"
      java:
        - |
          locationClient = new LocationClient(this, this, this);
          locationClient.connect();
          currentUser.setLocation(locationClient.getLastLocation());
          ... 

          catch (Exception e) {
              AlertDialog.Builder builder = new AlertDialog.Builder(this);
              builder.setMessage("Application Error.");
              AlertDialog alert = builder.create();
              alert.show();

              // user location is "sanitized" being written to log
              Log.e("Example", "Caught exception: " + e + " User:" + sanitizeUser(User.toString()));
          }
  language: java
  likelihood: P
  master_id: 81
  msg_templ: ''
  name: 未经清理的用户输入不应出现在日志中
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '117'
      - '150'
      - '144'
    owasp:
      - A3
    p3c-sec:
      - '2'
- alias: {}
  category: VUL
  code: ARR38-C
  cost: M
  csv_string:
    - A38C2
    - A38C1
    - A38C0
  desc: 该程序正调用有指针和大小参数的库函数。当这两个参数组合在一起时，它们会在该对象的合法范围之外。
  details: ''
  examples:
    bad:
      c:
        - |-
          #include <stdlib.h>
          #include <string.h>

          void func(size_t SIZE_LIMIT)
          {
              char *p = (char *)malloc(SIZE_LIMIT);
              /* ...  */

              // adding 100 is out of bounds
              const size_t n = SIZE_LIMIT + 100;
              /* ...  */
              memset(p, 0, n);
          }
    good:
      c:
        - |-
          #include <stdlib.h>
          #include <string.h>

          void func(size_t SIZE_LIMIT)
          {
              char *p = (char *)malloc(SIZE_LIMIT);
              /* ...  */

              // ensures that it will not go past last element
              const size_t n = SIZE_LIMIT - 1;
              /* ...  */
              memset(p, 0, n);
          }
  language: c,c++
  likelihood: L
  master_id: 82
  msg_templ: 在${si.filename}行${si.line}行，函数${si.func}正在调用有指针和大小参数的库函数。
  name: 数组在使用库函数时越界
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '787'
      - '119'
      - '125'
- category: VUL
  code: EXP34-C
  cost: MEDIUM
  desc: 该程序正通过带值的指针访问非法内存。该漏洞与鉴释NPD规则相同。
  details: |
    #### 概要
    该程序正通过带值的指针访问非法内存。该漏洞与鉴释NPD规则相同。

    #### 解释
    请参考鉴释漏洞列表里的NPD规则以获得详细的解释和示例。
  examples:
    bad:
      c:
        - |-
          extern int bar(int);

          int assign(int* a)
          {
           int i = bar(*a) // dereference a
           return i;
          }

          int foo(void)
          {
           int *p = 0; // p as a pointer has been initialized to 0 (null)
           assign(p);
          }
      java:
        - |-
          class User {
           public String getName() {
           return null;
           }
          }

          class Bar {
           private User findUser(String uid) {
           if (user.containsKey(uid)) {
           return user.get(uid);
           }
           else
           return null;
           }
           public void Npd(String uid) {
           // do something
           // ...
           User user = findUser(uid); // Throws NPE if \"user\" has not been properly initialized
           String getName() {
           return null;
           }
           }
          }
    good: {}
  language: c,c++
  likelihood: LIKELY
  master_id: 83
  msg_templ: 在${si.filename}行${si.line}行，函数${si.func}正通过带值的指针访问非法内存。
  name: 不要使用空指针来解除引用
  severity: HIGH
- category: VUL
  code: FIO47-C
  cost: LOW
  desc: 该程序正调用函数，其使用的参数个数与原型声明的参数个数不同。
  details: >
    #### 概要

    该程序正调用函数，其使用的参数个数与原型声明的参数个数不同。


    #### 解释

    在调用点里，传递的实际参数个数与函数声明里的参数个数不同。如果传递的实际参数比声明的要少，缺失的实际参数最终会变成\"wild\"，并可能发生不可预测的后果。
  examples:
    bad:
      c:
        - |-
          int foo(int a, int guard)
          {
              int x = 0;
              int result = 0;
              if (guard != 0)
                  result = a * x;

              // missing one parameter, and \"guard\" will have random value during execution at this point
              foo(result); 
              return 0;
          }
    good:
      c:
        - |-
          int foo(int a, int guard)
          {
              int x = 0;
              int result = 0;
              if (guard != 0)
                  result = a * x;
              foo(result, guard); // no parameters missing
              return 0;
          }
  language: c,c++
  likelihood: UNLIKELY
  master_id: 84
  msg_templ: >-
    在${si.filename}，第${si.line}行，${si.func}的参数与文件${si.filename}，第${si.line}行里的函数声明不匹配。
  name: 避免对格式字符串使用有冲突的类型
  severity: HIGH
- category: VUL
  code: MEM30-C
  cost: MEDIUM
  desc: 该程序正访问已被释放的内存。
  details: >
    #### 概要

    该程序正访问已被释放的内存。


    #### 解释

    使用已经释放的内存是悬空指针引用的一种形式。它通常会发生在内存对象被释放而其所指的指针未被更新的情况下。在再次使用指针时，指针会指向不正确的内存而导致未经授权的访问。
  examples:
    bad:
      c:
        - |-
          #include <stddef.h>

          int g = 2;

          void my_free(void *p)
          {
              if (p != NULL)
                  free(p); // free p
          }

          int main()
          {
              int i, j, *p, *q;
              p = malloc(10 * sizeof(int));
              if (p == NULL)
                  return 1;
              for (i = 0; i < 10; ++i)
                  p[i] = i;
              q = p;
              my_free(p); // p is freed
              j = 0;
              for (i = 0; i < 10; ++i)
                  j += q[i]; // Use after free here (note the statement q = p), read of q[i] is illegal
              return j;
          }
    good:
      c:
        - |-
          #include <stddef.h>

          int g = 2;

          void my_free(void *p)
          {
              if (p != NULL)
                  free(p); // free p
          }

          int main()
          {
              int i, j, *p, *q;
              p = malloc(10 * sizeof(int));
              if (p == NULL)
                  return 1;
              for (i = 0; i < 10; ++i)
                  p[i] = i;

              // do not free p

              j = 0;
              for (i = 0; i < 10; ++i)
                  j += q[i]; 
              return j;
          }
  language: c,c++
  likelihood: LIKELY
  master_id: 85
  msg_templ: 在${si.filename}行${si.line}行，函数${si.func}正访问已被释放的内存。
  name: 不应再次访问或使用已释放的内存
  severity: HIGH
- category: VUL
  code: MEM50-CPP
  cost: MEDIUM
  desc: 程序读取已经释放的指针变量，这可能会导致未定义行为。
  details: >
    #### 概要

    该程序在已释放了内存后引用了该内存。这可能导致程序崩溃或不可预测的程序行为。


    #### 解释

    释放后重用是悬空指针引用的一种形式。它通常发生在指针所指向的内存对象已被释放而指针未被更新时。该指针将指向不正确的内存，这在使用指针时会引起未经授权的访问。
  examples:
    bad:
      cpp:
        - |-
          int g = 2;

          void my_free(void *p) {
           if (p != NULL)
           free(p); // free p
          }

          int main() {
           int i, j, *p, *q;
           p = malloc(10 * sizeof(int));
           if (p == NULL)
           return 1;
           for (i=0; i < 10; ++i)
           p[i] = i;
           q = p;
           my_free(p); // p is freed
           j = 0;
           for (i=0; i < 10; ++i)
           j += q[i]; // Use after free here (note the statement q = p), read of q[i] is illegal
           return j;
          }
    good: {}
  language: c++
  likelihood: LIKELY
  master_id: 86
  msg_templ: >-
    在${so.filename}，第${so.line}行，${so.func}里使用了变量${so.var}。然而，此变量在${so.filename}第${so.line}行已被释放。
  name: 不应访问己释放的内存
  severity: HIGH
- alias: {}
  category: VUL
  code: MEM51-CPP
  cost: M
  csv_string:
    - m51P0
  desc: 程序无法适当地释放动态分配的内存。
  details: >
    #### 概要

    该程序已分配了堆内存，但未能释放那块内存。


    #### 解释

    分配了堆内存并且分配的内存地址存储在引用（指针）类型的变量里。该堆内存在其生命周期结束后从未被释放，其对应的引用仍然指向该内存空间。这可能会导致敏感数据泄漏或意外程序行为（例如拒绝服务）。
  examples:
    bad:
      cpp:
        - |-
          struct S {
           int *p;
          };

          int main() {
           int *p;
           struct S *s;
           p = malloc(10 * sizeof(int)); // heap memory allocated and pointed to by p
           if (p == NULL)
           return 1;
           s = (struct S*)malloc(sizeof(struct S)); // heap memory allocated and pointed to by s
           if (s == NULL) {
           free(p);
           return 1;
           }
           s->p = p;
           free(s); // only s is freed
           // s->p, which is copied from p is not freed
           return 0;
          }
    good: {}
  language: c++
  likelihood: L
  master_id: 87
  msg_templ: 在${si.filename}，第${si.line}行，${si.func}里的变量${si.var}未被释放。
  name: 分配的资源需要适当的释放
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '401'
- category: VUL
  code: EXP53-CPP
  cost: LOW
  desc: 程序尝试读取已声明但尚未初始化的内存。
  details: |
    #### 概要
    该程序在变量初始化前使用该变量。

    #### 解释
    C和C++里的栈变量默认为非初始化，并且非静态全局变量不默认为零。它们的初始值取决于调用函数时它们在内存中的位置里恰好有的值。这么做会导致意外程序行为。
  examples:
    bad:
      cpp:
        - |-
          int assign(int* a)
          {
           return *a; // dereference a
          }

          int main() {
           int a, b;
           b = assign(&a); // call assign with a uninitialized
           printf("value of b = %d\\", b);
           return 0;
          }
    good: {}
  language: c++
  likelihood: UNLIKELY
  master_id: 88
  msg_templ: 在${so.filename}，第${so.line}行，已经使用了${so.func}里的变量${so.var}但从未对其赋值。
  name: 禁止读取未初始化的内存
  severity: MEDIUM
- category: VUL
  code: EXP54-CPP
  cost: MEDIUM
  desc: 程序试图在对象的生存期之外访问该对象，这将导致未定义的行为。
  details: |
    #### 概要
    已使用了悬空指针来引用无效的内存资源。

    #### 解释
    悬空指针是引用无效或不正确的内存资源的指针。引用这些内存资源可能会造成内存损坏，从而导致不可预测的程序行为或系统不稳定。
  examples:
    bad:
      cpp:
        - |-
          int *assign()
          {
           int *c;
           c = 1;
           return &c;
          }

          int foo()
          {
           int *a;
           a = assign(); // return a stack address and assign to a
           printf(\"assigned value: %d\", a); // use dangling pointer
           return 0;
          }
    good: {}
  language: c++
  likelihood: UNLIKELY
  master_id: 89
  msg_templ: >-
    在${so.filename}，第${so.line}行，使用了${so.func}里的内存引用变量${so.var}。该变量首次被赋值为内存引用，这在${so.filename}的第${so.line}行可能无效。
  name: 仅在对象的生存期内访问该对象
  severity: HIGH
- alias: {}
  category: VUL
  code: ERR00-J
  cost: M
  csv_string:
    - E00J0
  desc: 该程序有带空catch块的异常构造。
  details: |+
    #### 概要
    异常必须得到适当处理。

    #### 解释
    异常会破坏应用程序的预期控制流。 catch块必须从异常条件中恢复，或者抛出适合于catch块上下文的异常。

  examples:
    bad:
      java:
        - |-
          import java.io.*;

          public class j_err00_0 {

           public void foo0(String fileName) {
           try {
           BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));
           int b;
           while ((b = reader.read()) != -1) {
           System.out.println("byte: " + b);
           }
           } catch (IOException ioe) {
           ioe.printStackTrace(); // print will not recover nor throw exception 
           }
           }

           public void foo1(String fileName) {
           try {
           BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));
           int b;
           while ((b = reader.read()) != -1) {
           System.out.println("byte: " + b);
           }
           } catch (IOException ioe) {
           // do nothing - no recovery of any kind
           }
           }
          }
    good:
      java:
        - |
          import java.io.*;

          public class j_err00_0 {

           public void foo0(String fileName) {
           try {
           BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));
           int b;
           while ((b = reader.read()) != -1) {
           System.out.println("byte: " + b);
           }
           } catch (IOException ioe) {
           throw new IllegalIOException(ioe.toString()); // we assume there is such exception handler here
           }
           }

           public void foo1(String fileName) {
           // indentation preserved to better show the difference with \"avoid\" example
           BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));
           int b;
           while ((b = reader.read()) != -1) {
           System.out.println("byte: " + b);
           }

           }
          }
  language: Java
  likelihood: P
  master_id: 90
  msg_templ: 在${si.filename}，${si.func}里第${si.line}行的catch块是空的。
  name: 空的异常catch块
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: L
  standards:
    cwe:
      - '223'
    owasp:
      - A10
- alias: {}
  category: VUL
  code: FIO08-J
  cost: M
  csv_string:
    - F08J0
  desc: 程序无法区分read（）方法读取的字符和流结束指示符。
  details: >-
    #### 概要

    程序无法区分read()方法读取的字符和流结束指示符。


    #### 解释

    用InputStream.read()和Reader.read()来读字节流，字节流以32位的数值-1结尾。正确的检查应当在字节流转换成字节或者字符之前。
  examples:
    bad:
      java:
        - >-
          // read result is cast to byte, loop will halt prematurely if 0xFF is
          reached

          public class j_fio08_0 {
            // ... 
            static void readData(String fileName) throws FileNotFoundException, IOException {
              FileInputStream t = new FileInputStream(fileName);
              try {
                byte data;
                StringBuffer value = new StringBuffer();
                while((data = (byte) t.read()) != -1) {
                  value.append(data);
                }
                System.out.println(value.toString());
              } finally {
                t.close();
              }
            }

            static void readData2(String fileName) throws IOException {
              FileReader fr = new FileReader(fileName);
              try {
                char data;
                StringBuffer sb = new StringBuffer();
                while ((data = (char) fr.read()) != -1) {
                  sb.append(data);
                }
              } finally {
                fr.close();
              }
            }

            static void readData3(String fileName) throws IOException {
              FileReader fr = new FileReader(fileName);
              try {
                byte data;
                StringBuffer sb = new StringBuffer();
                while (true) {
                  int i = fr.read();
                  int j = i;
                  data = (byte) j;
                  if (data == -1) {
                    break;
                  }
                  sb.append(data);
                }
              } finally {
                fr.close();
              }
            }
    good:
      java:
        - "// read result is cast to byte after read and check for end of stream\npublic class j_fio08_0 {\n\n  // ...\n\n  static void readData(String fileName) throws FileNotFoundException, IOException {\n    FileInputStream t = new FileInputStream(fileName);\n    try {\n      int inputbuf;\n      byte data;\n      StringBuffer value = new StringBuffer();\n      while((inputbuf = t.read()) != -1) {\n\tdata = (byte) inputbuf;\n        value.append(data);\n      }\n      System.out.println(value.toString());\n    } finally {\n      t.close();\n    }\n  }\n\n  static void readData2(String fileName) throws IOException {\n    FileReader fr = new FileReader(fileName);\n    try {\n      int inputbuf;\n      char data;\n      StringBuffer sb = new StringBuffer();\n      while (inputbuf = fr.read()) != -1) {\n\tdata = (char)inputbuf;\n        sb.append(data);\n      }\n    } finally {\n      fr.close();\n    }\n  }\n\n  static void readData3(String fileName) throws IOException {\n    FileReader fr = new FileReader(fileName);\n    try {\n      byte data;\n      StringBuffer sb = new StringBuffer();\n      while (true) {\n        int i = fr.read();\n        int j = i;\n        data = (byte) j;\n        if (data == -1) {\n          break;\n        }\n        sb.append(data);\n      }\n    } finally {\n      fr.close();\n    }\n  }"
  language: Java
  likelihood: P
  master_id: 91
  msg_templ: 在${si.filename}，第${si.line}行，${si.func}无法区分read()方法读取的字符和流结束指示符。
  name: 从流读取的字符或字节与-1是不同的
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- alias: {}
  category: VUL
  code: FIO30-C
  cost: M
  csv_string:
    - F30C1
    - F30C0
  desc: 该程序含有的格式规范包含了char类型（即字符串）参数，其来源不受信任，因此被认定为已受污染。
  details: |
    #### 概要
    该程序含有的格式规范包含了char类型（即字符串）参数，其来源不受信任，因此被认定为已受污染。

    #### 解释
    格式化的I/O函数可能会被诱导去覆盖或读取任意内存位置的值。当输入来源不受信任时，最好不要使用格式字符串以及相关函数来执行I/O操作。
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>

          int main(int argc, char *argv[])
          {
           int var_to_hold_content; // the variable where printf will store content of an address
           if (argc > 2) {
           scanf(argv[1]); // get a string from stdin (user input)
           printf(argv[1]); // user can read any address to a variable using a format specification
           }
          }
    good:
      c:
        - |-
          #include <stdio.h>

          int main(int argc, char *argv[])
          {
           int var_to_hold_content; // the variable where printf will store content of an address
           if (argc > 2) {
           scanf(argv[1]); // get a string from stdin (user input)
           fputs(argv[1, stdout]); // do not use printf with format specification
           }
          }
  language: c,c++
  likelihood: L
  master_id: 92
  msg_templ: >-
    在${si.filename}，第${si.line}行的函数${si.func}，在${si.var}调用了printf调用函数族，它有来自用户输入的未经清理的格式字符串。
  name: 格式规范中的字符串参数来自不受信任的源头
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '20'
      - '134'
    owasp:
      - A1
      - A5
- alias: {}
  category: VUL
  code: MSC41-C
  cost: M
  csv_string:
    - M41C2
    - M41C1
    - M41C0
  desc: 该程序有可读取形式的硬编码敏感信息（例如密码、密钥）。
  details: |
    #### 概要
    该程序有可读取形式的硬编码敏感信息（例如密码、密钥）。

    #### 解释
    即使在可执行文件里，字符串或其它可读取形式的敏感信息都是可以被检查到的。
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>

          #define BUF_SZ 1024

          int check_passwd(const char *s);

          int func(void)
          {
              // program logic
              // ...

              // sensitive data is revealed below 
              if (check_passwd("admin"))
              {
                  // ... continue
              }
              else
              {
                  // handle error
                  // ...
              }
          }
    good:
      c:
        - |+
          #include <stdio.h>

          int check_passwd(const char *s);

          int func(void)
          {
              // user inputs password so no sensitive
              // data leaked
              #define PASSWORD_LEN 10
              char password[PASSWORD_LEN];
              printf("Please enter your password:\n");
              fgets(password, sizeof(password), stdin);

              int check = check_passwd(password);
              memset_s(password, 0, sizeof(password));
              // program logic
              // ...
              if (check)
              {
                  // ... continue
              }
              else
              {
                  // handle error
                  // ...
              }
          }

  language: c,c++
  likelihood: P
  master_id: 93
  msg_templ: 在${si.filename}，第${si.line}行的函数${si.func}，有可读取的硬编码敏感信息。
  name: 不应暴露程序中硬编码的敏感信息
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '798'
      - '311'
      - '259'
    owasp:
      - A3
      - A1
      - A5
- alias: {}
  category: VUL
  code: FIO52-J
  cost: M
  csv_string:
    - F52J2
    - F52J1
    - F52J0
  desc: 程序在客户端存储了未加密的敏感信息。
  details: |
    #### 概要
    程序在客户端存储了未加密的敏感信息。

    #### 解释
    如果在客户端提供并存储了未加密的敏感信息，则攻击者可以直接或间接地获取这些信息来攻击客户端计算机。
  examples:
    bad:
      java:
        - |-
          import javax.servlet.ServletException;
          import javax.servlet.annotation.WebServlet;
          import javax.servlet.http.HttpServlet;
          import javax.servlet.http.HttpServletRequest;
          import javax.servlet.http.HttpServletResponse;
          import javax.servlet.http.Cookie;
          interface Login {
           public Boolean isUserValid(String userName, char[] passwd);
          }

          class LoginImpl implements Login {
           public Boolean isUserValid(String userName, char[] passwd) {
           // do the checking
           return true;
           }
          }

          public class fio52_0 {
           protected void doPost(HttpServletRequest request, HttpServletResponse response) {
           
           String username = request.getParameter("username");
           char[] password = request.getParameter("password").toCharArray();
           String userInfo = request.getParameter("userInfo");
           
           Login login = new LoginImpl();
           
           if (request.getCookies()[0] != null &&
           request.getCookies()[0].getValue() != null) {
           String[] value = request.getCookies()[0].getValue().split(";");
           
           if (!login.isUserValid(value[0], value[1].toCharArray())) {
           // Set error and return
           } else {
           // Forward to welcome page
           }
           } else {
           boolean validated = login.isUserValid(username, password);
           
           if (validated) {
           Cookie loginCookie = new Cookie("MyCookie", username + ";" + new String(password));
           Cookie infoCookie = new Cookie("userInfo", username + ":" + userInfo);
           loginCookie.setSecure(false); // set loginCookie sent by any protocol
           response.addCookie(loginCookie); // [FIO52-J] sensitive cookie, should be encrypted or sent through secure protocol 
           infoCookie.setSecure(true); // set infoCookie sent by secure protocol
           \t response.addCookie(infoCookie);
           \t 
           // ... Forward to welcome page
           } else {
           // Set error and return
           }
           }
           } 
          }
    good:
      java:
        - |-
          import javax.servlet.ServletException;
          import javax.servlet.annotation.WebServlet;
          import javax.servlet.http.HttpServlet;
          import javax.servlet.http.HttpServletRequest;
          import javax.servlet.http.HttpServletResponse;
          import javax.servlet.http.Cookie;
          interface Login {
           public Boolean isUserValid(String userName, char[] passwd);
          }

          class LoginImpl implements Login {
           public Boolean isUserValid(String userName, char[] passwd) {
           // do the checking
           return true;
           }
          }

          public class fio52_0 {
           protected void doPost(HttpServletRequest request, HttpServletResponse response) {
           
           String username = request.getParameter("username");
           char[] password = request.getParameter("password").toCharArray();
           String userInfo = request.getParameter("userInfo");
           
           Login login = new LoginImpl();
           
           if (request.getCookies()[0] != null &&
           request.getCookies()[0].getValue() != null) {
           String[] value = request.getCookies()[0].getValue().split(";");
           
           if (!login.isUserValid(value[0], value[1].toCharArray())) {
           // Set error and return
           } else {
           // Forward to welcome page
           }
           } else {
           boolean validated = login.isUserValid(username, password);
           
           if (validated) {
           Cookie loginCookie = new Cookie("MyCookie", username + ";" + new String(password));
           Cookie infoCookie = new Cookie("userInfo", username + ":" + userInfo);
           loginCookie.setHttpOnly(true); // use http protocol only
           loginCookie.setSecure(true); // set loginCookie through secure protocol
           response.addCookie(loginCookie); // sensitive cookie is encrypted and sent through secure protocol 
           infoCookie.setSecure(true); // set infoCookie sent by secure protocol
           response.addCookie(infoCookie);
            
           // ... Forward to welcome page
           } else {
           // Set error and return
           }
           }
           } 
          }
  language: Java
  likelihood: L
  master_id: 94
  msg_templ: 在${si.filename}，${si.func} 第${si.line}行，未加密的敏感数据经過${si.var}存储在客户端。
  name: 存储在客户端的敏感信息，应进行加密
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '522'
      - '200'
      - '312'
    owasp:
      - A2
      - A3
- alias: {}
  category: VUL
  code: IDS07-J
  cost: M
  csv_string:
    - I07J1
    - I07J0
  desc: 该程序将不受信任数据作为输入传递给了Runtime.exec()方法。
  details: |
    #### 概要
    该程序将不受信任数据作为输入传递给了Runtime.exec()方法。

    #### 解释
    传递给Runtime.exec()的不受信任数据会暴露系统使其受到参数注入攻击。字符串必须经过安全清理来删除像空格、双引号和“-”这样的字符。
  examples:
    bad:
      java:
        - |
          import java.io.InputStream;

          public class ids07_0 { // example from CERT-J
           public static void main(String[] args) throws Exception {
           
           // dir is input from environment in which the app is running
           String dir = System.getProperty(\"dir\");
           Runtime rt = Runtime.getRuntime();
           
           // input from environment is directly concatenated and fed to Runtime.exec
           // Subject to command line injection
           Process proc = rt.exec(\"bash -c ls \" + dir);
           
           int result = proc.waitFor();
           if (result != 0) {
           System.out.println(\"process error: \" + result);
           }
           // continue processing
           // ...
           }
          }
    good:
      java:
        - |
          import java.io.InputStream;

          public class ids07_0 { // example from CERT-J
           public static void main(String[] args) throws Exception {
           
           // dir is input from environment in which the app is running
           String dir = System.getProperty(\"dir\");
           if (!Pattern.matches(\"[0-9A-Za-z@.]+\", dir) { // whitelist characters allowed
           // report error and exit
           ...
           }
           Runtime rt = Runtime.getRuntime();
           
           // input from environment is directly concatenated and fed to Runtime.exec
           // Subject to command line injection
           Process proc = rt.exec(\"bash -c ls \" + dir);
           
           int result = proc.waitFor();
           if (result != 0) {
           System.out.println(\"process error: \" + result);
           }
           // continue processing
           // ...
           }
          }
  language: Java
  likelihood: P
  master_id: 95
  msg_templ: 在${si.filename}，第${si.line}行的字符串${si.var}在传递给runtime()之前未经过清理。
  name: 请勿把不受信任数据作为输入传递给Runtime.exec()方法
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '78'
      - '917'
    owasp:
      - A1
    p3c-sec:
      - '4'
- alias: {}
  category: VUL
  code: IDS15-J
  cost: H
  csv_string:
    - I15J2
    - I15J1
    - I15J0
  desc: 应该要保持敏感数据的安全性，这包括输入和输出数据。
  details: |
    #### 概要
    应该要保持敏感数据的安全性，包括输入和输出数据边界泄漏。

    #### 解释
    敏感信息不应该被允许跨越信任边界而泄漏，这有助于保持复杂系统里不同子系统的完整性和安全性。 
  examples:
    bad:
      java:
        - |-
          import javax.servlet.http.HttpServletRequest;

          public class j_ids15_0
          {
           public void setSession(HttpServletRequest request, String attrName, String attrValue) {
           request.getSession().setAttribute(attrName, attrValue);
           }

           public void configSession(HttpServletRequest request) {
           String value = request.getParameter(\"Config\");
           String data = System.getenv(\"APP_DATA\");
           if(value.startsWith(\"APP_DATA\")) {
           setSession(request, \"APP_DATA\", data); // sensitive data
           } else if(value.startsWith(\"SAFE_DATA\")) {
           String safeData = Encryption(data);
           setSession(request, \"SAFE_DATA\", safeData); // data sanitized
           } else {
           setSession(request, \"attr\", \"value\");
           }
           }

           public String Encryption(String data) {
           // encrypt the input data
           // ...
           String safeData = data.replace(\"a\", \"z\");
           return safeData;
           }
          }
    good: {}
  language: Java
  likelihood: L
  master_id: 96
  msg_templ: 在${si.filename}，第${si.line}行，${si.func}中的敏感数据${si.var}有跨越信任边界而泄漏的情况。
  name: 应安全清理/规范化敏感数据（输入和输出）
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '523'
      - '200'
      - '284'
    owasp:
      - A2
      - A5
    p3c-sec:
      - '1'
      - '7'
- alias: {}
  category: VUL
  code: MSC03-J
  cost: M
  csv_string:
    - M03J0
  desc: 该程序硬编码了敏感信息。
  details: |
    #### 概要
    该程序硬编码了敏感信息。

    #### 解释
    安全和隐私敏感型信息应该在执行时从安全的文件里取回。Java可执行文件是字节码的形式，它能轻易地转换回有纯文本形式信息的源代码形式。
  examples:
    bad:
      java:
        - |-
          import java.net.InetAddress;
          import java.net.UnknownHostException;
          import java.sql.Connection;
          import java.sql.DriverManager;
          import java.sql.SQLException;

          public class msc03_0 {
           public final Connection getConnection() throws SQLException, UnknownHostException {
           
           // hard coded IP address in String
           String ipAddress = new String(\"184.15.254.1\");
           if (InetAddress.getByName(ipAddress).isAnyLocalAddress()){
           // hard coded username and password
           return DriverManager.getConnection(\"dbhost:mysql://localhost/mydb\", \"7f4j9vj\", \"xsi9j2nn8\");
           }
           return DriverManager.getConnection(\"dbhost:mysql://localhost/dbName\", \"username\", \"password\");
           }
          }
    good:
      java:
        - |
          import java.net.InetAddress;
          import java.net.UnknownHostException;
          import java.sql.Connection;
          import java.sql.DriverManager;
          import java.sql.SQLException;

          public class msc03_0 {
           public final Connection getConnection() throws SQLException, UnknownHostException {
           
           // IP address class to fill in at runtime. The address should be cleared immediately after use
           class IPAddress {
           // IP address in string
           char[] ipAddress = new char[128];
           try {
           // read in from some secure channel or file
           ...
           }
           finally {
           // clear after use
           Arrys.fill(ipAddress, (byte)0);
           // close file or channel
           ...
           }
           
           }
           if (InetAddress.getByName(ipAddress).isAnyLocalAddress()){
           // hard coded username and password
           String username, password;
           // Username and password should be read from a secure config file/channel at rungime
           return DriverManager.getConnection(\"dbhost:mysql://localhost/mydb\", username, password);
           }
           return DriverManager.getConnection(\"dbhost:mysql://localhost/dbName\", \"username\", \"password\");
           }
          }
  language: Java
  likelihood: P
  master_id: 97
  msg_templ: 在${si.filename}，第${si.line}行，函数${si.func}中，${si.var}有硬编码的敏感信息。
  name: 不要把敏感信息硬编码在程序中
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '798'
    owasp:
      - A3
- alias: {}
  category: VUL
  code: OBJ07-J
  cost: M
  csv_string:
    - O07J1
    - O07J0
  desc: 具有敏感数据的类应受到保护, 不被复制或克隆。
  details: |
    #### 概要
    具有敏感数据的类应受到保护, 不被复制或克隆.

    #### 解释
    具有敏感数据的类在被恶意克隆或复制时，可能会导致违反关键数据不变属性的线程安全问题。
  examples:
    bad:
      java:
        - |-
          public class j_obj07_sensitive
          {
           private String userName;
           private char[] passwd;

           public j_obj07_sensitive(String name, char[] pass) { // OBJ07-J: class not provide clone throw exception and mark final
           userName = name;
           passwd = pass;
           } 

           public String getUserName() {
           return userName;
           }

           public char[] getPasswd() {
           return passwd;
           }

           protected void resetPasswd() {
           for(int i = 0; i < passwd.length; i++) {
           passwd[i] = 'a';
           }
           }

           void display() {
           System.out.println(\"UserName addr:\" + System.identityHashCode(userName));
           System.out.println(\"Passwd addr:\" + System.identityHashCode(passwd));
           System.out.print(\"User:\" + userName + \" passwd:\");
           System.out.println(passwd);
           }

          }
    good:
      java:
        - |
          public class j_obj07_fp_1 
          {
           private String userName;
           private char[] passwd;

           public j_obj07_fp_1(String name, String pass) {
           userName = name;
           passwd = pass.toCharArray();
           }

           // [certj pages]
           // sensitive class define clone() and throws CloneNotSupportedException
           // and clone() method marked finalclone
           // Well behaved clone that prevents subclasses from being made cloneable by defining a final clone that always fails
           public final j_obj07_fp_1 clone() throws CloneNotSupportedException {
           throw new CloneNotSupportedException();
           }

           void resetPasswd() {
           for(int i = 0; i < passwd.length; i++) {
           passwd[i] = 'a';
           } 
           }

           void display() {
           System.out.println(\"UserName addr:\" + System.identityHashCode(userName));
           System.out.println(\"Passwd addr:\" + System.identityHashCode(passwd));
           System.out.print(\"User:\" + userName + \" passwd:\");
           System.out.println(passwd);
           }

           public static void main(String[] args) {
           j_obj07_fp_1 obj1= new j_obj07_fp_1(\"user1\", \"abcdef\");
           try {
           j_obj07_fp_1 obj2 = (j_obj07_fp_1)obj1.clone();
           obj2.resetPasswd();
           obj1.display();
           obj2.display();
           } catch (CloneNotSupportedException e) {
           System.out.println(\"Error: clone is not allowed for sensitive class\");
           }
           }
          }
  language: Java
  likelihood: P
  master_id: 98
  msg_templ: 在${si.filename}，第${si.line}行，${si.var}是可以被复制或克隆的。
  name: 具有敏感数据的类应受到保护，防止被复制或克隆
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '498'
    owasp:
      - A3
      - A5
- alias: {}
  category: VUL
  code: SEC01-J
  cost: L
  csv_string:
    - C01J2
    - C01J1
    - C01J0
  desc: 该程序在权限代码块里有不受信任数据。
  details: |
    #### 概要
    该程序在权限代码块里有不受信任数据。

    #### 解释
    不受信任数据可能含有特殊字符，它最终会形成受污染的路径或文件名。攻击者能利用进入权限代码块的受污染数据以达到恶意企图。
  examples:
    bad:
      java:
        - |-
          import java.io.FileInputStream;
          import java.io.FileNotFoundException;
          import java.security.AccessController;
          import java.security.PrivilegedActionException;
          import java.security.PrivilegedExceptionAction;

          public class sec01_0 { // edited from CERT-J example
           // input file name may be tainted since origin is unknown
           // should have gone through sanitization and normalization before 
           // enter the doPrivileged() block
           private void privilegedMethod(final String filename)
           throws FileNotFoundException {
           try {
           FileInputStream fis =
           (FileInputStream) AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () -> {
           return new FileInputStream(filename);
           });
           // Do something with the file and then close it
           } catch (PrivilegedActionException e) {
           // Forward to handler
           }
           }
          }
    good:
      java:
        - |-
          import java.io.FileInputStream;
          import java.io.FileNotFoundException;
          import java.security.AccessController;
          import java.security.PrivilegedActionException;
          import java.security.PrivilegedExceptionAction;

          public class sec01_0 { // edited from CERT-J example
           // input file name gone through sanitization and normalization before 
           // enter the doPrivileged() block
           }
           private void privilegedMethod(final String filename)
           throws FileNotFoundException {
           
           final String sanitizeFilename;
           try {
           sanitizeFilename = sanitizeFilename(filename);
           } catch {
           // call handler appropriately 
           ...
           }
           
           try {
           FileInputStream fis =
           (FileInputStream) AccessController.doPrivileged((PrivilegedExceptionAction<Object>) () -> {
           return new FileInputStream(filename);
           });
           // Do something with the file and then close it
           } catch (PrivilegedActionException e) {
           // Forward to handler
           }
           }
          }
  language: Java
  likelihood: L
  master_id: 99
  msg_templ: '在${si.filename}，第${si.line}行，敏感信息可能已经通过${si.func}中的${si.var}被泄露。 '
  name: 不允许在权限代码块里有不受信任数据
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '732'
      - '266'
      - '272'
    owasp:
      - A2
      - A5
      - A3
- category: VUL
  code: DCL55-CPP
  cost: LOW
  desc: 程序中有类别的填充位可能含有敏感数据。使用后,它们并未被清除。
  details: ''
  examples:
    bad: {}
    good: {}
  language: c++
  likelihood: UNLIKELY
  master_id: 100
  msg_templ: ''
  name: 当跨信任边界传输类对象时发生信息泄漏
  severity: LOW
- alias: {}
  category: VUL
  code: ENV01-J
  cost: M
  csv_string:
    - N01J0
  desc: 程序经过代码签名以验证代码的来源。这样的代码会包含一些执行特权操作的代码。
  details: >+
    #### Abstract

    The program is code signed to authenticate the origin of the code. Such code
    should contain some code that performs privileged operations.


    #### Explanation

    Code signing is usually taken as trusted and safe to execute code. Many
    systems are configured to \"Always trust\". The implied permission can
    easily be exploited.

  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: P
  master_id: 101
  msg_templ: ''
  name: 应在单个JAR里签名并密封对安全性敏感的代码
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '349'
    owasp:
      - A2
- category: VUL
  code: FIO21-C
  cost: MEDIUM
  desc: 程序在共享目录中创建了临时文件，但没有删除或防止访问程序来避免共享目录受到攻击。
  details: >
    ### 概要

    程序在共享目录中创建了临时文件，但没有删除或防止访问程序来避免共享目录受到攻击。


    #### 解释

    当数据需要从一个进程传输到另一个而不能保存在内存中的时候，创建临时文件通常被用作传输数据的一种方式。如果对于这些临时文件没有清理操作，或者临时文件名是可预测的，那么就容易造成攻击者攻击这些临时文件。要是这些临时文件包含敏感信息，那么后果将会非常严重。
  examples:
    bad:
      c:
        - |-
          void func(const char * file_name) {
          FILE *fp=fopen(file_name),"wb+";
          if(fp == NULL){
          return
          }
          // write to file ...
          fclose(fp)
          }
    good: {}
  language: c,c++
  likelihood: LIKELY
  master_id: 102
  msg_templ: ''
  name: 临时文件不应存储在共享目录中
  severity: HIGH
- category: VUL
  code: DCL56-CPP
  cost: MEDIUM
  desc: 程序在初始化静态对象时进行递归调用。因此可能有无序的初始化，这样递归也可能会导致意外的行为。
  details: ''
  examples:
    bad: {}
    good: {}
  language: c++
  likelihood: UNLIKELY
  master_id: 103
  msg_templ: ''
  name: 静态对象的初始化不应具有循环依赖关系
  severity: LOW
- category: VUL
  code: FIO51-CPP
  cost: MEDIUM
  desc: 在程序终止之前程序未有关闭已打开的文件。
  details: ''
  examples:
    bad: {}
    good: {}
  language: c++
  likelihood: UNLIKELY
  master_id: 104
  msg_templ: 在${si.filename}，第${si.line}行，${si.func}在程序终止之前未关闭已打开的文件。
  name: 在程序终止前应关闭文件
  severity: MEDIUM
- category: VUL
  code: MEM52-CPP
  cost: MEDIUM
  desc: 默认的allocators不会检查allocation的结果，即使它产生任何异常。任何错误都必须被捕捉和处理。
  details: >
    ### 概要

    默认的allocators不会检查allocation的结果，即使它产生任何异常。任何错误都必须被捕捉和处理。


    #### 解释

    C++中最常用的内存分配操作程序为::operator new(std::size_t)，
    当分配失败时，会抛出std::bad_alloc。新的分配操作程序也有不抛出错误的版本::operator new(std::size_t, const
    std::nothrow_t&)，会给出nullptr而不抛出异常。不论何种分配操作程序，都应该有对应错误检查的功能。异常必须通过catch来处理，而nullptr也应该被检查，来避免程序的突然终止  
  examples:
    bad:
      cpp:
        - |-
          #include <cstring>
          #include <new>

           void f(std::size_t size) noexcept {
          int *var = new int[size];
          var[0]=5;
          delete[] var;
          }
    good: {}
  language: c++
  likelihood: LIKELY
  master_id: 105
  msg_templ: ''
  name: 内存分配失败应得到适当处理
  severity: HIGH
- category: VUL
  code: MSC50-CPP
  cost: LOW
  desc: 程序使用了std:：rand（），对于随机数序列不是一个好的选择。
  details: >
    ### 概要

    程序使用了std::rand()，对于随机数序列不是一个好的选择。


    #### 解释

    伪数字生成器譬如rand()运用数学算法使得产生的数字不是完全随机。由std::rand()产生的数字，由于其周期相对较短，因此对随机数序列来说质量还不够好。因此，不建议使用rand() 
  examples:
    bad:
      cpp:
        - |-
          #include <iostream>
          #include<string>

          void func(void){
          std::string id{\"id\"};
          id += std::to_string(std::rand()%1000);
          }
    good: {}
  language: c++
  likelihood: UNLIKELY
  master_id: 106
  msg_templ: ''
  name: '使用比std :: rand（）更强的伪随机数生成器'
  severity: MEDIUM
- category: VUL
  code: MSC52-CPP
  cost: MEDIUM
  desc: 程序具有non-void return函数，但该函数有执行路径将到达出口而不会遇到“return”语句。
  details: |
    ### 概要
    程序具有non-void return函数，但该函数有执行路径将到达出口而不会遇到“return”语句。 

    #### 解释
    当调用函数时会预期有返回指，然后不是所有的代码路径都会返回一个值，而这可能会造成未定义的行为。 
  examples:
    bad:
      cpp:
        - |-
          int get_number(int x){
          if(x>=1 && x<=10) return x;
          }
    good: {}
  language: c++
  likelihood: PROBABLE
  master_id: 107
  msg_templ: >-
    在${si.filename}，第${si.line}行，${si.func}虽然有non-void
    return但在该函数结束时都不会遇到return语句。
  name: 有返回值的函数必须确保所有退出路径都返回一个值
  severity: MEDIUM
- category: VUL
  code: OBJ05-J
  cost: MEDIUM
  desc: 程序正在返回声明为非公开的可变类成员的引用。
  details: |
    #### 概要
    程序正在返回声明为非公开的可变类成员的引用。

    #### 解释
    返回声明为非公开的可变类成员的引用会造成解封并可能引发非公开对象被不可信任的方法操作调用。
  examples:
    bad:
      java:
        - |
          import java.util.Date;

          public class obj05_0 {
              private Data private_d;

              // this class is mutable
              public obj05_0() {
                  // private_d is declared private, and is being returned 
                  // thus exposes the internal mutable component to untrustable caller
                  private_d = new Data();
          }

          public Data getData() {
              return private_d;
          }

          }
    good:
      java:
        - |
          import java.util.Date;

          public class obj05_0 {
           private Data private_d;

           // this class is mutable
           public obj05_0() {
           private_d = new Data();
           }

           // a copy is returned, hence, no leakage using this method
           public Data getDataSafe() {
           return (Data)d.clone();
           }
          }
  language: Java
  likelihood: PROBABLE
  master_id: 108
  msg_templ: ''
  name: 不应返回并暴露非公开且可变的类成员的引用
  severity: HIGH
- category: VUL
  code: ENV02-J
  cost: LOW
  desc: 程序对环境变量的使用可能被利用为攻击的漏洞。
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: LIKELY
  master_id: 109
  msg_templ: ''
  name: ' 环境变量应视为不可信'
  severity: LOW
- category: VUL
  code: ENV04-J
  cost: LOW
  desc: Java类有文件未进行验证, 这些文件可能来自不受信任的来源。
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: LIKELY
  master_id: 110
  msg_templ: ''
  name: 不应关闭字节码验证
  severity: HIGH
- category: VUL
  code: ENV05-J
  cost: LOW
  desc: 程序无法禁用远程监视。
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: PROBABLE
  master_id: 111
  msg_templ: ''
  name: 不应在产品中部署远程监视的应用程序
  severity: HIGH
- alias: {}
  category: VUL
  code: JNI01-J
  cost: L
  csv_string:
    - J01J0
  desc: 程序通过loadLibrary方法代表不受信任的代码来调用标准API。
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: L
  master_id: 112
  msg_templ: ''
  name: 安全地调用标准API
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards: {}
- alias: {}
  category: VUL
  code: OBJ01-J
  cost: M
  csv_string:
    - O01J0
  desc: 程序可能通过使用公有成员修饰符暴露敏感字段。
  details: |
    #### 概要
    程序可能通过使用公有成员修饰符暴露敏感字段。
  examples:
    bad:
      java:
        - |-
          import java.util.List;

          public class j_obj01_0 {

            private static final String[] items = {"abc", "def", "ghj"/* ... */};

            public static final List<String> itemsList =
              Collections.unmodifiableList(Arrays.asList(items));

            public static final String[] getItems() {
              return items.clone();
            }
            public static final String getItem(int index) {
              return items[index];
            }

            public static final int getItemCount() {
              return items.length;
            }

            private static final HashMap<Integer, String> hm = new HashMap<Integer, String>();

            public static String getElement(int key) {
              return hm.get(key);
            }

            public int total; // Unprotected

            public int getTotal () {
              return total;
            }

          }
    good:
      java:
        - |-
          import java.util.List;

          public class j_obj01_0 {

            private static final String[] items = {"abc", "def", "ghj"/* ... */};

            public static final List<String> itemsList =
              Collections.unmodifiableList(Arrays.asList(items));

            public static final String[] getItems() {
              return items.clone();
            }
            public static final String getItem(int index) {
              return items[index];
            }

            public static final int getItemCount() {
              return items.length;
            }

            private static final HashMap<Integer, String> hm = new HashMap<Integer, String>();

            public static String getElement(int key) {
              return hm.get(key);
            }

            private int total; // Declared private

            public int getTotal () {
              return total;
            }

          }
  language: Java
  likelihood: L
  master_id: 113
  msg_templ: ''
  name: 对象的字段访问必须正确管理
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '766'
    owasp:
      - A5
- alias: {}
  category: VUL
  code: OBJ13-J
  cost: L
  csv_string:
    - O13J1
    - O13J0
  desc: 程序会引用可变对象並且公开给用户端，在用户端可以自由修改。
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: L
  master_id: 114
  msg_templ: ''
  name: 对可变对象的引用不应显示给客户端
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    owasp:
      - A2
      - A3
- alias: {}
  category: VUL
  code: SEC03-J
  cost: M
  csv_string:
    - C03J1
    - C03J0
  desc: 程序可以允许来自不受信任来源的类加载器加载受信任的类。
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: P
  master_id: 115
  msg_templ: ''
  name: 受信任类必须由受信任类加载器加载
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '269'
      - '284'
    owasp:
      - A5
      - A2
- alias: {}
  category: VUL
  code: SEC04-J
  cost: M
  csv_string:
    - C04J2
    - C04J1
    - C04J0
  desc: 程序允许绕过安全管理器检查的敏感方法调用。
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: P
  master_id: 116
  msg_templ: ''
  name: 应该用适当的security manager来检查及保护敏感操作
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '284'
      - '285'
    owasp:
      - A5
      - A3
      - A6
- alias: {}
  category: VUL
  code: SEC05-J
  cost: M
  csv_string:
    - C05J0
  desc: 程序有使用Java反射API来改变某些字段的可访问性。
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: P
  master_id: 117
  msg_templ: ''
  name: 不要使用反射来修改类，方法或字段的可访问性
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '269'
- alias: {}
  category: VUL
  code: SER01-J
  cost: L
  csv_string:
    - R01J0
  desc: 程序未正确使用序列化方法的签名。
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: L
  master_id: 118
  msg_templ: ''
  name: 在生成自定义序列化方法时，请遵循正确的签名
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '502'
    owasp:
      - A8
- category: VUL
  code: SER04-J
  cost: HIGH
  desc: 程序在不进行安全检查的情况下进行序列化，会导致允许不受信任的代码修改类的内部状态。
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: PROBABLE
  master_id: 119
  msg_templ: ''
  name: 序列化和反序列化应通过安全管理器
  severity: HIGH
- alias: {}
  category: VUL
  code: SER05-J
  cost: M
  csv_string:
    - R05J0
  desc: 程序包含实现Serializable接口的内部类。
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: L
  master_id: 120
  msg_templ: ''
  name: 避免内部类的序列化
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards: {}
- category: VUL
  code: SER08-J
  cost: MEDIUM
  desc: 程序会在特权上下文中执行反序列化。
  details: ''
  examples:
    bad: {}
    good: {}
  language: Java
  likelihood: LIKELY
  master_id: 121
  msg_templ: ''
  name: 如果反序列化需要特权，应将权限剥离到预期使用的最低限度
  severity: HIGH
- alias: {}
  category: VUL
  code: IDS53-J
  cost: L
  csv_string:
    - I53J1
    - I53J0
  desc: 用来从XML获取数据的字符串在输入前需要进行适当清理
  details: >-
    #### 概要

    此程序正在使用字符串输入从XML文档中检索数据，然而此输入在检索前未经过适当清理。


    #### 解释

    此程序正在使用字符串输入从XML文档中检索数据，然而此输入并未经过充分清理和验证。这有可能会发生恶意用户定制SQL或者XML检索输入使得结果恒真，从而使攻击者访问到受限信息。
  examples:
    bad:
      java:
        - |
          package io.xc5.cert;

          import javax.xml.xpath.*;
          import org.xml.sax.SAXException;
          import java.io.IOException;
          import java.io.FileInputStream;
          import javax.xml.parsers.DocumentBuilder;
          import org.w3c.dom.Document;
          import org.w3c.dom.NodeList;

          public class example_bad {
            private final String accountFile = "account.xml";
            private DocumentBuilder docBuilder;
            private XPath xpath;

            // the code below trying to query account Info with given id
            public String queryAccountInfo(String id) throws XPathExpressionException, SAXException, IOException {
              Document accountDoc = docBuilder.parse(accountFile);

              // attacker can inject by provide id with '1'='1 causing evaluate to return "true"
              String compileStr = "/Accounts/account[@id='" + id + "']"; 
              String res = xpath.evaluate(compileStr, accountDoc); // IDS53-J
              return res;
            }
          }
    good:
      java:
        - |+
          import javax.xml.xpath.*;
          import org.xml.sax.SAXException;
          import java.io.IOException;
          import java.io.FileInputStream;
          import javax.xml.parsers.DocumentBuilder;
          import org.w3c.dom.Document;
          import org.w3c.dom.NodeList;
          public class j_ids53_0 {
            private final String accountFile = "account.xml";
            private DocumentBuilder docBuilder;
            private XPath xpath;

            // the code below trying to query account Info with given id
            public String queryAccountInfo(String id) throws XPathExpressionException, SAXException, IOException {
              Document accountDoc = docBuilder.parse(accountFile);
              Map queryVars = new HashMap();

              // validate input "id" using StringEscapeUtils
              String filteredId = StringEscaptUtils.escapeXml(id);
              String compileStr = "/Accounts/account[@id='" + filteredId + "']";
              String res = xpath.evaluate(compileStr, accountDoc); 
              return res;
            }
          }

  language: Java
  likelihood: P
  master_id: 122
  msg_templ: '在${si.filename}，第${si.line}行，${si.func}中的${si.var}在用来从XML获取数据前未经过适当清理。 '
  name: 防止XPath注入
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '91'
      - '943'
    owasp:
      - A1
- alias: {}
  category: VUL
  code: IDS54-J
  cost: L
  csv_string:
    - I54J1
    - I54J0
  desc: 用来远程访问系统目录的字符串在输入前需要进行适当清理和验证
  details: |-
    #### 概要
    此程序在使用LDAP进行远程操作，然而并未有充分的输入清理及验证。

    #### 解释
    此程序正在使用轻量型目录访问协议来进行远程操作，然而并未有充分的输入清理和验证，这可能会造成恶意用户访问到受限信息。
  examples:
    bad:
      java:
        - |
          import javax.naming.NamingEnumeration;
          import javax.naming.NamingException;
          import javax.naming.directory.InitialDirContext;
          import javax.naming.directory.SearchControls;
          import javax.naming.directory.SearchResult;

          public class example_bad
          {
            public NamingEnumeration<SearchResult> queryUserInfo(InitialDirContext ctx, String id) throws NamingException {
              SearchControls sc = new SearchControls();
              sc.setReturningAttributes(new String[]{"balance", "phone"});
              sc.setSearchScope(SearchControls.SUBTREE_SCOPE);

              String searchBase = "dc=Users,dc=com";
              String filter = "(id=" + id + ")"; // attacker can inject by provide id with "*"
              return ctx.search(searchBase, filter, sc); // IDS54-J, query user info with id 
            }
          }
    good:
      java:
        - |
          import javax.naming.NamingEnumeration;
          import javax.naming.NamingException;
          import javax.naming.directory.InitialDirContext;
          import javax.naming.directory.SearchControls;
          import javax.naming.directory.SearchResult;

          public class example_good
          {
            public NamingEnumeration<SearchResult> queryUserInfo(InitialDirContext ctx, String id) throws NamingException {
              SearchControls sc = new SearchControls();
              sc.setReturningAttributes(new String[]{"balance", "phone"});
              sc.setSearchScope(SearchControls.SUBTREE_SCOPE);

              String searchBase = "dc=Users,dc=com";

              // check against special characters 
              if (!id.matches("[\\w\\s]*") || !id.matches("[\\w]*")) {
                throw new IllegalArgumentException("Invalid input");
              }
              
              String filter = "(id=" + id + ")"; // attacker can inject by provide id with "*"
              return ctx.search(searchBase, filter, sc); // IDS54-J, query user info with id 
            }
          }
  language: Java
  likelihood: P
  master_id: 123
  msg_templ: '在${si.filename}，第${si.line}行，${si.func}中的${si.var}在用来远程访问系统目录前未经过适当清理和验证。 '
  name: 防止LDAP注入
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '90'
      - '943'
    owasp:
      - A1
- alias: {}
  category: VUL
  code: IDS06-J
  cost: M
  csv_string:
    - I06J0
  desc: 格式字符串不应包括未经适当清理和验证的输入
  details: |-
    #### 概要
    此程序中的格式字符串含有未经过清理的用户输入。

    #### 解释
    来源不受信任且未经过清理的输入，不应被包含在格式字符串中。否则会导致数据泄露或阻断服务攻击。
  examples:
    bad:
      java:
        - |

          import java.util.Calendar;
          import java.util.GregorianCalendar;

          // this example is taken from CERT-J site Dashboard
          // 
          public class example_bad {
            static Calendar c = new GregorianCalendar(1995, GregorianCalendar.MAY, 23);
            public static void main(String[] args) {
              // Untrusted data is incorporated into the format string below.
              // Attacker can expose the date against which input is compared against
              // with some special input string, resulting in infomation leakage.
              System.out.format(
                args[0] + "did not match! HINT: It was issued on %1$terd of some month", c
              );
            }
          }
    good:
      java:
        - |

          import java.util.Calendar;
          import java.util.GregorianCalendar;

          // this example is taken from CERT-J site Dashboard
          // 
          public class example_bad {
            static Calendar c = new GregorianCalendar(1995, GregorianCalendar.MAY, 23);
            public static void main(String[] args) {
              // simply compare input with c
              System.out.format(
                "%s did not match! HINT: It was issued on %terd of some month", args[0], c
              );
            }
          }
  language: Java
  likelihood: U
  master_id: 124
  msg_templ: '在${si.filename}，第${si.line}行，${si.func}中的${si.var}在包括未经适当清理和验证的输入。 '
  name: 从格式字符串中排除未经过滤的用户输入
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '134'
- alias: {}
  category: BAD_PRACTICE
  code: MSC30-C
  cost: L
  csv_string:
    - M30C2
    - M30C1
    - M30C0
  desc: 此程序正在使用伪随机数生成器，这有可能会生成可预测的数字序列
  details: |-
    #### 概要
    此程序正在使用伪随机数生成器，因此可能会生成可预测的数字序列。

    #### 解释
    rand()函数会生成不完全随机且周期较短的数字，使攻击者有可能会猜出下一个生成的数值。程序员应该使用更好且适当播种的随机函数。
  examples:
    bad:
      c:
        - |
          #include <stdio.h>
          #include <stdlib.h>

          void use_rand(void) {
            int r;
            int i;

            // the same sequence will be printed every time this function is called
            for (i = 0; i < 10; i++) {
              r = rand();
              printf("Random %d is %d\n", i, r);
            }
            
          }
    good:
      c:
        - |
          #include <stdio.h>
          #include <stdlib.h>
          #include <time.h>

          void use_rand(void) {
            int r;
            int i;
            time_t t;

            // seeds the rand()
            srand((unsigned) time(&t));
            
            // random is a better pseudorandom number generator
            for (i = 0; i < 10; i++) {
              r = random();
              printf("Random %d is %d\n", i, r);
            }
            
          }
  language: c/c++
  likelihood: U
  master_id: 125
  msg_templ: '在${si.filename}，第${si.line}行，${si.func}程序正在使用伪随机数生成器，这有可能会生成可预测的数字序列。 '
  name: 不要使用rand（）函数生成伪随机数
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards:
    cwe:
      - '338'
      - '327'
      - '330'
    owasp:
      - A3
- alias: {}
  category: VUL
  code: INT32-C
  cost: H
  csv_string:
    - N322
    - N321
    - N320
  desc: 程序在表达式中有符号整数运算会导致整数溢出或环绕
  details: ''
  examples:
    bad: {}
    good: {}
  language: c/c++
  likelihood: L
  master_id: 126
  msg_templ: 在${si.filename}，第${si.line}行，${si.func}在表达式中有符号整数运算。
  name: 确保对有符号整数的运算会被环绕或溢出
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: H
  standards:
    cwe:
      - '190'
      - '191'
      - '680'
- alias: {}
  category: VUL
  code: IDS04-J
  cost: H
  csv_string:
    - I04J0
  desc: 在未经过清理或者资源保护的情况下，此程序正在使用java.util.zip.ZipInputStream从zip文件中提取文件。
  details: >-
    #### 概要

    在未经过清理或者资源保护的情况下，此程序正在使用java.util.zip.ZipInputStream从zip文件中提取文件


    #### 解释

    当使用java.util.zip从zip文件中提取文件时，文件名可能包含路径信息，这些文件名应做规范化处理并经过验证，以防止路径注入攻击。同时应注意监控资源使用情况，确保不会由于资源耗尽而造成服务中断。
  examples:
    bad:
      java:
        - "import java.util.zip.*;\nimport java.io.*;\n\n\npublic class IDS04J_bad {\n    public static void main(String[] args) throws IOException {\n        // Path may be manipulated to access areas outside of intended directory\n        String zipPath = args[0];\n        String destPath = args[1];\n\n        byte[] buffer = new byte[1024];\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(zipPath));\n        ZipEntry zipEntry = zis.getNextEntry();\n        File destDirectory = new File(destPath);\n\n        try {          \n            // Exhaustion of resource without limit to the size of zip files in while loop\n            while (zipEntry != null) {\n                System.out.println(\"File being extracted: \" + zipEntry);\n                FileOutputStream fos = new FileOutputStream(destDirectory + \"/\" + zipEntry.getName());\n\n                int len;\n                while ((len = zis.read(buffer)) > 0) {\n                    fos.write(buffer, 0, len);\n                }\n\n                fos.close();\n                zipEntry = zis.getNextEntry();\n            }\n        } \n        finally {\n        \tzis.close(); \t\n        }\n    }\n}\n\n\n"
    good:
      java:
        - "import java.util.zip.*;\nimport java.io.*;\n\n\npublic class IDS04J_good {\n    public static void main(String[] args) throws IOException, IllegalStateException {\n        String zipPath = args[0];\n        String destPath = args[1];\n        \n        // Fix vulnerability by canonicalizing path\n        File checkZip = new File(zipPath);\n        File checkDest = new File(destPath);\n        String canonicalZip =  checkZip.getCanonicalPath();\n        String canonicalDest =  checkDest.getCanonicalPath();\n\n        // Check result of canonicalization\n        if (!canonicalZip.startsWith(canonicalDest)) {\n            throw new IllegalStateException(\"Accesing Out of Bounds Area, set a correct path\");\n        }\n    \n        byte[] buffer = new byte[1024];\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(zipPath));\n        ZipEntry zipEntry = zis.getNextEntry();\n        File destDirectory = new File(destPath);\n\n        long sizeLimit = 0x6400000; \n        int fileLimit = 2000; \n        long currentSize =  0; \n        int entry = 0; \n\n        try {\n            // Limit size to avoid DoS attack through resource exhaustion      \n            while (zipEntry != null) {\n                // Limit number of files\n                if (entry > fileLimit){\n                    throw new IllegalStateException(\"Unzipped file exceed the allowed limit\");\n                } \n                // Limit size of file\n                if (currentSize > sizeLimit) {\n                    throw new IllegalStateException(\"Unzipped file exceed the allowed size\");\n                }\n\n                System.out.println(\"File being extracted: \" + zipEntry);\n                FileOutputStream fos = new FileOutputStream(destDirectory + \"/\" + zipEntry.getName());\n                \n                int len;\n                while ((len = zis.read(buffer)) > 0) {\n                    fos.write(buffer, 0, len);\n                    currentSize += len;\n                }\n                fos.close();\n                zipEntry = zis.getNextEntry();\n                entry++;\n            }\n        } \n        finally {\n        \tzis.close(); \t\n        }\n    }\n}\n\n\n"
  language: Java
  likelihood: P
  master_id: 127
  msg_templ: 在${si.filename}，第${si.line}行，${si.func}在未经过清理或者资源保护的情况下从zip文件中提取文件。
  name: 安全地从ZipInputStream中提取文件
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: L
  standards:
    cwe:
      - '409'
- alias: {}
  category: VUL
  code: IDS03-J
  cost: L
  csv_string:
    - SIL0
  desc: 当未经过清理的用户输入被记录或者以stdout输出时，可能造成敏感信息泄漏
  details: |-
    #### 名称
    未经过清理的用户信息不应该被暴露

    #### 概要
    当未经过清理的用户输入被记录或者以stdout输出时，可能造成敏感信息泄漏

    #### 解释
    记录未经过清理的用户输入可能导致敏感信息在信任边界外泄漏。Log注入攻击会进一步引起信息泄漏。Java和C/C++程序都可能遭到类似的攻击（见示例）。
  examples:
    bad:
      c:
        - "\nusing namespace mychain;\nusing namespace MyContract::Sample;\n\nclass demoBranch:public Contract {\npublic:\n    TransferPtr m_ptransfer;\n\n    demoBranch() {\n        m_ptransfer = GetTransferM();\n    }\n    INTERFACE void Init() {\n        InitRoot();\n    }\n    \n    INTERFACE void LeakToLog(const std::string& sAccountName ) {\n        if(!m_ptransfer) {\n            Revert(\"error\");\n        }\n\n\t// get account, balance etc\n        AccountMMapPtr pAccountMap = m_ptransfer->get_accounts();\n        if (!pAccountMap) {\n            Revert(\"AcountMMapPtr Error.\");\n        }\n\n        // obtain user account number and name\n\t// ...\n\n\t//\n        int32_t iBalanceRmb = pBalance->get_rmb();\n        std::string sBalanceTopic = std::to_string(iBalanceRmb);\n        std::vector<std::string> leak_msg;\n        leak_msg.push_back(sAccountName);\n        leak_msg.push_back(sBalanceTopic);\n\t\n        if (iBalanceRmb < 1) {\n          Log(std::string(\"acc_bal\"), leak_msg);\n        }\n    }\n};\nINTERFACE_EXPORT(demoBranch, (Init) (LeakToLog))\n"
      java:
        - |
          locationClient = new LocationClient(this, this, this);
          locationClient.connect();
          currentUser.setLocation(locationClient.getLastLocation());
          ... 

          catch (Exception e) {
              AlertDialog.Builder builder = new AlertDialog.Builder(this);
              builder.setMessage("Application Error.");
              AlertDialog alert = builder.create();
              alert.show();

              // user location is written to log
              Log.e("Example", "Caught exception: " + e + " User:" + User.toString());
          }
    good:
      c:
        - "\nusing namespace mychain;\nusing namespace MyContract::Sample;\n\nclass demoBranch:public Contract {\npublic:\n    TransferPtr m_ptransfer;\n\n    demoBranch() {\n        m_ptransfer = GetTransferM();\n    }\n    INTERFACE void Init() {\n        InitRoot();\n    }\n    \n    INTERFACE void LeakToLog(const std::string& sAccountName ) {\n        if(!m_ptransfer) {\n            Revert(\"error\");\n        }\n\n\t// get account, balance etc\n        AccountMMapPtr pAccountMap = m_ptransfer->get_accounts();\n        if (!pAccountMap) {\n            Revert(\"AcountMMapPtr Error.\");\n        }\n\n        // obtain user account number and name\n\t// ...\n\n\t//\n        int32_t iBalanceRmb = pBalance->get_rmb();\n        std::string sBalanceTopic = std::to_string(iBalanceRmb);\n        std::vector<std::string> leak_msg;\n        leak_msg.push_back(sAccountName);\n        leak_msg.push_back(sBalanceTopic);\n\n        if (iBalanceRmb < 1) {\n\t  // Sanitize and clean up message before logging\n          Log(std::string(\"acc_bal\"), SanitizeUser(leak_msg));\n        }\n    }\n};\nINTERFACE_EXPORT(demoBranch, (Init) (LeakToLog))\n"
      java:
        - |
          locationClient = new LocationClient(this, this, this);
          locationClient.connect();
          currentUser.setLocation(locationClient.getLastLocation());
          ... 

          catch (Exception e) {
              AlertDialog.Builder builder = new AlertDialog.Builder(this);
              builder.setMessage("Application Error.");
              AlertDialog alert = builder.create();
              alert.show();

              // user location is "sanitized" being written to log
              Log.e("Example", "Caught exception: " + e + " User:" + sanitizeUser(User.toString()));
          }
  language: c,c++,java
  likelihood: P
  master_id: 128
  msg_templ: ''
  name: 未经过清理的用户信息不应该被暴露
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards: {}
- alias: {}
  category: ''
  code: FIO39-C
  cost: M
  csv_string:
    - F39C0
  details: ''
  examples:
    bad: {}
    good: {}
  language: c/c++
  likelihood: L
  master_id: 129
  msg_templ: ''
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: L
  standards: {}
- alias: {}
  category: ''
  code: POS39-C
  cost: L
  csv_string:
    - P39C0
  details: ''
  examples:
    bad: {}
    good: {}
  language: c/c++
  likelihood: L
  master_id: 130
  msg_templ: ''
  ruleSet:
    code: CERT
    displayName: CERT
    id: S
  severity: M
  standards: {}
- alias: {}
  category: VUL
  code: MLU
  cost: H
  csv_string:
    - MLU0
  desc: 违反对互斥锁的锁和解锁函数须成对调用的惯用语法，缺少其一或另一个对应函数
  details: |-
    #### 名称
    缺少锁或者解锁函数的调用

    #### 概要
    违反对互斥锁的锁和解锁函数须成对调用的惯用语法，缺少其一或另一个对应函数

    #### 解释
    线程必须通过正确调用对应的锁或者解锁函数来进入或者离开互斥区域，否则会导致其他线程饥饿问题。
  examples:
    bad:
      c:
        - "#include <pthread.h>\n#include <stdio.h>\n \ntypedef struct sMutex_Lock {\n  int index;\n  pthread_mutex_t mutex;\n} Mutex_Lock_Type;\n \nMutex_Lock_Type g_struct[100];\n \nvoid hc1_bad (int ret) {\n  int i;\n  for (i = 0; i < 100; i++){\n    pthread_mutex_lock(&g_struct[i].mutex);\n    if (ret > 0) {\n      if (ret < 100) {\n        printf(\"ret < 100\\n\");\n        pthread_mutex_unlock(&g_struct[i].mutex);\n        break;\n      }\n      else {\n\t// break statement exits the loop prematurely without calling unlock \n        if (ret > 1000) {\n          printf(\"ret > 1000\\n\");\n          break;\n        }\n      }\n    }\n    pthread_mutex_unlock(&g_struct[i].mutex);\n  }\n}\n"
    good:
      c:
        - "void hc1_good (int ret) {\n  int i;\n  for (i = 0; i < 100; i++){\n    pthread_mutex_lock(&g_struct[i].mutex);\n    if (ret > 0) {\n      if (ret < 100) {\n        printf(\"ret < 100\\n\");\n        pthread_mutex_unlock(&g_struct[i].mutex);\n        break;\n      }\n      else {\n\t// unlock before break \n        if (ret > 1000) {\n          printf(\"ret > 1000\\n\");\n          pthread_mutex_unlock(&g_struct[i].mutex);\n          break;\n        }\n      }\n    }\n    pthread_mutex_unlock(&g_struct[i].mutex);\n  }\n}\n \n"
  language: c/c++
  likelihood: L
  master_id: 132
  msg_templ: ''
  name: 缺少锁或者解锁函数的调用
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    cwe:
      - '832'
- alias:
    cert:
      - CON35-C
  category: VUL
  code: DBLI
  cost: H
  csv_string:
    - DBLI0
  desc: 线程自旋锁在被取消初始化前已经被初始化了多于一次
  details: |-
    #### 名称
    自旋锁初始化不能多于一次

    #### 概要
    线程自旋锁在被取消初始化前已经被初始化了多于一次

    #### 解释
    在初始化一个线程以后，应该在下一次初始化之前先取消初始化，否则会引起其他线程饥饿问题。
  examples:
    bad:
      c:
        - |
          #include <linux/spinlock.h>
           
          struct sbuf_mgr {
            int         sbuf_inited;
            spinlock_t  sbuf_lock;
            char       *sbuf;
          };
           
          int is_sbuf_inited(struct sbuf_mgr *p_sbuf_mgr);
          void sbuf_mgr_reset(struct sbuf_mgr *p_sbuf_mgr);
          void write_data(struct sbuf_mgr *p_sbuf_mgr);
           
          // thread 1
          int *worker1(void *args)
          {
            struct sbuf_mgr * p_sbuf_mgr = args;
            if (is_sbuf_inited(p_sbuf_mgr)) {
               write_data(p_sbuf_mgr);
            }
            return 0;
          }
           
          int is_sbuf_inited( struct sbuf_mgr *p_sbuf_mgr )
          {
              int tmp_inited;
              unsigned long irq_flags;
              spin_lock_irqsave( &p_sbuf_mgr->sbuf_lock, irq_flags );
              tmp_inited = p_sbuf_mgr->sbuf_inited;
              spin_unlock_irqrestore( &p_sbuf_mgr->sbuf_lock, irq_flags );
              return tmp_inited;
          }
           
          // thread 2
          int *worker2(void *args)
          {
            struct sbuf_mgr * p_sbuf_mgr = args;

            // spin_lock_init called in thread2 with this call
            sbuf_mgr_reset(p_sbuf_mgr);
            return 0;
          }
           
          void sbuf_mgr_reset( struct sbuf_mgr *p_sbuf_mgr )
          {
              int i;
              unsigned long irq_flags;
              
              spin_lock_init(&(p_sbuf_mgr->sbuf_lock));  
              spin_lock_irqsave(&p_sbuf_mgr->sbuf_lock, irq_flags);
              // .. do the work 
          }
           
          int test_init_in_thread(void)
          {
            struct sbuf_mgr buf_mgr;
            struct task_struct *worker1_task, *worker2_task;
           
            worker1_task = kthread_create(worker1, (void*)&buf_mgr, "thread1");
           
            worker2_task = kthread_create(worker2, (void*)&buf_mgr, "thread2");
            // ,,, 
            
            // start tasks
            wake_up_process(worker1_task);
            wake_up_process(worker2_task);
            return 0;
          }
           
          void init(struct sbuf_mgr *buf_mgr)
          {
            spin_lock_init(&(buf_mgr->sbuf_lock));
          }
            
          int test_double_init(bool is_double_init)
          {
            struct sbuf_mgr buf_mgr;

            // first initialization 
            init(&buf_mgr);
            
            if (is_double_init) {
              // if true, call init, causing double init
              init(&buf_mgr);
            }
          }
    good:
      c:
        - |2
           
          #include <linux/spinlock.h>
           
          struct sbuf_mgr {
            int         sbuf_inited;
            spinlock_t  sbuf_lock;
            char       *sbuf;
          };
           
          int is_sbuf_inited(struct sbuf_mgr *p_sbuf_mgr);
          void sbuf_mgr_reset(struct sbuf_mgr *p_sbuf_mgr);
          void write_data(struct sbuf_mgr *p_sbuf_mgr);
           
          // thread 1
          int *worker1(void *args)
          {
            struct sbuf_mgr * p_sbuf_mgr = args;
            if (is_sbuf_inited(p_sbuf_mgr)) {
               write_data(p_sbuf_mgr);
            }
            return 0;
          }
           
          int is_sbuf_inited( struct sbuf_mgr *p_sbuf_mgr )
          {
              int tmp_inited;
              unsigned long irq_flags;
              spin_lock_irqsave( &p_sbuf_mgr->sbuf_lock, irq_flags );
              tmp_inited = p_sbuf_mgr->sbuf_inited;
              spin_unlock_irqrestore( &p_sbuf_mgr->sbuf_lock, irq_flags );
              return tmp_inited;
          }
           
          // thread 2
          int *worker2(void *args)
          {
            struct sbuf_mgr * p_sbuf_mgr = args;

            // spin_lock_init called in thread2 with this call
            sbuf_mgr_reset(p_sbuf_mgr);
            return 0;
          }
           
          void sbuf_mgr_reset( struct sbuf_mgr *p_sbuf_mgr )
          {
              int i;
              unsigned long irq_flags;
              
              spin_lock_init(&(p_sbuf_mgr->sbuf_lock));  
              spin_lock_irqsave(&p_sbuf_mgr->sbuf_lock, irq_flags);
              // .. do the work 
          }
           
          int test_init_in_thread(void)
          {
            struct sbuf_mgr buf_mgr;
            struct task_struct *worker1_task, *worker2_task;
           
            worker1_task = kthread_create(worker1, (void*)&buf_mgr, "thread1");
           
            worker2_task = kthread_create(worker2, (void*)&buf_mgr, "thread2");
            // ,,, 
            
            // start tasks
            wake_up_process(worker1_task);
            wake_up_process(worker2_task);
            return 0;
          }
           
          void init(struct sbuf_mgr *buf_mgr)
          {
            spin_lock_init(&(buf_mgr->sbuf_lock));
          }
            
          int test_double_init(bool is_double_init)
          {
            struct sbuf_mgr buf_mgr;

            // initialization only if boolean is false
            if (!is_double_init)
              init(&buf_mgr);
            
            return;  
          }
  language: c/c++
  likelihood: L
  master_id: 133
  msg_templ: ''
  name: 自旋锁初始化不能多于一次
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    cwe:
      - '609'
- alias: {}
  category: VUL
  code: LIIT
  cost: H
  csv_string:
    - LIIT0
  desc: 在线程中调用自旋锁初始化可能导致线程被多次初始化
  details: |-
    #### 名称
    不要在线程中调用自旋锁初始化

    #### 概要
    在线程中调用自旋锁初始化可能导致线程被多次初始化

    #### 解释
    线程不应被直接或间接地多次初始化，否则会导致其他线程饥饿问题。
  examples:
    bad:
      c:
        - |
          #include <linux/spinlock.h>
           
          struct sbuf_mgr {
            int         sbuf_inited;
            spinlock_t  sbuf_lock;
            char       *sbuf;
          };
           
          int is_sbuf_inited(struct sbuf_mgr *p_sbuf_mgr);
          void sbuf_mgr_reset(struct sbuf_mgr *p_sbuf_mgr);
          void write_data(struct sbuf_mgr *p_sbuf_mgr);
           
          // thread 1
          int *worker1(void *args)
          {
            struct sbuf_mgr * p_sbuf_mgr = args;
            if (is_sbuf_inited(p_sbuf_mgr)) {
               write_data(p_sbuf_mgr);
            }
            return 0;
          }
           
          int is_sbuf_inited( struct sbuf_mgr *p_sbuf_mgr )
          {
              int tmp_inited;
              unsigned long irq_flags;
              spin_lock_irqsave( &p_sbuf_mgr->sbuf_lock, irq_flags );
              tmp_inited = p_sbuf_mgr->sbuf_inited;
              spin_unlock_irqrestore( &p_sbuf_mgr->sbuf_lock, irq_flags );
              return tmp_inited;
          }
           
          // thread 2
          int *worker2(void *args)
          {
            struct sbuf_mgr * p_sbuf_mgr = args;

            // spin_lock_init called with this call, can result in double init
            sbuf_mgr_reset(p_sbuf_mgr);
            return 0;
          }
           
          void sbuf_mgr_reset( struct sbuf_mgr *p_sbuf_mgr )
          {
              int i;
              unsigned long irq_flags;
              
              spin_lock_init(&(p_sbuf_mgr->sbuf_lock));  
              spin_lock_irqsave(&p_sbuf_mgr->sbuf_lock, irq_flags);
              // .. do the work 
          }
           
          int test_init_in_thread(void)
          {
            struct sbuf_mgr buf_mgr;
            struct task_struct *worker1_task, *worker2_task;
           
            worker1_task = kthread_create(worker1, (void*)&buf_mgr, "thread1");
           
            worker2_task = kthread_create(worker2, (void*)&buf_mgr, "thread2");
            // ,,, 
            
            // start tasks
            wake_up_process(worker1_task);
            wake_up_process(worker2_task);
            return 0;
          }
           
          void init(struct sbuf_mgr *buf_mgr)
          {
            spin_lock_init(&(buf_mgr->sbuf_lock));
          }
            
          int test_double_init(bool is_double_init)
          {
            struct sbuf_mgr buf_mgr;

            // first initialization 
            init(&buf_mgr);
            
            if (is_double_init) {
              // if true, call init, causing double init
              init(&buf_mgr);
            }
          }
    good: {}
  language: c/c++
  likelihood: L
  master_id: 134
  msg_templ: ''
  name: 不要在线程中调用自旋锁初始化
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards: {}
- alias:
    cert:
      - CON38-C
  category: VUL
  code: SLAE
  cost: M
  csv_string:
    - SLAE0
  desc: 自旋锁变量的地址暴露可能会导致死锁
  details: |-
    #### 名称
    自旋锁变量的地址逃逸

    #### 概要
    自旋锁变量的地址暴露可能会导致死锁

    #### 解释
    当自旋锁变量的地址暴露在线程之外时，线程可能因无法正确解锁而导致死锁。
  examples:
    bad:
      c:
        - |
          #include <linux/spinlock.h>
          void bad(int irq, spinlock_t lock)
          {
            // 
            spin_lock(&lock);
          }
           
          void bad2(int irq, spinlock_t lock, spinlock_t lock2)
          {
            spin_lock(&lock);
          }
    good: {}
  language: c/c++
  likelihood: U
  master_id: 135
  msg_templ: ''
  name: 自旋锁变量的地址逃逸
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: L
  standards:
    cwe:
      - '412'
- alias:
    cert:
      - CON30-C
  category: VUL
  code: LNR
  cost: H
  csv_string:
    - LNR0
  desc: ''
  details: ''
  examples:
    bad: {}
    good: {}
  language: c/c++
  likelihood: P
  master_id: 136
  msg_templ: ''
  name: ''
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: M
  standards:
    cwe:
      - '833'
- alias: {}
  category: VUL
  code: SAC
  cost: H
  csv_string:
    - SAC0
  desc: 当程序在原子上下文状态或者锁定区域时，存在着操作使得程序因等待中断或调用睡眠函数而引发程序运行暂停或者延迟
  details: |-
    #### 名称
    在原子上下文或者锁定区域中调用睡眠函数

    #### 概要
    当程序在原子上下文状态或者锁定区域时，存在着操作使得程序因等待中断或调用睡眠函数而引发程序运行暂停或者延迟

    #### 解释
    当程序在原子上下文状态或者锁定区域时，任何运行都有可能因睡眠、中断或者等待而发生中止，从而导致死锁。
  examples:
    bad:
      c:
        - |+
          #include <linux/spinlock.h>
          void test_isr1(int irq, spinlock_t *lock)
          {
            spin_lock(lock);  // VUL: should use spin_lock_irqsave
          }
           
          // cross function check
          noinline
          void call_spin(spinlock_t *lock)
          {
            spin_lock(lock);
          }


        - >
          #include <stdio.h>

          #include <pthread.h>


          int num = 8; // global variable

          pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; // initialise a
          mutex


          int main() {
              pthread_mutex_lock(&lock); // enter mutex locked region
              switch (num) {
              case 0:
                      num = 0;
                      break;
              case 1:
                      num++;
                      break;
              case 2:
                      num--;
                      break;
              default:
                      // does not exit mutex lock region before return
                      // can cause a deadlock because lock is never released
                      return 0;
              }
              pthread_mutex_unlock(&lock); // exit mutex lock region
              return 0;
          }
        - >

          #include <stdio.h>

          #include <pthread.h>

          #include <unistd.h>


          pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; // initialise a
          mutex

          int num; // global variable


          int main () {
              pthread_mutex_lock(&lock); // enter mutex lock region
              num++;
              sleep(1); // thread goes to sleep within lock region, never want to do this
              pthread_mutex_unlock(&lock); // exit mutex lock region
              return 0;
          }
    good:
      c:
        - |
          #include <linux/spinlock.h>
          void test_isr1(int irq, spinlock_t *lock)
          {
            // this guarantees interrupt state is saved and that
            // the critical section will not be preempted by the kernel
            spin_lock_irqsave(lock);  
          }
           
           
          // cross function check
          noinline
          void call_spin(spinlock_t *lock)
          {
            spin_lock(lock);
          }
        - >
          #include <stdio.h>

          #include <pthread.h>


          int num = 8; // global variable

          pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; // initialise a
          mutex


          int main() {
              pthread_mutex_lock(&lock); // enter mutex locked region
              switch (num) {
              case 0:
                      num = 0;
                      break;
              case 1:
                      num++;
                      break;
              case 2:
                      num--;
                      break;
              default:
                      pthread_mutex_unlock(&lock); // exit mutex lock region
                      return 0;
              }
              pthread_mutex_unlock(&lock); // exit mutex lock region
              return 0;
          }
        - >
          #include <stdio.h>

          #include <pthread.h>

          #include <unistd.h>


          pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER; // initialise a
          mutex

          int num; // global variable


          int main () {
              pthread_mutex_lock(&lock); // enter mutex lock region
              num++;
              pthread_mutex_unlock(&lock); // exit mutex lock region
              return 0;
          }
  language: c/c++
  likelihood: L
  master_id: 137
  msg_templ: ''
  name: 在原子上下文或者锁定区域中调用睡眠函数
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: L
  standards: {}
- alias:
    cert:
      - CON30-C
  category: VUL
  code: LLAT
  cost: H
  csv_string:
    - LLAT0
  desc: 当本地线程的地址被保存后，即使该线程被停止，仍可被其持有者调用
  details: |-
    #### 名称
    本地线程在线程被停止后仍然存在

    #### 概要
    当本地线程的地址被保存后，即使该线程被停止，仍可被其持有者调用

    #### 解释
    暴露本地线程变量的地址可能会引起对非法锁或者无效函数的调用。这会引起不可确定的行为。
  examples:
    bad:
      c:
        - |2
           
          struct completion {
            int done;
          };
           
          struct usb_request {
            struct completion *context;
            void (*complete)(struct usb_request *req);
          };
           
          void complete(struct completion *x)
          {
            printf("%d\n", x->done);
          }
           
          void ffs_epfile_io_complete(struct usb_request *req)
          {
            complete(req->context);
          }
           
          void usb_ep_queue(struct usb_request *req)
          {
            req->complete(req);
          }
           
          void ffs_epfile_io(struct usb_request *req)
          {
            struct completion done;
            req->context = &done;
            req->complete = ffs_epfile_io_complete;
            usb_ep_queue(req);
          }
           
    good: {}
  language: c/c++
  likelihood: P
  master_id: 138
  msg_templ: ''
  name: 本地线程在线程被停止后仍然存在
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: M
  standards:
    cwe:
      - '412'
- alias:
    cert:
      - CON35-C
  category: VUL
  code: UIL
  cost: H
  csv_string:
    - UIL0
  desc: 当自旋锁被调用时，锁未被初始化
  details: |-
    #### 名称
    锁未被初始化

    #### 概要
    当自旋锁被调用时，锁未被初始化

    #### 解释
    使用自旋锁时需要有资源分配，并且需要被初始化到解锁状态，否则会导致不可确定的系统行为。
  examples:
    bad:
      c:
        - |
          #include <stddef.h>
          #include <pthread.h>
           
          void mutex_initialise(pthread_mutex_t *lock) {
            pthread_mutex_init(lock, NULL);
          }
           
          void mutex_lock(pthread_mutex_t *lock) {
            pthread_mutex_lock(lock);
          }
           
          void mutex_unlock(pthread_mutex_t *lock) {
            pthread_mutex_unlock(lock);
          }
           
          int main(void) {
              pthread_mutex_t mlock;
              
              // mutex_initialize, nor pthread_mutex_init has been invoked
              mutex_lock(&mlock);
              mutex_unlock(&mlock);
              return 0;
          }
    good: {}
  language: c/c++
  likelihood: L
  master_id: 139
  msg_templ: ''
  name: 锁未被初始化
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: H
  standards:
    cwe:
      - '667'
- alias:
    cert:
      - CON43-C
  category: VUL
  code: TASR
  cost: H
  csv_string:
    - TASR0
  desc: 检查并设置场景下若没有锁保护将可能导致竞态条件
  details: |-
    #### Abstract
    检查和设置场景下若没有锁保护将可能导致竞态条件

    #### Explanation
    在检查和设置的场景下判断变量后，如果在分支修改变量且未有用锁保护这个场景，有可能导致竞态条件。
  examples:
    bad:
      c:
        - |
          extern int printf(const char*, ...);
          extern int get_int();
           
          void cmp_set_race_bad() {
            int flag = get_int();
            if (flag == 0) {
              flag = 1;
            }
            else {
              printf("\n");
            }
            printf("1st: get %d\n", flag);
            flag = get_int();
            if (flag != 0) {
              printf("2nd: get %d\n", flag);
            }
            else {
              flag = 1;
            }
            printf("final: %d\n", flag);
          }
    good: {}
  language: c/c++
  likelihood: P
  master_id: 140
  msg_templ: ''
  name: 检查并设置场景下的竞态条件
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: M
  standards: {}
- alias: {}
  category: VUL
  code: PNC
  cost: M
  csv_string:
    - PAIR-NOT-CALLED
  desc: 特定的函数应配对。 使用第一个函数时也必须使用成对中的第二个。
  details: |-
    #### 概要
    特定的函数应配对。 使用第一个函数时也必须使用成对中的第二个。

    #### 解释
    如果调用了函数“irq_of_parse_and_map”，则在程序执行过程中必须调用相应的“irq_dispose_mapping”。
  examples:
    bad:
      c:
        - |-
          #include <stdio.h>
          #include \"case.h\"

          static int sunxi_keyboard_startup(struct sunxi_key_data *key_data,
                                          struct platform_device *pdev)
          {
                  struct device_node *np = NULL;
                  int ret = 0;

                  key_data->reg_base = of_iomap(np, 0);
                  if (key_data->reg_base == 0) {
                          pr_err("%s:Failed to ioremap() io memory region.", __func__);
                          ret = -1;
                  }

                  key_data->irq_num = irq_of_parse_and_map(np, 0);
                  if (key_data->irq_num == 0) {
                          pr_err("%s:Failed to map irq.", __func__);
                          ret = -1;
                  }

                  key_data->mclk = of_clk_get(np, 0);
                  if (IS_ERR_OR_NULL(key_data->mclk)) {
                          pr_debug("%s: keyboard has no clk.", __func__);
                  } else{
                          if (clk_prepare_enable(key_data->mclk)) {
                                  pr_err("%s enable apb1_keyadc clock failed!", __func__);
                                  return -1;
                          }
                  }
                  
                  return ret;
          }
    good:
      c:
        - |-
          #include <stdio.h>
          #include "case.h"

          static int sunxi_keyboard_startup(struct sunxi_key_data *key_data,
                                          struct platform_device *pdev)
          {
                  struct device_node *np = NULL;
                  int ret = 0;

                  key_data->reg_base = of_iomap(np, 0);
                  if (key_data->reg_base == 0) {
                          pr_err("%s:Failed to ioremap() io memory region.", __func__);
                          ret = -1;
                          goto out_iounmap;
                  }

                  key_data->irq_num = irq_of_parse_and_map(np, 0);
                  if (key_data->irq_num == 0) {
                          pr_err("%s:Failed to map irq.", __func__);
                          ret = -1;
                          goto out_dispose_mapping;
                  }

                  key_data->mclk = of_clk_get(np, 0);
                  if (IS_ERR_OR_NULL(key_data->mclk)) {
                          pr_debug("%s: keyboard has no clk.", __func__);
                          goto out_clk;
                  } else{
                          if (clk_prepare_enable(key_data->mclk)) {
                                  pr_err("%s enable apb1_keyadc clock failed!", __func__);
                                  ret = -1;
                          }
                  }

          out_clk:
                  clk_put(key_data->mclk);
          out_dispose_mapping:
                  irq_dispose_mapping(key_data->irq_num);
          out_iounmap:
                  iounmap(key_data->reg_base);

                  return ret;
          }
  language: c/c++
  likelihood: P
  master_id: 141
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}，特定的函数对中仅仅使用了其中一个函数
  name: 配对未调用
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: M
  standards: {}
- alias: {}
  category: VUL
  code: LSO
  cost: M
  csv_string:
    - LSO0
  desc: 不应在生命周期的错误阶段执行对资源的操作。
  details: |
    #### 概要
    不应在生命周期的错误阶段执行对资源的操作。

    #### 解释
    如果开发人员在生命周期的错误阶段初始化、使用或释放资源，可能会导致意外行为。
  examples:
    bad:
      c:
        - |
          #include <sys/socket.h>
          #include <arpa/inet.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <unistd.h>

          #define BUF_SZ 256

          int foo(void)
          {
              int n;
              char buffer[BUF_SZ];
              int sockfd = socket(AF_INET, SOCK_STREAM, 0);

              if (sockfd < 0)
              {
                  perror("ERROR opening socket");
                  exit(1);
              }

              struct sockaddr_in addr;
              memset(&addr, 0, sizeof(addr));
              addr.sin_family = AF_INET;
              addr.sin_addr.s_addr = htonl(INADDR_ANY);
              addr.sin_port = htons(3128);
              if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
              {
                  perror("ERROR binding socket");
                  exit(1);
              }

              if (listen(sockfd, 0) < 0)
              {
                  perror("ERROR listening socket");
                  exit(1);
              }

              n = recv(sockfd, buffer, 255, 0);

              // use buffer
              // if buffer is used as argument to system() or to setenv()
              // the buffer may contain untrusted commands or characters leading to unpredictable program behavior
              // ...
              close(sockfd);
              return n;
          }
    good:
      c:
        - |
          #include <sys/socket.h>
          #include <arpa/inet.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <unistd.h>

          #define BUF_SZ 256

          int foo(void)
          {
              int n;
              char buffer[BUF_SZ];
              int sockfd = socket(AF_INET, SOCK_STREAM, 0);

              if (sockfd < 0)
              {
                  perror("ERROR opening socket");
                  exit(1);
              }

              struct sockaddr_in addr;
              memset(&addr, 0, sizeof(addr));
              addr.sin_family = AF_INET;
              addr.sin_addr.s_addr = htonl(INADDR_ANY);
              addr.sin_port = htons(3128);
              if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
              {
                  perror("ERROR binding socket");
                  exit(1);
              }

              if (listen(sockfd, 0) < 0)
              {
                  perror("ERROR listening socket");
                  exit(1);
              }

              close(sockfd);
              return n;
          }
  language: c/c++
  likelihood: P
  master_id: 142
  msg_templ: 在${si.filename}，第${si.line}行，${si.func}在生命周期的错误阶段执行了对资源的操作。
  name: 生命周期错误阶段的资源操作
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: M
  standards:
    cwe:
      - '666'
- alias: {}
  category: VUL
  code: MBSP
  cost: M
  csv_string:
    - MBSP0
  desc: 多个套接字不应绑定到同一个端口
  details: |
    #### 概要
    多个套接字不应绑定到同一个端口

    #### 解释
    如果多个套接字绑定到同一个端口，该端口的其他服务可能会被窃取。
  examples:
    bad:
      c:
        - |-
          #include <sys/socket.h>
          #include <arpa/inet.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <unistd.h>

          void func( void )
          {
              // create socket one
              int sockfd_one;
              int server_len;
              struct sockaddr_in addr;
              sockfd_one = socket(AF_INET, SOCK_STREAM, 0);
              memset(&addr, 0, sizeof(addr));
              addr.sin_family = AF_INET;
              addr.sin_addr.s_addr = htonl(INADDR_ANY);
              addr.sin_port = htons(6789);
              server_len = sizeof(struct sockaddr_in);

              // set SO_REUSEADDR and bind socket one to port
              int opt = 1;
              setsockopt( sockfd_one, SOL_SOCKET,SO_REUSEADDR, (const void *)&opt, sizeof(opt) );
              bind(sockfd_one, (struct sockaddr *) &addr, server_len);

              // create socket two
              int sockfd_two;
              sockfd_two = socket(AF_INET, SOCK_DGRAM, 0);

              // set SO_REUSEADDR and bind socket two to port
              opt = 1;
              setsockopt( sockfd_two, SOL_SOCKET,SO_REUSEADDR, (const void *)&opt, sizeof(opt) );
              bind(sockfd_two, (struct sockaddr *) &addr, server_len);
          }
    good:
      c:
        - |-
          #include <sys/socket.h>
          #include <arpa/inet.h>
          #include <stdio.h>
          #include <stdlib.h>
          #include <unistd.h>

          void func( void )
          {
              // create socket one and bind to port
              int sockfd_one;
              int server_len;
              struct sockaddr_in addr;
              sockfd_one = socket(AF_INET, SOCK_STREAM, 0);
              memset(&addr, 0, sizeof(addr));
              addr.sin_family = AF_INET;
              addr.sin_addr.s_addr = htonl(INADDR_ANY);
              addr.sin_port = htons(6789);
              server_len = sizeof(struct sockaddr_in);
              bind(sockfd_one, (struct sockaddr *) &addr, server_len);
          }
  language: c/c++
  likelihood: P
  master_id: 143
  msg_templ: 在${si.filename}，多个套接字绑定了同一个端口。
  name: 多个套接字绑定相同的端口
  ruleSet:
    code: BUILTIN
    displayName: XCALIBYTE
    id: X
  severity: M
  standards:
    cwe:
      - '605'
- alias: {}
  category: ''
  code: MSR_2_3
  compliance: A
  cost: H
  csv_string:
    - MSR_2_3
  desc: 不应该包含未使用的数据类型的定义
  details: |-
    #### 概要
    不应该包含未使用的数据类型的定义

    #### 解释
    未定义的数据类型，不单止会导致会浪费资源，还会在审查该代码时难以确定是由于编程过程中的错误导致没有使用该数据类型，还是其只是代码的多余部分。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          typedef int used; // type is declared but not used

          int main()
          {
              printf("finished");
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          typedef int used; // type is declared here

          int main()
          {
              used a = 1; // type is used here
              printf("%d",a);
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}包含未使用的数据类型的定义。
  name: 不应该包含未使用的数据类型的定义
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_2_3
- alias: {}
  category: ''
  code: MSR_2_6
  compliance: A
  cost: H
  csv_string:
    - MSR_2_6
  desc: 函数中不能声明未使用的标签
  details: |-
    #### 概要
    函数中不能声明未使用的标签

    #### 解释
    代码的审查者无法判断未使用的标签是多余的还是因疏漏而未使用，因此不能声明未使用的标签。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int func( void )
          {
              int i = 5;
              if (i != 5) i = 5;
          lab1: // unused label declared
              return i;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          int func( void )
          {
              int i = 5;
              goto lab1; // label used
              if (i != 5) i = 5;
          lab1: // label declared
              return i;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}使用了未使用的标签。
  name: 函数中不允许使用未使用的标签
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_2_6
- alias: {}
  category: ''
  code: MSR_2_7
  compliance: A
  cost: H
  csv_string:
    - MSR_2_7
  desc: 函数中不应出现未使用的参数
  details: |-
    #### 概要
    函数中不应出现未使用的参数

    #### 解释
    函数应该使用其所有的参数。若函数未使用其所有的参数则其功能的实现很可能与在设计该函数时所希望达到的目的不相匹配。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int Addtion(int a,int b,int c);

          int main()
          {
              printf("%d",Addtion(1,2,3));
              return 0;
          }
           // three parameters are defined
          int Addtion(int a,int b,int c)
          {
              return a+b; // only two of them are used
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          int Addtion(int a,int b,int c);

          int main()
          {
              printf("%d",Addtion(1,2,3));
              return 0;
          }
          int Addtion(int a,int b,int c)
          {
              return a+b+c; // every parameter is used
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中出现未使用的参数。
  name: 必须使用所有声明过的参数
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_2_7
- alias: {}
  category: ''
  code: MSR_5_1
  compliance: R
  cost: H
  csv_string:
    - MSR_5_1
  desc: 外部标识符要求可区别
  details: |-
    #### 概要
    外部标识符要求可区别

    #### 解释
    在C99标准中，外部标识符应至少满足前31个字符有区别，以确保所有外部标识符可通过前31个字符得以区分。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int main()
          {
              // the first 31 characters are not distinct
              int this_is_a_non_compliant_example_a = 1;
              int this_is_a_non_compliant_example_b = 2; 
              int a;
              a = this_is_a_non_compliant_example_a + this_is_a_non_compliant_example_b;
              printf("%d\n",a);
              return 0;
          } 
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          int main()
          {
              // the first 31 characters are distinct
              int a_non_compliant_example_a = 1;
              int a_non_compliant_example_b = 2; 
              int a;
              a = a_non_compliant_example_a + a_non_compliant_example_b;
              printf("%d\n",a);
              return 0;
          } 
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中出现不唯一的外部标识符。
  name: 所有外部标识符必须是唯一的，最多31个字符
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_5_1
- alias: {}
  category: ''
  code: MSR_5_2
  compliance: R
  cost: H
  csv_string:
    - MSR_5_2
  desc: 在同一作用域和命名空间中被声明的标识符应该可以被区分
  details: |-
    #### 概要
    在同一作用域和命名空间中被声明的标识符应该可以被区分

    #### 解释
    在同一作用域内应该满足不同标识符的前31个字符不完全相同以进行区别。
  examples:
    bad:
      c:
        - >-

          #include <stdio.h>


          // this example have two identifiers, first 31 characters are the same

          extern int a_non_compliant_example_a = 1;

          extern int a_non_compliant_example_b = 2; // two indistinct
          identifiers are defined in the same scope


          int main()

          {
              int a;
              a = 1 + a_non_compliant_example_b;
              printf("%d\n",a);
              return 0;
          } 
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - >-

          #include <stdio.h>


          // this example have two identifiers, first 31 characters are the same

          extern int this_is_a_non_compliant_example_a = 1; // first identifier,
          global scope


          int main()

          {
              int a;
              int this_is_a_non_compliant_example_b = 2; // two identifiers are defined in local scope
              a = 1 + this_is_a_non_compliant_example_b;
              printf ("%d\n",a);
              return 0;
          } 
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中出现不可被区分的标识符。
  name: 相同范围和名称空间的标识符必须是唯一的
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_5_2
- alias: {}
  category: ''
  code: MSR_5_3
  compliance: R
  cost: H
  csv_string:
    - MSR_5_3
  desc: 内部作用域的标识符应与外部作用域的不同
  details: |-
    #### 概要
    内部作用域的标识符应与外部作用域的不同

    #### 解释
    在内部作用域定义变量时应该避免与外部作用域同名，以防止产生歧义。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int a = 3; // identifier defined, outer scope

          int main()
          {
              int a; // identifier defined, inner scope, covering the outer one
              a = 4;
              printf("%d",a);
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          int a = 3; // identifier defined, outer scope

          int main()
          {
              int b; // identifier defined, inner scope, different form the outer one
              b = 4;
              printf("%d",b);
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中出现相同标识符，
  name: 内部和外部作用域中的标识符必须不同
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_5_3
- alias: {}
  category: ''
  code: MSR_5_6
  compliance: R
  cost: H
  csv_string:
    - MSR_5_6
  desc: typedef标识符必须唯一
  details: |-
    #### 概要
    typedef标识符必须唯一

    #### 解释
    除非该别名在头文件中被定义且该头文件被包含，否则所用typedef定义的别名在所有命名空间中必须唯一。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          typedef int my_name; // typedef declared

          int main()
          {
              int my_name = 1; // variable declared, same identifier
              printf("%d",my_name);
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          typedef int my_name; // unique typedef declared

          int main()
          {
              int my_name_2 = 1; // unique variable declared 
              printf("%d",my_name_2);
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中，typedef标识符不唯一。
  name: typedef 名称应为唯一标识符
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_5_6
- alias: {}
  category: ''
  code: MSR_5_7
  compliance: R
  cost: H
  csv_string:
    - MSR_5_7
  desc: 结构体标签必须唯一
  details: |-
    #### 概要
    结构体标签必须唯一

    #### 解释
    除非该结构体标签在头文件中被定义且该头文件被包含，否则所用标签在所有命名空间中必须唯一。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          struct my_name // tag declared
          {
              int a;
              int b;
          };

          int main()
          {
              int my_name = 1; // variable declared, same identifier
              printf("%d",my_name);
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          struct my_name // unique tag declared
          {
              int a;
              int b;
          };

          int main()
          {
              int my_name_2 = 1; // unique variable declared
              printf("%d",my_name_2);
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中，标签名称不是唯一标识符。
  name: 标签名称应是唯一标识符
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_5_7
- alias: {}
  category: ''
  code: MSR_6_1
  compliance: R
  cost: H
  csv_string:
    - MSR_6_1
  desc: 位域必须被声明为合适的数据类型
  details: |-
    #### 概要
    位域必须被声明为合适的数据类型

    #### 解释
    在声明位域时，必须将其声明为规定的几种数据类型中的一种且在声明中signed与unsigned不可省略。
  examples:
    bad:
      c:
        - |-

          struct str {
            int a:2;
            unsigned int b1:2;
          };


          struct str1 {
            unsigned int b1:2;
            short b:2;
          };

          int foo()
          {
            printf("finished\n");
            return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          struct str
          {
              signed int a:2;   // signed int permitted
              unsigned int b:2; // unsigned int permitted
          };

          int main()
          {
              printf("finished");
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中，位域未被声明为合适的数据类型。
  name: 位域类型不能是内置类型
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_6_1
- alias: {}
  category: ''
  code: MSR_6_2
  compliance: R
  cost: H
  csv_string:
    - MSR_6_2
  desc: 只占一个位的位域不能为有符号型数据
  details: |-
    #### 概要
    只占一个位的位域不能为有符号型数据

    #### 解释
    由于有符号型数据要求有第一位符号位，只占一个位的位域的位域不允许定义为有符号型的数据类型。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          struct str
          {
              signed int a:1;   // single-bit bit field declared signed
          };

          int main()
          {
              printf("finished");
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          struct str
          {
              unsigned int a:1;   // single-bit bit field declared unsigned
          };

          int main()
          {
              printf ("finished") ;
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中出现有符号的单位命名字段。
  name: 单位命名字段必须是无符号的
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_6_2
- alias: {}
  category: ''
  code: MSR_7_4
  compliance: R
  cost: H
  csv_string:
    - MSR_7_4
  desc: 将字符串字面量通过指向常量的指针赋值给字符型
  details: |-
    #### 概要
    将字符串字面量通过指向常量的指针赋值给字符型

    #### 解释
    由于常量字符串存储在静态存储区，对其的修改操作会出错，仅能将常量字符串复制给指向常量字符串的指针以防止其修改操作。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          extern int foo (char *a);
          extern int foo2 (char *b);

          int func()
          {
              char *str = "string"; // str is not const-qualified
              foo ( "string" );
              foo2 ( "string" ); // may be modified by foo
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          extern int foo (const char *a);
          extern int foo2 (const char *b);

          int func()
          {
              const char *str = "string"; // str is not const-qualified
              foo ( "string" );
              foo2 ( "string" ); // string can not be modified
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中的字符串文字未分配给常量指针。
  name: 字符串文字只能分配给常量指针
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_7_4
- alias: {}
  category: ''
  code: MSR_8_4
  compliance: R
  cost: H
  csv_string:
    - MSR_8_4
  desc: 在定义有外部链接的对象时，应保持与其声明兼容
  details: |-
    #### 概要
    在定义有外部链接的对象时，应保持与其声明兼容

    #### 解释
    在定义具有外部链接的对象或者函数时，必须保持该对象或者函数的数据类型，参数数量等与外部的声明兼容。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          extern int x = 0; // x not declared before

          extern int func1(int a); // extern function declared

          int func1(int a, int b) // parameters different
          {
              return 0;
          }

          int func2( void )
          {
              // func2 not declared before
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          extern int x;
          int x = 0; // compliant

          extern int func1(int a); // extern function declared

          int func1(int a) // extern compatible funtion defined
          {
              return 0;
          }

          // compliant for functions with internal linkage
          static int func2 ( void )
          {
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中的外部对象与其声明不兼容。
  name: 外部对象，在定义时必须与可见声明相同。
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_8_4
- alias: {}
  category: ''
  code: MSR_8_8
  compliance: R
  cost: H
  csv_string:
    - MSR_8_8
  desc: 有内部链接的对象要加上static说明符
  details: |-
    #### 概要
    有内部链接的对象要加上static说明符

    #### 解释
    在声明具有内部链接的对象或者函数时，必须加上static的说明符以保持声明的正确性。
  examples:
    bad:
      c:
        - |-

          // this example will cause compilation error
          extern int func (int a); // declare external scope

          static int func (int a) // function with internal linkage declared
          {
              return a;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          static int func (int a) // function defined with "static"
          {
              return a;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中，具有内部链接的对象未被声明为静态。
  name: 具有内部链接的对象应声明为静态
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_8_8
- alias: {}
  category: ''
  code: MSR_8_9
  compliance: A
  cost: H
  csv_string:
    - MSR_8_9
  desc: 对象应仅被定义在它出现的作用域内
  details: |-
    #### 概要
    对象应仅被定义在它出现的作用域内

    #### 解释
    当一个对象仅仅在一定的作用域内作用时，应该将它定义在该作用域内以防止其他作用域改变了它的值。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          extern int foo(int *a);
          extern void foo2( void );
          static int num = 0; // object declared, global scope

          int count( void )
          {
              num++; // object appears only in this function
              return num;
          }

          extern void foo2( void )
          {
              foo(&num); // object may be modified at outer scope
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          extern int foo (int *a);
          extern void foo2 ( void );

          int count ( void )
          {
              static int num = 0; // object declared at block scope
              num++; // object appears only in this function
              return num;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中的对象未被定义在它出现的作用域内。
  name: 如果对象的标识符仅出现在单个函数中，则应在该范围内定义该对象
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_8_9
- alias: {}
  category: ''
  code: MSR_8_10
  compliance: R
  cost: H
  csv_string:
    - MSR_8_10
  desc: 应该用静态存储类声明内联函数
  details: |-
    #### 概要
    应该用静态存储类声明内联函数

    #### 解释
    引用外部链接的内联函数可能会影响执行的时间，因此应该用静态储存类声明内联函数。
  examples:
    bad:
      c:
        - >-

          #include <stdio.h>


          extern inline int func( void ); // inline function declared with
          external linkage


          int func2( void )

          {
              func();
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - >-

          #include <stdio.h>


          static inline int func( void ); // inline function declared with
          internal linkage


          int func2( void )

          {
              func();
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中的内联函数没有静态声明 。
  name: '内联函数应具有静态声明 '
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_8_10
- alias: {}
  category: ''
  code: MSR_8_11
  compliance: A
  cost: H
  csv_string:
    - MSR_8_11
  desc: 需要明确外部链接的数组的大小
  details: |-
    #### 概要
    需要明确外部链接的数组的大小

    #### 解释
    为了保证一致性以及确定存储区的边界，在声明外部链接的数组时必须确定该数组的大小。
  examples:
    bad:
      c:
        - >-

          #include <stdio.h>


          extern int array[]; // declare array with external linkage but without
          size


          int foo ( void )

          {
              return array[10]; // 10 may be bigger than actual array size
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - >-

          #include <stdio.h>


          extern int array[20]; // declare array with external linkage and its
          size


          int foo ( void )

          {
              return array[10];
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中未明确外部链接的数组的大小。
  name: 声明带有外部链接的数组时，应明确指定其大小
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_8_11
- alias: {}
  category: ''
  code: MSR_8_12
  compliance: R
  cost: H
  csv_string:
    - MSR_8_12
  desc: 默认赋值的枚举成员的值唯一
  details: |-
    #### 概要
    默认赋值的枚举成员的值唯一

    #### 解释
    为了避免枚举成员的值错误地重复，应该保证通过枚举值列表顺序默认赋值地枚举成员的值唯一。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          // implicitly-specified enmueration sat is not unique
          typedef enum weekday {thu = 4, fri, sat, sun = 6};
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          // all implicitly-specified enmueration constants is unique
          typedef enum weekday {thu = 4, fri, sat = 6, sun = 6};
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中的隐式指定的枚举常量列表不唯一。
  name: 隐式指定的枚举常量列表应是唯一的
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_8_12
- alias: {}
  category: ''
  code: MSR_8_13
  compliance: A
  cost: H
  csv_string:
    - MSR_8_13
  desc: 建议将指针声明限定为常量
  details: |-
    #### 概要
    建议将指针声明限定为常量

    #### 解释
    指针应指向相同限定的类型。指针若是指向的限定类型不同，应进行显式转换。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func (char *ptr);

          void func (char *ptr) // pointer declared is not const-qualified
          {
              // ptr pointed to is not modified, it should be const-qualified
              printf ("%c", *ptr);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func (const char *ptr);

          void func (const char *ptr) // pointer declared const-qualified
          {
              // ptr pointed to is not modified
              printf ("%c", *ptr);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中指针声明不是常量。
  name: 指针应尽可能指向 const 限定的类型
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_8_13
- alias: {}
  category: ''
  code: MSR_8_14
  compliance: R
  cost: H
  csv_string:
    - MSR_8_14
  desc: 尽量避免使用restrict关键字
  details: |-
    #### 概要
    尽量避免使用restrict关键字

    #### 解释
    为防止指针指向的区域重合等问题，应该尽量避免使用restrict关键字。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          // restrict-qualified parameters declared
          extern void func (int * restrict ptr1, int * restrict ptr2);

          void func2(void)
          {
              int i;
              int *a,*b;
              a = b = &i;
              // overlap memory areas
              func (a, b);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          // restrict type qualifier removed
          extern void func (int * ptr1, int * ptr2);

          void func2(void)
          {
              int i;
              int *a,*b;
              a = b = &i;
              func (a, b);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中使用了restrict关键字
  name: 不能使用限制限定符
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_8_14
- alias: {}
  category: ''
  code: MSR_9_3
  compliance: R
  cost: H
  csv_string:
    - MSR_9_3
  desc: 不能只初始化数组的一部分
  details: |-
    #### 概要
    不能只初始化数组的一部分

    #### 解释
    为了保证在显式初始化数组后数组中不再存在未经过处理的值，在对数组进行显式初始化时也必须对数组内所有的元素进行显式初始化操作。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int func ( void )
          {
              int a[10] = {0, 0, 0}; // array only initialized three elements
              return a[9]; // a[9] is still unknown value
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          int func ( void )
          {
              int a[10] = {0}; // array totally initialized
              return a[9];
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中的数组只被部分初始化
  name: 数组不应该部分初始化
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_9_3
- alias: {}
  category: ''
  code: MSR_9_4
  compliance: R
  cost: H
  csv_string:
    - MSR_9_4
  desc: 对象中的元素只能初始化一次
  details: |-
    #### 概要
    对象中的元素只能初始化一次

    #### 解释
    在进行不按默认顺序的数组和结构体的初始化的时，必须注意不能对同一元素进行重复的初始化。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func( void )
          {
              // a[0] initialized twice
              int arr[3] = { [ 0 ] = 3, [ 1 ] = 2, [ 2 ] = 1, [ 0 ] = 4};
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func( void )
          {
              // all elements initialized once
              int arr[3] = { [ 0 ] = 3, [ 1 ] = 2, [ 2 ] = 1};
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}，对象中的元素被初始化多于一次
  name: 不允许对对象中的元素进行多次初始化
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_9_4
- alias: {}
  category: ''
  code: MSR_9_5
  compliance: R
  cost: H
  csv_string:
    - MSR_9_5
  desc: 使用显式初始化的数组必须声明其大小
  details: |-
    #### 概要
    使用显式初始化的数组必须声明其大小

    #### 解释
    为确定数组的最大的元素数量，使用显式初始化方法进行初始化的数组的大小必须是确定的。
  examples:
    bad:
      c:
        - |-

          // This is example from MISRA document
          // Non-compliant - probably unint entional to have single element
          int a1[ ] = { [ 0 ] = 1 };
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          // This is example from MISRA document
          // Compliant
          int a2[ 10 ] = { [ 0 ] = 1 };
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}使用显式初始化的数组未声明其大小
  name: 如果在数组中使用初始值设定项，则必须知道其大小
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_9_5
- alias: {}
  category: ''
  code: MSR_10_3
  compliance: R
  cost: H
  csv_string:
    - MSR_10_3
  desc: 不能为不同类型的对象赋值
  details: |-
    #### 概要
    不能为不同类型的对象赋值

    #### 解释
    把表达式的值赋值给不恰当类型的或者大小不足以表示该值的数据类型的对象，都是错误的做法。
  examples:
    bad:
      c:
        - |-

          #include <stdint.h>
          #include <stdbool.h>

          void func ( void )
          {
              short short_a;
              long int b;
              short_a = b;            // b assigned to narrower essential type
              uint16_t c = 0.5f;    // float to unsigned
              bool d = 1;             // signed to boolean
              char e = 3;             // signed to char
              uint32_t f = 'test';  // char to unsigned
              uint16_t g = 5;       // signed to unsigned
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdint.h>
          #include <stdbool.h>

          void func ( void )
          {
              short short_a;
              int b;              // b declared as int for illustration
              b = short_a;        // short_a assigned to wider essential type object
              uint16_t c = 0;   // compliant by exception
              bool d = false;     // compliant
              uint16_t e = 5;   // compliant by exception
              char f = "f_char";  // char to char
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中出现向下转换表达式
  name: 不允许向下转换表达式
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_10_3
- alias: {}
  category: ''
  code: MSR_10_4
  compliance: R
  cost: H
  csv_string:
    - MSR_10_4
  desc: 同一操作符的两个操作数为同一类型
  details: |-
    #### 概要
    同一操作符的两个操作数为同一类型

    #### 解释
    用二元或者三元操作数对两个不同的类型的操作数可能会使所得的值的部分信息丢失。因此在一般情况下，统一操作符的两操作数应该为同一类型。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int int_var;
              char char_var;
              // float 1.0f added to char char_var, not permitted
              char_var += 1.0f;
              // float 1.0f added to int int_var, differnt type
              int_var += 1.0f;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int int_var;
              char char_var;
              // int 1 added to char char_var, permitted
              char_var += 1;
              // int 1 added to int int_var, same type
              int_var += 1;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中同一操作符的两个操作数不是同一类型
  name: 操作数和类型转换
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_10_4
- alias: {}
  category: ''
  code: MSR_10_6
  compliance: R
  cost: H
  csv_string:
    - MSR_10_6
  desc: 使用复合表达式为更大的数据类型的对象赋值应使用显式转换
  details: |-
    #### 概要
    使用复合表达式为更大的数据类型的对象赋值应使用显式转换

    #### 解释
    将一个复合表达式的值转换为储存空间更大的数据类型并赋值给一个对象时必须要使用显式转换。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              long int long_var;
              short int short_a, short_b;
              short_a = short_b = 1;
              long_var = short_a + short_b; // implicitly converted to long
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              long long_var;
              short short_a, short_b;
              short_a = 1;
              short_b = 1;
              long_var = ( long )short_a + short_b; // explicitly converted to long
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中，使用复合表达式为更大的数据类型的对象赋值时未使用显式转换
  name: 复合表达式的赋值应保持相同的大小
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_10_6
- alias: {}
  category: ''
  code: MSR_10_7
  compliance: R
  cost: H
  csv_string:
    - MSR_10_7
  desc: 复合表达式作为操作数转化为更大的数据类型时用显式转换
  details: |-
    #### 概要
    复合表达式作为操作数转化为更大的数据类型时用显式转换

    #### 解释
    当复合表达式作为操作符的其中一个操作数并且需要转化为更大的数据类型时，必须使用显示转换。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              short int short_a, short_b;
              long int long_a, long_b;
              long_a = 1;
              short_a = short_b = 2;
              long_b = (short_a * short_b) * long_a; // implicitly converted to long
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              short int short_a, short_b;
              long int long_a, long_b;
              long_a = 1;
              short_a = short_b = 2;
              long_b = ( ( long ) short_a * short_b ) * long_a; // explicitly converted to long
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中，复合表达式作为操作数转化为更大的数据类型时未使用显式转换
  name: 对于复合表达式，不允许在任一侧进行任何向上转换
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_10_7
- alias: {}
  category: ''
  code: MSR_10_8
  compliance: R
  cost: H
  csv_string:
    - MSR_10_8
  desc: 复合表达式的值不能被转换为不适当的数据类型
  details: |-
    #### 概要
    复合表达式的值不能被转换为不适当的数据类型

    #### 解释
    在数据类型转换中可能会导致数据的丢失或者改变，因此不能复合表达式的值不能被转换为不适当的数据类型。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>
          #include<stdint.h>

          void func ( void )
          {
              float float_a, float_b;
              int int_var;
              float_a = float_b = 1.0f;
              int_var = ( int ) ( float_a + float_b ); // casted to inappropriate type int

              uint8_t uint_var;
              uint_var = ( uint8_t ) ( float_a + float_b ); // different essential type
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
          #include <stdint.h>

          void func ( void )
          {
              float float_a, float_b;
              int int_var;
              float_a = float_b = 1.0f;
              int_var = ( int ) float_a + ( int ) float_b; // float_a and float_b casted to type int

              uint8_t uint_var;
              uint_var = ( uint8_t ) int_var; // compliant
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中，复合表达式的值被转换为不适当的数据类型
  name: 复合表达式不能向上转换
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_10_8
- alias: {}
  category: ''
  code: MSR_11_2
  compliance: R
  cost: H
  csv_string:
    - MSR_11_2
  desc: 指向不完整类型的指针与其他类型的指针不能转换，反之亦然
  details: |-
    #### 概要
    指向不完整类型的指针与其他类型的指针不能转换，反之亦然

    #### 解释
    对指向不完整类型的指针进行类型转换操作可能会破坏不完整类型的封装，因此不能对不完整类型的指针转换为其他类型的指针。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          union uni; // incomplete type declared

          void func ( void )
          {
              union uni *ptr_union;
              int *ptr_int; 
              // ptr_int converted to pointer to incomplete type
              ptr_union = ( union uni * ) ptr_int;
              // ptr_union (incomplete type) converted to int pointer
              ptr_int = ( int * )ptr_union;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          union uni
          {
              int i;
              char c;
          }; // union declared

          void func ( void )
          {
              union uni union_var;
              union_var.i =1;
              int *ptr_int;
              // ptr_int point to union_var.i
              ptr_int = &union_var.i;

              // exception 1
              struct a;
              struct a *p;
              p = NULL;

              // exception 2
              struct a *test ( void );
              ( void ) test ();
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中，指向不完整类型的指针与其他类型的指针进行了转换
  name: 不能将指向不完整类型的指针转换为任何其他类型
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_11_2
- alias: {}
  category: ''
  code: MSR_11_3
  compliance: R
  cost: H
  csv_string:
    - MSR_11_3
  desc: 不能将指针转换为其他类型的指针
  details: |-
    #### 概要
    不能将指针转换为其他类型的指针

    #### 解释
    将指向一种类型的指针转换为另一种类型的指针可能会导致对齐错误以及未定义的行为，因此不能将指针转换为其他类型的指针。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int *ptr_int;                 // pointer to int declared
              char *ptr_char;               // pointer to char declared
              ptr_int = ( int * ) ptr_char; // convert to int type pointer

              const int * const * ptr_const_int;
              ptr_const_int = ( const int * const * ) ptr_int; // convert to constant-qualified int type pointer
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int *ptr_int;    // pointer to int declared
              char *ptr_char;  // pointer to char declared
              *ptr_char = NULL;
              *ptr_int = NULL; // pointers point to null
              const *ptr_const;
              const volatile *ptr_const_v;
              ptr_const_v = (const volatile *) ptr_const; // compliant
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中指针被转换为其他类型的指针
  name: 不同类型的指针之间不能相互转换
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_11_3
- alias: {}
  category: ''
  code: MSR_11_4
  compliance: A
  cost: H
  csv_string:
    - MSR_11_4
  desc: 避免指针和整数相互转换
  details: |-
    #### 概要
    避免指针和整形的相互转换

    #### 解释
    在实现指针和整形的转换可能会导致整形的数据溢出或者指针无法正常对齐，因此尽可能避免指针和整形的相互转换。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int *ptr_int;
              int int_a, int_b;
              int_a = 1;
              ptr_int = ( int * ) int_a; // convert int to pointer
              int_b = ( int ) ptr_int;   // convert pointer to type int
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int *ptr_int;
              int int_a, int_b;
              int_a = 1;
              ptr_int = &int_a; // ptr_int point to int_a
              int_b = *ptr_int; // *ptr_int assigned to int_b
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中出现指针和整数相互转换
  name: 避免指针和整数相互转换
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_11_4
- alias: {}
  category: ''
  code: MSR_11_5
  compliance: A
  cost: H
  csv_string:
    - MSR_11_5
  desc: 避免将空类型指针转换为指向其他对象的指针
  details: |-
    #### 概要
    避免将空类型指针转换为指向其他对象的指针

    #### 解释
    从指向 void 的指针转换为指向对象的指针可能会导致未定义的行为。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              void *ptr_void; // void pointer declared
              int *ptr_int;   // int pointer declared
              int int_var;
              ptr_void = &int_var;
              // convert void pointer into int pointer
              ptr_int = ( int * ) ptr_void;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              void *ptr_void; // void pointer declared
              int *ptr_int;   // int pointer declared
              int int_var;
              ptr_int = &int_var;
              // convert int pointer into void pointer
              ptr_void = ( void * ) ptr_int;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中出现将空类型指针转换为指向其他对象的指针
  name: 避免将空类型指针转换为指向其他对象的指针
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_11_5
- alias: {}
  category: ''
  code: MSR_11_6
  compliance: R
  cost: H
  csv_string:
    - MSR_11_6
  desc: 不能进行空类型指针以及算术类型的转换
  details: |-
    #### 概要
    不能进行空类型指针以及算术类型的转换

    #### 解释
    对空类型指针和算术类型相互的数据类型转换可能会引起对齐问题以及数据转换中出现未定义行为。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              void *ptr_void;
              int int_var;
              // convert int_var to void pointer
              ptr_void = ( void * ) int_var;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          #define ZERO 0

          void func ( void )
          {
              void *ptr_void;
              int int_var;
              // ptr_void point to the address of int_var
              ptr_void = &int_var;
              ptr_void = (void *)ZERO;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中出现空类型指针以及算术类型的转换
  name: 避免空指针和算术类型之间的转换
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_11_6
- alias: {}
  category: ''
  code: MSR_11_7
  compliance: R
  cost: H
  csv_string:
    - MSR_11_7
  desc: 不能进行指向对象的指针与非整形的算术类型的转换
  details: |-
    #### 概要
    不能进行指向对象的指针与非整形的算术类型的转换

    #### 解释
    为了防止在类型转换过程中出现未定义行为，不应进行指向对象的指针与非整形算术类型的相互数据类型转换。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              char a, b;
              int *p;
              a = ( char ) p;  // non-compliant
              p = ( int * ) b; // non-compliant
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int a, b;
              int *p;
              a = ( int ) p; // compliant
              p = ( int * ) b; // compliant
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中出现指向对象的指针与非整形的算术类型的转换
  name: 不能进行指向对象的指针与非整形的算术类型的转换
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_11_7
- alias: {}
  category: ''
  code: MSR_11_8
  compliance: R
  cost: H
  csv_string:
    - MSR_11_8
  desc: 指针的数据类型转换不能去除const和volatile限定符
  details: |-
    #### 概要
    指针的数据类型转换不能去除const和volatile限定符

    #### 解释
    在进行指针的数据类型转换时不能去除定义中的const和volatile限定符，否则可能导致该指针的读写过程出现错误。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>
          #include <malloc.h>

          void func ( void );

          void func ( void )
          {
              int * const *p_constpt;
              volatile int *p_volatile;
              // pointer to const declared
              const int * ptr_const = ( int *) malloc ( sizeof ( int ) );
              int *ptr_int;
              int * *p_ptr_int;
              // const qualifier removed in a cast
              ptr_int = ( int * ) ptr_const;
              ptr_int = ( int * ) p_volatile;
              p_ptr_int = ( int * * ) p_constpt;
              // more code that may change ptr_const
              // ... 
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
          #include <malloc.h>

          void func ( void );

          void func ( void )
          {
              // const pointer declared
              int * const ptr_const = ( int *) malloc ( sizeof ( int ) );
              int *ptr_int;
              // ptr_int point to the address of ptr_const
              ptr_int = ptr_const;
              // more code that may change ptr_const
              // ...
              
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中，指针的数据类型转换去除了const和volatile限定符
  name: 指针的数据类型转换不能去除const和volatile限定符
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_11_8
- alias: {}
  category: ''
  code: MSR_11_9
  compliance: R
  cost: H
  csv_string:
    - MSR_11_9
  desc: 空的整型指针只能指向宏定义NULL
  details: |-
    #### 概要
    空的整型指针只能指向宏定义NULL

    #### 解释
    在向指针赋值，或使用指针作为等于、不等于或者三目运算符时，应能用宏定义NULL表示空的整型。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func ( void );

          void func ( void )
          {
              int *int_ptr = 0; // 0 assigned to ptr_int
              // 0 appear as an operand with the other operand a pointer
              if ( int_ptr != 0 )
              {
                  *int_ptr = NULL;
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func ( void );

          void func ( void )
          {
              int *int_ptr = NULL; // ptr_int point to NULL
              // NULL appear as an operand with the other operand a pointer
              if ( int_ptr != (int *)NULL )
              {
                  *int_ptr = NULL;
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中，一个空整型指针不仅指向宏 NULL
  name: 空的整型指针只能指向宏定义NULL
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_11_9
- alias: {}
  category: ''
  code: MSR_12_2
  compliance: R
  cost: H
  csv_string:
    - MSR_12_2
  desc: 位移运算符的右操作数应该从零到左操作数的位数中取值
  details: |-
    #### 概要
    位移运算符的右操作数应该从零到左操作数的位数中取取值

    #### 解释
    位移运算符的右操作数应该为一个正整数，取值范围为零到左操作数的位数，取超出该范围的值为未定义的行为。
  examples:
    bad:
      c:
        - |-

          #include <stdint.h>

          void func ( void );

          void func ( void )
          {
              uint16_t uint16_var = 2;
              // 17 is bigger than the size of uint16_var
              uint16_var = uint16_var << 17;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdint.h>

          void func ( void );

          void func ( void )
          {
              uint16_t uint16_var = 2;
              uint32_t uint32_var;
              // 17 is in the range 0 to the size of uint16_var
              uint32_var = uint32_var << 17;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中，位移运算符的右操作数不是从零到左操作数的位数中取值
  name: 移位运算符的移位量必须小于操作数的位数
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_12_2
- alias: {}
  category: ''
  code: MSR_12_3
  compliance: A
  cost: H
  csv_string:
    - MSR_12_3
  desc: 尽量不使用逗号运算符
  details: |-
    #### 概要
    尽量不使用逗号运算符

    #### 解释
    由于使用逗号运算符会降低代码的可读性，因此要尽量避免使用逗号运算符。
  examples:
    bad:
      c:
        - |-

          #include <stdint.h>

          static char a[ 10 ];

          void func ( void )
          {
              int i;
              char *p;
              // comma operator would reduce the readability of code
              for ( i = 0, p = &a[ 0 ]; i < 10 ; ++i, *p++ = i)
              {
                  foo(p);
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdint.h>

          static char a[ 10 ];

          void func ( void )
          {
              int i;
              char *p;
              // same effect achieved by other mean
              p = &a[ 0 ];
              for ( i = 0; i < 10 ; ++i)
              {
                  *p++ = i;
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中使用了逗号运算符
  name: 不允许使用逗号运算符
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_12_3
- alias: {}
  category: ''
  code: MSR_12_4
  compliance: A
  cost: H
  csv_string:
    - MSR_12_4
  desc: 无符号整形常量表达式的值不能导致回绕
  details: |-
    #### 概要
    无符号整形常量表达式的值不能导致回绕

    #### 解释
    为防止发生回绕，因此无符号整形常量表达式的值的取值范围应为零到无符号整形能表示的最大值。
  examples:
    bad:
      c:
        - >-

          #include <stdio.h>


          #define MAXIMUM 0xffffffffu // value of unsigned int (assume int is 32
          bits)

          #define ONE     0x1u

          void func( void );


          void func( void )

          {
              unsigned int uint_var;
              // the value of MAXIMUM + 1 lead to wrap-around
              uint_var = MAXIMUM + ONE;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          #define MAXIMUM 0xffffffffu // maximum value of unsigned int

          const unsigned int const_int = 1;
          void func( void );

          void func( void )
          {
              unsigned int uint_var;
              // 0xffffffff assigned to long_long_var
              uint_var = MAXIMUM;
              // uint_var + 1 and uint_var + const_int is not a constant expression
              uint_var = uint_var + 1;
              uint_var = uint_var + const_int;
              
              if (( 1 < 0 ) || ( 0u - 10u ))
              {
                  // compliant
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中，无符号整形常量表达式的值导致了回绕
  name: 无符号整形常量表达式的值不能导致回绕
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_12_4
- alias: {}
  category: ''
  code: MSR_13_1
  compliance: R
  cost: H
  csv_string:
    - MSR_13_1
  desc: 初始化列表不应该产生副作用
  details: |-
    #### 概要
    初始化列表不应该产生副作用

    #### 解释
    为避免导致初始化的内容出现错误以及副作用影响程序运行，不应该在初始化列表中进行对其他参数赋值等产生副作用的操作。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func( void )
          {
              int x = 0;
              // object x modified due to side effect
              int arr[2] = { ++x, ++x };
              // more code may call x
              // ...
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func( void )
          {
              int x = 0;
              // array initialized with no side effect
              int arr[2] = { 1, 2 };
              // more code may call x
              // ...
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中，初始化列表产生了副作用
  name: 初始化列表不应含有持久的副作用
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_13_1
- alias: {}
  category: ''
  code: MSR_13_2
  compliance: R
  cost: H
  csv_string:
    - MSR_13_2
  desc: 所有执行顺序下表达式的值及副作用一致
  details: |-
    #### 概要
    所有执行顺序下表达式的值及副作用一致

    #### 解释
    由于表达式可能存在多种执行的顺序，设计表达式应该保证在所有可能的执行顺序下表达式的值以及其副作用都相同。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int func( void )
          {
              int a = 6;

              a += a -= a*a;
              return a;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          int func( void )
          {
              int a = 6;
              // the value will sure to be -60
              a -= a*a;
              a += a;
              return a;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，表达式${so.func}的值在所有可能的运行顺序下不是唯一确定的。
  name: '持久副作用表达式应相同 '
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_13_2
- alias: {}
  category: ''
  code: MSR_13_3
  compliance: A
  cost: H
  csv_string:
    - MSR_13_3
  desc: 增减量运算符不能有额外的副作用
  details: |-
    #### 概要
    增减量运算符不能有额外的副作用

    #### 解释
    避免混合使用增量或减量运算符与其他运算符，包括函数调用，否则可能损害程序可读性。
  examples:
    bad:
      c:
        - "\n#include <stdio.h>\n\nint func1( void )\n{\n    int int_a, int_b, int_c;\n    int_a = int_b = 1;\n    // the\_complex\_expression\_impairs\_the\_readability\n    int_c = ++int_a * int_b--;\n    return int_c;\n}\n\nvoid func2 ( void )\n{\n    int x = 1;\n    // function call is side effect\n    if ( ( func1() - ++x ) > 5)\n    {\n        // non-compliant\n    }\n}"
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          int func( void )
          {
              int int_a, int_b, int_c;
              int_a = int_b = 1;
              // make the code more readable by this mean
              ++int_a;
              int_c = int_a * int_b;
              int_b--;
              return int_c;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中，增减量运算符出现额外的副作用
  name: 增减量运算符无副作用
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_13_3
- alias: {}
  category: ''
  code: MSR_13_4
  compliance: A
  cost: H
  csv_string:
    - MSR_13_4
  desc: 赋值运算符的结果不能被使用
  details: |-
    #### 概要
    赋值运算符的结果不能被使用

    #### 解释
    由于会引入额外的副作用，赋值运算符的结果不能被作为一个值使用，否则会损害程序可读性。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>
          #include <stdbool.h>

          int test( void )
          {
            return 0;
          }

          int func(int x, int y)
          {
            int ret_var;
            ret_var = 1;
            bool bool_var;

            if ( ( ret_var == 1 ) || ( bool_var = true ) )
            {
              // non-compliant
            }

            if ( ( ret_var = test() ) > 1 )
            {
              // non-compliant
            }

            while (0) {
              // ...
              if (x = 0) {  // typical typo interpreted as an assignment
                ret_var = x = y; // non-compliant
              }
            }
            return ret_var;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
          #include <stdbool.h>

          void func( void )
          {
              bool bool_var;
              bool_var = true;
              // == is not an assignment operator
              while (bool_var == true)
              {
                  // some code that change bool_var
                  // ...
              }
              
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中赋值运算符的结果被使用
  name: 在表达式中分配运算符
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_13_4
- alias: {}
  category: ''
  code: MSR_13_5
  compliance: R
  cost: H
  csv_string:
    - MSR_13_5
  desc: '&&和||运算符的右操作数不能有副作用'
  details: |-
    #### 概要
    &&和||运算符的右操作数不能有副作用

    #### 解释
    为了防止右操作数不执行导致应有的副作用没有产生，&&和||运算符的右操作数不能产生副作用。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>
          #include <stdbool.h>

          static int int_a;
          void func( void );
          int func2( void );
          bool return_true( void );

          void func( void )
          {
              int int_b;
              
              // int_a is not modified as intended
              if( return_true() || int_b == func2() );
              // more code that may read int_a
              // ...
          }

          int func2( void )
          {
              int_a++; // side effect: int_a is modified
              return int_a;
          }

          bool return_true( void )
          {
              return true;
          }

          void func3( void )
          {
              volatile int x;
              int y = 1;
              if ( ( y != 0) || ( x != 1 ) );
              // access volatile object x has persistent side effect
          }

          void func4( void )
          {
              int *fp = func2;
              if ( (fp == NULL) || (*fp) );
              // fp points to function with persistent effect
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
          #include <stdbool.h>

          static int int_a;
          void func( void );
          int func2( void );
          bool return_true( void );

          void func( void )
          {
              int int_b;
              
              // right operand do not have side effect
              if( return_true() || int_b == func2() );
              // more code that may read int_a
              // ...
          }

          int func2( void )
          {
              return int_a + 1; // do not have side effect
          }

          bool return_true( void )
          {
              return true;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中，&&和||运算符的右操作数有副作用
  name: '&&和||运算符的右操作数不应该有副作用'
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_13_5
- alias: {}
  category: ''
  code: MSR_13_6
  compliance: M
  cost: H
  csv_string:
    - MSR_13_6
  desc: sizeof的操作数不能有持续的副作用
  details: |-
    #### 概要
    sizeof的操作数不能有持续的副作用

    #### 解释
    由于sizeof不一定会执行它的操作数中的表达式，sizeof的操作数不能产生副作用。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func( void )
          {
              int int_a, int_b;
              
              // int_b is not modified as intended
              int_a = sizeof( int_b++ );
              // some code that may read int_b
              // ...
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func( void )
          {
              int int_a, int_b;

              // the operand do not have side effect
              int_a = sizeof( int_b );
              int_b++; // int_b modified as intended
              // some code that may read int_b
              // ...
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中，sizeof的操作数有持续的副作用
  name: sizeof 运算符的操作数不应有潜在的副作用
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_13_6
- alias: {}
  category: ''
  code: MSR_18_4
  compliance: A
  csv_string:
    - MSR_18_4
  desc: 不能使用指针算术，除了++和--
  details: |-
    #### 概要
    不能使用指针算术，除了++和--

    #### 解释
    指针算法会让初学者感到困惑。表达式ptr+1可能被错误地解释为向ptr中保存的地址添加一个字节
  examples:
    bad:
      c:
        - |-

          void func(){
              int arr[3] = {0, 1, 2};

              int *ptr;
              ptr = arr;

              * (ptr + 1) = 0; // Using + in pointer arithmatic is confusing
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          void func(){
              int arr[3] = {0, 1, 2};

              int *ptr;
              ptr = arr;
              ptr++;  // ++ operator is allowed
              ptr[1] = 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中，使用了除++和--之外的指针算术
  name: 不能使用指针算术，除了++和--
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: L
  standards:
    mc:
      - MSR_18_4
- alias: {}
  category: ''
  code: MSR_18_8
  compliance: R
  cost: H
  csv_string:
    - MSR_18_8
  desc: 不得使用可变长数组类型
  details: |-
    #### 概要
    不得使用可变长数组类型

    #### 解释
    使用可变长度数组类型将无法静态确定必须为堆栈保留的内存量
  examples:
    bad:
      c:
        - |-

          void foo(int n) {
              int arr[n];
          }

          void func() {
              foo(-1);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          void foo() {
              // Don't use variable-length array
              int arr[5];
          }

          void func() {
              foo();
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中使用了可变长数组类型
  name: 不得使用可变长数组类型
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_18_8
- alias: {}
  category: ''
  code: MSR_19_2
  compliance: A
  csv_string:
    - MSR_19_2
  desc: 不得使用联合
  details: |-
    #### 概要
    不得使用联合

    #### 解释
    如果读取的联合成员比写入的成员宽，则该值未指定。由于可以访问具有未指定值的字节，因此不应使用联合
  examples:
    bad:
      c:
        - |-

          typedef union UnionT
          {
            int    i;
            char   c;
            double d;
          } UNIONT;

          typedef struct MyData
          {
            int     tag;
            UNIONT  u;
          } MYDATA;


          int foo(char ch_param)
          {
             MYDATA md;

             md.tag = 0;  // say, 0 for int, 1 for char, 2 for double
             md.u.c = ch_param;

             return md.u.i; // return is undefined
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
          #include <string.h>

          struct Foo {
              int i;
              float f;
              char str[10];
          };

          void func() {
              struct Foo data;

              data.i = 5;
              data.f = 10.5;
              strcpy(data.str, "string");

              // Use struct instead of union to keep everything
              printf("%d\n", data.i);
              printf("%f\n", data.f);
              printf("%s\n", data.str);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中使用了联合
  name: 不得使用联合
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_19_2
- alias: {}
  category: ''
  code: MSR_21_3
  compliance: R
  csv_string:
    - MSR_21_3
  desc: 不得使用 stdlib.h 中的内存分配相关函数
  details: |-
    #### 概要
    不得使用 stdlib.h 中的内存分配相关函数

    #### 解释
    在stdlib.h中使用内存分配相关函数可能会导致未定义的行为。例如：动态分配的内存可能不会随后释放
  examples:
    bad:
      c:
        - |-

          #include <string.h>
          #include <stdio.h>
          #include <stdlib.h>

          void func() {
              char *str;

              str = (char *) malloc(10);
              strcpy(str, "string");
              printf("%s", str);

              free(str);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <string.h>
          #include <stdio.h>
          #include <stdlib.h>

          void func() {

              #define MAX_STR_SZ 10   
              char str[MAX_STR_SZ];
              strncpy(str, "string", MAX_STR_SZ);
              
              strcpy(str, "string");
              printf("%s", str);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中使用了stdlib.h 中的内存分配相关函数
  name: 不得使用 stdlib.h 中的内存分配相关函数
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_21_3
- alias: {}
  category: ''
  code: MSR_21_4
  compliance: R
  csv_string:
    - MSR_21_4
  desc: '不可以使用setjmp.h '
  details: |-
    #### 概要
    不可以使用setjmp.h 

    #### 解释
    Setjmp允许绕过正常的函数调用/返回机制。使用该选项可能导致未定义和未指定的行为
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>
          #include <stdlib.h>
          #include <setjmp.h>

          void func() {
              int val;
              jmp_buf env_buffer;

              val = setjmp(env_buffer);

              // Set value to val after lngjmp
              if (val != 0) {
                  printf("Return from longjmp with value = %d", val);
                  exit(0);
              }

              // Jump back to top
              printf("Jump to top");
              // Using longjmp and setjmp can cause undefined behaviour
              longjmp(env_buffer, 10);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
          #include <stdlib.h>

          // Do not use functions from setjmp.h
          void func() {
              int val;
              val = 10;
              printf("%d", val);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: '在${so.filename}，第${so.line}行，函数${so.func}中使用了setjmp.h '
  name: '不可以使用setjmp.h '
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_21_4
- alias: {}
  category: ''
  code: MSR_21_5
  compliance: R
  csv_string:
    - MSR_21_5
  desc: '不可以使用signal.h '
  details: |-
    #### 概要
    不可以使用signal.h 

    #### 解释
    由于信号处理包含实现定义和未定义的行为，signal.h不得用于C90和C99模式
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>
          #include <signal.h>
          #include <stdbool.h>
          #include <unistd.h>

          void sig_handler(int signum) {
              printf("\nInside handler function\n");
          }

          void func() { 
              // Register signal handler
              // Using functions from signal.h can lead to undefined behaviour
              signal(SIGINT,sig_handler); 
            
              while(true) {    
                  printf("Inside func()");    
                  sleep(1);  
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
          #include <stdbool.h>
          #include <unistd.h>

          void func() { 
              // Do not use signal handler functions 

              while(true) {    
                  printf("Inside func()");    
                  sleep(1);  
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: '在${so.filename}，第${so.line}行，函数${so.func}中使用了signal.h '
  name: '不可以使用signal.h '
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_21_5
- alias: {}
  category: ''
  code: MSR_21_6
  compliance: R
  csv_string:
    - MSR_21_6
  desc: 不得使用 stdio.h 中的 I/O 函数
  details: |-
    #### 概要
    不得使用 stdio.h 中的 I/O 函数

    #### 解释
    由于I/O具有未指定的、未定义的和实现定义的行为，因此在stdio.h中，I/O函数及其字符等价物不得用于C90和C99模式
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void bar_c(void* ptr)
          {
              int* dest = (int*)ptr;
              int data = (*dest);
              int i;
              int Buffer[10] = { 0 };
              if(data >= 0)
                {
                   Buffer[data] = 1;
                   for(i=0; i<10; i++)
                   {
                       printf("%d", Buffer[i]);
                   }
               }
           }

           void foo_v()
           {
               int data;
               data = -1;
               fscanf(stdin, "%d", &data); // this can easily cause array out of bound
               bar_c(&data);
           } 
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          void func() {
              // Do something
              // Do not use stdio.h functions
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中使用了 stdio.h 中的 I/O 函数
  name: 不得使用 stdio.h 中的 I/O 函数
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_21_6
- alias: {}
  category: ''
  code: MSR_21_7
  compliance: R
  csv_string:
    - MSR_21_7
  desc: 不得使用 stdlib.h 中的 ascii 转换函数
  details: |-
    #### 概要
    不得使用 stdlib.h 中的 ascii 转换函数

    #### 解释
    由于atof、atol和atol函数在字符串无法转换时具有未定义的行为，因此它们不应用于C90和C99模式
  examples:
    bad:
      c:
        - |-

          #include <iostream>
          #include <cstdlib>

          int foo()
          {
            char s[] = "98";
            long num;

            num = atol(s);

            std::cout << "number in long = " << num << std::endl;
              
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
          #include <stdlib.h>
          #include <string.h>

          void func() {
             float val;
             char str[10];
             
             strcpy(str, "914");
             val = 914.000; //Do not use atof, atol, atoll, atoi
             printf("String value = %s, Float value = %f\n", str, val);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中使用了 stdlib.h 中的 ascii 转换函数
  name: 不得使用 stdlib.h 中的 ascii 转换函数
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_21_7
- alias: {}
  category: ''
  code: MSR_21_8
  compliance: R
  csv_string:
    - MSR_21_8
  desc: 不得使用 getenv、getenv 和 exit 函数
  details: |-
    #### 概要
    不得使用 getenv、getenv 和 exit 函数

    #### 解释
    由于getenv、getenv和exit函数具有未定义和实现定义的行为，因此它们不应用于C90和C99模式。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>
          #include <stdlib.h>

          int main(void)
          {
            char* ptr_h;
            char h[64];

            ptr_h = getenv("HOME");  // value of HOME could be > 64, need size guard
            if (ptr_h != NULL) {
              // ...
            }
            return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
          #include <stdlib.h>

          void func () {
             printf("Start of program\n");
             
             // Do not use abort, exit, getenv or system

             printf("End of program\n");

             return(0);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中使用了 getenv、getenv 和 exit 函数
  name: 不得使用 getenv、getenv 和 exit 函数
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_21_8
- alias: {}
  category: ''
  code: MSR_21_9
  compliance: R
  csv_string:
    - MSR_21_9
  desc: 不得使用 bsearch 和 qsort
  details: |-
    #### 概要
    不得使用 bsearch 和 qsort

    #### 解释
    如果bsearch和qsort函数在比较元素时行为不一致，或者它们修改了任何元素，则该行为未定义。因此，它们不应用于C90和C99模式
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>
          #include <stdlib.h>


          int cmpfunc(const void * a, const void * b) {
             return ( *(int*)a - *(int*)b );
          }

          int arr[] = { 1, 2, 3, 4, 5 };

          void func () {
             int *item;
             int key = 3;

             // use bsearch to compare and find values of 3 in the array arr
             item = (int*) bsearch (&key, arr, 5, sizeof (int), cmpfunc);
             if( item != NULL ) {
                printf("Found item");
             } else {
                printf("Item is not in the array");
             }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
          #include <stdlib.h>

          int arr[] = { 1, 2, 3, 4, 5 };

          void func () {
             int key = 3;

             // Use other method other than bsearch for searching element in an array
             for (int i = 0; i < sizeof(arr) / 4; i++) {
                if (arr[i] == key) {
                   printf("Item found");
                   break;
                }
             }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: ''
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中使用了 bsearch 和 qsort
  name: 不得使用 bsearch 和 qsort
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_21_9
- alias: {}
  category: ''
  code: MSR_21_10
  compliance: R
  csv_string:
    - MSR_21_10
  desc: 不得使用 stdlib.h 中的时间和日期函数
  details: |-
    #### 概要
    不得使用 stdlib.h 中的时间和日期函数

    #### 解释
    由于时间和日期函数具有未指定、未定义和实现定义的行为，因此它们不应用于C90和C99模式。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>
          #include <time.h>
           
          void func (){
             // Using time and date function can lead to undefined behaviour
             printf("%ld", time(NULL));
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
           
          void func (){
             // Do something
             // Do not use time and date function
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中使用了 stdlib.h 中的时间和日期函数
  name: 不得使用 stdlib.h 中的时间和日期函数
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_21_10
- alias: {}
  category: ''
  code: MSR_5_0_1
  compliance: R
  cost: H
  csv_string:
    - MSR_5_0_1
  desc: 评估一个表达式及其副作用时，其结果值在任何编程语言允许的运行顺序下都应该是一样的
  details: |-
    #### 概要
    评估一个表达式及其副作用时，其结果值在任何编程语言允许的运行顺序下都应该是一样的

    #### 解释
    由于表达式可能有多层运行顺序，表达式的设计应确保在所有可能的符合词法的运行顺序下，其结果值和副作用都是一样的。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #define LEN 1024

          int array_int[LEN];

          int foo(int i, int j)
          { 
            if (j > 0) {
              return i+1;
            }
            else
              return i;
          }

          int bar(unsigned int parm_b)
          {
            if (parm_b < LEN)
              array_int[parm_b++] = parm_b ; // behavior is undefined
            return parm_b;
          }
            
          int call_foo(int i)
          {
            return foo(i++, i); // return value is implementation defined
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #define LEN 1024

          int array_int[LEN];

          int foo(int i, int j)
          {
            if (j > 0) {
              return i+1;
            }
            else
              return i;
          }

          int bar(unsigned int parm_b)
          {
            if (parm_b < LEN) 
            {
              unsigned int temp = parm_b++;
              array_int[temp] = parm_b ; // behavior is deterministic
            }
            return parm_b;
          }

          int call_foo(int i)
          {
            int j = i++;
            return foo(j, i); // return value non-ambiguous
          }
      general:
        - ''
      java:
        - ''
  language: c++
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}的结果值在任何编程语言允许的运行顺序下都不是一样的
  name: 在标准允许的任何评估顺序下，表达式的值应该相同
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mcpp:
      - MSR_5_0_1
- alias: {}
  category: ''
  code: MSR_5_0_8
  compliance: R
  cost: H
  csv_string:
    - MSR_5_0_8
  desc: 表达式的值转换后不能大于表达式现有类型的大小
  details: |-
    #### 概要
    表达式的值转换后不能大于表达式现有类型的大小

    #### 解释
    当表达式的值在转换后大于现有类型的大小时，有可能导致信息损失，譬如表达式值的符号。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          void func_5_0_8(int si, short sh_j, float flt_k)
          {
            short  local_sh = 0x1234;
            int    local_int1, local_int2;
            float  local_flt = 1.0;
            double local_dbl, local_dbl2;

            local_int1 = static_cast< int > (local_sh + sh_j);  // non-compliant

            local_dbl2 = static_cast<double> (flt_k + local_flt);  // non-compliant
            
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          void func_5_0_8(int si, short sh_j, float flt_k)
          {
            short  local_sh = 0x1234;
            int    local_int1, local_int2;
            float  local_flt = 1.0;
            double local_dbl, local_dbl2;

            local_int1 = static_cast< int > (local_sh) + sh_j;  // compliant
            local_int2 = static_cast< int > (local_int1) + si;     // compliant

            local_dbl2 = static_cast<double> ((double)flt_k) + local_flt;  // compliant
            
          }
      general:
        - ''
      java:
        - ''
  language: c++
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中，表达式的值转换后大于表达式现有类型的大小
  name: 表达式的值转换后不能大于表达式现有类型的大小
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mcpp:
      - MSR_5_0_8
- alias: {}
  category: ''
  code: MSR_5_0_19
  compliance: R
  cost: H
  csv_string:
    - MSR_5_0_19
  desc: 在声明对象时不能有多于两层的间接指针
  details: |-
    #### 概要
    在声明对象时不能有多于两层的间接指针

    #### 解释
    当声明对象时有多于两层的间接指针，会引起至少三层的解引用，从而给理解程序预期的行为带来困难。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          int array[10][20];

          int mlk_three_indirect(int val)
          {
            int j = val;
            int *p = &j;
            int **p_2, **r_2;
            int *p_2_array = &array[*p][0];
            int ***p3;

            // ... 
            p_2 = &p;
            
            // ...
            array[val][0] = **p_2;
            
            //...
            r_2 = &p_2_array;
            
            // ...
            p3 = &r_2;
            
            // ... 
            return ***p3;

          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          int array[10][20];

          // this example is equivalent to the "avoid" example
          // 
          int mlk_three_indirect(int val)
          {
            int j = val;
            int *p = &j;
            int **p_2, **r_2;
            int *p_2_array = &array[*p][0];
            int p3;
            
            array[val][0] = val;
            p3 = array[val][0];
            return p3;

          }
      general:
        - ''
      java:
        - ''
  language: c++
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}，在声明对象时有多于两层的间接指针
  name: 多于两层间接指针
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mcpp:
      - MSR_5_0_19
- alias: {}
  category: ''
  code: MSR_8_5_3
  compliance: R
  cost: H
  csv_string:
    - MSR_8_5_3
  desc: 对于带有“=”构造的枚举，显式初始化能初始化或者不初始化全部枚举，也能仅初始化第一个枚举
  details: |-
    #### 概要
    对于带有“=”构造的枚举，显式初始化能初始化或者不初始化全部枚举，也能仅初始化第一个枚举

    #### 解释
    使用显式且一致的方式对枚举列表进行初始化，可以避免因混淆自动与手动赋值而造成错误，并且能使编译器发现枚举中可能是超出范围的错误。
  examples:
    bad:
      c:
        - ''
      cpp:
        - "\ntypedef enum color { red=3 } GoodEnum;   // compliant\n\ntypedef enum bad_enum_color { white=0,\n\t\t\t      blue=1,\n\t\t\t      yellow } BadEnum;  // non-compliant\n\ntypedef enum no_assign { NO_ONE, NO_TWO, NO_THREE } GoodEnum_NoAssign;\n\nextern void bar( color c, bad_enum_color b, no_assign n);\n\nvoid func_use(void)\n{\n  color var_color = red;\n  bad_enum_color var_bad_color = blue;\n  no_assign var_no_assign = NO_TWO;\n\n  bar(var_color, var_bad_color, var_no_assign);\n  return;\n}"
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          typedef enum color { red=3 } GoodEnum;   // compliant

          // compliant (but assignment not in sequence )
          typedef enum bad_enum_color { white=0,
                   blue=1,         // 2 is not used 
                   yellow=3 } BadEnum;  

          typedef enum no_assign { NO_ONE, NO_TWO, NO_THREE } GoodEnum_NoAssign;

          extern void bar( color c, bad_enum_color b, no_assign n);

          void func_use(void)
          {
            color var_color = red;
            bad_enum_color var_bad_color = blue;
            no_assign var_no_assign = NO_TWO;

            bar(var_color, var_bad_color, var_no_assign);
            return;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中出现错误的枚举初始化
  name: 错误的枚举初始化
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mcpp:
      - MSR_8_5_3
- alias: {}
  category: ''
  code: MSR_10_1_3
  compliance: R
  cost: H
  csv_string:
    - MSR_10_1_3
  desc: 基类不能在多继承体系中既是虚拟的又是非虚拟的
  details: |-
    #### 概要
    基类不能在多继承体系中既是虚拟的又是非虚拟的

    #### 解释
    如果基类在多继承体系中既是虚拟的又是非虚拟的，那么会在派生对象中产生多个基类子对象的复制版。这可能导致声明错误。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          class Base {};

          class Derived1 : public virtual Base {};

          class Derived2 : public Base { };


          class V_and_nonV : public Derived1, public Derived2 { };
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |

          class Base {};

          class Derived1 : public virtual Base {}; // Base is virtual

          class Derived2 : public virtual Base {}; // Base virtual

          // This hierarchy has two derived class from virtual base class
          class V_and_V : public Derived1, public Derived2 { /* code here */ };
            
      general:
        - ''
      java:
        - ''
  language: c++
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中的基类在多继承体系中既是虚拟的又是非虚拟的
  name: 基类有虚拟和非虚拟的
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mcpp:
      - MSR_10_1_3
- alias: {}
  category: ''
  code: MSR_12_1_1
  compliance: R
  csv_string:
    - MSR_12_1_1
  desc: 对象的动态类型不能在构造函数或者析构函数本体使用
  details: >-
    #### 概要

    对象的动态类型不能在构造函数或者析构函数本体使用


    #### 解释

    对象的非静态成员能通过成员声明进行初始化（NSDMI)。为避免混淆，成员既可以通过NSDMI方式来初始化也可以通过构造函数来初始化，两种方式对于成员的初始化应该是一样的。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <typeinfo>

          class Base {
          public:
            virtual void func_char();
            
            Base() {
              func_char();   // dynamic, virtual call to a virtual function
              typeid(Base);  // dynamic typeid on a class with virtual function
            };
          };


          void foo(void)
          {
            Base example;

            example.func_char();  //  
            return;
          }
            
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          class Base {
          public:
            virtual void func_char();
            
            Base() {
              Base::func_char();   // dynamic, non-virtual call
            };
          };


          void foo(void)
          {
            Base example;

            example.func_char();  //  
            return;
          }
            
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中，对象的动态类型在构造函数或者析构函数本体使用
  name: ctor 或 dtor 中的动态类型
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_12_1_1
- alias: {}
  category: ''
  code: MSR_12_1_2
  compliance: A
  csv_string:
    - MSR_12_1_2
  desc: ctor 必须为其所有直接基类显式调用 ctor
  details: |-
    #### 概要
    ctor 必须为其所有直接基类显式调用 ctor

    #### 解释
    如果 ctor 为其所有直接基类调用 ctor，它将减少对使用哪个构造函数和参数的混淆。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          class Base {
          public:
            Base() {}
            Base(int i);
          };


          class Derived1 : public virtual Base {
          public:
            Derived1() {}
            Derived1(int) : Base(0) {}
          }; 

          class Derived2 : public virtual Base {
          public:
            Derived2() {}
            Derived2(int) : Base(1) {}
          }; 


          class Hier : public Derived1, public Derived2 {
            //  Hier()    {}
            Hier(int) {} // constructor used is ambiguous w.r.t. Derived1 or Derived2

          };
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          class Base {
          public:
            Base() {}
            Base(int i);
          };
          class Derived1 : public virtual Base {
          public:
            //  Derived1() {}
            Derived1(int) : Base(0) {}
          };
          class Derived2 : public virtual Base {
          public:
            //  Derived2() {}
            Derived2(int) : Base(1) {}
          };
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中ctor没有为其所有直接基类显式调用 ctor
  name: ctor 必须为其所有直接基类显式调用 ctor
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_12_1_2
- alias: {}
  category: ''
  code: MSR_12_1_3
  compliance: R
  csv_string:
    - MSR_12_1_3
  desc: 具有基本类型的单个参数的 ctor 应该是显式的
  details: |
    #### 概要
    具有基本类型的单个参数的 ctor 应该是显式的

    #### 解释
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-


          class Base {
          public:
            Base(void) {}
            Base(int i);
          };


          class Derived1 : public virtual Base {
          public:
            Derived1() {}
            Derived1(int) : Base(0) {}
          }; 

          class Derived2 : public virtual Base {
          public:
            Derived2() {}
            Derived2(int) : Base(1) {}
          }; 

          class Hier : public Derived1, public Derived2 {
            Hier(int)    {}
          };
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          class Base {
          public:
            Base() {}
            explicit Base(int i);
          };


          class Derived1 : public virtual Base {
          public:
            Derived1() {} 
            explicit Derived1(int) : Base(0) {}    // make explicit
          }; 

          class Derived2 : public virtual Base {
          public:
            Derived2() {}
            explicit Derived2(int) : Base(1) {}    // make explicit
          }; 


          class Hier : public Derived1, public Derived2 {
            explicit Hier(int) : Derived1(2), Derived2(), Base() {}  // make explicit

          };
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中，具有基本类型的单个参数的 ctor 不是显式的
  name: 具有基本类型的单个参数的 ctor 应该是显式的
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_12_1_3
- alias: {}
  category: ''
  code: MSR_11_0_1
  compliance: R
  csv_string:
    - MSR_11_0_1
  desc: 类中的非 POD 成员必须是私有的
  details: |
    #### 概要
    类中的非 POD 成员必须是私有的

    #### 解释
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdint.h>

          typedef char    Letter;  
          typedef Letter* pLetter;
            
          class Class_Without_POD    
          {
          public:
            Letter  c;  
            pLetter p;
          };

          class Class_with_POD
          {
          public:
            int8_t   c;         // POD has no default constructor
            char*   pc;  
          };
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          typedef char    Letter;  
          typedef Letter* pLetter;
            
          class Class_Without_POD    
          {
          public:
            Letter  c;  
            pLetter p;
          };

          class Class_with_POD
          {
          private:
            char    c;         // will need interfaces to access and modify
            char*   pc;  
          };
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中，类中的非 POD 成员必须不是私有的
  name: 类中的非 POD 成员必须是私有的
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_11_0_1
- alias: {}
  category: ''
  code: MSR_10_2_1
  compliance: A
  csv_string:
    - MSR_10_2_1
  desc: 继承层次结构中的所有可见名称必须是唯一的
  details: |
    #### 概要
    继承层次结构中的所有可见名称必须是唯一的

    #### 解释
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-


          class Base {
          public:
            void func(char) {};
          };

          class Derived : public Base {
          public:
            void func(int) {};
          };


          int foo(void)
          {
            int   i;
            char ch;
            Derived example;

            example.func(i);
            example.func(ch);  // func(char) in Base is not visible 
            
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          class Base {
          public:
            Base() {}
            void func_char(char) {};
          };

          class Derived : public Base {
          public:
            Derived() : Base() {}
            void func_int(int) {};
          };


          int foo(void)
          {
            int   i;
            char ch;
            Derived example;

            example.func_int(i);

            example.func_char(ch);  // func(char) in Base is not visible

            return i;  
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中，继承层次结构中的所有可见名称不是唯一的
  name: 继承层次结构中的所有可见名称必须是唯一的
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_10_2_1
- alias: {}
  category: ''
  code: MSR_17_7
  compliance: R
  csv_string:
    - MSR_17_7
  desc: 应使用具有非 void 返回类型的函数返回的值
  details: |-
    #### 概要
    应使用具有非 void 返回类型的函数返回的值

    #### 解释
    对于 C90 和 C99 模式，不使用返回值调用函数可能是错误的。如果不打算显式使用函数的返回值，则应将其强制转换为 void 类型。
  examples:
    bad:
      c:
        - |-

          extern int func_ret_int(int);


          void bar(int n, int m)
          {
            if (n > 0) {
              n += func_ret_int(n);
            }
            else {
              func_ret_int(m); // func return value ignored
            }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |

          extern int func_ret_int(int, int);


          void bar(int n, int m)
          {
            if (n > 0) {
              n += func_ret_int(n, m);
            }
            else {
              (void)func_ret_int(m, m); // func return value ignored
            }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}的返回值未被使用
  name: 应使用函数返回的值
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_17_7
- alias: {}
  category: ''
  code: MSR_17_8
  compliance: A
  csv_string:
    - MSR_17_8
  desc: 不得修改函数的参数
  details: |-
    #### 概要
    不得修改函数的参数

    #### 解释
    对 C90 和 C99 模式而言，修改函数的参数可能会令人困惑并与程序员的期望相冲突。 所以不能修改函数的参数。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int param_0 =1;

          void func(int param){
              // Modifying parameter can cause confusion
              param = param_0;
              printf("%d\n", param);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func(int param){
              // Only use param, do not ever modify it by assigning another value
              printf("%d\n", param);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中函数的参数被修改
  name: 不得修改函数参数
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_17_8
- alias: {}
  category: ''
  code: MSR_10_2
  csv_string:
    - MSR_10_2
  desc: 正确使用基本字符型变量进行加减法运算
  details: |-
    #### 概要
    正确使用基本字符型变量进行加减法运算

    #### 解释
    由于基本字符型变量中的数据并不代表数值，在加法和减法表达式中应该正确地使用基本字符型变量。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int func( void );

          int func( void )
          {
              // essentially character type declared
              char char_var;
              int numb;
              char_var = '9';
              // the result of char_var + '>' do not make sense
              numb = char_var + '>';
              return numb;

          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |

          #include <stdio.h>

          int func( void );

          int func( void )
          {
              // essentially character type declared
            char char_var;   
            char numb;
            char_var = '9';
            // convert numa to digit value 9
            numb = char_var - '0';
            return numb

          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  msg_templ: 在${so.filename}，第${so.line}行，算术表达式${so.func}中使用了字符
  name: 算术表达式中不允许使用字符
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_10_2
- alias: {}
  category: ''
  code: MSR_14_2
  compliance: R
  csv_string:
    - MSR_14_2
  desc: >-
    一个循环由三个子句组成。 首先，正确分配和定义一个循环计数器（允许为空）。 其次，使用循环计数器的循环终止表达式，没有持久的副作用。
    并且该表达式不包含在循环体中修改的对象。 第三，循环计数器被修改且循环体中没有使用其他被修改的对象的表达式。
  details: |-
    #### 概要
    for循环应该是格式良好的

    #### 解释
    for循环语句的第二个和第三个子句不应使用在 for 循环体中修改的任何对象。 使用限制形式的 for 循环将使代码更容易检查和审查。
  examples:
    bad:
      c:
        - |-

          void func() {
              for (int i = 0; i < 5; i++) {
                  // modifying the induction variable i. Error prone and hard to review
                  i = i + 4;
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          void func() {
              for (int i = 0; i < 5; i++) {
                  // Do something 
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: ''
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中的for循环语句的格式不准确
  name: for循环应该是格式良好的
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_14_2
- alias: {}
  category: ''
  code: MSR_14_3
  compliance: R
  csv_string:
    - MSR_14_3
  desc: 语句的控制表达式不应是不变的
  details: |-
    #### 概要
    语句的控制表达式不应是不变的

    #### 解释
    使用不变值作为控制表达式会导致编程错误。 编译器甚至可能会删除代码，因为由于表达式不变，它可能无法访问。 这可能会导致不必要地删除防御性代码。
  examples:
    bad:
      c:
        - |-

          void func() {
              // The if statement always evaluates to false, dead code
              if (10 > 11) {
                  // Do something
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdbool.h>

          void func() {
              // Compliant by exception 1
              while (true) {
                  // Do something
              } 

              // Compliant by exception 2
              do {
                  // Do something
              } while (0 == 1);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}的控制表达式不应是不变的
  name: 控制表达式不应是不变的
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_14_3
- alias: {}
  category: ''
  code: MSR_15_1
  compliance: A
  csv_string:
    - MSR_15_1
  desc: 不应该使用goto语句
  details: |-
    #### 概要
    不应该使用goto语句

    #### 解释
    在没有约束的情况下使用 goto 语句会导致程序无结构化且极难理解。
  examples:
    bad:
      c:
        - |-

          void func() {
              int num = 0;

              P1:
              num += 1;

              // Using the goto statement can cause confusion
              goto P1;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          void func() {
              int num = 0;

              num += 1;
              // Do not use the goto statement
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}使用了goto语句
  name: 不应该使用goto语句
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_15_1
- alias: {}
  category: ''
  code: MSR_15_2
  compliance: R
  csv_string:
    - MSR_15_2
  desc: 如果确实需要goto语句，则应为forward goto。
  details: |-
    #### 概要
    如果确实需要goto语句，则应为forward goto。

    #### 解释
    由于使用没有约束的 goto 语句会导致程序非结构化且极难理解，因此应限制使用 goto 语句。 使用语言提供的迭代语句会产生更具可读性的代码。
  examples:
    bad:
      c:
        - |

          void func() {
              int num = 0;

              P1:
              num += 1;

              // Non-compliant as back jump is allowed
              goto P1;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |

          void func() {
              int num = 0;

              // No back jump in the code
              goto P1;

              P1:
              num += 1;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中的goto语句未跳转到稍后在同一函数中声明的标签
  name: goto语句应跳转到稍后在同一函数中声明的标签
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_15_2
- alias: {}
  category: ''
  code: MSR_15_3
  compliance: R
  csv_string:
    - MSR_15_3
  desc: 标签应在与其goto语句相同的范围内声明。
  details: |-
    #### 概要
    标签应在与其goto语句相同的范围内声明。

    #### 解释
    在没有约束的情况下使用goto语句会导致程序无结构化且极难理解。 允许goto语句在块之间跳转或在嵌套块中跳转到引用标签使代码在视觉上变得复杂。
  examples:
    bad:
      c:
        - |-

          void func() {
              int num = 0;

              P1:
                  if (num == 5) {
                  P2:
                      num += 1;
                  }

              // Jumping into nested label is non-compliant
              goto P2;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |

          void func() {
              int num = 0;

              P1:
                  if (num == 5) {
                  P2:
                      num += 1;
                  }

              // Jumping into the reference label outside of the nested block
              goto P1;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中的goto语句和它的标签不在同一范围内
  name: goto语句和它的标签必须在同一范围内
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_15_3
- alias: {}
  category: ''
  code: MSR_15_4
  compliance: A
  csv_string:
    - MSR_15_4
  desc: 不应该有超过一个 break 或 goto 用于提前终止循环
  details: |-
    #### 概要
    不应该有超过一个 break 或 goto 用于提前终止循环

    #### 解释
    在没有约束的情况下使用goto语句会导致程序无结构化且极难理解。 限制循环中的退出次数有助于简化源代码。
  examples:
    bad:
      c:
        - |-

          void func() {
              for (int i = 0; i < 5; i++) {
                  // Multiple early termination
                  if (i == 2) {
                      break;
                  }
                  // Multiple early termination
                  else if (i == 2) {
                      goto EXIT;
                  }
                  else {
                      // Continue
                  }
              }

              EXIT:
                  ;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          void func() {
              for (int i = 0; i < 5; i++) {
                  // Only use either break or goto, don
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}的循环提前退出在同一循环中同时使用了break和goto。
  name: 不应该有超过一个 break 或 goto 用于提前终止循环
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_15_4
- alias: {}
  category: ''
  code: MSR_15_7
  compliance: R
  csv_string:
    - MSR_15_7
  desc: if-else应包括if语句并以else语句结束。
  details: |-
    #### 概要
    if-else应包括if语句并以else语句结束。

    #### 解释
    使用else语句终止if...else if 结构补充了switch语句中对默认子句的要求，这是一种防御性编程。
  examples:
    bad:
      c:
        - |-

          #include <stdbool.h>

          void func() {
              bool flag;

              if (flag == true) {
                  // Do something
              }
              else if (flag == false) {
                  // Do something
              }
              // Non-compliant as there is no else statement
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdbool.h>

          void func() {
              bool flag;

              if (flag == true) {
                  // Do something
              }
              else {
                  // Add else statement as defensive programming
                  // Do something
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}的if-else缺少else语句。
  name: if-else中的每一个if语句都应该有一个else语句
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_15_7
- alias: {}
  category: ''
  code: MSR_16_5
  compliance: R
  csv_string:
    - MSR_16_5
  desc: switch语句的默认标签没有放在第一个或最后一个位置。
  details: |-
    #### 概要
    switch语句的默认标签没有放在第一个或最后一个位置。

    #### 解释
    将默认标签放在switch语句中的第一个或最后一个以外的任何其他位置会使其难以定位。
  examples:
    bad:
      c:
        - |-

          int loop_cnt(int count, int input)
          {
            int idx = count;
            
            switch (input) {
              
            case 0:
              idx--;
              break;
              
            default:  // default in between case statements
              break;
              
            case 1:
              idx++;
              break;    

            }
            
            // ...
            return idx;
          }


          int loop_cnt_ex2(int count, int input)
          {
            int idx = count;
            
            switch (input) {
              
            // missing default statement in begin nor end 
              
            case 0:
              idx--;
              break;
              
            case 1:
              idx++;
              break;

            }
            
            // ...
            return idx;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          int loop_cnt(int count, int input)
          {
            int idx = count;
            
            switch (input) {
            case 0:
              idx--;
              break;
              
            case 1:
              idx++;
              break;
              
            default:
              break;
            }
            
            // ...
            return idx;
          }


          int loop_cnt_ex2(int count, int input)
          {
            int idx = count;
            
            switch (input) {
              
            default:   // default at beginning of switch
              break;
              
            case 0:
              idx--;
              break;
              
            case 1:
              idx++;
              break;

            }
            
            // ...
            return idx;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}，switch语句的默认标签没有放在first或last。
  name: 默认标签应作为switch语句的第一个或最后一个switch标签出现
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_16_5
- alias: {}
  category: ''
  code: MSR_16_7
  compliance: R
  csv_string:
    - MSR_16_7
  desc: switch表达式不应是布尔类型。
  details: |-
    #### 概要
    switch表达式不应是布尔类型。

    #### 解释
    尽管可以使用布尔值实现switch语句控制表达式，但使用标准定义的if-else构造实现逻辑会更合适。
  examples:
    bad:
      c:
        - |-

          #include <stdbool.h>
          #include <stdio.h>

          void func() {
              int num = 0;
              // Switch with boolean caluse as the controlling expression is redundant
              switch(num == 0) {
                  case true:
                      printf("True case");
                      break;
                  default:
                      printf("default case");
                      break;
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdbool.h>
          #include <stdio.h>

          void func( int num ) {
              // If else is more appropriate than switch for controlling expression with boolean
              if (num == 0) {
                  printf("True");
              }
              else {
                  printf("default");
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}，switch表达式是布尔类型。
  name: switch表达式不应具有本质上的布尔类型
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_16_7
- alias: {}
  category: ''
  code: MSR_17_1
  compliance: R
  csv_string:
    - MSR_17_1
  desc: 不能使用<stdarg.h>的特性。
  details: >-
    #### 概要

    不能使用<stdarg.h>的特性。


    #### 解释

    不应使用va_list、va_arg、va_start、va_end和va_copy。
    当源代码没有正确组织导致类型或用法不一致时，有许多未定义行为的实例。
  examples:
    bad:
      c:
        - |-

          #include <stdarg.h>

          void func(va_list var_arg) {
              double var;
              
              // Using va_list and va_arg can cause undefined behaviour
              var = va_arg(var_arg, double);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          void func(double arg) {
              double var;
              
              // Should not use <stdarg.h> for variable argument processing
              var = arg;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}使用了<stdarg.h>的特性。
  name: 不得使用<stdarg.h>的特性
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_17_1
- alias: {}
  category: ''
  code: MSR_17_2
  compliance: R
  csv_string:
    - MSR_17_2
  desc: 函数不得直接或间接调用自身 - 不得重用递归函数（直接或间接）。
  details: |-
    #### 概要
    函数不得直接或间接调用自身 - 不得重用递归函数（直接或间接）。

    #### 解释
    当函数调用自身时，即递归，它会导致堆栈空间耗尽。 在执行之前无法确定最坏情况下的堆栈使用情况。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func(int num){
              if (num == 0) {
                  return;
              }

              printf("%d\n", num);

              func(num - 1); // Using recursion unless tightly controlled can exceed available stack
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func(int num){
              // Implement recursion using for loop instead
              for (int i = num; i == 0; i--){
                  printf("%d\n", i);
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}调用了自身。
  name: 函数不应直接或间接调用自身
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_17_2
- alias: {}
  category: ''
  code: MSR_17_5
  compliance: A
  csv_string:
    - MSR_17_5
  desc: 数组类型的参数应具有特定大小。
  details: |-
    #### 概要
    数组类型的参数应具有特定大小。

    #### 解释
    尽管在C中将未指定大小的数组传递给具有指定大小的参数是合法的，但这样做会导致意外行为，例如数组越界。
  examples:
    bad:
      c:
        - |-

          void arr1 (int array[4]) {
              // Do something
          }

          void func(int num){
              int arr[3] = {1, 2, 3};

              // Array size does not match prototype
              arr1(arr);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          void fun_arr1 (int array[4]) {
              // Do something
          }

          void func(int num){
              int arr[4] = {1, 2, 3, 4};

              // Array size match prototype
              func_arr1(arr);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}，数组类型的参数未确定其大小。
  name: 数组类型的参数应具有特定大小
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_17_5
- alias: {}
  category: ''
  code: MSR_18_1
  compliance: R
  csv_string:
    - MSR_18_1
  desc: 指针运算不应导致数组越界访问
  details: |-
    #### 概要
    指针运算不应导致数组越界访问

    #### 解释
    编译器只能在编译时确定是否超出了数组边界。 在运行时不检查无效的数组索引。 使用无效的索引会导致程序出现错误行为。
  examples:
    bad:
      c:
        - |-

          void func(){
              int arr[3] = {0, 1, 2};

              // Points to two beyond, undefined
              int *p = &arr[4];
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          void func(){
              int arr[3] = {0, 1, 2};

              // Points to one beyond only, still defined
              int *p = &arr[3];
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: ''
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}使用了越界的指针评估未定义的位置。
  name: 对指针操作数进行算术运算产生的指针应寻址与该指针操作数相同的数组中的元素
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  severity: H
  standards:
    mc:
      - MSR_18_1
- alias: {}
  category: ''
  code: MSR_21_11
  compliance: R
  csv_string:
    - MSR_21_11
  desc: 不得使用标准头文件 <tgmath.h>
  details: |-
    #### 概要
    不得使用标准头文件 <tgmath.h>

    #### 解释
    因为使用 tgmath.h 中声明的函数可能会导致未定义的行为，所以不应该使用<tgmath.h>
  examples:
    bad:
      c:
        - |-

          #include <tgmath.h>

          void func() {
             float f1;
             // Generic square root is used, can cause undefined behaviour
             f1 = sqrt(49);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <math.h>

          void func() {
             float f1;
             // Float version of square root is used, safer
             f1 = sqrt(49);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}使用标准头文件 <tgmath.h>
  name: 不得使用标准头文件 <tgmath.h>
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_21_11
- alias: {}
  category: ''
  code: MSR_21_12
  compliance: A
  csv_string:
    - MSR_21_12
  desc: 程序使用了 <fenv.h> 中声明的异常处理特性
  details: |-
    #### 概要
    程序使用了 <fenv.h> 中声明的异常处理特性

    #### 解释
    在某些情况下，浮点状态标志可能变得未指定。 尝试访问它们可能会导致未定义的行为
  examples:
    bad:
      c:
        - |-

          #include <fenv.h>
          #include <stdio.h>
          #include <math.h>

          void func() {
             // Using exception handlinf features can cause undefined behaviour
             feclearexcept(FE_ALL_EXCEPT);
             
             sqrt(-1);

             if (fetestexcept(FE_INVALID)) {
                printf("FE_INVALID casued by sqrt(-1");
             }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <fenv.h>
          #include <stdio.h>
          #include <math.h>

          void func() {
             // Do not use functions from fenv.h for exception handling
             sqrt(-1);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}使用了 <fenv.h> 中声明的异常处理特性
  name: 不应使用 <fenv.h> 的异常处理功能
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_21_12
- alias: {}
  category: ''
  code: MSR_14_1
  compliance: R
  csv_string:
    - MSR_14_1
  desc: 该程序使用浮点作为循环计数器，这可能导致预期结果与实际结果不匹配。
  details: |-
    #### 概要
    该程序使用浮点作为循环计数器，这可能导致预期结果与实际结果不匹配。

    #### 解释
    使用浮点数作为循环计数器会导致舍入误差的累积。 这可能会导致程序运行时预期迭代次数与实际迭代次数不匹配，具体取决于实现。
  examples:
    bad:
      c:
        - |-

          void func() {
              // Using float as a loop counter can lead to unexpected result
              for (float f = 0.0f; f < 10.0f; f += 0.1f) {
                  // Do something
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          void func() {
              // Using int as a loop counter
              for (int i = 1; i < 10; i++) {
                  // Do something
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}使用了浮点作为循环计数器
  name: 循环计数器不应具有本质上的浮动类型
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_14_1
- alias: {}
  category: ''
  code: MSR_16_6
  compliance: R
  csv_string:
    - MSR_16_6
  desc: 每个 switch 语句应该有多个 switch 子句
  details: |-
    #### 概要
    每个 switch 语句应该有多个 switch 子句

    #### 解释
    switch 语句只有一条路径不仅是多余的，而且也是编程错误的指示。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func() {
              int num = 2;
              switch(num + 2) {
                  default:
                      // Only one switch-clause
                      printf("default case");
                      break;
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          int func ( char grade )
          {
              // Switch statement have at least two switch-clauses
              switch( grade ) 
              {        
                  case 'A':
                      printf( "great" );
                      break;
                  case 'B':
                      printf( "good" );
                      break;
                  default:
                      printf( "not so well" );
                      break;
              }
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: ''
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}有少于两个 switch 子句
  name: 每个 switch 语句应至少有两个 switch 子句
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_16_6
- alias: {}
  category: ''
  code: MSR_9_1
  compliance: M
  csv_string:
    - MSR_9_1
  desc: 局部变量在被读取之前应该被初始化
  details: |-
    #### 概要
    局部变量在被读取之前应该被初始化

    #### 解释
    具有静态存储持续时间的对象会自动初始化为零
    除非显式初始化。 具有自动存储持续时间的对象不会自动初始化，因此它们可能具有不确定的值。
  examples:
    bad:
      c:
        - ''
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: ''
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}，在设置之前就读取具有自动存储持续时间的对象的值
  name: 局部变量在被读取之前应该被初始化
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_9_1
- alias: {}
  category: ''
  code: MSR_18_2
  compliance: R
  csv_string:
    - MSR_18_2
  desc: 指针减法不应导致访问冲突，例如数组越界。
  details: |-
    #### 概要
    指针减法不应导致访问冲突，例如数组越界。

    #### 解释
    如果指针不指向同一数组的元素或超出该数组末尾的元素，则它们之间的减法是未定义的行为。
  examples:
    bad:
      c:
        - |-

          #include <stddef.h>

          void func()
          {
              int arr[3] = {0, 1, 2};

              // Points to two beyond
              int *p1 = &arr[0];
              int *p2 = &arr[2];

              ptrdiff_t diff;
              diff = p1 - p2; // undefined
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}，指针减法导致了数组越界访问
  name: 指针之间的减法应仅适用于寻址同一数组元素的指针
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_18_2
- alias: {}
  category: ''
  code: MSR_18_6
  compliance: R
  csv_string:
    - MSR_18_6
  desc: 局部变量的地址不应传递到变量的作用域之外
  details: |-
    #### 概要
    局部变量的地址不应传递到变量的作用域之外

    #### 解释
    当一个对象的生命周期到期时，其地址变得不确定。因此使用该中间终止地址将导致未定义的行为。
  examples:
    bad:
      c:
        - ''
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}，局部变量的地址被传递到变量的作用域之外
  name: 局部变量的地址不应传递到变量的作用域之外
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_18_6
- alias: {}
  category: ''
  code: MSR_22_1
  compliance: R
  csv_string:
    - MSR_22_1
  desc: 应释放从标准库函数动态获取的资源。
  details: |-
    #### 概要
    应释放从标准库函数动态获取的资源。

    #### 解释
    如果没有明确释放这些资源，则可能由于资源耗尽而发生故障。 尽快释放资源可以减少耗尽的可能性。
  examples:
    bad:
      c:
        - ''
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}，通过标准库函数动态获取的资源没有被释放
  name: 所有通过标准库函数动态获取的资源都应该被释放
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_22_1
- alias: {}
  category: ''
  code: MSR_22_2
  compliance: M
  csv_string:
    - MSR_22_2
  desc: 内存块仅当由标准库函数分配时才可以被释放
  details: |-
    #### 概要
    内存块仅当由标准库函数分配时才可以被释放

    #### 解释
    释放未分配的内存或多次释放相同的分配内存是未定义的行为。
  examples:
    bad:
      c:
        - ''
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}，不是由标准库函数分配的内存块被释放
  name: 内存块仅当由标准库函数分配时才可以被释放
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_22_2
- alias: {}
  category: ''
  code: MSR_22_4
  compliance: M
  csv_string:
    - MSR_22_4
  desc: 不应写入以只读方式打开的流。
  details: |-
    #### 概要
    不应写入以只读方式打开的流。

    #### 解释
    由于标准没有指定尝试写入只读流时的行为，因此写入只读流是不安全的。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              FILE *fp;
              fp = fopen ( "test_file", "r" );
              fprintf( fp, "write to a read-only stream" ); // non-compliant
              fclose( fp );
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              FILE *fp;
              fp = fopen ( "test_file", "w+" );
              fprintf( fp, "write to a stream" ); // compliant
              fclose( fp );
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}，以只读方式打开的流被写入。
  name: 不应尝试写入已以只读方式打开的流
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_22_4
- alias: {}
  category: ''
  code: MSR_14_4
  compliance: R
  csv_string:
    - MSR_14_4
  desc: if 或迭代语句的控制表达式基本上应是布尔类型
  details: |-
    #### 概要
    if 或迭代语句的控制表达式基本上应是布尔类型

    #### 解释
    没有 if 语句或迭代语句的基本布尔类型的控制表达式将导致弱类型。
  examples:
    bad:
      c:
        - |-

          int foo(int *p_int)
          {
            int ret = 0;
            int i;
            
            while (p_int) {   // p_int is a pointer
              i = *p_int;
              
              if (i) {   // i is int, not boolean
                ret++;
              }

              ret++;
              p_int--;
            } 
            return ret;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - "\n#define NULL 0\n\nint foo(int *p_int)\n{\n  int ret = 0;\n  int i;\n  \n  while (p_int != NULL) {   // p_int is a pointer\n      i = *p_int;\n      \n      if (i != 0) {   // i != 0 is a boolean expression\n\tret++;\n      }\n    ret++;\n    p_int--;\n    if (ret > 5)\n    {\n      break;\n    }\n  } \n  return ret;\n}"
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}，if 语句的控制表达式不具有本质上的布尔类型
  name: if 语句和迭代语句的控制表达式应该是布尔类型
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_14_4
- alias: {}
  category: ''
  code: MSR_18_7
  compliance: R
  csv_string:
    - MSR_18_7
  desc: 程序声明了灵活数组成员
  details: |-
    #### 概要
    不应声明灵活的数组成员

    #### 解释
    由于将包含灵活数组成员的结构分配给另一个类似类型可能会出现意外行为，因此不应声明灵活数组成员。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          struct Books
          {
              char    title[20];
              char    author[10];
              int     id[ ]; // flexible array menber
          } book;
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          // compliant
          struct Books
          {
              char    title[20];
              char    author[10];
              int     id[5];
          } book;
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 灵活的数组成员被声明。
  name: 不应声明灵活的数组成员
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_18_7
- alias: {}
  category: ''
  code: MSR_8_1
  compliance: R
  csv_string:
    - MSR_8_1
  desc: 程序应明确指定所有对象的类型
  details: |-
    #### 概要
    程序应明确指定所有对象的类型

    #### 解释
    如果省略显式类型，可能会导致声明混淆。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          // Non-compliant function type
          extern void g (char a, const b); // Implicit int type for b

          // Non-compliant object type
          const   p; // Implicit int type for p
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          // Compliant function type
          extern void g (char a, const int b); // Explicit int type for b

          // Compliant object type
          const int p; // Explicit int type for p
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 类型没有被明确指定
  name: 类型应该被明确指定
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_8_1
- alias: {}
  category: ''
  code: MSR_11_1
  compliance: R
  csv_string:
    - MSR_11_1
  desc: 指向函数的指针不应转换为任何其他类型
  details: |-
    #### 概要
    指向函数的指针不应转换为任何其他类型

    #### 解释
    程序不应调用使用不兼容指针类型的函数。 否则会导致未定义的行为。
  examples:
    bad:
      c:
        - |2-
           
          #include <stdio.h>
           #include <stdlib.h>

          typedef char ( *f1 ) ( int );
          typedef char ( *f2 ) ( int );

          void func ( void )
          {
              int x = 1;
              int *p = &x;
              int *q[10];
              f1 a = ( f1 ) p; // function pointer converted into different one is non-compliant
              f2 b = ( f2 ) *q; // non-compliant
              f1 c = ( f1 ) 1; // function pointer converted into int is non-compliant
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>
          #include <stdlib.h>

          void func ( void )
          {
              typedef void ( *fp ) ( int x );
              extern void f ( int y );
              typedef fp ( *test ) ( void );

              fp p = NULL; // null pointer constant into function pointer is compliant
              fp q = f; // function into function pointer is compliant
              test tfunc;
              ( void ) ( *tfunc( ) ); // function pointer into void
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 指向函数的指针被转换为其他类型
  name: 转换不能在指向函数的指针和指向其他类型的指针中进行
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_11_1
- alias: {}
  category: ''
  code: MSR_16_2
  compliance: R
  csv_string:
    - MSR_16_2
  desc: switch 标签应该用在复合语句的最外层
  details: |-
    #### 概要
    switch 标签应该用在复合语句的最外层

    #### 解释
    将 switch 标签放在 switch 语句主体中的任何语句之前是非结构化代码
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int main()
          {
              int s, i;

              switch (s)
              {
                  case 5: // Compliant
                      printf("%d", 5);
                      for( i=0; i<3; i++ )
                      {
                  case 10: // Unstructed code
                      printf("%c", "s");
                      }
                      break;
                  default:
                      break;
              }
              
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          int main( int s )
          {
              switch (s)
              {
                  case 1: // Compliant
                      printf("%d", 1);
                      break;
                  case 2: // Compliant
                      printf("%d", 2);
                      break;
                  default:
                      break;
              }

              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, switch标签放在了任意语句之前
  name: switch标签的使用
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_16_2
- alias: {}
  category: ''
  code: MSR_16_4
  compliance: R
  csv_string:
    - MSR_16_4
  desc: 每个 switch 语句都应该具有一个default标签
  details: |-
    #### 概要
    每个 switch 语句都应该具有一个default标签

    #### 解释
    默认标签使编程具有防御性。 并且在默认标签之后应该有一个声明或注释。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int main( int s )
          {
              switch (s)
              {
                  case 10:
                      printf("%s", "ten");
                      break;
                  case 20:
                      printf("%s", "twenty");
                      break;
              // default label is missing
              }

              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          int main( int s )
          {
              switch (s)
              {
                  case 10:
                      printf("%s", "ten");
                      break;
                  case 20:
                      printf("%s", "twenty");
                      break;
                  default: // Compliant
                      break;
              }

              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, switch语句没有一个默认标签
  name: 每个 switch 语句都应该有一个default标签
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_16_4
- alias: {}
  category: ''
  code: MSR_17_4
  compliance: M
  csv_string:
    - MSR_17_4
  desc: 非void返回类型函数的应该有return语句表达式
  details: |-
    #### 概要
    非void返回类型函数的应该有return语句表达式

    #### 解释
    调用函数使用没有返回值的非空函数是未定义的行为。 
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int func ( int x )
          {
              for ( ; x < 5; x++){
                  printf("less than five");
                  return 0;
              }
              // control may reach end of function without returning
          }

          int main()
          {
              func(10); // undefined behaviour
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          int func ( void )
          {
              printf("Hello");
              return 0; // compliant
          }

          int main()
          {
              func(); // compliant
              return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 非 void 返回类型函数的return语句没有表达式
  name: 具有非 void 返回类型的函数的所有退出路径都应具有return语句
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_17_4
- alias: {}
  category: ''
  code: MSR_17_6
  compliance: M
  csv_string:
    - MSR_17_6
  desc: 数组参数声明中不应有静态关键字
  details: |-
    #### 概要
    数组参数声明中不应有静态关键字

    #### 解释
    如果数组参数包含的元素数小于指定的最小值，则为未定义行为。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          // non-compliant for use of static in array parameter declaration
          void func(int arr[static 5])
          {
              int i = 0;
              for (int i =0; i < 5; i++)
              {
                  arr[i]++;
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          // array parameter declaration without static
          void func(int arr[10])
          {
              for (int i =0; i < 10; i++)
              {
                  arr[i]++;
                  printf("%d", arr[i]);
              }
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 数组参数的声明在 [ ] 之间包含静态关键字
  name: 数组参数的声明不应在 [ ] 之间包含静态关键字
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_17_6
- alias: {}
  category: ''
  code: MSR_18_5
  compliance: A
  csv_string:
    - MSR_18_5
  desc: 声明的指针嵌套不应超过两层
  details: |-
    #### 概要
    声明的指针嵌套不应超过两层

    #### 解释
    如果有两层以上的指针嵌套用于声明，理解代码会很混乱。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          int i = 0;
          int * ip1 = &i;
          int ** ip2 = &ip1;
          // more than two levels of pointer nesting should be avoided
          int ***ip3 = &ip2;
          int ****ip4 = &ip3;
          int *****ip5 = &ip4;
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          // compliant for no more than two pointer declarators
          int i = 0;
          int * ip1 = &i;
          int ** ip2 = &ip1;
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 声明包含了超过两级的指针嵌套
  name: 声明不应包含超过两级的指针嵌套
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_18_5
- alias: {}
  category: ''
  code: MSR_3_1_2
  compliance: R
  csv_string:
    - MSR_3_1_2
  desc: 块范围内不应有函数声明
  details: |-
    #### 概要
    块范围内不应有函数声明

    #### 解释
    在块范围内声明函数会导致封闭命名空间, 令人困惑。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( int x )
          {
              x++;
              void func_in_block(); // function declared in block
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( int x )
          {
              x++;
          }

          void func_out_block(); // function declared out of block
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 函数在块范围内被声明
  name: 函数不应在块范围内声明
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_3_1_2
- alias: {}
  category: ''
  code: MSR_4_10_1
  compliance: R
  csv_string:
    - MSR_4_10_1
  desc: NULL 不应用作整数
  details: |-
    #### 概要
    NULL 不应用作整数

    #### 解释
    NULL 应被认为是指针类型，以便与 0 区分。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( int x )
          {
              x++;   
          }

          int main ( )
          {
              func ( NULL ); // NULL used as an integer value
              return 0;
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( int *x )
          {
              x++;
          }

          int main ( )
          {
              func ( NULL ); // NULL used as an pointer
              return 0;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, NULL 被用作整数
  name: NULL不应该被用作整数
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_4_10_1
- alias: {}
  category: ''
  code: MSR_4_10_2
  compliance: R
  csv_string:
    - MSR_4_10_2
  desc: 0 不应用作空指针常量
  details: |-
    #### 概要
    0 不应用作空指针常量

    #### 解释
    0 应该被认为是整数类型，以便与 NULL区分
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( int *x )
          {
              x++;   
          }

          int main ( )
          {
              func ( 0 ); // 0 used as an null pointer constant
              return 0;
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( int x )
          {
              x++;
          }

          int main ( )
          {
              func ( 0 ); // 0 used as an integer value
              return 0;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 0 被用作空指针常量
  name: 0 不应用作空指针常量
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_4_10_2
- alias: {}
  category: ''
  code: MSR_6_2_1
  compliance: R
  csv_string:
    - MSR_6_2_1
  desc: 不应在子表达式中使用赋值
  details: |-
    #### 概要
    不应在子表达式中使用赋值

    #### 解释
    子表达式中使用的赋值会给整个表达式增加副作用，并使 = 和 == 混淆。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int a,b,c;
              a = 5;
              b = 10;
              if ( ( c = b ) > a ) // assignment inside sub-expression
              {
                  printf("c bigger than a");
              }
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int a,b,c;
              a = 5;
              b = 10;
              c = b; // assignment outside sub-expression
              if ( c > a )
              {
                  printf("c bigger than a");
              }
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 赋值运算符在子表达式中使用
  name: 赋值运算符不应在子表达式中使用
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_6_2_1
- alias: {}
  category: ''
  code: MSR_6_4_1
  compliance: R
  csv_string:
    - MSR_6_4_1
  desc: if/else 结构后面应该跟复合语句
  details: |-
    #### 概要
    if/else 结构后面应该跟复合语句

    #### 解释
    如果在将单个语句更改为多语句时未能添加所需的大括号，则没有复合语句的 if 结构将引发错误。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int x, y;
              x = 5;
              y = 10;
              if ( x > y ); // if construct without compound statement
              {
                  x++;
              }
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int x, y;
              x = 5;
              y = 10;
              if ( x > y ) // if construct with compound statement
              {
                  printf("x bigger");
              }
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, if 结构没有伴随着一个复合语句
  name: if/else 结构后面应该跟复合语句
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_6_4_1
- alias: {}
  category: ''
  code: MSR_6_5_2
  compliance: R
  csv_string:
    - MSR_6_5_2
  desc: 循环计数器只能用于 <=、<、> 或 >=，当它不是被 -- 或 ++ 修改时
  details: |-
    #### 概要
    循环计数器只能用于 <=、<、> 或 >=，当它不是被 -- 或 ++ 修改时

    #### 解释
    如果循环计数器由 -- 或 ++ 以外的运算符修改，== 和 != 的使用会导致无限循环。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int i, j;
              j = 5;
              for ( i = 3; i != j; i += 3 ) // non-compliant
              {
                  printf("infinite loop");
              }
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int i, j;
              j = 5;
              for ( i = 3; i < j; i += 3 ) // compliant
              {
                  printf("i smaller than j");
              }
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 循环计数器被用于 != 当它不是被--或++修改
  name: 如果循环计数器不是被 -- 或 ++ 修改，它只能用作 <=、<、> 或 >= 的操作数
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_6_5_2
- alias: {}
  category: ''
  code: MSR_6_6_3
  compliance: R
  csv_string:
    - MSR_6_6_3
  desc: continue 语句不应该被过度使用
  details: |-
    #### 概要
    continue 语句不应该被过度使用

    #### 解释
    过度使用 continue 语句会使代码变得不必要的复杂
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int j = 3;
              for ( int i = 5; i > j; i++ )
              {
                  if ( ( i % j == 0 ) )
                  {
                      printf("not well-formed");
                      continue; // infinite loop
                  }
              }
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              int j = 2;
              for ( int i = 10; i < j; i-- )
              {
                  if ( ( i % j == 0 ) )
                  {
                      printf("well-formed");
                      continue; // finite loop
                  }
              }
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, continue 语句被过度使用
  name: continue 语句只能在格式良好的 for 循环中使用
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_6_6_3
- alias: {}
  category: ''
  code: MSR_7_5_3
  compliance: R
  csv_string:
    - MSR_7_5_3
  desc: 函数不应将引用参数作为临时对象返回
  details: |-
    #### 概要
    函数不应将引用参数作为临时对象返回

    #### 解释
    函数返回时将引用参数用作临时对象是未定义的行为。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          int & func ( int & test )
          {
              int & t = test;
              return t;
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          int t;
          int test = 1;

          int func( t )
          {   
              t = test;
              return t; // compliant
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: '在${so.filename}，第${so.line}行，函数${so.func}, 函数将引用参数作为临时对象返回 '
  name: 函数不应返回引用或指向通过引用或 const 引用传递的参数的指针
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_7_5_3
- alias: {}
  category: ''
  code: MSR_8_4_4
  compliance: R
  csv_string:
    - MSR_8_4_4
  desc: 函数标识符应用于调用函数或以 & 开头
  details: |-
    #### 概要
    函数标识符应用于调用函数或以 & 开头

    #### 解释
    函数标识符到函数指针的转换可能会使函数的地址和函数的调用之间变得不清楚。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          int func ( void )
          {
              return 0;
          }

          int main ( void )
          {
              if( func == 0 ) // unclear use of func
              {
                  printf("the use of func is not clear");
              }
              return 0;
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          int func ( void )
          {
              return 0;
          }

          int main ( void )
          {
              if( &func == 0 ) // compliant
              {
                  func(); // call the function
                  printf("the use of func is clear");
              }
              return 0;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 函数标识符没有用于调用函数或以 & 开头
  name: 函数标识符应用于调用函数或以 & 开头
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_8_4_4
- alias: {}
  category: ''
  code: MSR_4_2
  compliance: A
  csv_string:
    - MSR_4_2
  desc: 不应该使用三元组
  details: |-
    #### 概要
    不应该使用三元组

    #### 解释
    三元组的使用可能会导致与其他两个问号的意外混淆。
  examples:
    bad:
      c:
        - |-

          extern void prints(char *, char *);

          // trigraph is used
          char TRG_STR[] = "[??)"; // "??)" represents "]"

          int foo()
          {
            prints("This example uses %s", TRG_STR);
            return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          #define NON_TRG_STR "NON-Trigraph string"

          int foo()
          {
            printf("This example uses %s", NON_TRG_STR); // trigraph is not used
            return 0;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 三元组被使用了
  name: 不应该使用三元组
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_4_2
- alias: {}
  category: ''
  code: MSR_5_4
  compliance: R
  csv_string:
    - MSR_5_4
  desc: 宏标识符应该是唯一的
  details: |-
    #### 概要
    宏标识符应该是唯一的

    #### 解释
    宏标识符仅在非有效字符中不同是未定义的行为。
  examples:
    bad:
      c:
        - |-

          #include <stdio.h>

          /*
           this example does not guarantee the same result for
           different compilers with std C90 or before
          */

          #define VERY_VERY_LONG_NAME2123456789312   10

          #define VERY_VERY_LONG_NAME21234567893123  20

          int main()
          {
            int i;
            if (VERY_VERY_LONG_NAME2123456789312 == VERY_VERY_LONG_NAME21234567893123) {
              i = 0;
            }
            else {
              i = 1;
            }
            printf("i = %d\n", i);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          #define VERY_VERY_LONG_NAME_FST 10

          #define VERY_VERY_LONG_NAME_SEC 20 // compliant

          int main()
          {
            int i;
            if (VERY_VERY_LONG_NAME_FST == VERY_VERY_LONG_NAME_SEC) {
              i = 0;
            }
            else {
              i = 1;
            }
            printf("i = %d\n", i);
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 宏标识符不是唯一的
  name: 宏标识符应该是唯一的
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_5_4
- alias: {}
  category: ''
  code: MSR_5_5
  compliance: R
  csv_string:
    - MSR_5_5
  desc: 宏名称不应与程序中的标识符相同
  details: |-
    #### 概要
    宏名称不应与程序中的标识符相同

    #### 解释
    如果宏名称与标识符相同，则会引起混淆。
  examples:
    bad:
      c:
        - |-

          #include <string.h>

          extern int Both_Macro_and_Var_name(int, int);
           
          // this example will get compilation error
          #define Both_Macro_and_Var_name(a, b) ((a) * (b))

          int foo(int j) {
            int i = 5;
            i = Both_Macro_and_Var_name(i, j);
            return i;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdio.h>

          /*
           this example does not guarantee the same result for
           different compilers with std C90 or before
          */

          #define VERY_VERY_LONG_NAME   10

          int     VERY_VERY_LONG_NAME_test;  // compliant
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 宏名称与标识符相同
  name: 标识符应该不同于宏名称
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_5_5
- alias: {}
  category: ''
  code: MSR_8_2
  compliance: R
  csv_string:
    - MSR_8_2
  desc: 函数声明应为原型形式，原型中的参数应命名
  details: |-
    #### 概要
    函数声明应为原型形式，原型中的参数应命名

    #### 解释
    参数类型和函数类型的规范有助于避免未定义的行为。
  examples:
    bad:
      c:
        - |


          extern int functionX(int, char *);  /* parameters without name */

          int foo(int a1, char *c2)
          {
            int i = functionX(a1, c2);
            if (i != 0)
              return i;
            return -1;
          }


          int bar(b1, b2)
          int b1;
          char *b2;
          {
            int i = functionX(b1, b2);
            if (i != 0)
              return i;
            else
              return -1;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |


          extern int functionX(int, char *);  /* parameters without name */

          int foo(int a1, char *c2)
          {
            int i = functionX(a1, c2);
            if (i != 0)
              return i;
            return -1;
          }


          int bar(int b1, char *b2)    /* declaration in prototype form */
          {
            int i = functionX(b1, b2);
            if (i != 0)
              return i;
            else
              return -1;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 函数类型不是带有命名参数的原型形式
  name: 函数类型应该是带有命名参数的原型形式
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_8_2
- alias: {}
  category: ''
  code: MSR_15_6
  compliance: R
  csv_string:
    - MSR_15_6
  desc: 迭代或选择语句的主体应该在复合语句中
  details: |-
    #### 概要
    迭代或选择语句的主体应该在复合语句中

    #### 解释
    复合语句的使用可以明确哪些语句构成了迭代或选择语句的主体。
  examples:
    bad:
      c:
        - |-

          int foo(int i)
          {
            int ret = i;
            
            if (i == 0)  // conditional with non-compound statement
              return i++;
            else if (i < 0) 
              return -i;
            else 
              ; // empty else


            // loop with one non compound statement in body
            while (i != 0) 
              ret--;
            
            return ret;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          int foo(int i)
          {
            int ret = i;
            
            if (i == 0) {
              return i++;
            }
            else if (i < 0) {
              return -i;
            }
            else {
              ; // empty else
            }

            // loop with compound statement
            while (ret < 0) {
              ret++;
            }
            return ret;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 迭代或选择语句的主体不是复合语句
  name: 迭代或选择语句的主体应该是复合语句
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_15_6
- alias: {}
  category: ''
  code: MSR_16_3
  compliance: R
  csv_string:
    - MSR_16_3
  desc: 所有 switch 语句都应该有一个终止 break 语句
  details: |-
    #### 概要
    所有 switch 语句都应该有一个终止 break 语句

    #### 解释
    没有 break 语句的 switch 子句可能会归属于随后添加的 switch 子句。
  examples:
    bad:
      c:
        - |-

          int loop_cnt_ex2(int count, int input)
          {
            int idx = count;
            int ret = 0;
            
            switch (input) {
              
            default:   // default at beginning of switch
              
            case 0:
              idx--;
              break;
              
            case 1:    // this case at end of switch has no break
              idx++;

            }
            
            // ...
            return ret;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          int loop_cnt(int count, int input)
          {
            int idx = count;
            int ret = 0;
            
            switch (input) {
            case 0:
              idx--;
              ret++;
              break;
              
            case 1:
              idx++;
              ret++;
              break;
              
            default:   // default with a break statement
              break;
            }
            
            // ...
            return ret;
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, switch 语句没有终止的break 语句
  name: 所有 switch 语句都应该有一个终止 break 语句
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_16_3
- alias: {}
  category: ''
  code: MSR_15_0_2
  compliance: A
  csv_string:
    - MSR_15_0_2
  desc: 不应有指针类型的异常对象
  details: |-
    #### 概要
    不应有指针类型的异常对象

    #### 解释
    如果异常对象具有指针类型并引用动态创建的对象，则不清楚哪个函数应该销毁异常对象。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |


          class A {
          public:
            A(void) {}
            A(const A &b) {
              // ...
            }
            A(int) {}

            int Priv_int() const { return priv_int; }
          private:
            static int priv_int;
          };

          void foo(int i)
          {
            A varA;
            // local is dynamically created with local scope
            A *local = new A;
            
            if (varA.Priv_int() < 0) {
              throw(&varA);  // addr of local exposed (stack address)
            }
            else {
              throw(local);  // this could cause a heap object not properly deleted
            }
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          class A {
          public:
            A(void) {}
            A(const A &b) {
              // ...
            }
            A(int) {}

            int Priv_int() const { return priv_int; }
          private:
            static int priv_int;
          };

          void foo(int i)
          {
            A varA;
            // local is dynamically created with local scope
            A *local = new A;
            
            if (varA.Priv_int() == 0) {
              throw(varA);    // varA is not address
            }
            else {
              int l = local->Priv_int();
              delete local;
              throw(l); // return value copy of local's content, no heap address exposed
            }
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 一个异常对象具有指针类型
  name: 不应有指针类型的异常对象
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_15_0_2
- alias: {}
  category: ''
  code: MSR_15_1_1
  compliance: R
  csv_string:
    - MSR_15_1_1
  desc: 构造异常对象时，不应抛出异常
  details: |-
    #### 概要
    构造异常对象时，不应抛出异常

    #### 解释
    如果在构造异常对象的过程中抛出了异常，则该异常会优先于将要抛出的异常传播，这可能是出乎意料的。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <iostream>
           
          using namespace std;

          class MyException
          {
            public:
              MyException ()
              {
                throw "Exception thrown when constructing an exception object"; // non-compliant
              }
          };

          void func ( int n ) throw (int, MyException)
          {
            if ( n == 1 )
            {
              throw 1;
            }
            else
            {
              throw MyException();
            }
          }

          int main( void )
          {
            try
            {
              func(2);
            }

            catch ( int n )
            {
              cout << "catch int ..." << endl;
            }
            catch (MyException)
            {
              cout << "catch MyException ..." << endl;
            }
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <iostream>

          using namespace std;

          class MyException
          {
            public:
              MyException ()
              {
                cout << "constructor does not cause exception" << endl; // compliant
              }
          };

          void func ( int n ) throw (int, MyException)
          {
            if ( n == 1 )
            {
              throw 1;
            }
            else
            {
              throw MyException();
            }
          }

          int main( void )
          {
            try
            {
              func(2);
            }

            catch ( int n )
            {
              cout << "catch int ..." << endl;
            }
            catch (MyException)
            {
              cout << "catch MyException ..." << endl;
            }
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 构造异常对象时抛出了一个异常
  name: 构造异常对象时，不应抛出异常
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_15_1_1
- alias: {}
  category: ''
  code: MSR_15_1_2
  compliance: R
  csv_string:
    - MSR_15_1_2
  desc: 抛出 NULL 将被整数处理程序捕获，这可能是意外行为
  details: |-
    #### 概要
    抛出 NULL 将被整数处理程序捕获，这可能是意外行为

    #### 解释
    抛出 NULL 将被整数处理程序捕获，这可能与开发人员的期望不符。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |

          #include <iostream>
           
          using namespace std;

          class Str {
          public:
            int Report()  const { cout << "Str error "; return 0; }
            void NullReport(void) { cout << "Null pointer"; }
            
          public:
            Str() {} 
            void setLength( double len );
            int  Length( void ) {
              if (length == 0)
                throw Report();
              else
                return length;
            }
           
          private:
            int length;
          };


          void foo(class Str *p)
          {
            // ...
            
            try {
              if (p->Length() < 0) {
                throw (NULL);    // throw NULL
              }
              // ...
            }
            catch (int m) {
              if (m == 0) {
                p->NullReport();
              }
              // ...
            }

            // ..
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |

          #include <iostream>
           
          using namespace std;

          class Str {
          public:
            int Report()    const { cout << "Str error "; return 0; }
            void NullReport(void) { cout << "Null pointer"; }  
            
          public:
            Str() {} 
            void setLength( double len );
            int  Length( void ) {
              if (length <= 0)
                throw Report();
              else
                return length;
            }
           
          private:
            int length;
          };


          int main(class Str *p)
          {
            // ...
            
            try {
              p->Length();  // Legth() fully handle throw
              // ...
            }
            catch (int m) {
              if (m == 0)
                p->NullReport();
              // ...
            }
            catch (...) {
              // ...
            }

            // ..
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, NULL被显式抛出
  name: 不应显式抛出NULL
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_15_1_2
- alias: {}
  category: ''
  code: MSR_15_1_3
  compliance: R
  csv_string:
    - MSR_15_1_3
  desc: 不应在 catch 处理程序之外使用空的throw
  details: |-
    #### 概要
    不应在 catch 处理程序之外使用空的throw

    #### 解释
    在 catch 处理程序之外使用空抛出将终止程序，因为没有要重新抛出的异常对象。 行为是实现定义的。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |

          #include <iostream>
           
          using namespace std;

          class Str {
          public:
            int Report()  const { cout << "Str error "; return 0; }
            void NullReport(void) { cout << "Null pointer"; }
            
          public:
            Str() {} 
            void setLength( double len );
            int  Length( void ) {
              if (length == 0)
                throw Report();
              else
                return length;
            }
           
          private:
            int length;
          };


          void foo(class Str *p)
          {
            // ...
            
            try {
              if (p->Length() < 0) {
                throw;    // empty throw
              }
              // ...
            }
            catch (int m) {
              if (m == 0)
                p->NullReport();
              else {
                throw;
              }
              // ...
            }

            // ..
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |

          #include <iostream>
           
          using namespace std;

          class Str {
          public:
            int Report()    const { cout << "Str error "; return 0; }
            void NullReport(void) { cout << "Null pointer"; }  
            
          public:
            Str() {} 
            void setLength( double len );
            int  Length( void ) {
              if (length <= 0)
                throw Report();
              else
                return length;
            }
           
          private:
            int length;
          };


          void foo(class Str *p)
          {
            // ...
            
            try {
              p->Length();
              // ...
            }
            catch (int m) {
              if (m == 0)
                p->NullReport();
              else {
                throw;  // re-throw - allowed
              }
              // ...
            }

            // ..
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 在catch 处理程序之外使用了空的throw
  name: 一个空的 throw 应该只在 catch 处理程序中使用
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_15_1_3
- alias: {}
  category: ''
  code: MSR_15_3_2
  compliance: A
  csv_string:
    - MSR_15_3_2
  desc: 应提供一个异常处理程序来捕获所有未处理的异常
  details: |-
    #### 概要
    应提供一个异常处理程序来捕获所有未处理的异常

    #### 解释
    一个用于捕获所有未处理异常的异常处理程序可确保也可以捕获意料之外的异常。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |


          #include <stdlib.h>

          void f()
          {

            // code
            // ...
            
            exit(0);
          }


          int main(int argc, char *argv[])
          {
            try {
              
              // code with no call to f()

            }
            catch (int m) {    
              // handle any uncaught exception
            }
            
            return 0;
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |


          #include <stdlib.h>

          class X {
            
          public:
            X() { }  // constructor that does not throw
            void setLen( double len );
            int check_and_handle_error(int) {
              if (len < 0)
                throw 0;
              return len;
            }  
          private:
            int  len;
          };

          void f()
          {
            X local_x;
            int i;
            
            // code
            // ...

            // where check_and_error() resides inside main
            // such that all exceptions are caught
            i = local_x.check_and_handle_error(0);
            // ...
          }


          int main(int argc, char *argv[])
          {
            try {
              
              // code can call f() which may throw exception
              // ...
             
            }
            catch (int m) {    
              // handle any uncaught exception
            }
            
            return 0;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 没有提供一个异常处理程序来捕获所有未处理的异常
  name: 应提供一个异常处理程序来捕获所有未处理的异常
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_15_3_2
- alias: {}
  category: ''
  code: MSR_15_3_3
  compliance: R
  csv_string:
    - MSR_15_3_3
  desc: 在 ctor/dtor 中，函数try模块的处理程序不应引用此类或其基类的非静态成员
  details: |-
    #### 概要
    在 ctor/dtor 中，函数try模块的处理程序不应引用此类或其基类的非静态成员

    #### 解释
    在 function-try-block 的处理程序中访问类或基类的非静态成员是未定义的行为。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <iostream>
           
          using namespace std;

          class Count {
          public:
            int Report()  const { cout << "argument C "; return 0; }
            void NullReport(void) { cout << "Null pointer"; }
            
          public:
            int local_x;
            Count( void ) {
              try {
                // ...
              }
              catch (int m) {
                // reference local that may be in unknown state
                if (local_x == 0) throw Report();  
              }
            }
            ~Count( void ) {
              try {
                // ...
              }
              catch (int m) {
                // reference local who
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |

          #include <iostream>
           
          using namespace std;

          class Count {
          public:
            int Report()  const { cout << "argument C "; return 0; }
            void NullReport(void) { cout << "Null pointer"; }
            
          public:
            static int static_x;  // static scope variable
            Count( void ) {
              try {
                // ...
              }
              catch (int m) {
                // static var will have deterministic state
                if (static_x == 0) throw Report();  
              }
            }
            void setCount( int c );

          };

          Count ct; 

          int main(int argc, char *argv[])
          {

            // ...
            // main code

            return 0;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 函数try模块的处理程序引用了此类或其基类的非静态成员
  name: function-try-block 的处理程序不应引用此类或其基类的非静态成员
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_15_3_3
- alias: {}
  category: ''
  code: MSR_15_3_5
  compliance: R
  csv_string:
    - MSR_15_3_5
  desc: 一个类类型异常对象应仅通过引用捕获
  details: |-
    #### 概要
    一个类类型异常对象应仅通过引用捕获

    #### 解释
    如果类类型异常对象不是通过引用捕获的，则无法访问派生类中的其他成员数据。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |

          class Base {
          public:
            Base(void) {}
            Base(const Base &b) {}
            virtual const char* test() {
              return "Base";
            }; 
          private:
            static int priv_int;
          };


          class Derived : public virtual Base {
          public:
            Derived() {}
            virtual const char* test() {
              return "Derived";
            };
          private:
            int d;
            
            void foo()
            {    
              try {
                // ...
                throw Derived();
                throw Base();
              }
              catch (Base b) {
                b.test();
                throw b;
              }
            }
          };
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |

          class Base {
          public:
            Base(void) {}
            Base(const Base &b) {}
            virtual const char* test() {
              return "Base";
            };

          private:
            static int priv_int;
          };


          class Derived : public virtual Base {
          public:
            Derived() {}
            //  Derived1(int) : Base(0) {}
            virtual const char* test() {
              return "Derived";
            };
            
            
            void foo()
            {
              Derived D1;
              
              try {
                // ...
                throw Derived();
                throw Base();
              }
              catch (Base &b) {
                b.test();
                throw b;
              }
              catch (Derived &d) {
                d.test();
                throw d;
              }
            }
          };
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 类类型异常对象未被引用捕获
  name: 一个类类型异常对象应仅通过引用捕获
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_15_3_5
- alias: {}
  category: ''
  code: MSR_12_5
  compliance: M
  csv_string:
    - MSR_12_5
  desc: 声明为“类型数组”的函数参数不应用作 sizeof 的运算符
  details: |-
    #### 概要
    声明为“类型数组”的函数参数不应用作 sizeof 的运算符

    #### 解释
    由于声明为数组的函数参数会退化为指向类型的指针，因此使用 sizeof 不能返回数组的大小。
  examples:
    bad:
      c:
        - |-

          #include <stdint.h>

          void func( int arr1[ 5 ], int arr2[ 3 ] )
          {
              int a = sizeof( arr1 ) - sizeof (arr2);
              /*
                  non-compliant;
                  arr1, arr2 have type int *;
                  sizeof arr1, arr2 do not return the size of array
              */
              printf( a );
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
    good:
      c:
        - |-

          #include <stdint.h>

          int arr1[] = {1, 2, 3};
          int arr2[] = {1, 2};

          void func( void )
          {
              int a = sizeof( arr1 ) - sizeof (arr2);
              /*
                  compliant;
                  sizeof arr1, arr2 return the size of arrays
              */
              printf( a );
          }
      cpp:
        - ''
      general:
        - ''
      java:
        - ''
  language: c
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, sizeof 运算符被应用于声明为“类型数组”的函数参数
  name: sizeof 运算符不应用于声明为“类型数组”的函数参数
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mc:
      - MSR_12_5
- alias: {}
  category: ''
  code: MSR_2_10_6
  compliance: R
  csv_string:
    - MSR_2_10_6
  desc: 标识符不应引用同一范围内的类型和对象
  details: |-
    #### 概要
    标识符不应引用同一范围内的类型和对象

    #### 解释
    同时引用类型和对象或类型和函数的标识符可能会导致混淆。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          // a name refer to both a type and an object
          typedef struct test1 { int x; int y; } test1;

          /* 
          a name refer to both a type and a function,
          this example will get compilation error
          */
          typedef struct test2 { int a; int b; } test2;

          int test2( void )
          {
              return 1;
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          // different names refer to a type and an object
          typedef struct test1 { int x; int y; } test2;
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 标识符引用同一范围内的类型和对象
  name: 标识符不应引用同一范围内的类型和对象
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_2_10_6
- alias: {}
  category: ''
  code: MSR_4_5_1
  compliance: R
  csv_string:
    - MSR_4_5_1
  desc: bool 类型的表达式不应用作除 =, &&, ||, !, ==, !=, &, ?:的内置运算符的操作数
  details: |-
    #### 概要
    bool 类型的表达式不应用作除 =, &&, ||, !, ==, !=, &, ?:的内置运算符的操作数

    #### 解释
    将 bool 操作数与其他运算符一起使用是没有意义的。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          bool a = true;
          bool b = false;

          void func( void )
          {
              if ( a < b ) // the use of bool and < is unmeaningful
              {
                  printf("non-compliant");
              }
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          bool a = true;
          bool b = false;

          int func( void )
          {
              if ( a && b )           // the use of bool and && is meaningful
              {
                  printf("compliant");
              }
              else if ( a != b )      // the use of bool and != is meaningful
              {
                  printf("compliant");
              }
              return 0;   
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: >-
    在${so.filename}，第${so.line}行，函数${so.func}, bool 类型的表达式被应用作除 =, &&, ||, !,
    ==, !=, &, ?:的内置运算符的操作数
  name: bool 类型的表达式不应用作除 =, &&, ||, !, ==, !=, &, ?:的内置运算符的操作数
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_4_5_1
- alias: {}
  category: ''
  code: MSR_7_3_4
  compliance: R
  csv_string:
    - MSR_7_3_4
  desc: 不应使用 using-directives
  details: |-
    #### 概要
    不应使用 using-directives

    #### 解释
    using-directives 增加了编译器找到的标识符造成混淆的可能性，而 using-declarations 是更安全的选择。
  examples:
    bad:
      c:
        - ''
      cpp:
        - "\n#include <iostream>\n\nnamespace T1\n{\n\tint t{ 5 };\n}\n\nnamespace T2\n{\n\tint t{ 1 };\n}\n\n/* This example may cause compilation error;\nusing directives raises confusion for \n\"std::cout << t\" of which t to refer to*/\nint func( void )\n{   \n    using namespace T1; \n    using namespace T2;\n    std::cout << t;\n    return 0;\n}"
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - "\n#include <iostream>\n\nnamespace T1\n{\n\tint t{ 5 };\n}\n\nnamespace T2\n{\n\tint t{ 1 };\n}\n\nint func( void )\n{   \n    using T2::t; // using declaration is compliant\n    std::cout << t;\n    return 0;\n}"
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 使用了 using-directives
  name: 不应使用 using-directives
  ruleSet:
    code: M
    displayName: MISRA
    id: M
  standards:
    mcpp:
      - MSR_7_3_4
- alias: {}
  category: ''
  code: A5_0_3
  compliance: A
  cost: H
  csv_string:
    - A5_0_3
  desc: 表达式的值不能被转换为不适当的类型
  details: |-
    #### 概要
    表达式的值不能被转换为不适当的类型

    #### 解释
    在两种不适当的类型之间进行强制类型转换可能会导致数据的丢失或者改变，因此表达式的值不能不能被强制转换为不适当的类型。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
           
          void func ( void );
           
          bool bool_var;
          char char_var;
          enum enum_var {} enum_var;
          signed signed_var;
          unsigned unsigned_var;
          float float_var;
           
          void func ( void )
          {
            // expression 1.0f cast to an narrower type char
            char_var = ( char ) 1.0f;
            // char_var cast to narrower type bool
            bool_var = ( bool ) char_var;
            char_var = ( char ) bool_var; // non-compliant
            enum_var = ( enum enum_var ) bool_var; // non-compliant
            signed_var = ( signed ) bool_var; // non-compliant
            unsigned_var = ( unsigned ) bool_var; // non-compliant
            float_var = ( float ) bool_var; // non-compliant
            bool_var = ( bool ) char_var; // non-compliant
            enum_var = ( enum enum_var ) char_var; // non-compliant
            float_var = ( float ) char_var; // non-compliant
            bool_var = ( bool ) enum_var; // non-compliant
            bool_var = ( enum enum_var ) enum_var; // non-compliant
            bool_var = ( bool ) signed_var; // non-compliant
            bool_var = ( enum enum_var ) signed_var; // non-compliant
            bool_var = ( bool ) unsigned_var; // non-compliant
            bool_var = ( enum enum_var ) unsigned_var; // non-compliant
            bool_var = ( bool ) float_var; // non-compliant
            bool_var = ( enum enum_var ) float_var; // non-compliant
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( void );

          void func ( void )
          {
              char char_var;
              bool bool_var;
              // int can be cast to char
              char_var = ( char ) 1;
              // int 1 can be cast to bool by exception
              bool_var = ( bool ) 1;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  likelihood: L
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}中表达式的值被转换为不适当的类型
  name: 表达式中相同的基本类型
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  severity: H
  standards: {}
- alias: {}
  category: ''
  code: A3_3_1
  compliance: R
  csv_string:
    - A3_3_1
  desc: 具有外部链接的对象或函数应在头文件中声明
  details: |-
    #### 概要
    具有外部链接的对象或函数应在头文件中声明

    #### 解释
    没有外部链接的对象和函数应在未命名的命名空间中声明或声明为静态，以降低它们的可见性。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
          #include "header.h"

          int x = 5;
          int y = 10; // non-compliant
          int test ( void ) // non-compliant
          {
              x = 10;
              y = 5;
              return 0;
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |

          #include <stdio.h>
          #include "header.h"

          int x = 5;
          static int y = 10; // compliant
          void func ( void ) // compliant
          {
              x = 10;
              y = 5;
          }

          static int test ( void ) // compliant
          {
              x = 10;
              y = 5;
              return 0;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 具有外部链接的对象或函数没有在头文件中声明
  name: 具有外部链接的对象或函数应在头文件中声明
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A3_9_1
  compliance: R
  csv_string:
    - A3_9_1
  desc: 固定宽度整数类型应该替换基本的数值类型
  details: |-
    #### 概要
    固定宽度整数类型应该替换基本的数值类型

    #### 解释
    <cstdint> 中的特定长度类型应用于替换 char、int、short、long 的基本数字类型
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
          #include <stdint.h>

          void func ( void )
          {
              int a = 1; // basic numerical types
              int b = 5;
              int c = 10;
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
          #include <stdint.h>

          void func ( void )
          {
              int8_t a = 1; // fixed width integer types
              int16_t b = 5;
              int32_t c = 10;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 使用基本数值类型而不是固定宽度的整数类型
  name: 应使用固定宽度整数类型代替基本数值类型
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A2_11_5
  compliance: A
  csv_string:
    - A2_11_5
  desc: 不应重复使用具有静态存储持续时间的标识符
  details: |-
    #### 概要
    不应重复使用具有静态存储持续时间的标识符

    #### 解释
    重复使用具有静态存储持续时间的标识符可能会使不相关的变量错误地与同名相关联。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
          #include <stdint.h>

          namespace TEST1
          {
              static int a = 1;
          }

          namespace TEST2
          {
              void func ( void )
              {
                  int a; // reused identifier a
                  a++;
              }
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
          #include <stdint.h>

          namespace TEST1
          {
              static int a = 1;
          }

          namespace TEST2
          {
              void func ( void )
              {
                  int b; // not reused identifier b
                  b++;
              }
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 重复使用具有静态存储持续时间的标识符
  name: 不应重复使用具有静态存储持续时间的标识符
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: 枚举不应用于算术
  code: A4_5_1
  compliance: R
  csv_string:
    - A4_5_1
  desc: 枚举不应用于算术
  details: |-
    #### 概要
    枚举不应用于算术

    #### 解释
    枚举具有实现定义的表示。 Eums 只能用作部分运算符的操作数，包括 [ ]、=、==、!=、<、<=、>、>=。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
          #include <stdint.h>

          extern void extern_func(char *);

          enum {a, b, c} test;

          void func ( void )
          {
              if ( ( a + b ) == test ) // non-compliant
              {
                  extern_func("test_1");
              }
              else if ( ( a - c  ) != b ) // non-compliant
              {
                  extern_func("test_2");
              }
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
          #include <stdint.h>

          enum {a, b, c} test;

          void func ( void )
          {
              if ( a != b )  // compliant
              {
                  printf("test_1");
              }
              else if ( b <= c ) // compliant
              {
                  printf("test_2");
              }
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 枚举被应用于算术
  name: 枚举不应用于算术
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A5_1_1
  compliance: R
  csv_string:
    - A5_1_1
  desc: 除了类型初始化之外，不应使用文字值
  details: |-
    #### 概要
    除了类型初始化之外，不应使用文字值

    #### 解释
    文字值的使用对代码的可读性和可维护性有不良影响。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
          #include <stdint.h>
          #include <iostream>

          void function( void )
          {
            for (int32_t i = 0; i < 100; i++)  // non-compliant
              {
                printf("magic number for 100"); // compliant by exception
                std::cout << "magic number" << i << '\n'; // compliant by exception
              }
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
          #include <stdint.h>

          #include <stdio.h>
          #include <stdint.h>

          void function( void )
          {
              const int max_length = 100;
              for (int i = 0; i < max_length; i++)
              {
                  printf("avoid magic numbers"); // compliant
              }
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 使用了文字值
  name: 除了类型初始化之外，不应使用文字值
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A2_10_1
  compliance: R
  csv_string:
    - A2_10_1
  desc: 在内部范围中声明的标识符不应与外部范围中的相同
  details: |-
    #### 概要
    在内部范围中声明的标识符不应与外部范围中的相同

    #### 解释
    如果在内部作用域中声明的标识符使用与在外部作用域中的标识符相同的名称，则会引起开发人员的混淆。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          int i, j;

          int func ( int i, int j ) // non-compliant
          {
              i = 1;
              j = 2;
              if ( i - j < 0 )
              {
                  return 0;
              }
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          int i;

          int func1 ( int j ) // compliant
          {
              j ++;
              return 0;
          }

          namespace test1
          {
              int t;
              namespace test2
              {
                  int t; // compliant by exception
              }
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 在内部范围内声明的标识符隐藏了外部标识符
  name: 在内部范围内声明的标识符不应隐藏外部标识符
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A2_11_1
  compliance: R
  csv_string:
    - A2_11_1
  desc: 不应该使用volatile关键字
  details: |-
    #### 概要
    不应该使用volatile关键字

    #### 解释
    Volatile 关键字容易出错，并且经常被开发人员误用。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          int func ( void )
          {
              volatile int i = 10; // non-compliant
              int a, b;
              a = i;
              /*
              ...
              do something
              */
              b = i;
              return 0;
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          int func ( void )
          {
              int i = 10; // compliant
              int a;
              a = i;
              return a;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, volatile关键字被使用了
  name: 不应该使用volatile关键字
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A2_13_5
  compliance: A
  csv_string:
    - A2_13_5
  desc: 十六进制常量应为大写
  details: |-
    #### 概要
    十六进制常量应为大写

    #### 解释
    对十六进制常量使用大写字母可使源代码保持一致并减少开发人员的困惑。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
          #include <cstdint>

          int   i = 0xa;    // non-compliant
          short j = 0x4b;   // non-compliant
          short k = 0x0f5c; // non-compliant

          int foo(int i, short s1, short s2)
          {
            return i + (int)j + (int)k;
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>
          #include <cstdint>

          int16_t i = 0xA;    // compliant
          int16_t j = 0x4B;   // compliant
          int16_t k = 0x0F5C; // compliant
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 十六进制常量不是大写
  name: 十六进制常量应为大写
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A2_13_4
  compliance: R
  csv_string:
    - A2_13_4
  desc: 不应将字符串文字分配给非常量指针
  details: |-
    #### 概要
    不应将字符串文字分配给非常量指针

    #### 解释
    字符串文字应更改为常量指针，以防止调用可能修改其参数的不适当函数。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              char non_const1[] = "str_literal";      // non-compliant
              char* non_const2 = "str_literal";       // non-compliant
              char non_const3[ 12 ] = "str_literal";  // non-compliant
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          void func ( void )
          {
              const char a1[] = "str_literal";    // compliant
              const char* a2 = "str_literal";     // compliant
              const char a3[12] = "str_literal";  // compliant
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 字符串文字被分配给非常量指针
  name: 不应将字符串文字分配给非常量指针
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A7_2_2
  compliance: R
  csv_string:
    - A7_2_2
  desc: 枚举基础类型应明确定义
  details: |-
    #### 概要
    枚举基础类型应明确定义

    #### 解释
    枚举基础类型必须能够表示枚举值。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          enum test // non-compliant
          {   
              t1,
              t2,
              t3
          };
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          enum test : int // compliant
          {   
              t1,
              t2,
              t3
          };
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 枚举基础类型没有被明确定义。
  name: 枚举基础类型应明确定义
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A5_16_1
  compliance: R
  csv_string:
    - A5_16_1
  desc: 三元条件运算符不应用作子表达式
  details: |-
    #### 概要
    三元条件运算符不应用作子表达式

    #### 解释
    使用三元条件运算符作为子表达式会降低代码的可读性。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdio.h>

          int func ( int x, int y )
          {
              // ternary conditional operator used as sub-expression
              int z = y - (x > y ? 10 : ( y > 5 ? 2 : ( x + y )));
              return z;
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |

          #include <stdio.h>

          int func ( int x, int y )
          {
              int z = x > y ? 10 : x; // compliant
              return z;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 三元条件运算符被用作子表达式
  name: 三元条件运算符不应用作子表达式
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A7_1_6
  compliance: R
  csv_string:
    - A7_1_6
  desc: typedef 说明符不应用于定义别名
  details: |-
    #### 概要
    typedef 说明符不应用于定义别名

    #### 解释
    应该使用 using 语法来替换 typedef，因为 typedef 会使代码的可读性降低。
  examples:
    bad:
      c:
        - ''
      cpp:
        - >-

          #include<string>


          // defining aliases with typedef

          typedef unsigned int uint_t;

          typedef int *p;

          typedef int f( void );


          // template <typename Test>

          // typedef func_t: void (*)(Test, Test); // this example would raise
          compilation error
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          // defining aliases with using
          using uint_t = unsigned int;

          template <typename Test>
          using func_t = void (*)(Test, Test);
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, typedef 说明符被使用了。
  name: typedef 说明符不应用于定义别名
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A7_2_3
  compliance: R
  csv_string:
    - A7_2_3
  desc: 枚举应声明为有范围的枚举类
  details: |-
    #### 概要
    枚举应声明为有范围的枚举类

    #### 解释
    在全局范围内声明无范围的 enum 可能会造成混淆，因此应该使用 enum-class 作为枚举。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          // unscoped enumeration enum is declared in a global scope
          enum test : int
          {   
              t1,
              t2,
              t3
          };
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          // Using enum-class as enumeration is compliant
          enum class test : int
          {   
              t1,
              t2,
              t3
          };
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 枚举没有被声明为有范围的枚举类
  name: 枚举应声明为有范围的枚举类
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A7_2_4
  compliance: R
  csv_string:
    - A7_2_4
  desc: 在枚举中，应该或是全部无初始化，或是初始化第一个或所有枚举数。
  details: |-
    #### 概要
    在枚举中，应该或是全部无初始化，或是初始化第一个或所有枚举数。

    #### 解释
    在枚举中仅初始化部分枚举数是令人困惑的。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          enum class test1 : int // non-compliant
          {   
              t1,
              t2 = 10,
              t3
          };

          enum class test2 : int // non-compliant
          {   
              t4,
              t5 = 10,
              t6 = 11
          };
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |

          enum class test1 : int // compliant
          {   
              t1,
              t2,
              t3
          };

          enum class test2 : int // compliant
          {   
              t4 = 1,
              t5,
              t6
          };

          enum class test3 : int // compliant
          {   
              t7 = 1,
              t8 = 2,
              t9 = 3
          };
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 仅部分枚举数被初始化。
  name: 在枚举中，应该或是全部无初始化，或是初始化第一个或所有枚举数。
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A10_1_1
  compliance: R
  csv_string:
    - A10_1_1
  desc: 类不应从多个非接口基类派生
  details: |-
    #### 概要
    类不应从多个非接口基类派生

    #### 解释
    从多个非接口基类派生的类将使代码更难维护。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          class Base1
          {
              public:
                  void func1(){}
          };

          class Base2
          {
              public:
                  void func2(){}
          };

          // Non-compliant
          // Base1 and Base2 are both not interface classes
          class Derived : public Base1,
                          public Base2
          {};
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          class Base1 
          {
              public:
                  virtual void func1() = 0;
                  virtual void func2() = 0;
          };

          class Base2
          {
              public:
                  void func3(){}
                  void func4(){}
          };

          class Base3
          {
              public:
                  virtual void func5() = 0;
                  virtual void func6() = 0;
          };


          // compliant
          // Only Base2 is not interface class
          class Derived1 : public Base1,
                           public Base2
          {};

          // compliant
          // Both Base1 and Base3 are interface classes
          class Derived2 : public Base1,
                           public Base3
          {};
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 类从多个非接口基类派生
  name: 类不应从多个非接口基类派生
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A11_0_1
  compliance: A
  csv_string:
    - A11_0_1
  desc: 非 POD 类型应定义为类
  details: |-
    #### 概要
    非 POD 类型应定义为类

    #### 解释
    类说明符强制 non-POD 类型在默认情况下为其所有成员提供专用访问控制，这与开发人员的期望一致。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <stdint.h>

          typedef char    Letter;  
          typedef Letter* pLetter;
            
          struct Struct_With_non_POD    
          {
          public:
            Letter  c;  
            pLetter p;
          };
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - >-

          #include <stdint.h>


          typedef char    Letter;  

          typedef Letter* pLetter;
            
          class Xlass_With_non_POD    

          {

          public:
            Letter  c;  
            pLetter p;
          };


          struct Struct_with_POD // declared as struct

          {
            char*   pc;
          };



          class Class_with_POD // declared as class

          {

          public:              // POD declared as public, not conformed to
          M11-0-1
            int8_t   c;        
            char*   pc;
          private:
            int32_t  x;        // data member is private
          };
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 非 POD 类型没有被定义为类
  name: 非 POD 类型应定义为类
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A12_1_6
  compliance: R
  csv_string:
    - A12_1_6
  desc: 当派生类不需要进一步初始化时，请使用继承构造函数
  details: |-
    #### 概要
    当派生类不需要进一步初始化时，请使用继承构造函数

    #### 解释
    重新实现不需要进一步初始化的构造函数可能会导致使用错误的基类构造函数。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          #include <cstdint>
          #include <iostream>

          class Base {
            
          public:
            // destructor non-virtual
            ~Base(void) { std::cout << "Base dtor called\n"; }
            explicit Base(std::int32_t x) : Base(x+1) {}
          };

          class Derived : public Base {
            
          public:

            ~Derived(void)  { std::cout<< "Derived dtor called\n"; }
            explicit Derived(std::int32_t) : Base(x-1) {}
          }; 


          int main()
          {
              Base* b = new Derived;
              delete b;
          }

          // bad example from document
          class A  
          {
              public: 
                  A(std::int32_t x, std::int32_t y) : x(x + 8), y(y) {}
                  explicit A(std::int32_t x) : A(x, 0) {}

                  private:
                      std::int32_t x;
                      std::int32_t y;
          };


          class B : public A
          {
              public:
                  B(std::int32_t x, std::int32_t y) : A(x, y) {}
                  explicit B(std::int32_t x) : A(x) {}
          }
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          #include <iostream>

          class Base {
            
          public:
            // destructor non-virtual
            ~Base(void) { std::cout << "Base dtor called\n"; }
          };

          class Derived : public Base {
            
          public:
              using Base::Base;
          }; 


          int main()
          {
              Base* b = new Derived;
              delete b;
          }
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 当派生类不需要进一步初始化时，没有使用继承构造函数。
  name: 当派生类不需要进一步初始化时，请使用继承构造函数
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
- alias: {}
  category: ''
  code: A13_5_1
  compliance: R
  csv_string:
    - A13_5_1
  desc: 下标运算符不应该只定义非常量版本
  details: |-
    #### 概要
    下标运算符不应该只定义非常量版本

    #### 解释
    如果实现了运算符[]的非常量版本，则只允许修改对象。但在没有常量版本重载的情况下，无法读取常量对象。
  examples:
    bad:
      c:
        - ''
      cpp:
        - |-

          // Both const and non-const version of operator[] are implemented
          class Test{
              public:
                  int& operator[](int n) {
                      return elements[n];
                  }
                  const int& operator[](int n) const {
                      return elements[n];
                  }
              private:
                  int* elements;
          };
      general:
        - ''
      java:
        - ''
    good:
      c:
        - ''
      cpp:
        - |-

          // Only non-const version of operator[] is implemented
          class Test{
              public:
                  int& operator[](int n) {
                      return elements[n];
                  }
              private:
                  int* elements;
          };
      general:
        - ''
      java:
        - ''
  language: c++
  mapping: ''
  msg_templ: 在${so.filename}，第${so.line}行，函数${so.func}, 下标运算符只定义了非常量版本
  name: 下标运算符不应该只定义非常量版本
  ruleSet:
    code: A
    displayName: Autosar
    id: A
  standards: {}
